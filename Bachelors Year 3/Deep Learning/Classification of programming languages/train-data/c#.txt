namespace MehulIndustries.Controllers
    [AuthorizeWebForm]
    public class DispatchController : BaseController
    {
        public ActionResult Index()
        {
            return View();
        }
        public ActionResult GetOrderDetail(int ID, int DispatchID)
        {
            var order = OrderLogic.GetOrderByID(ID).FirstOrDefault();
            ViewBag.Parties = PartyLogic.GetPartyByID(order.PartyID);
            ViewBag.Transports = TransportLogic.GetTransportByID(0);
            ViewBag.Products = ProductLogic.GetFinishedProducts();
            ViewBag.Addresses = PartyAddressLogic.GetPartyAddress(order.PartyID);
            var dispatch = new Dispatch();
            if (DispatchID == 0)
            {
                dispatch.DONo = DispatchLogic.GetMaxDispatchNo();
                dispatch.DODate = DateTime.Now;
            }
            else
            {
                dispatch = DispatchLogic.GetDispatchByID(DispatchID).FirstOrDefault();
            }
            

            dispatch.details = DispatchLogic.GetDispatchDetail(DispatchID, order.ID);
            if (DispatchID > 0)
            {
                dispatch.order.PartyID = dispatch.PartyID;
                dispatch.order.DeliveryAddressID = dispatch.DeliveryAddressID;
                dispatch.order.TransportID = dispatch.TransportID;
                dispatch.order.BookingAt = dispatch.BookingAt;
            }
            return PartialView("_DispatchDetails", dispatch);
        }
        public ActionResult Add(int ID)
        {
            ViewBag.ViewID = ID;
            if (ID > 0)
            {
                ViewBag.OrderID = DispatchLogic.GetDispatchByID(ID).FirstOrDefault().OrderID;
            }
            ViewBag.Parties = PartyLogic.GetOrderedParties();
            return View();
        }
        [HttpPost]
        public ActionResult Add(Dispatch dispatch)
        {
            ResponseMsg response = new ResponseMsg();
            dispatch.CreatedBy = ((Employee)Session

            if (DispatchLogic.SaveDispatch(dispatch))
            {
                response.IsSuccess = true;
                response.ResponseValue = DispatchLogic.GetDispatchByDONo(dispatch.DONo);
            }
            else
            {
                response.IsSuccess = false;
            }
            return Json(response);
        }
        public string CheckDuplicateDONo(string DONo, string ID)
        {
            var dispatches = DispatchLogic.GetDispatchByID(0);
            if (dispatches != null && dispatches.Count() > 0)
            {
                if (Convert.ToInt32(ID) > 0)
                {
                    dispatches = dispatches.Where(x => x.DONo == DONo && x.ID != Convert.ToInt32(ID));
                }
                else
                {
                    dispatches = dispatches.Where(x => x.DONo == DONo);
                }
                if (dispatches.Count() > 0)
                {
                    return "false";
                }
        
public static class MapData {
	public static Chunk[,,] Chunks { get { return _chunks; } }
	private static Vector3 CurrentPosition
	{
		get
		{
			return Vector3.zero;
		}
	}
	private const byte CHUNK_RADIUS = 1;
	private static Chunk[,,] _chunks = new Chunk[CHUNK_RADIUS * 2, CHUNK_RADIUS * 2, CHUNK_RADIUS * 2];
	public static void Poll()
	{
		for (int x = 0; x < CHUNK_RADIUS * 2; x++)
		{
			for (int y = 0; y < CHUNK_RADIUS * 2; y++)
			{
				for (int z = 0; z < CHUNK_RADIUS * 2; z++)
				{
					_chunks [x, y, z] = new Chunk(new Vector3(x, y, z));
				}
			}
		}
	}
	public static Chunk GetChunk(int x, int y, int z)
	{
		return GetChunk (new Vector3 (x, y, z));
	}
	public static Chunk GetChunk(Vector3 chunkPosition)
	{
		Vector3 relativeChunkPosition = chunkPosition - CurrentPosition;
		try {
			return _chunks[(byte)relativeChunkPosition.x, (byte)relativeChunkPosition.y, (byte)relativeChunkPosition.z];
		} catch (System.Exception ex) {
			return null;
		}
		if ((byte)relativeChunkPositi
namespace Taki.Common
    public static class ProcessExtensions
    {
        private static string FindIndexedProcessName(int pid)
        {
            var processName = Process.GetProcessById(pid).ProcessName;
            var processesByName = Process.GetProcessesByName(processName);
            string processIndexdName = null;
            for (var index = 0; index < processesByName.Length; index++)
            {
                processIndexdName = index == 0 ? processName : processName + "#" + index;
                var processId = new PerformanceCounter("Process", "ID Process", processIndexdName);
                if ((int)processId.NextValue() == pid)
                {
                    return processIndexdName;
                }
            }
            return processIndexdName;
        }
        private static Process FindPidFromIndexedProcessName(string indexedProcessName)
        {
            var parentId = new PerformanceCounter("Process", "Creating Process ID", indexedPr
namespace SEP.HRMIS.Bll.DiyProcesses
    public class AddDiyProcess : Transaction
    {
        private readonly IDiyProcessDal _IDiyProcessDal = new DiyProcessDal();
        private readonly DiyProcess _DiyProcess;
        public AddDiyProcess(DiyProcess diyProcess)
        {
            _DiyProcess = diyProcess;
        }
        public AddDiyProcess(DiyProcess diyProcess, IDiyProcessDal mockIDiyProcessDal)
        {
            _DiyProcess = diyProcess;
            _IDiyProcessDal = mockIDiyProcessDal;
        }
        protected override void Validation()
        {
            if(_IDiyProcessDal.CountDiyProcessByName(_DiyProcess.Name)>0)
            {
                HrmisUtility.ThrowException(HrmisUtility._DiyProcess_Name_Repeat);
            }
        }
        protected override void ExcuteSelf()
        {
            try
            {
                _IDiyProcessDal.InsertDiyProcess(_DiyProcess);
            }
            catch
            {
                BllUtility.ThrowExc
namespace TaxiOnline.Toolkit.Threading.Patterns
    public class TimeoutHelper
    {
        public static bool InvokeWithTimeout<T>(Func<T> functionToInvoke, TimeSpan timeout, out T result)
        {
            Task<T> taskToInvoke = Task.Factory.StartNew(functionToInvoke);
            if (taskToInvoke.Wait(timeout))
            {
                CheckTaskResult(taskToInvoke);
                result = taskToInvoke.Result;
                return true;
            }
            else
            {
                result = default(T);
                return false;
            }
        }
        public static bool InvokeWithTimeout<T>(Func<T> functionToInvoke, CancellationToken cancellation, out T result)
        {
            EventWaitHandle waitTask = new EventWaitHandle(false, EventResetMode.ManualReset);
            Task<T> taskToInvoke = Task.Factory.StartNew(WrapFunctionToInvoke<T>(functionToInvoke, waitTask));
            if (WaitHandle.WaitAny(new WaitHandle[] { waitTask, cancell

            {
                CheckTaskResult(taskToInvoke);
                result = taskToInvoke.Result;
                return true;
            }
            else
            {
                result = default(T);
                return false;
            }
        }
        public static bool InvokeWithTimeout<T>(Func<T> functionToInvoke, CancellationToken cancellation, TimeSpan timeout, out T result)
        {
            EventWaitHandle waitTask = new EventWaitHandle(false, EventResetMode.ManualReset);
            Task<T> taskToInvoke = Task.Factory.StartNew(WrapFunctionToInvoke<T>(functionToInvoke, waitTask));
            if (WaitHandle.WaitAny(new WaitHandle[] { waitTask, cancellation.WaitHandle }, timeout) == 0)
            {
                CheckTaskResult(taskToInvoke);
                result = taskToInvoke.Result;
                return true;
            }
            else
            {
                result = default(T);
                return false;
            }
     
﻿namespace UPE_ONS.Controllers
    class FactoryController
    {
        public static FactoryController instance;
        public PrevEOL_Controller PrevEOL_Controller { get; internal set; }
        public ParqueEolicoController ParqueEolicoController { get; internal set; }
        public PrevisorController PrevisorController { get; internal set; }
        public CalibradorController CalibradorController { get; internal set; }
        public CPTEC_Controller CPTEC_Controller { get; internal set; }
        private FactoryController()
        {
            this.PrevEOL_Controller = new PrevEOL_Controller();
            this.ParqueEolicoController = new ParqueEolicoController();
            this.PrevisorController = new PrevisorController();
            this.CalibradorController = new CalibradorController();
            this.CPTEC_Controller = new CPTEC_Controller();
        }
        public static FactoryController getInstance()
        {
            if (instance == null)
               
namespace DAL.Data.UnitofWork
    public interface IUnitofWork : IDisposable
    {
        #region Model
        IGenericRepository<Agenda> AgendaRepository { get; }
        IGenericRepository<Booths> BoothRepository { get; }
        IGenericRepository<Buyers> BuyerRepository { get; }
        IGenericRepository<Companies> CompanyRepository { get; }
        IGenericRepository<EventRateSection> EventRateSectionRepository { get; }
        IGenericRepository<Events> EventRepository { get; }
        IGenericRepository<EventTypes> EventTypeRepository { get; }
        IGenericRepository<FeedBacks> FeedBackRepository { get; }
        IGenericRepository<InvitationsAccepted> InvitationAcceptedRepository { get; }
        IGenericRepository<InvitationsRefuseds> InvitationRefusedRepository { get; }
        IGenericRepository<InvitationSchedules> InvitationScheduleRepository { get; }
        IGenericRepository<Invitations> InvitationsRepository { get; }
        IGenericRepository<Sellers> SellerRepo
namespace SESD.MRP.REF
    public class DispatchProducts
    {
        private DispatchNote _objDispatchNote;
        public DispatchNote DispatchNote
        {
            get { return _objDispatchNote; }
            set { _objDispatchNote = value; }
        }
        private FinishProduct _objFinishProduct;
        public FinishProduct DispatchFinishProduct
        {
            get { return _objFinishProduct; }
            set { _objFinishProduct = value; }
        }
        private Decimal _lngDispatchQty;
        public Decimal DispatchQty
        {
            get { return _lngDispatchQty; }
            set { _lngDispatchQty = value; }
        }
        private String _strItem;
        public String Item
        {
            get 
            {
                _strItem = DispatchFinishProduct.Code;
                return _strItem; 
            }
        }
	}
    public class DispatchProductsCollec:CollectionBase
    {
        public void Add(DispatchProducts objDispatchNoteList)

public class World : MonoBehaviour {
    public enum WorldSizes {
        Small = 32,
        Medium = 64,
        Large = 128
    }
    public string worldName = "BaseWorld";
    public WorldSizes worldSize = WorldSizes.Small;
    [Range(0, 128)]
    public int height = 64;
    public int seed = 0;
    public Transform target;
    public bool CenterTargetInWorld = false;
    private Dictionary<Vector2, Chunk> loadedChunks;
    private Vector2 oldChunkPosition;
    protected ushort[,] worldData;
    protected int worldWidth;
    protected int worldHeight;
    internal ChunkMeshCreatorPool MeshCreatorPool;
    public EntityID entityID;
    public void Awake() {
        loadedChunks = new Dictionary<Vector2, Chunk>();
        oldChunkPosition = new Vector2(float.MaxValue, float.MaxValue);
        worldWidth = (int)worldSize * CHUNK_SIZE;
        worldHeight = WORLD_HEIGHT_CHUNKS * CHUNK_SIZE;
        
        CenterTarget();
        MeshCreatorPool = new ChunkMeshCreatorPool();
        O

    }
    void Start () {
	    if (target == null) {
            Debug.LogError("Missing world target!");
            Debug.Break();
        }
	}
	void Update () {
        Vector2 targetChunkPosition = Utilities.PositionInChunks(target.position);
        if (UpdateChunksToDisable(targetChunkPosition)) {
            UpdateChunksToEnable(targetChunkPosition);
        }
        ReBuildChunks();
    }
    private bool UpdateChunksToDisable(Vector2 targetChunkPosition) {
        bool positionUpdated = false;
        if (targetChunkPosition != oldChunkPosition) {
            oldChunkPosition = targetChunkPosition;
            positionUpdated = true;
            foreach (Vector2 chunkCoord in loadedChunks.Keys) {
                if ((Mathf.Abs(targetChunkPosition.x - chunkCoord.x) > X_RENDER_CHUNKS) ||
                      (Mathf.Abs(targetChunkPosition.y - chunkCoord.y) > Y_RENDER_CHUNKS)) {
                    loadedChunks[chunkCoord].markedToDisable = true;
                }
            

        }
        return positionUpdated;
    }
    private void UpdateChunksToEnable(Vector2 targetChunkPosition) {
        int minX = (int)targetChunkPosition.x - X_RENDER_CHUNKS;
        int maxX = (int)targetChunkPosition.x + X_RENDER_CHUNKS;
        int minY = (int)targetChunkPosition.y - Y_RENDER_CHUNKS;
        int maxY = (int)targetChunkPosition.y + Y_RENDER_CHUNKS;
        minX = (minX < 0) ? 0 : minX;
        maxX = (maxX > ((int)worldSize - 1)) ? ((int)worldSize - 1) : maxX;
        minY = (minY < 0) ? 0 : minY;
        maxY = (maxY > (WORLD_HEIGHT_CHUNKS - 1)) ? (WORLD_HEIGHT_CHUNKS - 1) : maxY;
        for (int chunkX = minX; chunkX <= maxX; chunkX++) {
            for (int chunkY = minY; chunkY <= maxY; chunkY++) {
                if (loadedChunks.ContainsKey(new Vector2(chunkX, chunkY))) {
                    EnableChunk(chunkX, chunkY);
                } else {
                    AddChunk(chunkX, chunkY);
                }
            }
        }
    }
    public void
﻿@model IEnumerable<LiteDispatch.Domain.Models.DispatchNoteModel>
@{
    ViewBag.Title = "Haulier - Active Dispatch Notes";    
@section headSection{
    <script src="~/Scripts/jquery.signalR-1.1.0.js" type="text/javascript"></script>
    <!--Reference the autogenerated SignalR hub script. -->
    <script src="~/signalr/hubs" type="text/javascript"></script>
@section featured {
    <section class="featured">
        <div class="content-wrapper">
            <div id="detail_up" class="float-right"><img src="~/Images/deploy_chevronup.gif"/></div>
            <div id="detail_down" class="float-right"><img src="~/Images/deploy_chevrondown.gif"/></div>
            <hgroup class="title">
                <h1>@ViewBag.Title</h1>                
                <br/>
                <h2>@ViewBag.Message</h2>                
            </hgroup>
            <div id="featured_detail">
                <p>
                    <h5>Design Notes</h5>
                    This page display active dispa

                    <h5>Comments</h5>
                    Currently this page displays all active dispatches for all hauliers
                </p>
            </div>
        </div>
    </section>
@if (Model.Any())
    <table id="dispatches">
        <thead>
            <th>Haulier</th>
            <th>Date</th>
            <th>Reference</th>
            <th>Truck</th>
            <th>State</th>
            <th>Last Update (utc)</th>
            <th>Lines</th>
            <th>Duration</th>
            <th>Distance (km)</th>
            <th></th>
        </thead>
        @foreach (var listado in Model)
        {            
            @Html.Partial("GetDispatchNoteDetails", listado)            
        }
    </table>
    <input type="hidden" id="userName"/>
    <input type="button" id="sendMessage" value="Send Message"/>    
else
    <p>No active dispatch notes are available</p>
@section scripts
    <script type="text/javascript">
        $(document).ready(function () {
            set

        });
        var setDispatchesStyle = function() {
            $("#dispatches > tbody tr:odd").css("background-color", "#F7F7F7");
            $("#dispatches > tbody tr:even").css("background-color", "#EFEEEF");
        };
        
    </script>
    <script src="~/Scripts/feature-detail.js" type="text/javascript"></script>
    <script type="text/javascript">
        var chat = $.connection.liteDispatchHub;
        
        chat.client.addNewMessageToPage = function(name, message) {
            alert("Message from: " + name + "\r\r" + message);
        };
        chat.client.newDispatch = function (dispatchId) {
            alert("A new DispatchNote was created by other user with Id: " + dispatchId);
            $.get('@Url.Action("GetDispatchNoteDetails", "Dispatch")' + '?dispatchId=' + dispatchId, function (html) {
                renderDispatch(dispatchId, html);
            });
        };
       
        chat.client.updateDispatch = function (dispatchId) {
            alert(
public class TerrainGen
    float stoneBaseHeight = -24;
    float stoneBaseNoise = 0.05f;
    float stoneBaseNoiseHeight = 4;
    float stoneMountainHeight = 48;
    float stoneMountainFrequency = 0.008f;
    float stoneMinHeight = -12;
    float dirtBaseHeight = 1;
    float dirtNoise = 0.04f;
    float dirtNoiseHeight = 3;
    public Chunk ChunkGen(Chunk chunk)
    {
        for (int x = chunk.pos.x; x < chunk.pos.x + Chunk.chunkSize; x++)
        {
            for (int z = chunk.pos.z; z < chunk.pos.z + Chunk.chunkSize; z++)
            {
                chunk = ChunkColumnGen(chunk, x, z);
            }
        }
        return chunk;
    }
    public Chunk ChunkColumnGen(Chunk chunk, int x, int z)
    {
        int stoneHeight = Mathf.FloorToInt(stoneBaseHeight);
        stoneHeight += GetNoise(x, 0, z, stoneMountainFrequency, Mathf.FloorToInt(stoneMountainHeight));
        if (stoneHeight < stoneMinHeight)
            stoneHeight = Mathf.FloorToInt(stoneMinHeight);
        stone
namespace DRMFSS.BLL
    public class UnitOfWork : IUnitOfWork, IDisposable
    {
        
        private readonly CTSContext _context;
        public UnitOfWork()
        {
            _context= new CTSContext();
        }
        #region Fields
        private IGenericRepository<Account> _AccountRepository = null;
        private IGenericRepository<Adjustment> _AdjustmentRepository = null;
        private IGenericRepository<AdjustmentReason> _AdjustmentReasonRepository = null;
        private IGenericRepository<AdminUnit> _AdminUnitRepository = null;
        private IGenericRepository<AdminUnitType> _AdminUnitTypeRepository = null;
        private IGenericRepository<Audit> _AuditRepository = null;
        private IGenericRepository<Commodity> _CommodityRepository = null;
        private IGenericRepository<CommodityGrade> _CommodityGradeRepository = null;
        private IGenericRepository<CommoditySource> _CommoditySourceRepository = null;
        private IGenericRepository<Commodit

        private IGenericRepository<Contact> _ContactRepository = null;
        private IGenericRepository<Detail> _DetailRepository = null;
        private IGenericRepository<Dispatch> _DispatchRepository = null;
        private IGenericRepository<DispatchAllocation> _DispatchAllocationRepository = null;
        private IGenericRepository<DispatchDetail> _DispatchDetailRepository = null;
        private IGenericRepository<Donor> _DonorRepository = null;
        private IGenericRepository<FDP> _FDPRepository = null;
        private IGenericRepository<ForgetPasswordRequest> _ForgetPasswordRequestRepository = null;
        private IGenericRepository<GiftCertificate> _GiftCertificateRepository = null;
        private IGenericRepository<GiftCertificateDetail> _GiftCertificateDetailRepository = null;
        private IGenericRepository<Hub> _HubRepository = null;
        private IGenericRepository<HubOwner> _HubOwnerRepository = null;
        private IGenericRepository<HubSetting> _HubSettin

        private IGenericRepository<HubSettingValue> _HubSettingValueRepository = null;
        private IGenericRepository<InternalMovement> _InternalMovementRepository = null;
        private IGenericRepository<Ledger> _LedgerRepository = null;
        private IGenericRepository<LedgerType> _LedgerTypeRepository = null;
        private IGenericRepository<LetterTemplate> _LetterTemplateRepository = null;
        private IGenericRepository<Master> _MasterRepository = null;
        private IGenericRepository<OtherDispatchAllocation> _OtherDispatchAllocationRepository = null;
        private IGenericRepository<Partition> _PartitionRepository = null;
        private IGenericRepository<Period> _PeriodRepository = null;
        private IGenericRepository<Program> _ProgramRepository = null;
        private IGenericRepository<ProjectCode> _ProjectCodeRepository = null;
        private IGenericRepository<ReceiptAllocation> _ReceiptAllocationRepository = null;
        private IGenericRepository<
namespace DrxApi.Services
    public class InstrumentService : IInstrumentService
    {
        private readonly DrxContext _dbContext;
        public InstrumentService(DrxContext dbContext)
        {
            _dbContext = dbContext;
        }
        public IEnumerable<Instrument> ListAll()
        {
            var instruments = _dbContext.Instruments.ToList();
            return instruments.AsEnumerable();
        }
        public Instrument GetById(long id)
        {
            var intstrument = _dbContext.Instruments.FirstOrDefault(x => x.Id == id);
            return intstrument;
        }
        public void Add(Instrument instrument)
        {
            _dbContext.Instruments.Add(instrument);
            _dbContext.SaveChanges();
        }
        public Instrument Update(Instrument instrument)
        {
            var instrument2Update = _dbContext.Instruments.FirstOrDefault(x => x.Id == instrument.Id);
            instrument2Update.Name = instrument.Name;
            

namespace fluidedotnet
  public delegate void MyCallbackDelegate(SceneParam param);
  public partial class FormParam : Form
  {
    MyCallbackDelegate callback;
    Instrument instrument= new Instrument();
    public FormParam()
    {
      InitializeComponent();
    }
    public void InitParam(string path,MyCallbackDelegate c)
    {
      callback = c;
      var files = from file in Directory.GetFiles(path)
                  orderby file where file.EndsWith(".geo")
                  select file;
      foreach (var file in files)
      {
        FileList.Items.Add(Path.GetFileNameWithoutExtension(file));
      }
      XTrack.Value = 1;
      instrument.zoom = true;
      instrument.zoomx = XTrack.Value;
      instrument.changeinstrument = true;
      SetParams(true);
    }
    private void FormParam_Load(object sender, EventArgs e)
    {
    }
    public void SetParams(bool reinit)
    {
      SceneParam param = new SceneParam();
      param.reinit = reinit;
      if(FileList.SelectedI

        param.file = FileList.SelectedItem.ToString();
      else
      param.file = "free2";
      param.instrument = instrument;
      callback(param);
    }
    private void FileList_SelectedIndexChanged(object sender, EventArgs e)
    {
      instrument = new Instrument();
      SetParams(true);
    }
    private void XTrack_Scroll(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.zoom = true;
      instrument.zoomx = XTrack.Value;
      instrument.changeinstrument = true;
      SetParams(false);
    }
    private void ButDrop_Click(object sender, EventArgs e)
    {
      instrument = new  Instrument();
      instrument.changeinstrument = true;
      instrument.drop = true;
      SetParams(false);
    }
    private void butPipe_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.pipe = true;
      SetParams(false);
    }
    private void butObstacle_Click(objec

    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.setter = true;
      SetParams(false);
    }
    private void butDelate_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.remover = true;
      SetParams(false);
    }
    private void butForce_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.forceup = true;
      SetParams(false);
    }
    private void butForceDown_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.forcedown = true;
      SetParams(false);
    }
    private void butPush_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.push = true;
      SetParams(false);
    }
    private void 
﻿namespace SDK.Lib
    /**
     * @brief 非引用计数资源加载结果通知
     */
    public class ResLoadResultNotify
    {
        public ResLoadResultNotify()
        {
            m_resLoadState = new ResLoadState();
            m_loadResEventDispatch = new ResEventDispatch();
        }
        public ResLoadState resLoadState
        {
            get
            {
                return m_resLoadState;
            }
            set
            {
                m_resLoadState = value;
            }
        }
        public ResEventDispatch loadResEventDispatch
        {
            get
            {
                return m_loadResEventDispatch;
            }
            set
            {
                m_loadResEventDispatch = value;
            }
        }
        public void onLoadEventHandle(IDispatchObject dispObj)
        {
            m_loadResEventDispatch.dispatchEvent(dispObj);
            m_loadResEventDispatch.clearEventHandle();
        }
        virtual public void copyFrom(ResLoadRe
namespace Laugris.Sage
    public sealed class InvokeProcessor : IDisposable
    {
        private Queue<InvokeObjectHandler> queue;
        private IntPtr handle;
        public InvokeProcessor(IntPtr handle)
        {
            this.handle = handle;
            queue = new Queue<InvokeObjectHandler>();
        }
        ~InvokeProcessor()
        {
            Dispose(false);
        }
        public void ExecuteRequest()
        {
            InvokeObjectHandler method = null;
            lock (this.queue)
            {
                if (queue.Count > 0)
                {
                    method = queue.Dequeue();
                }
            }
            if (method != null)
            {
                try
                {
                    if (method.Entry != null)
                        method.Entry(method.Parameter);
                }
                catch (Exception ex)
                {
                    InvocationException ie = new InvocationException(method.E

                    Application.OnThreadException(ie);
                }
            }
        }
        public void BeginInvoke(WaitCallback method)
        {
            InvokeObjectHandler entry = new InvokeObjectHandler(method);
            queue.Enqueue(entry);
            NativeMethods.PostMessage(handle, NativeMethods.CN_BEGININVOKE, IntPtr.Zero, IntPtr.Zero);
        }
        public void BeginInvoke(WaitCallback method, object parameter)
        {
            InvokeObjectHandler entry = new InvokeObjectHandler(method, parameter);
            queue.Enqueue(entry);
            NativeMethods.PostMessage(handle, NativeMethods.CN_BEGININVOKE, IntPtr.Zero, IntPtr.Zero);
        }
        public void BeginInvoke(WaitCallback method, object parameter, string errorMessage)
        {
            InvokeObjectHandler entry = new InvokeObjectHandler(method, parameter, errorMessage);
            queue.Enqueue(entry);
            NativeMethods.PostMessage(handle, NativeMethods.CN_BEGININVOK

        }
        public void BeginInvoke(WaitCallback method, string errorMessage)
        {
            InvokeObjectHandler entry = new InvokeObjectHandler(method, errorMessage);
            queue.Enqueue(entry);
            NativeMethods.PostMessage(handle, NativeMethods.CN_BEGININVOKE, IntPtr.Zero, IntPtr.Zero);
        }
        #region INVOKE
        public void Invoke(WaitCallback method)
        {
            InvokeObjectHandler entry = new InvokeObjectHandler(method);
            queue.Enqueue(entry);
            NativeMethods.SendMessage(handle, NativeMethods.CN_INVOKE, IntPtr.Zero, IntPtr.Zero);
        }
        public void Invoke(WaitCallback method, object parameter)
        {
            InvokeObjectHandler entry = new InvokeObjectHandler(method, parameter);
            queue.Enqueue(entry);
            NativeMethods.SendMessage(handle, NativeMethods.CN_INVOKE, IntPtr.Zero, IntPtr.Zero);
        }
        public void Invoke(WaitCallback method, object parameter, string 
namespace NXKit.XForms
    [Serializable]
    public class XFormsModelItemState : ISerializable
    {
        private bool dispatchReadOnly;
        private bool dispatchReadWrite;
        private bool dispatchRequired;
        private bool dispatchOptional;
        private bool dispatchEnabled;
        private bool dispatchDisabled;
        private bool dispatchValid;
        private bool dispatchInvalid;
        public XFormsModelItemState()
        {
        }
        public XFormsModelItemState(SerializationInfo info, StreamingContext context)
        {
            Id = (int?)info.GetValue("Id", typeof(int?));
            Type = (XName)info.GetValue("Type", typeof(XName));
            ReadOnly = (bool?)info.GetValue("ReadOnly", typeof(bool?));
            Required = (bool?)info.GetValue("Required", typeof(bool?));
            Relevant = (bool?)info.GetValue("Relevant", typeof(bool?));
            Valid = (bool?)info.GetValue("Valid", typeof(bool?));
        }
        public int? Id

        public XName Type { get; set; }
        public bool DispatchValueChanged { get; set; }
        public bool? ReadOnly { get; set; }
        public bool DispatchReadOnly
        {
            get { return dispatchReadOnly; }
            set { dispatchReadOnly = value; if (dispatchReadOnly) dispatchReadWrite = false; }
        }
        public bool DispatchReadWrite
        {
            get { return dispatchReadWrite; }
            set { dispatchReadWrite = value; if (dispatchReadWrite) dispatchReadOnly = false; }
        }
        public bool? Required { get; set; }
        public bool DispatchRequired
        {
            get { return dispatchRequired; }
            set { dispatchRequired = value; if (dispatchRequired) dispatchOptional = false; }
        }
        public bool DispatchOptional
        {
            get { return dispatchOptional; }
            set { dispatchOptional = value; if (dispatchOptional) dispatchRequired = false; }
        }
        public bool? Releva

        public bool DispatchEnabled
        {
            get { return dispatchEnabled; }
            set { dispatchEnabled = value; if (dispatchEnabled) dispatchDisabled = false; }
        }
        public bool DispatchDisabled
        {
            get { return dispatchDisabled; }
            set { dispatchDisabled = value; if (dispatchDisabled) dispatchEnabled = false; }
        }
        public bool? Valid { get; set; }
        public bool DispatchValid
        {
            get { return dispatchValid; }
            set { dispatchValid = value; if (dispatchValid) dispatchInvalid = false; }
        }
        public bool DispatchInvalid
        {
            get { return dispatchInvalid; }
            set { dispatchInvalid = value; if (dispatchInvalid) dispatchValid = false; }
        }
        public bool Clear { get; set; }
        public XElement NewElement { get; set; }
        public string NewValue { get; set; }
        void ISerializable.GetObjectData(SerializationInfo info, 
namespace ProcessRouting.ProcessManagment
    public class ProcessState
    {
        private readonly IList<ProcessStep> _completedProcessStep;
        private readonly IList<MessageType> _receivedMessages;
        private readonly IList<ProcessStep> _startedProcessSteps;
        public ProcessState()
        {
            _startedProcessSteps = new List<ProcessStep>();
            _completedProcessStep = new List<ProcessStep>();
            _receivedMessages = new List<MessageType>();
        }
        public IEnumerable<ProcessStep> CompletedProcessStep => _completedProcessStep;
        public IEnumerable<MessageType> ReceivedMessages => _receivedMessages;
        public IEnumerable<ProcessStep> StartedProcessSteps => _startedProcessSteps;
        public void ReceiveMessage(MessageType messageType)
        {
            _receivedMessages.Add(messageType);
        }
        public void ProcessStarted(ProcessStep processStep)
        {
            _startedProcessSteps.Add(processStep)
namespace ManyToMany.Migrations
    
    public partial class instproj : DbMigration
    {
        public override void Up()
        {
            DropForeignKey("dbo.Instrument", "Project_ProjectID", "dbo.Project");
            DropIndex("dbo.Instrument", new[] { "Project_ProjectID" });
            CreateTable(
                "dbo.InstrumentProject",
                c => new
                    {
                        Instrument_InstrumentID = c.Int(nullable: false),
                        Project_ProjectID = c.Int(nullable: false),
                    })
                .PrimaryKey(t => new { t.Instrument_InstrumentID, t.Project_ProjectID })
                .ForeignKey("dbo.Instrument", t => t.Instrument_InstrumentID, cascadeDelete: true)
                .ForeignKey("dbo.Project", t => t.Project_ProjectID, cascadeDelete: true)
                .Index(t => t.Instrument_InstrumentID)
                .Index(t => t.Project_ProjectID);
            
            DropColumn("dbo.Instrumen
namespace SERVICE.Service
    public class FinanceDispatchDetailService:IFinanceDispatchDetailService
    {
        private HSSNInventoryEntities _context = null;
        public bool SaveFinanceDispatchDetail(List<FinanceDispatchDetailModel> financeDispatchDetailModelsList, int FinanceDispatchid)
        {
            {
                try
                {
                    foreach (var rowData in financeDispatchDetailModelsList)
                    {
                        var model = new FinanceDispatchDetail()
                        {
                            FinanceDispatchId = FinanceDispatchid,
                            ProductId = rowData.ProductId,
                            DispatchFromWareHouseId = rowData.DispatchFromWareHouseId,
                            DispatchOrderId = rowData.DispatchOrderId,
                            Quantity = rowData.Quantity,
                            Rate = rowData.Rate,
                            ExcessShortageQuantity = rowData.
namespace ApiFox.Migrations
    
    public partial class FixIdIssue2 : DbMigration
    {
        public override void Up()
        {
            DropForeignKey("dbo.ApiRequests", "ApiId", "dbo.Apis");
            DropIndex("dbo.ApiRequests", new[] { "ApiId" });
            RenameColumn(table: "dbo.ApiRequests", name: "ApiId", newName: "Api_Id");
            AlterColumn("dbo.ApiRequests", "Api_Id", c => c.Int());
            CreateIndex("dbo.ApiRequests", "Api_Id");
            AddForeignKey("dbo.ApiRequests", "Api_Id", "dbo.Apis", "Id");
        }
        
        public override void Down()
        {
            DropForeignKey("dbo.ApiRequests", "Api_Id", "dbo.Apis");
            DropIndex("dbo.ApiRequests", new[] { "Api_Id" });
            AlterColumn("dbo.ApiRequests", "Api_Id", c => c.Int(nullable: false));
            RenameColumn(table: "dbo.ApiRequests", name: "Api_Id", newName: "ApiId");
            CreateIndex("dbo.ApiRequests", "ApiId");
            AddForeignKey("dbo.ApiReq
namespace Sean.World
	public struct Blocks
	{
		internal Blocks(int chunkSizeX, int chunkHeight, int chunkSizeZ)
		{
			Array = new ushort[chunkHeight, chunkSizeX, chunkSizeZ];
		}
		internal Block this[Coords coords]
		{
			get { return new Block(Array[coords.Yblock, coords.Xblock % Chunk.CHUNK_SIZE, coords.Zblock % Chunk.CHUNK_SIZE]); }
			set { Array[coords.Yblock, coords.Xblock % Chunk.CHUNK_SIZE, coords.Zblock % Chunk.CHUNK_SIZE] = value.BlockData; }
		}
		internal Block this[Position position]
		{
			get { return new Block(Array[position.Y, position.X % Chunk.CHUNK_SIZE, position.Z % Chunk.CHUNK_SIZE]); }
			set { Array[position.Y, position.X % Chunk.CHUNK_SIZE, position.Z % Chunk.CHUNK_SIZE] = value.BlockData; }
		}
		internal Block this[int x, int y, int z]
		{
			get { return new Block(Array[y, x, z]); }
			set { Array[y, x, z] = value.BlockData; }
		}
		internal readonly ushort[, ,] Array;
		[Obsolete("This was for world diffs. Not being used currently.")]
		internal ushort[,
#if UNITY_EDITOR
#endif
namespace VoxelBusters.Utility
#if UNITY_EDITOR
	[InitializeOnLoad]
#endif
	public class EditorInvoke 
	{
		#region Properties
#pragma warning disable
		private static double				m_cachedTimeSinceStartup	= 0f;
#pragma warning restore
		private static Dictionary<System.Action, Dictionary<string, float>>	invokeMethodsContainer;
		#endregion
		#region Constants
		
		private const string 				kTimeSinceLastInvoke		= "time-since-last-invoke";
		private const string				kRepeatRate					= "repeat-rate";
		private const string 				kInvokeAfter				= "invoke-after";
		#endregion
		#region Constructors
		static EditorInvoke ()
		{
			invokeMethodsContainer		= new Dictionary<System.Action, Dictionary<string, float>>();
#if UNITY_EDITOR
			m_cachedTimeSinceStartup	= EditorApplication.timeSinceStartup;
			EditorApplication.update	-= ManageMethodInvoke;
			EditorApplication.update	+= ManageMethodInvoke;
#endif
		}
		#endregion
		#region Invoke Methods
#if UNITY_EDITOR
		private s

		{
			float _dt					= (float)(EditorApplication.timeSinceStartup - m_cachedTimeSinceStartup);
			System.Action[] _methodList	= invokeMethodsContainer.Keys.ToArray<System.Action>();
			for (int _iter = 0; _iter < _methodList.Length; _iter++)
			{
				System.Action _invokeMethod						= _methodList[_iter];
				Dictionary<string, float> _invokeMethodDetails	= invokeMethodsContainer[_invokeMethod];
				_invokeMethodDetails[kTimeSinceLastInvoke] 		+= _dt;
				
				if (_invokeMethodDetails[kTimeSinceLastInvoke] > _invokeMethodDetails[kInvokeAfter])
				{
					_invokeMethod();
					if (!_invokeMethodDetails.ContainsKey(kRepeatRate))
					{
						invokeMethodsContainer.Remove(_invokeMethod);
						continue;
					}
					_invokeMethodDetails[kTimeSinceLastInvoke]	= 0f;
					_invokeMethodDetails[kInvokeAfter]			= _invokeMethodDetails[kRepeatRate];
				}
			}
			
			m_cachedTimeSinceStartup		= EditorApplication.timeSinceStartup;
		}
#endif
		public static void Invoke (System.Action _method, float
namespace Instrument.Business
    public class InstrumentCheckLogServiceImpl
    {
        public void DeleteByInstrumentId(int InstrumentId)
        {
            DBProvider.InstrumentCheckLogDAO.DeleteByInstrumentId(InstrumentId);
        }
        public void DeleteById(int LogId)
        {
            DBProvider.InstrumentCheckLogDAO.DeleteById(LogId);
        }
        public InstrumentCheckLogModel GetById(int LogId)
        {
            return DBProvider.InstrumentCheckLogDAO.GetById(LogId);
        }
        public IList<InstrumentCheckLogModel> GetAll()
        {
            return DBProvider.InstrumentCheckLogDAO.GetAll();
        }
        public IList<Hashtable> GetByInstrumentBarCode(string barCode)
        {
            return DBProvider.InstrumentCheckLogDAO.GetByInstrumentBarCode(barCode);
        }
        public IList<Hashtable> GetByInstrumentId(int instrumentId)
        {
            return DBProvider.InstrumentCheckLogDAO.GetByInstrumentId(instrumentId);
        }
namespace LQT.Core.Domain
    public class ForecastCategoryInstrument
    {
        #region Member Variables
        private int _id;
        private Instrument _instrument;
        private int _forecastId;
        private decimal _testRunPercentage;
        #endregion
        #region Constructors
        public ForecastCategoryInstrument() 
        {
            this._id = -1;
        }
        #endregion
        #region Public Properties
        public virtual int Id
        {
            get { return _id; }
            set { _id = value; }
        }
        public virtual Instrument Instrument
        {
            get { return _instrument; }
            set { _instrument = value; }
        }
        public virtual int ForecastId
        {
            get { return _forecastId; }
            set { _forecastId = value; }
        }
        public virtual decimal TestRunPercentage
        {
            get { return _testRunPercentage; }
            set { _testRunPercentage = value; }
  
namespace BclExtras.Threading
    public static class SafeInvoke
    {
        private static object[] EmptyObjectArray = new object[] { };
        #region Static
        public static void Invoke(this ISynchronizeInvoke target, Action callback)
        {
            InvokeImpl(target, callback);
        }
        public static void Invoke<TArg1>(this ISynchronizeInvoke target, Action<TArg1> callback, TArg1 arg1)
        {
            InvokeImpl(target, () => callback(arg1));
        }
        public static void Invoke<TArg1,TArg2>(this ISynchronizeInvoke target, Action<TArg1,TArg2> callback, TArg1 arg1, TArg2 arg2)
        {
            InvokeImpl(target, () => callback(arg1, arg2));
        }
        public static void InvokeNoThrow(this ISynchronizeInvoke target, Action callback)
        {
            InvokeImplNoThrow(target, callback);
        }
        public static void InvokeNoThrow<TArg1>(this ISynchronizeInvoke target, Action<TArg1> callback, TArg1 arg1)
        {
           

        }
        public static void InvokeNoThrow<TArg1,TArg2>(this ISynchronizeInvoke target, Action<TArg1,TArg2> callback, TArg1 arg1, TArg2 arg2)
        {
            InvokeImplNoThrow(target, () => callback(arg1,arg2)); 
        }
        public static TReturn Invoke<TReturn>(this ISynchronizeInvoke target, Func<TReturn> del)
        {
            return InvokeImpl(target, del);
        }
        public static TReturn Invoke<TReturn,TArg1>(this ISynchronizeInvoke target, Func<TArg1, TReturn> del, TArg1 arg1)
        {
            return InvokeImpl(target, () => del(arg1)); 
        }
        public static TReturn Invoke<TReturn,TArg1,TArg2>(this ISynchronizeInvoke target, Func<TArg1,TArg2, TReturn> del, TArg1 arg1, TArg2 arg2)
        {
            return InvokeImpl(target, () => del(arg1, arg2)); 
        }
        public static TReturn InvokeNoThrow<TReturn>(this ISynchronizeInvoke target, Func<TReturn> del)
        {
            return InvokeImplNoThrow(target, del);
        

        public static TReturn InvokeNoThrow<TReturn,TArg1>(this ISynchronizeInvoke target, Func<TArg1, TReturn> del, TArg1 arg1)
        {
            return InvokeImplNoThrow(target, () => del(arg1)); 
        }
        public static TReturn InvokeNoThrow<TReturn,TArg1,TArg2>(this ISynchronizeInvoke target, Func<TArg1,TArg2,TReturn> del, TArg1 arg1, TArg2 arg2)
        {
            return InvokeImplNoThrow(target, () => del(arg1, arg2)); 
        }
        public static IAsyncResult BeginInvoke(this ISynchronizeInvoke target, Action callback)
        {
            return BeginInvokeImpl(target, callback);
        }
        public static IAsyncResult BeginInvoke<TArg1>(this ISynchronizeInvoke target, Action<TArg1> callback, TArg1 arg1)
        {
            return BeginInvokeImpl(target, Lambda.Create(() => callback(arg1))); 
        }
        public static IAsyncResult BeginInvoke<TArg1,TArg2>(this ISynchronizeInvoke target, Action<TArg1,TArg2> callback, TArg1 arg1, TArg2 arg2)
    
namespace Shop.Web
    public static class WebApiConfig
    {
        public static void Register(HttpConfiguration config)
        {
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/countries/get", "ManufacturerApi", "GetCountries");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/categories/get", "CategoryApi", "GetCategories");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/categories/order/update", "CategoryApi", "UpdateSortOrder");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/category/create", "CategoryApi", "Create");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/category/update", "CategoryApi", "Update");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/category/{categoryId}/delete", "CategoryApi", "Remove");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/manufacturers/get", "ManufacturerApi", "GetManufacturers");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/manufactur

            WebApiConfigHelper.ApiRoute(config.Routes, "shop/manufacturer/create", "ManufacturerApi", "Create");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/manufacturer/update", "ManufacturerApi", "Update");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/manufacturer/{manufacturerId}/delete", "ManufacturerApi", "Delete");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/suppliers/get", "ManufacturerApi", "GetSuppliers");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/packs/get", "PackApi", "GetPacks");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/pack/create", "PackApi", "Create");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/pack/update", "PackApi", "Update");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/pack/{packId}/delete", "PackApi", "Delete");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/pack/{packId}/get", "PackApi", "Get");
            WebApiConfigHelper.Ap

            WebApiConfigHelper.ApiRoute(config.Routes, "shop/compatible/create", "CompatibleApi", "Create");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/compatible/update", "CompatibleApi", "Update");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/compatible/{compatibleSetId}/delete", "CompatibleApi", "Delete");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/compatible/{compatibleSetId}/get", "CompatibleApi", "Get");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/actions/get", "ActionApi", "GetActions");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/action/{actionId}/get", "ActionApi", "Get");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/action/create", "ActionApi", "Create");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/action/update", "ActionApi", "Update");
            WebApiConfigHelper.ApiRoute(config.Routes, "shop/action/{actionId}/delete", "ActionApi", "Delete");
          
namespace UI
    public class EntityConvert
    {
        #region 库存管理
        public static RdRecord ConvertToRdrecord(DispatchList dispatchList)
        {
            RdRecord rdRecord = new RdRecord();
            rdRecord.cWhCode = dispatchList.cWhCode;
            rdRecord.cWhName = dispatchList.cWhName;
            rdRecord.cAccounter = dispatchList.cAccounter;
            rdRecord.cAddCode = dispatchList.caddcode;
            rdRecord.cBusCode = string.IsNullOrEmpty(dispatchList.cSBVCode) ? dispatchList.cDLCode : dispatchList.cSBVCode;
            rdRecord.cBusType = dispatchList.cBusType;
            rdRecord.cContactName = dispatchList.cContactName;
            rdRecord.cCusAbbName = dispatchList.cCusAbbName;
            rdRecord.cCusCode = dispatchList.cCusCode;
            rdRecord.ccusperson = dispatchList.ccusperson;
            rdRecord.cDefine1 = dispatchList.cDefine1;
            rdRecord.cDefine2 = dispatchList.cDefine2;
            rdRecord.cDefine3 = dispatchList.cDe

            rdRecord.cDefine4 = dispatchList.cDefine4;
            rdRecord.cDefine5 = dispatchList.cDefine5;
            rdRecord.cDefine6 = dispatchList.cDefine6;
            rdRecord.cDefine7 = dispatchList.cDefine7;
            rdRecord.cDefine8 = dispatchList.cDefine8;
            rdRecord.cDefine9 = dispatchList.cDefine9;
            rdRecord.cDefine10 = dispatchList.cDefine10;
            rdRecord.cDefine11 = dispatchList.cDefine11;
            rdRecord.cDefine12 = dispatchList.cDefine12;
            rdRecord.cDefine13 = dispatchList.cDefine13;
            rdRecord.cDefine14 = dispatchList.cDefine14;
            rdRecord.cDefine15 = dispatchList.cDefine15;
            rdRecord.cDefine16 = dispatchList.cDefine16;
            rdRecord.cdeliverunit = dispatchList.cdeliverunit;
            rdRecord.cDepCode = dispatchList.cDepCode;
            rdRecord.cDepName = dispatchList.cDepName;
            rdRecord.DLID = dispatchList.DLID;
            rdRecord.cDLCode = dispatchList.cDLCod

            rdRecord.cMemo = dispatchList.cMemo;
            rdRecord.cmobilephone = dispatchList.cmobilephone;
            rdRecord.cofficephone = dispatchList.cofficephone;
            rdRecord.cPersonCode = dispatchList.cPersonCode;
            rdRecord.cPersonName = dispatchList.cPersonName;
            rdRecord.cShipAddress = dispatchList.cShipAddress;
            rdRecord.cSource = dispatchList.cVouchName;
            rdRecord.cSTCode = dispatchList.cSTCode;
            rdRecord.cSTName = dispatchList.cSTName;
            rdRecord.iswfcontrolled= dispatchList.iswfcontrolled;
            rdRecord.ufts = dispatchList.ufts;
            return rdRecord;
        }
        public static RdRecords ConvertToRdrecords(DispatchLists dispatchLists)
        {
            RdRecords rdRecords = new RdRecords();
            rdRecords.bCosting = dispatchLists.bCosting;
            rdRecords.bGsp = dispatchLists.bGsp;
            rdRecords.cWhCode = dispatchLists.cWhCode;
            rdRecords.c
namespace TaskManager.Models.Repository
    public partial class UnitOfWork
    {
        private GenericRepository<Project> _projectsRepository;
        public GenericRepository<Project> ProjectsRepository
        {
			get { return _projectsRepository ?? (_projectsRepository = new GenericRepository<Project>(_context)); }
        }
        private GenericRepository<Module> _modulesRepository;
        public GenericRepository<Module> ModulesRepository
        {
			get { return _modulesRepository ?? (_modulesRepository = new GenericRepository<Module>(_context)); }
        }
        private GenericRepository<TaskCategory> _taskcategoriesRepository;
        public GenericRepository<TaskCategory> TaskCategoriesRepository
        {
			get { return _taskcategoriesRepository ?? (_taskcategoriesRepository = new GenericRepository<TaskCategory>(_context)); }
        }
        private GenericRepository<TaskReportDetail> _taskreportdetailsRepository;
        public GenericRepository<TaskReportDetai

        {
			get { return _taskreportdetailsRepository ?? (_taskreportdetailsRepository = new GenericRepository<TaskReportDetail>(_context)); }
        }
        private GenericRepository<TaskFormDetail> _taskformdetailsRepository;
        public GenericRepository<TaskFormDetail> TaskFormDetailsRepository
        {
			get { return _taskformdetailsRepository ?? (_taskformdetailsRepository = new GenericRepository<TaskFormDetail>(_context)); }
        }
        private GenericRepository<TaskNote> _tasknotesRepository;
        public GenericRepository<TaskNote> TaskNotesRepository
        {
			get { return _tasknotesRepository ?? (_tasknotesRepository = new GenericRepository<TaskNote>(_context)); }
        }
        private GenericRepository<Task> _tasksRepository;
        public GenericRepository<Task> TasksRepository
        {
			get { return _tasksRepository ?? (_tasksRepository = new GenericRepository<Task>(_context)); }
        }
        private GenericRepository<Comment> _commentsRe
namespace FacturatieSysteem.Models
    public class UnitOfWork : IDisposable
    {
        public FacturatieSysteemContext Context { get; set; }
        private AddressRepository addressRepository;
        private CustomerRepository customerRepository;
        private DepartmentRepository departmentRepository;
        private HourRegistrationRepository hourRegistrationRepository;
        private HourRegistrationDetailRepository hourRegistrationDetailRepository;
        private InvoiceRepository invoiceRepository;
        private InvoiceDetailRepository invoiceDetailRepository;
        private RateRepository rateRepository;
        private RoleRepository roleRepository;
        private UserRepository userRepository;
        public UserRepository UserRepository
        {
            get
            {
                if (userRepository == null)
                {
                    userRepository = new UserRepository(Context);
                }
                return userRepository;
     

            set { userRepository = value; }
        }
        
        public RoleRepository RoleRepository
        {
            get
            {
                if (roleRepository == null)
                {
                    roleRepository = new RoleRepository(Context);
                }
                return roleRepository;
            }
            set { roleRepository = value; }
        }
        
        public RateRepository RateRepository
        {
            get
            {
                if (rateRepository == null)
                {
                    rateRepository = new RateRepository(Context);
                }
                return rateRepository;
            }
            set { rateRepository = value; }
        }
        
        public InvoiceDetailRepository InvoiceDetailRepository
        {
            get
            {
                if (invoiceDetailRepository == null)
                {
                    invoiceDetailRepository = new InvoiceDetailRepos

                }
                return invoiceDetailRepository;
            }
            set { invoiceDetailRepository = value; }
        }
        
        public InvoiceRepository InvoiceRepository
        {
            get 
            {
                if (invoiceRepository == null)
                {
                    invoiceRepository = new InvoiceRepository(Context);
                }
                return invoiceRepository;
            }
            set { invoiceRepository = value; }
        }
        
        public HourRegistrationDetailRepository HourRegistrationDetailRepository
        {
            get
            {
                if (hourRegistrationDetailRepository == null)
                {
                    hourRegistrationDetailRepository = new HourRegistrationDetailRepository(Context);
                }
                return hourRegistrationDetailRepository;
            }
            set { hourRegistrationDetailRepository = value; }
        }
        
     
namespace WindowsFormsApplication4
    public partial class Dispatch_Orders : UserControl
    {
        Database db = new Database();
        private static Dispatch_Orders _instance;
        public static Dispatch_Orders Instance
        {
            get
            {
                if (_instance == null)
                    _instance = new Dispatch_Orders();
                return _instance;
            }
        }
        public Dispatch_Orders()
        {
            InitializeComponent();
        }
        private void orderIdDispatch_OnValueChanged(object sender, EventArgs e)
        {
        }
        private void orderIdDispatch_Enter(object sender, EventArgs e)
        {
            if (orderIdDispatch.Text == "Order Id")
            {
                orderIdDispatch.Text = "";
                orderIdDispatch.ForeColor = Color.Black;
            }
        }
        private void orderIdDispatch_Leave(object sender, EventArgs e)
        {
            if (orderIdDispatch.Text 

            {
                orderIdDispatch.Text = "Order Id";
                orderIdDispatch.ForeColor = Color.DimGray;
            }
        }
        private void reasonDispatch_Enter(object sender, EventArgs e)
        {
            if (reasonDispatch.Text == "Reason")
            {
                reasonDispatch.Text = "";
                reasonDispatch.ForeColor = Color.Black;
            }
        }
        private void reasonDispatch_OnValueChanged(object sender, EventArgs e)
        {
        }
        private void reasonDispatch_Leave(object sender, EventArgs e)
        {
            if (reasonDispatch.Text == "")
            {
                reasonDispatch.Text = "Reason";
                reasonDispatch.ForeColor = Color.DimGray;
            }
        }
        private void button2_Click(object sender, EventArgs e)
        {
            DataSet ds = db.dbse("SELECT itemId,stockNo,ItemName,status,reason_dispatch FROM item");
            bunifuCustomDataGrid1.DataSource =
public class WaitTimeCount : Katana.Singleton<WaitTimeCount>
	public Action Action;
    [System.Serializable]
    private class InvokeWaitSet
	{
		public float time;
		public InvokeAction invoke;
        public bool ignoreTimeScale;
        public bool active;
		public InvokeWaitSet(float _time , InvokeAction _invoke, bool _ignoreTimeScale) {
			time = _time;
			invoke = _invoke;
            ignoreTimeScale = _ignoreTimeScale;
            active = true;
        }
        public InvokeWaitSet()
        {
            time = 0;
            invoke = null;
            ignoreTimeScale = false;
            active = false;
        }
    }
    InvokeWaitSet[] invokeWaitSetList = new InvokeWaitSet[64];
    void Start() {
        for (int index = 0; index < invokeWaitSetList.Length; index++)
        {
            invokeWaitSetList[index] = new InvokeWaitSet();
        }
    }
	void Update()
	{
		for (int index = 0; index < invokeWaitSetList.Length; index++)
		{
            InvokeWaitSet invokeWai

            if (invokeWaitSet.active)
            {
                invokeWaitSet.time -= invokeWaitSet.ignoreTimeScale ? Time.unscaledDeltaTime : Time.deltaTime;
                if (invokeWaitSet.time <= 0.0f)
                {
                    invokeWaitSet.invoke();
                    invokeWaitSet.time = -1;
                    invokeWaitSet.active = false;
                    invokeWaitSet.invoke = null;
                }
            }
		}
	}
	public void AddCommand(float duration, InvokeAction InvokeAction ,  bool ignoreTimeScale)
	{
        for (int index = 0; index < invokeWaitSetList.Length; index++)
        {
            if (!invokeWaitSetList[index].active) {
                invokeWaitSetList[index].time = duration;
                invokeWaitSetList[index].invoke = InvokeAction;
                invokeWaitSetList[index].ignoreTimeScale = ignoreTimeScale;
                invokeWaitSetList[index].active = true;
                return;
            }
        }
        Debug.
namespace DL.GuildWars2Api.V2
    internal class Version2Facade : IVersion2Api
    {
        private string key;
        public Version2Facade()
            : this(string.Empty)
        {
        }
        public Version2Facade(string apiKey)
        {
            this.key = apiKey;
            this.Account = new AccountApi(apiKey);
            this.Character = new CharacterApi(apiKey);
            this.Currency = new CurrencyApi();
            this.Dungeon = new DungeonApi();
            this.Guild = new GuildApi(apiKey);
            this.Item = new ItemApi();
            this.Raid = new RaidApi();
            this.Skin = new SkinApi();
            this.World = new WorldApi();
        }
        public string ApiKey
        {
            get => this.key;
            set
            {
                this.key = value;
                this.Account.Key = value;
                this.Character.Key = value;
                this.Guild.Key = value;
            }
        }
        public IAuthe
/* 
*   NatCam
*   Copyright (c) 2016 Yusuf Olokoba
*/
namespace NatCamU {
    
    namespace Internals {
        
        public sealed class NatCamDispatch {
            public bool isRunning {get {return running;}}
            
            private DispatchMode mode;
            private Thread targetThread, mainThread, workerThread;
            private Queue invocation, update, execution;
            private MonoBehaviour timesliceProvider;
            private Coroutine routine;
            private readonly object queueLock = new object();
            private volatile bool running;
            
            #region --Ctor & Dtor--
            public static NatCamDispatch Prepare (DispatchMode Mode, MonoBehaviour TimesliceProvider = null, int Rate = 15) {
                NatCamDispatch dispatch = new NatCamDispatch {
                    mode = Mode,
                    mainThread = Thread.CurrentThread,
                    timesliceProvider = TimesliceProvider,
                    invo

                    update = new Queue(),
                    execution = new Queue(),
                    running = true
                };
                dispatch.workerThread = Mode == DispatchMode.Asynchronous ? new Thread(() => dispatch.Routine<Camera>(dispatch.Update, Rate)) : null;
                dispatch.targetThread = Mode == DispatchMode.Asynchronous ? dispatch.workerThread : dispatch.mainThread;
                if (Mode == DispatchMode.Synchronous) {
                    if (dispatch.timesliceProvider) dispatch.routine = Routine<Camera>(dispatch.Update, new WaitForEndOfFrame()).Invoke(dispatch.timesliceProvider);
                    else Camera.onPostRender += dispatch.Update;
                }
                else dispatch.workerThread.Start();
                Debug.Log("NatCam: Initialized "+Mode+" Dispatcher");
                return dispatch;
            }
            public static void Release (NatCamDispatch dispatch) {
                if (dispatch == null) return;
 

                dispatch.running = false;
                if (dispatch.mode == DispatchMode.Synchronous) {
                    if (dispatch.routine != null) dispatch.routine.Terminate(dispatch.timesliceProvider);
                    else Camera.onPostRender -= dispatch.Update;
                }
                else dispatch.workerThread.Join();
                Debug.Log("NatCam: Released "+dispatch.mode+" Dispatcher");
            }
            private NatCamDispatch () {}
            ~NatCamDispatch () {
                invocation.Clear(); update.Clear(); execution.Clear();
                invocation =
                update =
                execution = null;
                mainThread =
                workerThread =
                targetThread = null;
                timesliceProvider = null;
                routine = null;
            }
            #endregion
            #region --Dispatching--
            public void Dispatch (Action action) {
                if (Thread.Current
namespace NAudio.SoundFont 
	internal class InstrumentBuilder : StructureBuilder<Instrument>
	{
		private Instrument lastInstrument = null;
        public override Instrument Read(BinaryReader br) 
		{
			Instrument i = new Instrument();
			string s = Encoding.UTF8.GetString(br.ReadBytes(20), 0, 20);
			if(s.IndexOf('\0') >= 0) 
			{
				s = s.Substring(0,s.IndexOf('\0'));
			}
			i.Name = s;
			i.startInstrumentZoneIndex = br.ReadUInt16();
			if(lastInstrument != null)
			{
				lastInstrument.endInstrumentZoneIndex = (ushort) (i.startInstrumentZoneIndex - 1);
			}
			data.Add(i);
			lastInstrument = i;
			return i;
		}
        public override void Write(BinaryWriter bw, Instrument instrument) 
		{
		}
		public override int Length 
		{
			get 
			{
				return 22;
			}
		}
		public void LoadZones(Zone[] zones)
		{
			for(int instrument = 0; instrument < data.Count - 1; instrument++)
			{
				Instrument i = (Instrument) data[instrument];
				i.Zones = new Zone[i.endInstrumentZoneIndex - 
namespace FreeQuant.Trading
	[StrategyComponent("{849E4CFE-C19E-4d1e-899D-0BB26DB12AAD}", ComponentType.MarketManager, Description = "", Name = "Default_MarketManager")]
	public class MarketManager : StrategyBaseMultiComponent
	{
		public const string GUID = "{849E4CFE-C19E-4d1e-899D-0BB26DB12AAD}";
		private Dictionary<Instrument, IMarketDataProvider> nxTAjlViDK;
		private Dictionary<Instrument, IExecutionProvider> utDAWNS3ic;
		private InstrumentList cYRAR9UWJy;
		protected IMarketDataProvider strategyMarketDataProvider;
		protected IExecutionProvider strategyExecutionProvider;
		[Browsable(false)]
		public InstrumentList Instruments
		{
			get
			{
				return this.cYRAR9UWJy;
			}
		}
		[Browsable(false)]
		internal IMarketDataProvider OM26eKMfqS
		{
			get
			{
				return this.strategyMarketDataProvider;
			}
			set
			{
				this.strategyMarketDataProvider = value;
			}
		}
		[Browsable(false)]
		internal IExecutionProvider TOY6zSGlVT
		{
			get
			{
				return this.strategyExecuti

			}
			set
			{
				this.strategyExecutionProvider = value;
			}
		}
		[Browsable(false)]
		internal Dictionary<Instrument, IMarketDataProvider> jcIApP7GcT
		{
			get
			{
				return this.nxTAjlViDK;
			}
		}
		[Browsable(false)]
		internal Dictionary<Instrument, IExecutionProvider> UyiAAd6ITD
		{
			get
			{
				return this.utDAWNS3ic;
			}
		}
		public MarketManager() : base()
		{
			this.nxTAjlViDK = new Dictionary<Instrument, IMarketDataProvider>();
			this.utDAWNS3ic = new Dictionary<Instrument, IExecutionProvider>();
			this.cYRAR9UWJy = new InstrumentList();
		}
		public void AddInstrument(Instrument instrument, IMarketDataProvider marketDataProvider, IExecutionProvider executionProvider)
		{
			if (!this.cYRAR9UWJy.Contains(instrument))
				this.cYRAR9UWJy.Add(instrument);
			this.nxTAjlViDK[instrument] = marketDataProvider == null ? this.strategyMarketDataProvider : marketDataProvider;
			if (executionProvider != null)
				this.utDAWNS3ic[instrument] = executionProvider;
			

				this.utDAWNS3ic[instrument] = this.strategyExecutionProvider;
		}
		public void AddInstrument(Instrument instrument, string marketDataProviderName, string executionProviderName)
		{
			IMarketDataProvider marketDataProvider = ProviderManager.MarketDataProviders[marketDataProviderName];
			IExecutionProvider executionProvider = ProviderManager.ExecutionProviders[executionProviderName];
			if (marketDataProvider == null && marketDataProviderName != "")
				throw new InvalidOperationException(instrument.Symbol);
			if (executionProvider == null && executionProviderName != "")
				throw new InvalidOperationException(instrument.Symbol);
			this.AddInstrument(instrument, marketDataProvider, executionProvider);
		}
		public void AddInstrument(string symbol, string marketDataProviderName, string executionProviderName)
		{
			Instrument instrument = InstrumentManager.Instruments[symbol];
			if (instrument == null)
				return;
			this.AddInstrument(instrument, marketDataProviderName, execut
﻿namespace Allors.Server
    public class InvokeResponseBuilder
    {
        private readonly ISession session;
        private readonly InvokeRequest invokeRequest;
        private User user;
        public InvokeResponseBuilder(ISession session, User user, InvokeRequest invokeRequest)
        {
            this.session = session;
            this.user = user;
            this.invokeRequest = invokeRequest;
        }
        public InvokeResponse Build()
        {
            if (this.invokeRequest.M == null || this.invokeRequest.I == null || this.invokeRequest.V == null)
            {
                throw new ArgumentException();
            }
            var obj = this.session.Instantiate(this.invokeRequest.I);
            var composite = (Composite)obj.Strategy.Class;
            var methodTypes = composite.WorkspaceMethodTypes;
            var methodType = methodTypes.FirstOrDefault(x => x.Name.Equals(this.invokeRequest.M));
            if (methodType == null)
            {
    

            }
            
            var invokeResponse = new InvokeResponse();
            if (!this.invokeRequest.V.Equals(obj.Strategy.ObjectVersion.ToString()))
            {
                invokeResponse.AddVersionError(obj);
            }
            else
            {
                var acl = new AccessControlList(obj, this.user);
                if (acl.CanExecute(methodType))
                {
                    var method = obj.GetType().GetMethod(methodType.Name, new Type[] { });
                    try
                    {
                        method.Invoke(obj, null);
                    }
                    catch (Exception e)
                    {
                        var innerException = e;
                        while (innerException.InnerException != null)
                        {
                            innerException = innerException.InnerException;
                        }
                        invokeResponse.ErrorMessage = innerException.Mes
namespace Assets.Scripts.GameScripts.GameLogic.Misc
    [AddComponentMenu("Misc/FixTimeDispatcher")]
    public class FixTimeDispatcher : GameLogic
    {
        public event Action DispatchEventHander;
        public float DispatchInterval;
        public float DispatchCoolDownPercentage {
            get
            {
                return ((Time.fixedTime - _lastFrameTime) >= DispatchInterval)
                    ? 1.0f
                    : ((Time.fixedTime - _lastFrameTime) / DispatchInterval);
            }
        }
        private float _lastFrameTime;
        public void ResetTime () 
        {
            _lastFrameTime = Time.time;
        }
        public bool CanDispatch()
        {
            if (DispatchInterval <= 0f)
            {
                return true;
            }
            return ((Time.fixedTime - _lastFrameTime) >= DispatchInterval);
        }
        public bool Dispatch()
        {
            if (CanDispatch())
            {
                if (Dispa
namespace Omega.Lib.APNG.Chunks
	{
	public class ChunkType
		{
		public static readonly ChunkType IHDR = new ChunkType("IHDR");
		public static readonly ChunkType PLTE = new ChunkType("PLTE");
		public static readonly ChunkType IDAT = new ChunkType("IDAT");
		public static readonly ChunkType IEND = new ChunkType("IEND");
		public static readonly ChunkType cHRM = new ChunkType("cHRM");
		public static readonly ChunkType gAMA = new ChunkType("gAMA");
		public static readonly ChunkType iCCP = new ChunkType("iCCP");
		public static readonly ChunkType sBIT = new ChunkType("sBIT");
		public static readonly ChunkType sRGB = new ChunkType("sRGB");
		public static readonly ChunkType bKGD = new ChunkType("bKGD");
		public static readonly ChunkType hIST = new ChunkType("hIST");
		public static readonly ChunkType tRNS = new ChunkType("tRNS");
		public static readonly ChunkType pHYs = new ChunkType("pHYs");
		public static readonly ChunkType sPLT = new ChunkType("sPLT");
		public static readonly Ch
namespace MusicSchool.Controllers
    public class ResetController : Controller
    {
        private MusicSchoolDbContext MusicSchoolDB = new MusicSchoolDbContext();
        /* Re creates the database and populates data */
        public ActionResult Index()
        {
            MusicSchoolDB.Database.Create();
            PopulateInstruments();
            PopulateStudents();
            PopulateTutors();
            PopulateQualifications();
            return View();
        }
         /*************************************************************************************************************************************************************
                                                            POPULATING THE DATABASE
         * ***********************************************************************************************************************************************************
         */
        public Instrument findInstrument(int id)
        {
            return Musi

        }
        
        /* Inserting Students */
        public void PopulateStudents()
        {
            List<Student> Students = new List<Student>
            {
                new Student{FirstName="Arthur", LastName="Miller", PhoneNumber=113456789, Age=14, Instrument = findInstrument(2), OwnInstrument = true},
                new Student{FirstName="Leonard", LastName="Cohen", PhoneNumber=223456789, Age=8, Instrument = findInstrument(3), OwnInstrument = true},
                new Student{FirstName="Maria", LastName="Callas", PhoneNumber=333456789, Age=4, Instrument = findInstrument(3), OwnInstrument = true},
                new Student{FirstName="Jessye", LastName="Norman", PhoneNumber=443456789, Age=16, Instrument = findInstrument(4), OwnInstrument = true},
                new Student{FirstName="Kathleen", LastName="Battle", PhoneNumber=553456789, Age=17, Instrument = findInstrument(6), OwnInstrument = false},
            };
            foreach(Student s in Students)
      

                MusicSchoolDB.Students.Add(s);
            }
            MusicSchoolDB.SaveChanges();
        }
        /* Inserting Instruments */
        public void PopulateInstruments()
        {
            List<Instrument> Instruments = new List<Instrument>
            {
                new Instrument{Name="Cello", RentalFee=40},
                new Instrument{Name="Flute", RentalFee=25},
                new Instrument{Name="Violin", RentalFee=25},
                new Instrument{Name="Clarinet", RentalFee=40},
                new Instrument{Name="Trumpet", RentalFee=60},
                new Instrument{Name="Trombone", RentalFee=65},
                new Instrument{Name="Saxophone", RentalFee=60},
            };
            foreach (Instrument i in Instruments)
            {
                MusicSchoolDB.Instruments.Add(i);
            }
            MusicSchoolDB.SaveChanges();
        }
        /* Inserting Tutors */
        public void PopulateTutors()
        {
            List
namespace Microsoft.AspNetCore.Mvc.Razor.Directives
    public class InjectChunkMerger : IChunkMerger
    {
        private readonly HashSet<string> _addedMemberNames = new HashSet<string>(StringComparer.Ordinal);
        private string _modelType;
        public InjectChunkMerger(string modelType)
        {
            if (modelType == null)
            {
                throw new ArgumentNullException(nameof(modelType));
            }
            _modelType = "<" + modelType + ">";
        }
        public void VisitChunk(Chunk chunk)
        {
            if (chunk == null)
            {
                throw new ArgumentNullException(nameof(chunk));
            }
            var injectChunk = chunk as InjectChunk;
            if (injectChunk != null)
            {
                injectChunk.TypeName = ChunkHelper.ReplaceTModel(injectChunk.TypeName, _modelType);
                _addedMemberNames.Add(injectChunk.MemberName);
            }
        }
        public void MergeInherited

        {
            if (chunkTree == null)
            {
                throw new ArgumentNullException(nameof(chunkTree));
            }
            if (inheritedChunks == null)
            {
                throw new ArgumentNullException(nameof(inheritedChunks));
            }
            for (var i = inheritedChunks.Count - 1; i >= 0; i--)
            {
                var injectChunk = inheritedChunks[i] as InjectChunk;
                if (injectChunk != null &&
                    _addedMemberNames.Add(injectChunk.MemberName))
                {
                    chunkTree.Children.Add(TransformChunk(injectChunk));
                }
            }
        }
        private InjectChunk TransformChunk(InjectChunk injectChunk)
        {
            var typeName = ChunkHelper.ReplaceTModel(injectChunk.TypeName, _modelType);
            if (typeName != injectChunk.TypeName)
            {
                return new InjectChunk(typeName, injectChunk.MemberName)
                {
   
namespace PP.WaiMai.Repository
	public class CommentRepository : BaseRepository<Comment>,ICommentRepository
    {
    }
	public class ConfigRepository : BaseRepository<Config>,IConfigRepository
    {
    }
	public class ExpendLogRepository : BaseRepository<ExpendLog>,IExpendLogRepository
    {
    }
	public class FeedbackRepository : BaseRepository<Feedback>,IFeedbackRepository
    {
    }
	public class FoodMenuRepository : BaseRepository<FoodMenu>,IFoodMenuRepository
    {
    }
	public class FoodMenuCategoryRepository : BaseRepository<FoodMenuCategory>,IFoodMenuCategoryRepository
    {
    }
	public class OrderRepository : BaseRepository<Order>,IOrderRepository
    {
    }
	public class RechargeRepository : BaseRepository<Recharge>,IRechargeRepository
    {
    }
	public class RestaurantRepository : BaseRepository<Restaurant>,IRestaurantRepository
    {
    }
	public class SarcasmRepository : BaseRepository<Sarcasm>,ISarcasmRepository
    {
    }
	public class UserRepository : BaseRe
public class Battle
    public List<Instrument> sideOneInstruments = new List<Instrument>();
    public List<Instrument> sideTwoInstruments = new List<Instrument>();
    public int Participants { get { return sideOneInstruments.Count + sideTwoInstruments.Count; } }
    public List<Instrument> AllInstruments { get { return sideOneInstruments.Concat(sideTwoInstruments).ToList(); } }
    public bool battleGoing;
    Instrument _currentRiffer;
    public Instrument CurrentRiffer { get { return _currentRiffer; } }
    public bool RoundFinished()
    {
        bool roundFinished = true;
        foreach (Instrument instrument in AllInstruments)
        {
            if (instrument.AudioPlaying) roundFinished = false;
        }
        return roundFinished;
    }
    public void RunRound()
    {
        if (sideOneInstruments.Contains(_currentRiffer))
            _currentRiffer = sideTwoInstruments[Random.Range(0, sideTwoInstruments.Count)];
        else if (sideTwoInstruments.Contains(_curren

            _currentRiffer = sideOneInstruments[Random.Range(0, sideOneInstruments.Count)];
        foreach (Instrument instrument in AllInstruments)
        {
            if (instrument == _currentRiffer)
                instrument.PlayRiff();
            else
                instrument.PlayRythm();
        }
    }
    public void UpdateBattle()
    {
        if (sideOneInstruments.Count == 0 || sideTwoInstruments.Count == 0)
        {
            if (battleGoing)
                battleGoing = false;
            return;
        }
        if (!battleGoing)
        {
            int startingRifferTeam = Random.Range(0, 2);
            if (startingRifferTeam == 0) _currentRiffer = sideOneInstruments[Random.Range(0, sideOneInstruments.Count)];
            else if (startingRifferTeam == 1) _currentRiffer = sideTwoInstruments[Random.Range(0, sideTwoInstruments.Count)];
            battleGoing = true;
        }
    }
public class BattleManager : MonoBehaviour 
    public static BattleManage

    public GameObject riffRing;
    List<Battle> _currentBattles = new List<Battle>();
    void Awake()
    {
        Instance = this;
    }
    void Update()
    {
        foreach (Battle battle in _currentBattles)
        {
            if (battle == null)
            {
                _currentBattles.Remove(battle);
                break;
            }
            if (battle.battleGoing)
            {
                if (battle.RoundFinished())
                {
                    battle.RunRound();
                    riffRing.transform.position = battle.CurrentRiffer.transform.position;
                }
            }
        }
    }
    public void AddInstrumentToBattle(Battle battle, Instrument instrument, int side)
    {
        if (battle == null)
        {
            battle = new Battle();
            _currentBattles.Add(battle);
        }
        if (side == 1) battle.sideOneInstruments.Add(instrument);
        else if (side == 2) battle.sideTwoInstruments.Add(instrument);
namespace NordicaAssistans.Data
    public interface IUnitOfWork
    {
        UserRepository UserRepository { get; }
        ClientRepository ClientRepository { get; }
        AssistantRepository AssistantRepository { get; }
        AssistanceRepository AssistanceRepository { get; }
        PaymentRepository PaymentRepository { get; }
        LogRepository ChangeLogRepository { get; }
        DivergenceRepository DivergenceRepository { get; }
        ResultRepository ResultRepository { get; }
        PlanRepository PlanRepository { get; }
        PaymentComparisonRepository PaymentComparisonRepository { get; }
        ImportFileRepository ImportFileRepository { get; }
        PermissionRepository PermissionRepository { get; }
        UserPermissionRepository UserPermissionRepository { get; }
        SettingRepository SettingRepository { get; }
        SettingValueRepository SettingValueRepository { get; }
        ImportLogRepository ImportLogRepository { get;  }
        LogRepository 

        AgeGroupRepository AgeGroupRepository { get; }
        RateRepository RateRepository { get; }
        int Save();
    }
    public class UnitOfWork : IUnitOfWork, IDisposable
    {
        private readonly NordicaAssistansContext _context;
        private UserRepository _userRepository;
        private ClientRepository _clientRepository;
        private AssistantRepository _assistantRepository;
        private AssistanceRepository _assistanceRepository;
        private PaymentRepository _paymentRepository;
        private LogRepository _changeLogRepository;
        private DivergenceRepository _divergenceRepository;
        private ResultRepository _resultRepository;
        private PlanRepository _planRepository;
        private PaymentComparisonRepository _paymentComparisonRepository;
        private ImportFileRepository _importFileRepository;
        private PermissionRepository _permissionRepository;
        private UserPermissionRepository _userPermissionRepository;
     

        private SettingValueRepository _settingValueRepository;
        private ImportLogRepository _importLogRepository;
        private LogRepository _logRepository;
        private AgeGroupRepository _ageGroupRepository;
        private RateRepository _rateRepository;
        public UnitOfWork()
        {
            _context = new NordicaAssistansContext();
        }
        public UnitOfWork(string connStr)
        {
            _context = new NordicaAssistansContext(connStr);
        }
        public bool IsConnectionCorrect()
        {
            return _context.IsConnectionCorrect();
        }
        public UserRepository UserRepository
        {
            get
            {
                return _userRepository ?? (_userRepository = new UserRepository(_context));
            }
        }
        public ClientRepository ClientRepository
        {
            get
            {
                return _clientRepository ?? (_clientRepository = new ClientRepository(_context));
 
namespace Orkidea.Pioneer.Webfront.Controllers
    public class ProcessController : Controller
    {
        ProcessBiz processBiz = new ProcessBiz();
        public ActionResult Index()
        {
            return View();
        }
        [Authorize]
        public ActionResult List()
        {
            List<Process> lstProcess = processBiz.GetProcessList();
            return View(lstProcess);
        }
        [Authorize]
        public ActionResult Details(int id)
        {
            #region User identification
            System.Security.Principal.IIdentity context = HttpContext.User.Identity;
            int user = 0;
            if (context.IsAuthenticated)
            {
                System.Web.Security.FormsIdentity ci = (System.Web.Security.FormsIdentity)HttpContext.User.Identity;
                string[] userRole = ci.Ticket.UserData.Split('|');
                user = int.Parse(userRole[0]);
            }
            #endregion
            ProcessDocumentBiz process

            Process process = processBiz.GetProcessbyKey(new Process() { id = id });
            vmProcess oProcess = new vmProcess() { id = id, nombre = process.nombre, descripcion = process.descripcion, archivoCaracterizacion = process.archivoCaracterizacion };
            ActivityLogBiz.SaveActivityLog(new ActivityLog() { idUsuario = user, accion = "Proceso " + process.nombre, fecha = DateTime.Now });
            oProcess.lstDocumentType = processDocumentBiz.GetDocumentTypeByProcess(process);
            return View(oProcess);
        }
        public ActionResult Create()
        {
            vmProcess process = new vmProcess();
            return View(process);
        }
        [HttpPost]
        public ActionResult Create(Process process)
        {
            try
            {
                if (string.IsNullOrEmpty(process.descripcion))
                    process.descripcion = "";
                if (string.IsNullOrEmpty(process.archivoCaracterizacion))
                   

                processBiz.SaveProcess(process);
                return RedirectToAction("List");
            }
            catch
            {
                return View();
            }
        }
        [Authorize]
        public ActionResult Edit(int id)
        {
            Process process = processBiz.GetProcessbyKey(new Process() { id = id });
            vmProcess oProcess = new vmProcess() { id = process.id, archivoCaracterizacion = process.archivoCaracterizacion, descripcion = process.descripcion, nombre = process.nombre };
            ViewBag.idProcess = id;
            return View(oProcess);
        }
        [HttpPost]
        public ActionResult Edit(int id, Process process)
        {
            try
            {
                if (string.IsNullOrEmpty(process.descripcion))
                    process.descripcion = "";
                if (string.IsNullOrEmpty(process.archivoCaracterizacion))
                    process.archivoCaracterizacion = "";
                pro
namespace SystemController.InstrumentBLL
    internal delegate void DayCloseQuotationReceivedHandle(Guid instrumentId, DateTime tradeDay);
    internal sealed class InstrumentManager
    {
        private static readonly ILog Logger = LogManager.GetLogger(typeof(InstrumentManager));
        internal static readonly InstrumentManager Default = new InstrumentManager();
        private Dictionary<Guid, Instrument> _instrumentDict = new Dictionary<Guid, Instrument>();
        private object _mutex = new object();
        static InstrumentManager() { }
        private InstrumentManager() { }
        internal int Count
        {
            get
            {
                lock (_mutex)
                {
                    return _instrumentDict.Count;
                }
            }
        }
        internal DateTime? GetInstrumentTradeDay(Guid instrumentId)
        {
            lock (_mutex)
            {
                try
                {
                    return _instrumentDict[

                }
                catch (System.Collections.Generic.KeyNotFoundException ex)
                {
                    Logger.ErrorFormat("instrumentId = {0}, error = {1}", instrumentId, ex);
                    throw;
                }
            }
        }
        internal void DayCloseQuotationReceivedEventHandle(Guid instrumentId, DateTime tradeDay)
        {
            lock (_mutex)
            {
                Instrument instrument;
                if (!_instrumentDict.TryGetValue(instrumentId, out instrument))
                {
                    Logger.InfoFormat("DayCloseQuotationReceived instrument not exists. instrumentId = {0}, tradeDay = {1}", instrumentId, tradeDay);
                    return;
                }
                Logger.InfoFormat("DayCloseQuotationReceivedEventHandle instrumentId = {0}, instrument.TradeDay = {1}, tradeDay = {2}", instrumentId, instrument.TradeDay, tradeDay);
                instrument.DayCloseQuotationReceived = true;
   

        }
        internal bool IsAllInstrumentsReceivedDayCloseQuotation(DateTime tradeDay)
        {
            lock (_mutex)
            {
                foreach (var eachInstrument in _instrumentDict.Values)
                {
                    if (!IsInstrumentReceivedDayCloseQuotation(eachInstrument, tradeDay))
                    {
                        Logger.InfoFormat("IsInstrumentReceivedDayCloseQuotation instrumentId = {0}, instrument.TradeDay = {1}, instrument.ReceivedDayCloseQuotation = {2}, tradeDay = {3}", eachInstrument.Id,
                            eachInstrument.TradeDay, eachInstrument.DayCloseQuotationReceived, tradeDay);
                        return false;
                    }
                }
                return true;
            }
        }
        private bool IsInstrumentReceivedDayCloseQuotation(Instrument instrument, DateTime tradeDay)
        {
            return (instrument.TradeDay == tradeDay.AddDays(1) && instrument.DayCloseQuotationRecei
namespace MTB
    public class PersistanceWorker : ProcessWorker
    {
        #region implemented abstract members of ProcessWorker
        protected override void Process()
        {
            try
            {
                SinglePersistanceWorker();
                NetPersistanceWorker();
            }
            catch (Exception e)
            {
                UnityEngine.Debug.LogError(e);
            }
        }
        #endregion
        private void SinglePersistanceWorker()
        {
            PriorityChunk loadPriorityChunk = DeLoadQueue();
            if (loadPriorityChunk != null)
            {
				WorldPos pos = loadPriorityChunk.chunk.worldPos;
				if(World.world.GetChunk(pos.x,pos.y,pos.z) == null)return;
                loadPriorityChunk.chunk.InitData();
                if (WorldConfig.Instance.loadInMap)
                {
                    WorldPersistanceManager.Instance.LoadChunk(loadPriorityChunk.chunk);
                }
                _manager.generat

            }
            Chunk saveChunk = DeSaveQueue();
            if (saveChunk != null)
            {
                if (saveChunk.isUpdate)
                {
                    if (WorldConfig.Instance.saveBlock)
                    {
                        WorldPersistanceManager.Instance.SaveChunk(saveChunk);
                        saveChunk.isUpdate = false;
                    }
                }
                _manager.EnqueueWaitRemove(saveChunk);
            }
            RefreshChunkArea refreshChunkArea = DeRefreshQueue();
            if (refreshChunkArea != null)
            {
                _manager.generatorWorker.EnRefreshQueue(refreshChunkArea);
            }
        }
        private void NetPersistanceWorker()
        {
            NetChunkData netLoadChunkData = DeNetLoadQueue();
            if (netLoadChunkData != null)
            {
                bool succ = WorldPersistanceManager.Instance.LoadNetChunk(netLoadChunkData);
                if (succ) net

                else netLoadChunkData.isExist = false;
                _manager.EnResponseNetChunkData(netLoadChunkData);
            }
            NetChunkData netSaveChunkData = DeNetSaveQueue();
            if (netSaveChunkData != null)
            {
                WorldPersistanceManager.Instance.SaveNetChunk(netSaveChunkData);
            }
            NetPriorityChunk requestNetChunk = DeNetChunkLoadQueue();
            if (requestNetChunk != null)
            {
                requestNetChunk.netChunk.chunk.InitData();
                if (requestNetChunk.netChunk.chunkData.isExist)
                {
                    requestNetChunk.netChunk.chunk = WorldPersistanceManager.Instance.GetChunk(requestNetChunk.netChunk);
                    EventManager.SendEvent(EventMacro.CHUNK_DATA_GENERATE_FINISH, requestNetChunk.netChunk.chunk);
                }
                else
                {
                    if (NetManager.Instance.client.isMainClient)
                    {
   
namespace WaveformView.Chunks
    class Riff : Chunk
    {
        const string m_chunkName = "Riff Chunk";
        readonly string m_chunkID;
        readonly UInt32 m_chunkSize;
        readonly string m_format;
        readonly ChunkCollection m_chunkCollection = new ChunkCollection();
        public Riff( UInt32 size, Byte [] data )
        {
            Int32 pos = 0;
            m_chunkID = Encoding.ASCII.GetString( data, pos, 4 );
            pos += 4;
            m_chunkSize = BitConverter.ToUInt32( data, pos );
            pos += 4;
            m_format = Encoding.ASCII.GetString( data, pos, 4 );
            pos += 4;
            if ( "RIFF" != m_chunkID )
            {
                MessageBox.Show( "Unsupported header format \"" + m_chunkID + "\". Quitting.",
                    "Error!",
                    MessageBoxButtons.OK );
                Application.Exit();
            }
            if ( "WAVE" != m_format )
            {
                MessageBox.Show( "Unsuppo

                    "Error!", MessageBoxButtons.OK );
                Application.Exit();
            }
            while ( pos < m_chunkSize )
            {
                string chunkType = Encoding.ASCII.GetString( data, pos, 4 );
                pos += 4;
                UInt32 chunkSize = BitConverter.ToUInt32( data, pos );
                pos += 4;
                if ( chunkSize % 2 == 1 )
                {
                    pos += 1;
                }
                if ( m_chunkSize < pos )
                {
                    break;
                }
                Byte[] chunkData = new Byte[chunkSize];
                Array.Copy(data, pos, chunkData, 0, chunkSize);
                Chunk nextChunk = ChunkFactory.CreateChunk( chunkType, chunkSize, chunkData );
                if ( nextChunk != null )
                {
                    m_chunkCollection.Add( nextChunk );
                }
                pos += (Int32)chunkSize;
            }
        }
        public o
﻿@model SusDulu.Models.Ticket
@{
    ViewBag.Title = "Cetak Tiket";
    Layout = null;
<itext producer="RazorPDF">
    <table width="100%" cellpadding="0.5" cellspacing="0.5" widths="30;70" borderwidth="1.0" left="false" right="false" top="false" bottom="false" red="0" green="0" blue="0">
        <row>
            <cell>
                <chunk style="font-weight:bold;">ID:</chunk>
            </cell>
            <cell>
                <chunk style="">@Model.ID</chunk>
            </cell>
        </row>
        <row>
            <cell>
                <chunk style="font-weight:bold;">ID Flight:</chunk>
            </cell>
            <cell>
                <chunk style="">@Model.ID_flight</chunk>
            </cell>
        </row>
        <row>
            <cell>
                <chunk style="font-weight:bold;">Email:</chunk>
            </cell>
            <cell>
                <chunk style="">@Model.Email</chunk>
            </cell>
        </row>
        <row>
            <cell>
   

            </cell>
            <cell>
                <chunk style="">@Model.First_name</chunk>
            </cell>
        </row>
        <row>
            <cell>
                <chunk style="font-weight:bold;">Middle Name:</chunk>
            </cell>
            <cell>
                <chunk style="">@Model.Middle_name</chunk>
            </cell>
        </row>
        <row>
            <cell>
                <chunk style="font-weight:bold;">Last Name:</chunk>
            </cell>
            <cell>
                <chunk style="">@Model.Last_name</chunk>
            </cell>
        </row>
        <row>
            <cell>
                <chunk style="font-weight:bold;">Address:</chunk>
            </cell>
            <cell>
                <chunk style="">@Model.Address</chunk>
            </cell>
        </row>
        <row>
            <cell>
                <chunk style="font-weight:bold;">Phone:</chunk>
            </cell>
            <cell>
                <chunk style="">@Mo

            </cell>
        </row>
        <row>
            <cell>
                <chunk style="font-weight:bold;">Gender:</chunk>
            </cell>
            <cell>
                <chunk style="">@Model.Gender</chunk>
            </cell>
        </row>
        <row>
            <cell>
                <chunk style="font-weight:bold;">City:</chunk>
            </cell>
            <cell>
                <chunk style="">@Model.City</chunk>
            </cell>
        </row>
        <row>
            <cell>
                <chunk style="font-weight:bold;">Province:</chunk>
            </cell>
            <cell>
                <chunk style="">@Model.Province</chunk>
            </cell>
        </row>
        <row>
            <cell>
                <chunk style="font-weight:bold;">Postcode:</chunk>
            </cell>
            <cell>
                <chunk style="">@Model.Postcode</chunk>
            </cell>
        </row>
        <row>
            <cell>
                <chunk 
namespace Dwarves.Core.Terrain
    public class TerrainChunk
    {
        public TerrainChunk(Vector2I chunkIndex)
        {
            this.Index = chunkIndex;
            this.Points = new TerrainPoint[Metrics.ChunkWidth, Metrics.ChunkHeight];
            this.Mesh = new TerrainChunkMesh();
            for (int x = 0; x < Metrics.ChunkWidth; x++)
            {
                for (int y = 0; y < Metrics.ChunkHeight; y++)
                {
                    this.Points[x, y] = new TerrainPoint();
                }
            }
        }
        public Vector2I Index { get; private set; }
        public TerrainPoint[,] Points { get; private set; }
        public SurfacePosition SurfacePosition { get; internal set; }
        public TerrainChunkMesh Mesh { get; private set; }
        public static Vector2I[] GetNeighboursIncluding(Vector2I chunk)
        {
            return new Vector2I[]
                {
                    chunk,
                    new Vector2I(chunk.X + 1, chu

                    new Vector2I(chunk.X + 1, chunk.Y + 1),
                    new Vector2I(chunk.X, chunk.Y + 1),
                    new Vector2I(chunk.X - 1, chunk.Y + 1),
                    new Vector2I(chunk.X - 1, chunk.Y),
                    new Vector2I(chunk.X - 1, chunk.Y - 1),
                    new Vector2I(chunk.X, chunk.Y - 1),
                    new Vector2I(chunk.X + 1, chunk.Y - 1)
                };
        }
        public static Vector2I[] GetNeighboursExcluding(Vector2I chunk)
        {
            return new Vector2I[]
                {
                    new Vector2I(chunk.X + 1, chunk.Y),
                    new Vector2I(chunk.X + 1, chunk.Y + 1),
                    new Vector2I(chunk.X, chunk.Y + 1),
                    new Vector2I(chunk.X - 1, chunk.Y + 1),
                    new Vector2I(chunk.X - 1, chunk.Y),
                    new Vector2I(chunk.X - 1, chunk.Y - 1),
                    new Vector2I(chunk.X, chunk.Y - 1),
                    new V
namespace TShanTC.Business.QiXiu.Processer
    public class WorkShopDispatchProcesser : IWorkShopDispatchProcesser
    {
        public int AddWorkShopDispatch(WorkShopDispatchEntity workShopDispatchInfo)
        {
            QiXiuHttpPost<int> addWorkShopDispatchResponse = new QiXiuHttpPost<int>();
            var result = addWorkShopDispatchResponse.Execute(workShopDispatchInfo, QiXiuApiUrl.AddWorkShopDispatch);
            return result;
        }
        public QiXiuListResponse<WorkShopDispatchEntity> GetWorkShopDispatchList(WorkShopDispatchListRequest workShopDispatchListRequest)
        {
            QiXiuHttpPost<QiXiuListResponse<WorkShopDispatchEntity>> getWorkShopDispatchListResponse = new QiXiuHttpPost<QiXiuListResponse<WorkShopDispatchEntity>>();
            var result = getWorkShopDispatchListResponse.Execute(workShopDispatchListRequest, QiXiuApiUrl.GetWorkShopDispatchList);
            return result;
        }
        public QiXiuOperateResponse WorkShopDispatchOperate(
namespace BattleNetApi.Api
    public class BattleNetApiClient
    {
        private string _apiClientKey { get; set; }
        private Region _region { get; set; }
        private Locale _locale { get; set; }
        protected string RegionString
        {
            get
            {
                return _region.ToString().ToLower();
            }
        }
        protected string LocaleString
        {
            get
            {
                return _locale.ToString();
            }
        }
        public OAuthApi OAuthApi { get; private set; }
        public WoWCommunityApi WowCommunityApi { get; private set; }
        public BattleNetApiClient(string apiClientKey, Region region = Region.US, Locale locale = Locale.en_US)
        {
            _apiClientKey = apiClientKey;
            _region = region;
            _locale = locale;
            InitializeApiInterfaces();
        }
        private void InitializeApiInterfaces()
        {
            OAuthApi = new OAuthApi(
﻿namespace LaTeXTemplate
    public class TemplateReader
    {
        public string TemplateText { get; set; }
        public TemplateReader() { }
        public TemplateReader(string filePath)
        {
            TemplateText = File.ReadAllText(filePath);
        }
        public IEnumerable<string> GetTemplateChunks()
        {
            int chunkStart = 0;
            int chunkEnd = 0;
            bool nextChunkIsText;
            while (chunkStart < TemplateText.Length)
            {
                nextChunkIsText = !TemplateText.Substring(chunkStart, TemplateConsts.TMPL_LEN).Equals(TemplateConsts.TMPL_START);
                chunkEnd = TemplateText.IndexOf(nextChunkIsText ? TemplateConsts.TMPL_START : TemplateConsts.TMPL_END, chunkStart);
                if (!nextChunkIsText)
                if (chunkEnd <= TemplateConsts.TMPL_LEN)
                var chunk = TemplateText.Substring(chunkStart, chunkEnd - chunkStart);
                yield return chunk;
                chunkS
#if WINDOWS_UWP
#endif
namespace System.Windows
    public abstract class JasilyDispatcher
    {
        public abstract void Invoke(Action action);
        public abstract Task InvokeAsync(Action action);
        public abstract void BeginInvoke(Action action);
        public void BeginInvoke<T1>(Action<T1> action, T1 arg1)
            => this.BeginInvoke(() => this.BeginInvoke(() => action(arg1)));
        public void BeginInvoke<T1, T2>(Action<T1, T2> action, T1 arg1, T2 arg2)
            => this.BeginInvoke(() => this.BeginInvoke(() => action(arg1, arg2)));
        public abstract bool CheckAccess();
        public bool CheckAccessOrBeginInvoke(Action action)
        {
            if (this.CheckAccess()) return true;
            this.BeginInvoke(action);
            return false;
        }
        public bool CheckAccessOrBeginInvoke<T1, T2>(Action<T1, T2> action, T1 arg1, T2 arg2)
        {
            if (this.CheckAccess()) return true;
            this.BeginInvoke(action, arg1,
namespace GameFramework
	public class processManager : BaseCrossPlugin
	{
		private processQueue _processQMaster = null;
		private processQueue _processQ = null;
		private processQueue _renderQ = null;
		private processQueue _renderQMaster = null;
		public static processManager instance;
		public override string pluginName
		{
			get
			{
				return "processManager";
			}
		}
		public processManager()
		{
			processManager.instance = this;
			this._processQMaster = new processQueue();
			this._processQ = new processQueue();
			this._renderQ = new processQueue();
			this._renderQMaster = new processQueue();
			this._processQMaster.setDebug("processManager master proc ");
			this._processQ.setDebug("processManager proc");
			this._renderQMaster.setDebug("processManager master _render ");
			this._renderQ.setDebug("processManager _render");
		}
		public override void onRender(float tmSlice)
		{
			this._renderQMaster.process(tmSlice);
			this._renderQ.process(tmSlice);
		}
		public overri
public class MGEventDispatcher
	static MGEventDispatcher instance;
	public static MGEventDispatcher Instance(){
		if(instance != null){
			instance = new MGEventDispatcher();
		}
		return instance;
	}
    private Dictionary<int, List<DispatchEventHandler> > EventTable;
    public delegate void DispatchEventHandler(System.Object sender, DispatchEventArgs e);
    public event DispatchEventHandler Dispatch;
	public MGEventDispatcher()
    {
        EventTable = new Dictionary<int, List<DispatchEventHandler>>();
    }
    public void ClearAllEvent()
    {
        EventTable = new Dictionary<int, List<DispatchEventHandler>>();
    }
    public void dispacthEvent(int type)
    {
        if (EventTable.ContainsKey(type))
        {
            DispatchEventArgs e = new DispatchEventArgs();
            List<DispatchEventHandler> funcArr = (List<DispatchEventHandler>)EventTable[type];
            List<DispatchEventHandler> funcArrTemp = new List<DispatchEventHandler>(funcArr);
            foreac

            {
                this.Dispatch = func;
                OnDispatch(e);
            }
        }
    }
    public void dispacthEvent(int type, params object[] data)
    {
        if (EventTable.ContainsKey(type))
        {
            DispatchEventArgs e = new DispatchEventArgs(type, data);
            List<DispatchEventHandler> funcArr = (List<DispatchEventHandler>)EventTable[type];
            List<DispatchEventHandler> funcArrTemp = new List<DispatchEventHandler>(funcArr);
            foreach (DispatchEventHandler func in funcArrTemp)
            {
                this.Dispatch = func;
                OnDispatch(e);
            }
        }
    }
    protected virtual void OnDispatch(DispatchEventArgs e)
    {
        {
        }
    }
    public void addEventListener(int type, DispatchEventHandler func)
    {
        if (!EventTable.ContainsKey(type))
        {
            List<DispatchEventHandler> FuncList = new List<DispatchEventHandler>();
            FuncList.Add(fun
namespace BBN.DAL.Repositories
    public class UnitOfWork : IUnitOfWork
    {
        BBNEntities db = new BBNEntities();
        private UsersRepository _usersRepository;
        private RolesRepository _rolesRepository;
        private PermissionsRepository _permissionsRepository;
        private TokensRepository _tokensRepository;
        private CitiesRepository _citiesRepository;
        private ActionsRepository _actionsRepository;
        private ControllersRepository _controllersRepository;
        private CountriesRepository _countriesRepository;
        private ExerciesesRepository _exerciesesRepository;
        private ExerciesesGroupRepository _exerciesesGroupRepository;
        private FriendsRepository _friendsRepository;
        private TagsRepository _tagsRepository;
        private PostsRepository _postsRepository;
        private SocialLoginsRepository _socialLoginsRepository;
        private TrainingProgramRepository _trainingProgramRepository;
        private UserD

        private UserProgramsRepository _userProgramsRepository;
        private ProgramDaysRepository _programDaysRepository;
        private DaysRepository _daysRepository;
        private AlarmsRepository _alarmsRepository;
        private AlarmDaysRepository _alarmDaysRepository;
        private ProductsRepository _productsRepository;
        private ProductTypeRepository _productTypesRepository;
        private MenuRepository _menuRepository;
        private TipsDataRepository _tipsDataRepository;
        private TipsRepository _tipsRepository;
        private UserSettingsRepository _userSettingsRepository;
        private SettingsRepository _settingsRepository;
        private SetDetailsRepository _setDetailsRepository;
        private UserTipsRepository _userTipsRepository;
        private UserResultsRepository _userResultsRepository;
        private bool _disposed;
        public virtual void Dispose(bool disposing)
        {
            if (!_disposed)
            {
          

                {
                    db.Dispose();
                }
                _disposed = true;
            }
        }
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        public ICitiesRepository CitiesRepository => _citiesRepository ?? (_citiesRepository = new CitiesRepository(db));
        public IActionsRepository ActionsRepository => _actionsRepository ?? (_actionsRepository = new ActionsRepository(db));
        public IRepository<Controllers> ControllersRepository => _controllersRepository ?? (_controllersRepository = new ControllersRepository(db));
        public IRepository<Countries> CountriesRepository => _countriesRepository ?? (_countriesRepository = new CountriesRepository(db));
        public IRepository<Excercise> ExerciesesRepository => _exerciesesRepository ?? (_exerciesesRepository = new ExerciesesRepository(db));
        public IRepository<ExercieseGroup> ExerciesesGroupRepository => _ex
namespace RicksGuitarsStart.Model
    class Inventory
    {
        private List<Instrument> instruments = new List<Instrument>();
        public ICollection<string> Models
        {
            get
            {
                List<string> models = new List<string>();
                foreach (Instrument instrument in instruments)
                {
                    string model = instrument.Specification.GetProperty("Model") as string;
                    if (!models.Contains(model))
                        models.Add(model);
                }
                models.Sort();
                return models;
            }
        }
        public ICollection<string> InstrumentTypes
        {
            get
            {
                List<string> instrumentTypes = new List<string>();
                foreach (Instrument instrument in instruments)
                {
                    string instrumentType = ((InstrumentType)instrument.Specification.GetProperty("InstrumentType")).ToSt

                    if (!instrumentTypes.Contains(instrumentType))
                        instrumentTypes.Add(instrumentType);
                }
                instrumentTypes.Sort();
                return instrumentTypes;
            }
        }
        public void Initialize()
        {
            Dictionary<string, object> properties = new Dictionary<string, object>
            {
                { "InstrumentType", InstrumentType.Guitar },
                { "Builder", Builder.Collings },
                { "Model", "CJ" },
                { "Category", Category.Acoustic },
                { "NumberOfStrings", 6 },
                { "TopWood", Wood.IndianRosewood },
                { "BackWood", Wood.Sitka }
            };
            Add(new Instrument("11277", 3999.95m, new InstrumentSpecification(properties)));
            properties["Builder"] = Builder.Martin;
            properties["Model"] = "D-18";
            properties["TopWood"] = Wood.Mahogany;
            properties[

            Add(new Instrument("122784", 5495.95m, new InstrumentSpecification(properties)));
            properties["Builder"] = Builder.Fender;
            properties["Model"] = "Stratocastor";
            properties["Category"] = Category.Electric;
            properties["TopWood"] = Wood.Alder;
            properties["BackWood"] = Wood.Alder;
            Add(new Instrument("V95693", 1499.95m, new InstrumentSpecification(properties)));
            Add(new Instrument("V9512", 1549.95m, new InstrumentSpecification(properties)));
            properties["Builder"] = Builder.Gibson;
            properties["Model"] = "Les Paul";
            properties["TopWood"] = Wood.Maple;
            properties["BackWood"] = Wood.Maple;
            Add(new Instrument("70108276", 2295.95m, new InstrumentSpecification(properties)));
            properties["Model"] = "SG '61 Reissue";
            properties["TopWood"] = Wood.Mahogany;
            properties["BackWood"] = Wood.Mahogany;
            Add(n
namespace SlashPay
    public class SlashPay
    {
        protected string ApiVersion = "v1";
        protected string PublicKey = "";
        protected string PrivateKey = "";
        protected Request.RequestGateway Request = null;
        protected Api.CheckoutApi checkoutApi = null;
        protected Api.RedirectApi redirectApi = null;
        protected Api.SubscriptionApi subscriptionApi = null;
        protected Api.MessagingApi messagingApi = null;
        public SlashPay(string publicKey, string privateKey)
        {
            this.PublicKey = publicKey;
            this.PrivateKey = privateKey;
            this.Request = new Request.RequestGateway(ApiUrl + ApiVersion + '/');
            this.checkoutApi = new Api.CheckoutApi(this.PrivateKey, this.Request);
            this.redirectApi = new Api.RedirectApi(this.PrivateKey, this.Request);
            this.subscriptionApi = new Api.SubscriptionApi(this.PrivateKey, this.Request);
            this.messagingApi = new Api.Messagi
namespace Charltone.UI.Controllers
    [RoutePrefix("Instrument/{id}")]
    public class InstrumentController : Controller
    {
        private readonly IProductRepository _products;
        private readonly IInstrumentTypeRepository _instrumentTypes;
        private readonly IClassificationRepository _classifications;
        private readonly ISubClassificationRepository _subClassifications;
        private readonly IProductStatusRepository _productStatus;
        private readonly IPhotoRepository _photos;
        public InstrumentController(IProductRepository products, 
            IInstrumentTypeRepository instrumentTypes,
            IClassificationRepository classifications,
            ISubClassificationRepository subClassifications,
            IProductStatusRepository productStatus, 
            IPhotoRepository photos)
        {
            _products = products;
            _instrumentTypes = instrumentTypes;
            _classifications = classifications;
            _subCla

            _productStatus = productStatus;
            _photos = photos;
        }
        public ActionResult Index()
        {
            return View(LoadInstrumentListViewModel());
        }
        [HttpGet]
        [Route("Detail")]
        public ActionResult Detail(int id)
        {
            return View(LoadInstrumentDetailViewModel(id));
        }
        [HttpPost]
        [Authorize]
        [Route("Upload")]
        public ActionResult Upload(int id)
        {
            var file = Request.Files[0];
            var product = _products.Get(id);
            var count = product.Photos.Count;
            var reader = new BinaryReader(file.InputStream);
            var data = reader.ReadBytes(file.ContentLength);
            var photo = new Photo
                        {
                            IsDefault = (count == 0),
                            Data = data,
                            SortOrder = count + 1,
                            Product = product
            

            product.Photos.Add(photo);
            var newId = _photos.Add(photo);
            return Json( new { success = true, id = newId } );
        }
        [HttpGet]
        [Authorize]
        [Route("Edit")]
        public ActionResult Edit(int id)
        {
            return View(LoadInstrumentEditViewModel(id));
        }
        [HttpPost]
        [Authorize]
        [Route("Edit")]
        public ActionResult Edit(int id, InstrumentEditViewModel viewModel)
        {
            var product = _products.Get(id);
            UpdateProductInstrument(product, viewModel);
            return RedirectToAction("Index", "Instrument");
        }
        [HttpGet]
        [Authorize]
        public ActionResult Create()
        {
            return View(LoadInstrumentEditViewModel(-1));
        }
        [HttpPost]
        [Authorize]
        public ActionResult Create(InstrumentEditViewModel viewModel)
        {
            AddInstrument(viewModel);
            return RedirectToAc
namespace FlyweightTräning
    class Program
    {
        static void Main(string[] args)
        {
            InstrumentFlyweightFactory factory = new InstrumentFlyweightFactory();
            IInstrument instrument1 = factory.GetInstrument(InstrumentType.Violin);
            IInstrument instrument2 = factory.GetInstrument(InstrumentType.Violin);
            IInstrument instrument3 = factory.GetInstrument(InstrumentType.Drum);
            IInstrument instrument4 = factory.GetInstrument(InstrumentType.Drum);
            IInstrument instrument5 = factory.GetInstrument(InstrumentType.Trumpet);
            IInstrument instrument6 = factory.GetInstrument(InstrumentType.Trumpet);
            Console.WriteLine(instrument1.GetHashCode());
            Console.WriteLine(instrument2.GetHashCode());
            Console.WriteLine(instrument3.GetHashCode());
            Console.WriteLine(instrument4.GetHashCode());
            Console.WriteLine(instrument5.GetHashCode());
            Console.Writ
namespace Peaf.Core.Repository
    public static class RepositoryFactory
    {
        public static IEnvironmentVariableRepository EnvironmentVariableRepository
        {
            get
            {
                IEnvironmentVariableRepository repository = CallContext.GetData("Peaf.Core.Repository.EnvironmentVariableRepository") as EnvironmentVariableRepository;
                if (repository == null)
                {
                    repository = new EnvironmentVariableRepository();
                    CallContext.SetData("Peaf.Core.Repository.EnvironmentVariableRepository", repository);
                }
                return repository;
            }
        }
        public static ICategoryRepository CategoryRepository
        {
            get
            {
                ICategoryRepository repository = CallContext.GetData("Peaf.Core.Repository.CategoryRepository") as CategoryRepository;
                if (repository == null)
                {
                    repo

                    CallContext.SetData("Peaf.Core.Repository.CategoryRepository", repository);
                }
                return repository;
            }
        }
        public static ISimpageRepository SimpageRepository
        {
            get
            {
                ISimpageRepository repository = CallContext.GetData("Peaf.Core.Repository.SimpageRepository") as SimpageRepository;
                if (repository == null)
                {
                    repository = new SimpageRepository();
                    CallContext.SetData("Peaf.Core.Repository.SimpageRepository", repository);
                }
                return repository;
            }
        }
        public static IAttachmentRepository AttachmentRepository
        {
            get
            {
                IAttachmentRepository repository = CallContext.GetData("Peaf.Core.Repository.AttachmentRepository") as AttachmentRepository;
                if (repository == null)
                {
   
namespace data.Infrastructure
    public class UnitOfWork : IUnitOfWork
    {
        private jpadbContext dataContext;
        DatabaseFactory dbFactory;
        public UnitOfWork(DatabaseFactory dbFactory)
        {
            this.dbFactory = dbFactory;
        }
        protected jpadbContext DataContext
        {
            get
            {
                return dataContext ?? (dataContext = dbFactory.Get());
            }
        }
        private IDoctorRepository doctorRepository;
        IDoctorRepository IUnitOfWork.DoctorRepository
        {
            get { return doctorRepository ?? (doctorRepository = new DoctorRepository(dbFactory)); }
        }
        private IOfferRepository offerRepository;
        IOfferRepository IUnitOfWork.OfferRepository
        {
            get { return offerRepository ?? (offerRepository = new OfferRepository(dbFactory)); }
        }
        private IConsultationRepository consultationRepository;
        IConsultationRepository IUnitOfWo

        {
            get { return consultationRepository ?? (consultationRepository = new ConsultationRepository(dbFactory)); }
        }
        private IDocdispRepository doctordispRepository;
        IDocdispRepository IUnitOfWork.DoctordispRepository
        {
            get { return doctordispRepository ?? (doctordispRepository = new DocdispRepository(dbFactory)); }
        }
        private IAuthentificationRepository user1Repository;
        IAuthentificationRepository IUnitOfWork.AuthentificationRepository
        {
            get { return user1Repository ?? (user1Repository = new AuthentificationRepository(dbFactory)); }
        }
        private ICongeRepository congeRepository;
        public ICongeRepository CongeRepository
        {
            get
            {
                return congeRepository = new CongeRepository(dbFactory);
            }
        }
        private ITimetableRepository timetableRepository;
        public ITimetableRepository TimetableRepository

        {
            get
            {
                return timetableRepository = new TimetableRepository(dbFactory);
            }
        }
        public void commit()
        {
            DataContext.SaveChanges();
        }
        private ITransportCompagnieRepository expenseRepositoriii;
        ITransportCompagnieRepository IUnitOfWork.TransportCompagnieRepository
        {
            get
            {
                return expenseRepositoriii ?? (expenseRepositoriii = new
         TransportCompagnieRepository(dbFactory));
            }
        }
        private IDemandeRepository expenseRepositort;
        IDemandeRepository IUnitOfWork.DemandeRepository
        {
            get
            {
                return expenseRepositort ?? (expenseRepositort = new
         DemandeRepository(dbFactory));
            }
        }
        private IEventRepository eventRepository;
        IEventRepository IUnitOfWork.EventRepository
        {
            get { return eventRepos
namespace Joyeon.Group.DAL
    public static class JoyeonContext
    {
        private static object locker = new object();
        private static IEmployeeRepository employeeRepository = null;
        
        private static IJobRepository jobRepository = null;
        private static IBranchRepository branchRepository = null;
        private static IFrameRepository frameRepository = null;
        private static IDishRepository dishRepository = null;
        private static ITableRepository tableRepository = null;
        private static IGroupRepository groupRepository = null;
        private static ICustomerRepository customerRepository = null;
        private static ICardRepository cardRepository = null;
        private static IReportRepository reportRepository = null;
        private static IPermissionRepository permissionRepository = null;
        private static ICookbookRepository cookbookRepository = null;
        private static ICookbookCategoryRepository cookbookcategoryReposito

        private static IBusinessRepository businessRepository = null;
        private static IVersionControlRepository versionControlRepository = null;
        private static IDepartmentRepository departmentRepository = null;
        private static IBookRepository bookRepository = null;
        private static IPosterRepository posterRepostory = null;
        private static IMPosterRepository mposterRepostory = null;
        private static ISurveyRepository surveyRepository = null;
        private static IMessageRepository messageRepository = null;
        private static IVendorRepository vendorRepository = null;
        private static IVendorCategoryRepository vendorCategoryRepository = null;
        private static IWarehouseRepository warehouseRepository = null;
        private static ITableZoneRepository tableZoneRepository = null;
        private static ITakeOutRepository takeOutRepository = null;
        private static IPromotionRepository promotionRepository = null;
        priva

        private static IWeixinConfigRepository weixinConfigRepository = null;
        private static IPracticeRepository practiceRepository = null;
        #region 采购订单
        private static IPurchaseOrderRepository purchaseOrderRepository = null;
        private static IPurchaseOrderHeaderRepository purchaseOrderHeaderRepository = null;
        private static IPurchaseOrderLineRepository purchaseOrderLineRepository = null;
        #endregion
        #region 申请
        private static IPurchaseRequisitionRepository purchaseRequisitionRepository = null;
        private static IPurchaseRequisitionHeaderRepository purchaseRequisitionHeaderRepository = null;
        private static IPurchaseRequisitionLineRepository purchaseRequisitionLineRepository = null;
        #endregion
        #region 出入库单据
        private static IInventoryTicketRepository inventoryTicketRepository = null;
        private static IInventoryTicketHeaderRepository inventoryTicketHeaderRepository = null;
        private
﻿#region Using
#endregion
namespace Willcraftia.Xna.Blocks.Models
    public sealed class ChunkTaskRequest
    {
        Chunk chunk;
        ChunkTaskType taskType;
        ChunkTaskPriority priority;
        TimeSpan timestamp;
        public Chunk Chunk
        {
            get { return chunk; }
        }
        public ChunkTaskType TaskType
        {
            get { return taskType; }
        }
        public ChunkTaskPriority Priority
        {
            get { return priority; }
        }
        internal TimeSpan Timestamp
        {
            get { return timestamp; }
        }
        internal ChunkTaskRequest() { }
        internal void Initialize(Chunk chunk, ChunkTaskType taskType, ChunkTaskPriority priority)
        {
            if (chunk == null) throw new ArgumentNullException("chunk");
            this.chunk = chunk;
            this.taskType = taskType;
            this.priority = priority;
            timestamp = TimeSpan.FromTicks(Environment.TickCount);
     
namespace ExpressionToCodeLib.Internal {
  internal interface IExpressionTypeDispatch<T> {
		[Pure] T DispatchAdd(Expression e);
		[Pure] T DispatchAddChecked(Expression e);
		[Pure] T DispatchAnd(Expression e);
		[Pure] T DispatchAndAlso(Expression e);
		[Pure] T DispatchArrayLength(Expression e);
		[Pure] T DispatchArrayIndex(Expression e);
		[Pure] T DispatchCall(Expression e);
		[Pure] T DispatchCoalesce(Expression e);
		[Pure] T DispatchConditional(Expression e);
		[Pure] T DispatchConstant(Expression e);
		[Pure] T DispatchConvert(Expression e);
		[Pure] T DispatchConvertChecked(Expression e);
		[Pure] T DispatchDivide(Expression e);
		[Pure] T DispatchEqual(Expression e);
		[Pure] T DispatchExclusiveOr(Expression e);
		[Pure] T DispatchGreaterThan(Expression e);
		[Pure] T DispatchGreaterThanOrEqual(Expression e);
		[Pure] T DispatchInvoke(Expression e);
		[Pure] T DispatchLambda(Expression e);
		[Pure] T DispatchLeftShift(Expression e);
		[Pure] T DispatchLessThan(Expression e)

		[Pure] T DispatchLessThanOrEqual(Expression e);
		[Pure] T DispatchListInit(Expression e);
		[Pure] T DispatchMemberAccess(Expression e);
		[Pure] T DispatchMemberInit(Expression e);
		[Pure] T DispatchModulo(Expression e);
		[Pure] T DispatchMultiply(Expression e);
		[Pure] T DispatchMultiplyChecked(Expression e);
		[Pure] T DispatchNegate(Expression e);
		[Pure] T DispatchUnaryPlus(Expression e);
		[Pure] T DispatchNegateChecked(Expression e);
		[Pure] T DispatchNew(Expression e);
		[Pure] T DispatchNewArrayInit(Expression e);
		[Pure] T DispatchNewArrayBounds(Expression e);
		[Pure] T DispatchNot(Expression e);
		[Pure] T DispatchNotEqual(Expression e);
		[Pure] T DispatchOr(Expression e);
		[Pure] T DispatchOrElse(Expression e);
		[Pure] T DispatchParameter(Expression e);
		[Pure] T DispatchPower(Expression e);
		[Pure] T DispatchQuote(Expression e);
		[Pure] T DispatchRightShift(Expression e);
		[Pure] T DispatchSubtract(Expression e);
		[Pure] T DispatchSubtractChecked(Express

		[Pure] T DispatchTypeAs(Expression e);
		[Pure] T DispatchTypeIs(Expression e);
		[Pure] T DispatchAssign(Expression e);
		[Pure] T DispatchBlock(Expression e);
		[Pure] T DispatchDebugInfo(Expression e);
		[Pure] T DispatchDecrement(Expression e);
		[Pure] T DispatchDynamic(Expression e);
		[Pure] T DispatchDefault(Expression e);
		[Pure] T DispatchExtension(Expression e);
		[Pure] T DispatchGoto(Expression e);
		[Pure] T DispatchIncrement(Expression e);
		[Pure] T DispatchIndex(Expression e);
		[Pure] T DispatchLabel(Expression e);
		[Pure] T DispatchRuntimeVariables(Expression e);
		[Pure] T DispatchLoop(Expression e);
		[Pure] T DispatchSwitch(Expression e);
		[Pure] T DispatchThrow(Expression e);
		[Pure] T DispatchTry(Expression e);
		[Pure] T DispatchUnbox(Expression e);
		[Pure] T DispatchAddAssign(Expression e);
		[Pure] T DispatchAndAssign(Expression e);
		[Pure] T DispatchDivideAssign(Expression e);
		[Pure] T DispatchExclusiveOrAssign(Expression e);
		[Pure] T DispatchLe
﻿#if !TRAVIS_CI
namespace TestSharp.Tests
	[TestFixture()]
	public class ProcessHelperTest
	{
		#region Fields
		private string m_processPath;
		private string m_processName;
		private string m_processArgs;
		#endregion
		[TestFixtureSetUp]
		public void Initialize()
		{
			if(Environment.OSVersion.Platform == PlatformID.MacOSX || Environment.OSVersion.Platform == PlatformID.Unix)
			{
				m_processPath = "vim";
				m_processName = "vim";
				m_processArgs = String.Empty;
			}
			else 
			{
				m_processPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.System), @"calc.exe");
				m_processName = "calc";
				m_processArgs = String.Empty;
			}
		}
		[Test]
		public void CountInstancesTest()
		{
			ProcessHelper.KillAll(m_processName);
			ProcessAssert.IsProcessInstancesCount(0, m_processName);
			ProcessHelper.Run(m_processPath, m_processArgs, false);
			ProcessAssert.IsProcessInstancesCount(1, m_processName);
			ProcessHelper.Run(m_processPath, m_processArgs, false)

			ProcessAssert.IsProcessInstancesCount(2, m_processName);
			ProcessHelper.Run(m_processPath, m_processArgs, false);
			ProcessAssert.IsProcessInstancesCount(3, m_processName);
			ProcessHelper.KillAll(m_processName);
			ProcessAssert.IsProcessInstancesCount(0, m_processName);
		}
		[Test]
		public void KillAllTest()
		{
			ProcessHelper.KillAll(m_processName);
			ProcessAssert.IsProcessInstancesCount(0, m_processName);
			ProcessHelper.Run(m_processPath, m_processArgs, false);
			ProcessHelper.Run(m_processPath, m_processArgs, false);
			ProcessHelper.Run(m_processPath, m_processArgs, false);
			
			ProcessAssert.IsProcessInstancesCount(3, m_processName);
			ProcessHelper.KillAll(m_processName);
			ProcessAssert.IsProcessInstancesCount(0, m_processName);
			Parallel.For(0, 100, (i) =>
			{
				try
				{
					ProcessHelper.Run(m_processPath, m_processArgs, false);
				}
				catch
				{
				}
				ProcessHelper.KillAll(m_processName);
			});
		}
		[Test]
		public void KillFirstTest()


			ProcessHelper.KillFirst(m_processName);
			ProcessAssert.IsProcessInstancesCount(0, m_processName);
			ProcessHelper.Run(m_processPath, m_processArgs, false);
			ProcessHelper.Run(m_processPath, m_processArgs, false);
			ProcessHelper.Run(m_processPath, m_processArgs, false);
			ProcessAssert.IsProcessInstancesCount(3, m_processName);
			ProcessHelper.KillFirst(m_processName);
			ProcessAssert.IsProcessInstancesCount(2, m_processName);
			ProcessHelper.KillFirst(m_processName);
			ProcessAssert.IsProcessInstancesCount(1, m_processName);
			ProcessHelper.KillFirst(m_processName);
			ProcessAssert.IsProcessInstancesCount(0, m_processName);
		}
		[Test]
		public void WaitForExitTest()
		{
			Parallel.Invoke(
				() =>
				{
				ProcessHelper.Run(m_processPath, m_processArgs, false);
					var beforeTime = DateTime.Now;
					ProcessHelper.WaitForExit(m_processName);
					Assert.AreNotEqual(beforeTime, DateTime.Now);
				},
				() =>
				{
					Thread.Sleep(1000);
					ProcessHelper.Kill
namespace d60.Framework.Server.ServerJob.Intf.Invoke
    [ContractClass(typeof(IServerInvokerContract))]
    public interface IServerInvoker
    {
        void Invoke(IInvokeCallback callback);
        void Invoke(IReadInvokeCallback callback);
        void Invoke(IWriteInvokeCallback callback);
        void Invoke<T>(IInvokeCallback<T> callback, T state);
        void Invoke<T>(IReadInvokeCallback<T> callback, T state);
        void Invoke<T>(IWriteInvokeCallback<T> callback, T state);
        void Invoke<T1, T2>(IInvokeCallback<T1, T2> callback, T1 arg1, T2 arg2);
        void Invoke<T1, T2>(IReadInvokeCallback<T1, T2> callback, T1 arg1, T2 arg2);
        void Invoke<T1, T2>(IWriteInvokeCallback<T1, T2> callback, T1 arg1, T2 arg2);
    }
    [ContractClassFor(typeof(IServerInvoker))]
    abstract class IServerInvokerContract : IServerInvoker
    {
        void IServerInvoker.Invoke(IInvokeCallback callback)
        {
            Contract.Requires(callback != null);
        }
        

        {
            Contract.Requires(callback != null);
        }
        void IServerInvoker.Invoke(IWriteInvokeCallback callback)
        {
            Contract.Requires(callback != null);
        }
        void IServerInvoker.Invoke<T>(IInvokeCallback<T> callback, T state)
        {
            Contract.Requires(callback != null);
        }
        void IServerInvoker.Invoke<T>(IReadInvokeCallback<T> callback, T state)
        {
            Contract.Requires(callback != null);
        }
        void IServerInvoker.Invoke<T>(IWriteInvokeCallback<T> callback, T state)
        {
            Contract.Requires(callback != null);
        }
        void IServerInvoker.Invoke<T1, T2>(IInvokeCallback<T1, T2> callback, T1 arg1, T2 arg2)
        {
            Contract.Requires(callback != null);
        }
        void IServerInvoker.Invoke<T1, T2>(IReadInvokeCallback<T1, T2> callback, T1 arg1, T2 arg2)
        {
            Contract.Requires(callback != null);
        }
        void IServe
public class ChunkHandler
    private List<Chunk> chunks = new List<Chunk>();
    private int chunkSize;
    public ChunkHandler(int size)
    {
        chunkSize = size;
    }
    Chunk createNewChunk(Vector2 target)
    {
        Rect rect = new Rect(Mathf.FloorToInt(target.x / chunkSize) * chunkSize, (Mathf.FloorToInt(target.y / chunkSize)) * chunkSize, chunkSize, chunkSize);
        Chunk newChunk = new Chunk(rect);
        chunks.Add(newChunk);
        return newChunk;
    }
    public void destoryChunksDirection(string direction, Vector2 position)
    {
        if (direction == "left")
        {
            int maxX = (Mathf.FloorToInt(position.x / chunkSize) * chunkSize) - chunkSize;
            foreach (Chunk chunk in getNonRenderChunks(position))
            {
                if (chunk.ChunkRect.position.x < maxX)
                    destroyChunk(chunk);
            }
        }
        if (direction == "right")
        {
            int minX = (Mathf.FloorToInt(position.x / ch

            foreach (Chunk chunk in getNonRenderChunks(position))
            {
                if (chunk.ChunkRect.position.x > minX)
                    destroyChunk(chunk);
            }
        }
        if (direction == "up")
        {
            int minY = (Mathf.FloorToInt(position.y / chunkSize) * chunkSize) + (chunkSize * 2);
            foreach (Chunk chunk in getNonRenderChunks(position))
            {
                if (chunk.ChunkRect.position.y > minY)
                    destroyChunk(chunk);
            }
        }
        if (direction == "down")
        {
            int minY = (Mathf.FloorToInt(position.y / chunkSize) * chunkSize);
            foreach (Chunk chunk in getNonRenderChunks(position))
            {
                if (chunk.ChunkRect.position.y < minY)
                    destroyChunk(chunk);
            }
        }
    }
    public void destroyChunk(Chunk destory)
    {
        foreach (GameObject obj in destory.Objects)
        {
            GameObjec

        }
        chunks.Remove(destory);
    }
    List<Chunk> getNonRenderChunks(Vector2 position)
    {
        List<Chunk> nonRenderChunks = new List<Chunk>(chunks);
        foreach (Chunk chunk in getRenderChunks(position))
        {
            nonRenderChunks.Remove(chunk);
        }
        return nonRenderChunks;
    }
    public List<Chunk> getEmptyChunks()
    {
        List<Chunk> emptyChunks = new List<Chunk>();
        foreach (Chunk chunk in chunks)
        {
            if (chunk.Objects.Count == 0)
                emptyChunks.Add(chunk);
        }
        return emptyChunks;
    }
    public List<Chunk> getRenderChunks(Vector2 position)
    {
        List<Chunk> renderChunks = new List<Chunk>();
        renderChunks.Add(getChunk(new Vector2(position.x - chunkSize, position.y)));
        renderChunks.Add(getChunk(position));
        renderChunks.Add(getChunk(new Vector2(position.x + chunkSize, position.y)));
        renderChunks.Add(getChunk(new Vector2(position.x - ch
namespace Xu.Genres.VoxelBased
	[DebuggerDisplay("Chunk ({Position.X}, {Position.Y}, {Position.Z})")]
	public class Chunk : IDisposable
	{
		public const int ChunkSizeX = 32;
		public const int ChunkSizeY = 32;
		public const int ChunkSizeZ = 32;
		public readonly BoundingBox BoundingBox;
		public readonly Vector3 Center;
		public Block[] Blocks;
		private Chunk _leftChunk;
		private Chunk _downChunk;
		private Chunk _forwardChunk;
		private Chunk _rightChunk;
		private Chunk _upChunk;
		private Chunk _backwardChunk;
		private ChunkState _state;
		public Chunk(IntVector3 position)
		{
			Position = position;
			Center.X = Position.X * ChunkSizeX + ChunkSizeX / 2;
			Center.Y = Position.Y * ChunkSizeY + ChunkSizeY / 2;
			Center.Z = Position.Z * ChunkSizeZ + ChunkSizeZ / 2;
			BoundingBox.Min.X = Position.X * ChunkSizeX;
			BoundingBox.Min.Y = Position.Y * ChunkSizeY;
			BoundingBox.Min.Z = Position.Z * ChunkSizeZ;
			BoundingBox.Max.X = (Position.X + 1) * ChunkSizeX;
			BoundingBox.Max

			BoundingBox.Max.Z = (Position.Z + 1) * ChunkSizeZ;
			State = ChunkState.New;
		}
		public IntVector3 Position { get; private set; }
		public ChunkState State
		{
			get { return _state; }
			set { _state = value; }
		}
		public bool HasAllNeighbors
		{
			get { return _leftChunk != null && _rightChunk != null && _downChunk != null && _upChunk != null && _forwardChunk != null && _backwardChunk != null; }
		}
		public VertexBuffer VertexBuffer { get; set; }
		public IndexBuffer IndexBuffer { get; set; }
		public bool HasGraphicsData { get; set; }
		#region IDisposable Members
		public void Dispose()
		{
			DisposeBuffers();
		}
		#endregion
		public static void TranslateWorldToChunkCoord(IntVector3 worldCoordinate, out IntVector3 chunkCoordinate)
		{
			chunkCoordinate.X = worldCoordinate.X >= 0 ? worldCoordinate.X / ChunkSizeX : (worldCoordinate.X + 1) / ChunkSizeX - 1;
			chunkCoordinate.Y = worldCoordinate.Y >= 0 ? worldCoordinate.Y / ChunkSizeY : (worldCoordinate.Y + 1) / ChunkS

			chunkCoordinate.Z = worldCoordinate.Z >= 0 ? worldCoordinate.Z / ChunkSizeZ : (worldCoordinate.Z + 1) / ChunkSizeZ - 1;
		}
		public static void TranslateWorldToChunkBlockCoord(IntVector3 worldCoordinate, out IntVector3 chunkCoordinate, out IntVector3 blockCoordinate)
		{
			chunkCoordinate.X = worldCoordinate.X >= 0 ? worldCoordinate.X / ChunkSizeX : (worldCoordinate.X + 1) / ChunkSizeX - 1;
			chunkCoordinate.Y = worldCoordinate.Y >= 0 ? worldCoordinate.Y / ChunkSizeY : (worldCoordinate.Y + 1) / ChunkSizeY - 1;
			chunkCoordinate.Z = worldCoordinate.Z >= 0 ? worldCoordinate.Z / ChunkSizeZ : (worldCoordinate.Z + 1) / ChunkSizeZ - 1;
			blockCoordinate.X = XuMath.Modulo(worldCoordinate.X, ChunkSizeX);
			blockCoordinate.Y = XuMath.Modulo(worldCoordinate.Y, ChunkSizeY);
			blockCoordinate.Z = XuMath.Modulo(worldCoordinate.Z, ChunkSizeZ);
		}
		public void DisposeBuffers()
		{
			if (VertexBuffer != null)
			{
				VertexBuffer.Dispose();
				VertexBuffer = null;
			}
			if (IndexBuff
namespace ThreeBytes.Email.Dashboard.DispatchDaily.Data.Concrete
    public class DispatchDailyDashboardRepository : KeyedGenericRepository<DashboardDispatchDailyEmail>, IDispatchDailyDashboardRepository
    {
        public DispatchDailyDashboardRepository(IDispatchDailyDashboardDatabaseFactory databaseFactory, IDispatchDailyDashboardUnitOfWork unitOfWork)
            : base(databaseFactory, unitOfWork)
        {
        }
        public int GetTodaysDispatchCount(string applicationName)
        {
            return Session.QueryOver<DashboardDispatchDailyEmail>()
                .Where(x => x.DispatchDate == DateTime.Today)
                .And(x => x.ApplicationName == applicationName)
                .RowCount();
        }
        public int[] GetLastThirtyDaysDispatchCounts(string applicationName)
        {
            var counts = Session.QueryOver<DashboardDispatchDailyEmail>()
                .Select(
                    Projections.Group<DashboardDispatchDailyEmail>(x => x.Dis
namespace VetTrainer.Controllers.Apis
    public class ClinicInstrumentModifyController : ApiController
    {
        VetAppDBContext _context = new VetAppDBContext();
        protected override void Dispose(bool disposing)
        {
            _context.Dispose();
        }
        public IHttpActionResult PostClinicInstrumentModify(InstrumentDto instrument)
        {
            string msg = "";
            if (instrument == null)
            {
                msg = "参数错误";
            }
            try
            {
                var instrumentToModify = _context.Instruments.Find(instrument.Id);
                _context.Entry(instrumentToModify).Collection(u => u.Texts).Load();
                _context.Entry(instrumentToModify).Collection(u => u.Pictures).Load();
                _context.Entry(instrumentToModify).Collection(u => u.Videos).Load();
                var instrumentToModifyDto = Mapper.Map<Instrument, InstrumentDto>(instrumentToModify);
                foreach (TextDto 

                {
                    var text = _context.Texts.Find(t.Id);
                    _context.Texts.Remove(text);
                }
                foreach (PictureDto p in instrumentToModifyDto.Pictures)
                {
                    var picture = _context.Pictures.Find(p.Id);
                    _context.Pictures.Remove(picture);
                }
                foreach (VideoDto v in instrumentToModifyDto.Videos)
                {
                    var video = _context.Videos.Find(v.Id);
                    _context.Videos.Remove(video);
                }
                instrumentToModify.Texts.Clear();
                foreach(TextDto t in instrument.Texts)
                {
                    var text = Mapper.Map<TextDto, Text>(t);
                    instrumentToModify.Texts.Add(text);
                }
                instrumentToModify.Pictures.Clear();
                foreach (PictureDto p in instrument.Pictures)
                {
                    v
public class ChunkMap : MonoBehaviour
    public Dictionary<IntVec3, ChunkData> Chunks = new Dictionary<IntVec3, ChunkData>();
    public GameObject ChunkPrefab;
    public ChunkData EnsureChunk(IntVec3 chunkCoord)
    {
        ChunkData cd;
        if (!Chunks.TryGetValue(chunkCoord, out cd))
        {
            var go = (GameObject)Instantiate(ChunkPrefab, Constants.ChunkSize * chunkCoord.NegativeCornersToVector3(), Quaternion.identity);
            go.transform.SetParent(transform, false);
            go.name = string.Format("Chunk @ {0},{1},{2}", chunkCoord.x, chunkCoord.y, chunkCoord.z);
            cd = go.GetComponent<ChunkData>();
            Chunks.Add(chunkCoord, cd);
        }
        return cd;
    }
    public ChunkData GetChunk(IntVec3 chunkCoord)
    {
        ChunkData cd;
        Chunks.TryGetValue(chunkCoord, out cd);
        return cd;
    }
    public void Start()
    {
        var ce = EnsureChunk(new IntVec3(0, 0, 0));
        ce.Contents[3, 0, 3] = 1;
        
namespace UIA.Extensions.AutomationProviders
    [TestFixture]
    public class InvokeProviderTest
    {
        private InvokeControlStub _invokeControl;
        private InvokeProvider _invokeProvider;
        private Control _control;
        [SetUp]
        public void SetUp()
        {
            _control = new Control();
            _invokeControl = new InvokeControlStub(_control);
            _invokeProvider = new InvokeProvider(_invokeControl);
        }
        [Test]
        public void ItHasTheCorrectPattern()
        {
            _invokeProvider.GetPatternProvider(InvokePatternIdentifiers.Pattern.Id)
                .Should().BeSameAs(_invokeProvider);
        }
        [Test]
        public void ItCanBeInvoked()
        {
            _invokeProvider.Invoke();
            _invokeControl.WasInvoked.Should().BeTrue();
        }
        [Test]
        public void ItCanTakeAction()
        {
            var actualInvocation = string.Empty;
            new InvokeProvider(_contr
namespace MistRidge
    public class ChunkFacade : Facade
    {
        private readonly Chunk chunk;
        private readonly ChunkView chunkView;
        private ChunkFacade previousChunkFacade;
        public ChunkFacade(
                Chunk chunk,
                ChunkView chunkView)
        {
            this.chunk = chunk;
            this.chunkView = chunkView;
        }
        public ChunkFacade PreviousChunkFacade
        {
            get
            {
                return previousChunkFacade;
            }
            set
            {
                previousChunkFacade = value;
            }
        }
        public Transform Parent
        {
            get
            {
                return chunkView.Parent;
            }
            set
            {
                chunkView.Parent = value;
            }
        }
        public string Name
        {
            get
            {
                return chunkView.Name;
            }
            set
            {


            }
        }
        public Vector3 Position
        {
            get
            {
                return chunkView.Position;
            }
            set
            {
                chunkView.Position = value;
            }
        }
        public Quaternion Rotation
        {
            get
            {
                return chunkView.Rotation;
            }
            set
            {
                chunkView.Rotation = value;
            }
        }
        public CheckpointWallView CheckpointWallView
        {
            get
            {
                return chunk.CheckpointWallView;
            }
        }
        public CheckpointView CheckpointView
        {
            get
            {
                return chunk.CheckpointView;
            }
        }
        public ChunkView ChunkView
        {
            get
            {
                return chunkView;
            }
        }
        public SpawnView SpawnView
        {
            get
    
namespace COP4710.Controllers
    [Authorization]
    public class DispatchController : Controller
    {
        public ActionResult Index(int? page)
        {
            if (page.HasValue)
            {
                ViewBag.Page = page;
                return View(DispatchDAO.List(page.Value));
            }
            else
            {
                ViewBag.Page = page;
                Boolean disablePaging = false;
                Boolean.TryParse(ConfigurationManager.AppSettings["DisablePaging"].ToString(), out disablePaging);
                if (disablePaging == false)
                    return RedirectToAction("Index", new { @page = 0 });
                else
                    return View(DispatchDAO.List());
            }
        }
        public ActionResult Details(int id)
        {
            DispatchModel dispatch = DispatchDAO.GetDispatchByID(id);
            if (dispatch != null)
                return View(dispatch);
            else
                return Red

        }
        public ActionResult Create()
        {
            return View(new DispatchModel());
        }
        [HttpPost]
        public ActionResult Create(FormCollection collection)
        {
            try
            {
                DispatchModel form = new DispatchModel();
                TryUpdateModel<DispatchModel>(form, collection.ToValueProvider());
                int rowsAffected = DispatchDAO.Insert(form);
                return RedirectToAction("Index");
            }
            catch
            {
                return RedirectToAction("Create");
            }
        }
        [Authorization(UserRole = AccountType.Administrator)]
        public ActionResult Edit(int id)
        {
            if (id > 0)
                return View(DispatchDAO.GetDispatchByID(id));
            else
                return RedirectToAction("Index");
        }
        [HttpPost]
        public ActionResult Edit(int id, FormCollection collection)
        {
            Dispatc
#region Using
#endregion Using
namespace CY.CSTS.Core.Services.DALService
	internal sealed class ExhibitionInstrumentService
	{
		#region Constructor
		static ExhibitionInstrumentService()
		{
			LoadProvider();
		}
		#endregion Constructor
		#region Provider model
		private static volatile Providers.DALProvider.IExhibitionInstrumentProvider provider;
		private static object syncLock = new object();
		private static void LoadProvider()
		{
			if (provider == null)
			{
				lock (syncLock)
				{
					if (provider == null)
					{
						string path = CY.CSTS.Configuration.ConfigurationManager.Providers.DALProviders.Default.Path;
						string className = CY.CSTS.Configuration.ConfigurationManager.Providers.DALProviders.Default.Namespace + ".ExhibitionInstrumentProvider";
						provider = System.Reflection.Assembly.Load(path).CreateInstance(className) as Providers.DALProvider.IExhibitionInstrumentProvider;
					}
				}
			}
		}
		#endregion Provider model
		public static Business.Exhibition

		{
			return provider.Select(id);
		}
		public static void Update(Business.ExhibitionInstrument exhibitionInstrument)
		{
			provider.Update(exhibitionInstrument);
		}
		public static void Delete(Business.ExhibitionInstrument exhibitionInstrument)
		{
			provider.Delete(exhibitionInstrument);
		}
		public static void Insert(Business.ExhibitionInstrument exhibitionInstrument)
		{
			provider.Insert(exhibitionInstrument);
		}
        public static IList<Core.Business.ExhibitionInstrument> GetAllExhibitionInstrument(string strWhere)
		{
			return provider.GetAllExhibitionInstrument(strWhere);
		}
        public static IList<Core.Business.ExhibitionInstrument> GetExhibitionInstrumentByPage(string sqlwhere, int pagenumber, int pagesize)
        {
            return provider.GetExhibitionInstrumentByPage(sqlwhere, pagenumber, pagesize);
        }
        public static IList<Core.Business.ExhibitionInstrument> GetExhibitionInstrumentTopBySequenceNumber(int num)
        {
            return 
namespace SmartQuant
	public class InstrumentManager
	{
		private Framework framework;
		private InstrumentServer server;
		private InstrumentList instruments;
		private int next_id;
		public InstrumentList Instruments
		{
			get
			{
				return this.instruments;
			}
		}
		public InstrumentServer Server
		{
			get
			{
				return this.server;
			}
		}
		public Instrument this[string symbol]
		{
			get
			{
				return this.instruments.Get(symbol);
			}
		}
		public InstrumentManager(Framework framework, InstrumentServer server)
		{
			this.framework = framework;
			this.server = server;
			this.server.Open();
			this.next_id = -1;
			this.instruments = server.Load();
			for (int i = 0; i < this.instruments.Count; i++)
			{
				this.instruments.GetByIndex(i).isPersistent = true;
				int id = this.instruments.GetByIndex(i).Id;
				if (id > this.next_id)
				{
					this.next_id = id;
				}
			}
			this.next_id++;
		}
		public Instrument GetById(int id)
		{
			Instrument instrument = this.

			if (instrument == null)
			{
				instrument = new Instrument(id, InstrumentType.Synthetic, Guid.NewGuid().ToString(), "", 1);
				this.instruments.Add(instrument);
			}
			return instrument;
		}
		public Instrument Get(string symbol)
		{
			return this.instruments.Get(symbol);
		}
		public bool Contains(string symbol)
		{
			return this.instruments.Contains(symbol);
		}
		public void Add(Instrument instrument, bool save = true)
		{
			if (this.Contains(instrument.symbol))
			{
				throw new ApplicationException("Instrument with the same symbol is already present in the framework : " + instrument.symbol);
			}
			instrument.Id = this.next_id;
			this.next_id++;
			this.instruments.Add(instrument);
			if (save && this.server != null)
			{
				this.server.Save(instrument);
			}
			this.framework.eventServer.OnInstrumentAdded(instrument);
		}
		public void Delete(Instrument instrument)
		{
			this.instruments.Remove(instrument);
			if (this.server != null && instrument.isPersistent)
		

				this.server.Delete(instrument);
			}
			this.framework.eventServer.OnInstrumentDeleted(instrument);
		}
		public void Delete(string symbol)
		{
			Instrument instrument = this.Get(symbol);
			if (instrument != null)
			{
				this.Delete(instrument);
			}
		}
		public void Clear()
		{
			foreach (Instrument current in this.instruments)
			{
				current.bid = null;
				current.ask = null;
				current.trade = null;
			}
			InstrumentList instrumentList = new InstrumentList();
			foreach (Instrument current2 in this.instruments)
			{
				if (!current2.isPersistent)
				{
					instrumentList.Add(current2);
				}
			}
			foreach (Instrument current3 in instrumentList)
			{
				this.Delete(current3);
			}
		}
		public void Save(Instrument instrument)
		{
			if (this.server != null)
			{
				instrument.isPersistent = true;
				this.server.Save(instrument);
			}
		}
		public void Dump()
		{
			Console.WriteLine("Instrument manager contains " + this.instruments.Count + " intruments:");
			f
namespace IF.Lastfm.Core.Api
    public class LastfmClient : ApiBase
    {
        private AlbumApi _albumApi;
        private ArtistApi _artistApi;
        private ChartApi _chartApi;
        private LibraryApi _libraryApi;
        private ScrobblerBase _scrobbler;
        private TagApi _tagApi;
        private TrackApi _trackApi;
        private UserApi _userApi;
        public AlbumApi Album => _albumApi ?? (_albumApi = new AlbumApi(Auth, HttpClient));
        public ArtistApi Artist => _artistApi ?? (_artistApi = new ArtistApi(Auth, HttpClient));
        public ChartApi Chart => _chartApi ?? (_chartApi = new ChartApi(Auth, HttpClient));
        public LibraryApi Library => _libraryApi ?? (_libraryApi = new LibraryApi(Auth, HttpClient));
        public TagApi Tag => _tagApi ?? (_tagApi = new TagApi(Auth, HttpClient));
        public TrackApi Track => _trackApi ?? (_trackApi = new TrackApi(Auth, HttpClient));
        public UserApi User => _userApi ?? (_userApi = new UserApi(Auth, H
namespace monotest.Components.World
    public class ChunkDataComponent : Component
    {
        public int ChunkX;
        public int ChunkY;
        public TileData[,] ChunkTileData;
        public bool IsDirty { get; internal set; }
        public void Init(int X, int Y)
        {
            ChunkX = X;
            ChunkY = Y;
            
            var  MapData = Noise2d.GenerateNoiseMap(ChunkX * ChunkManager.Instance.ChunkWidth, ChunkY * ChunkManager.Instance.ChunkHeight,
             ChunkManager.Instance.ChunkWidth, ChunkManager.Instance.ChunkHeight, 8, 256);
            var  BaseTileData = new int[ChunkManager.Instance.ChunkWidth, ChunkManager.Instance.ChunkHeight];
            var DecorationTileData = new int[ChunkManager.Instance.ChunkWidth, ChunkManager.Instance.ChunkHeight];
            ChunkTileData = new TileData[ChunkManager.Instance.ChunkWidth, ChunkManager.Instance.ChunkHeight];
            for (var i = 0; i < ChunkManager.Instance.ChunkWidth; i++)
            {
  

                {
                    BaseTileData[i, j]
                        = TerrainGen.TileForHeight((ChunkX * ChunkManager.Instance.ChunkWidth) + i, (ChunkY * ChunkManager.Instance.ChunkHeight) + j,
                            MapData[i, j]);
                    DecorationTileData[i, j] = -1;
                    var tree = TerrainGen.WantTree(
                        (ChunkX * ChunkManager.Instance.ChunkWidth) + i, (ChunkY * ChunkManager.Instance.ChunkHeight) + j, MapData[i, j]);
                    TileData tData = new TileData();
                    tData.ChunkTileOffsetX = i;
                    tData.ChunkTileOffsetY = j;
                    tData.TileBaseType = BaseTileData[i, j];
                    tData.TileDetailType = DecorationTileData[i, j];
                    tData.TileX = (ChunkX * ChunkManager.Instance.ChunkWidth) + i;
                    tData.TileY = (ChunkY * ChunkManager.Instance.ChunkHeight) + j;
                    tData.TileEntity =  new Entity();
      
namespace  BestCS.Audio.SoundFont 
	internal class InstrumentBuilder : StructureBuilder<Instrument>
	{
		private Instrument lastInstrument = null;
        public override Instrument Read(BinaryReader br) 
		{
			Instrument i = new Instrument();
			string s = Encoding.UTF8.GetString(br.ReadBytes(20), 0, 20);
			if(s.IndexOf('\0') >= 0) 
			{
				s = s.Substring(0,s.IndexOf('\0'));
			}
			i.Name = s;
			i.startInstrumentZoneIndex = br.ReadUInt16();
			if(lastInstrument != null)
			{
				lastInstrument.endInstrumentZoneIndex = (ushort) (i.startInstrumentZoneIndex - 1);
			}
			data.Add(i);
			lastInstrument = i;
			return i;
		}
        public override void Write(BinaryWriter bw, Instrument instrument) 
		{
		}
		public override int Length 
		{
			get 
			{
				return 22;
			}
		}
		public void LoadZones(Zone[] zones)
		{
			for(int instrument = 0; instrument < data.Count - 1; instrument++)
			{
				Instrument i = (Instrument) data[instrument];
				i.Zones = new Zone[i.endInstrumentZoneI
namespace RiskAnalysisTool.MobileApp.Converters
    class InstrumentSummaryConverter : DynamicVisitor<Instrument>, IValueConverter
    {
        private object _result;
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            Instrument instrument = value as Instrument;
            if (instrument == null)
            {
                return null;
            }
            this.Visit(instrument);
            return _result;
        }
        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotSupportedException();
        }
        protected void OnVisit(InterestRateSwap instrument)
        {
            string str1, str2;
            if(instrument.IsPayFloating)
            {
                str1 = string.Format("LIBOR{0:+#0;-#0;+#0}bps", instrument.FloatingSpread * 10000);
                str2 = string.Format("{0:#0.0%}", instrument.FixedRate

            }
            else
            {
                str1 = string.Format("{0:#0.0%}", instrument.FixedRate);
                str2 = string.Format("LIBOR{0:+#0;-#0;+0}bps", instrument.FloatingSpread * 10000);
            }
            _result = string.Format("N: {0}, Pay: {1}, Rec: {2}", instrument.Nominal, str1, str2);
        }
        protected void OnVisit(CrossCurrencySwap instrument)
        {
            _result = string.Format("Pay: {0} x {1} , Rec: {2} x {3}", 
                instrument.PayNominal, instrument.PayRate, instrument.ReceiveNominal, instrument.ReceiveRate);
        }
        protected void OnVisit(EquitySwap instrument)
        {
            _result = string.Format("{0} div. of {1} shares @ {2:#0.0%}",
                instrument.PaySymbol != null ? "Pay":"Receive", instrument.Amount, instrument.FixedRate);
        }
        protected void OnVisit(Bond instrument)
        {
            _result = string.Format("Maturity: {0:d}, Price: {1:#0.000}", instrumen
namespace DataAccess
   public class UnitOfWork
    {
        LMSTSContext _context;
        public UnitOfWork()
        {
            _context = new LMSTSContext();
        }
        AnswerRepository _answerRepository;
        public AnswerRepository AnswerRepository
        {
            get
            {
                if (_answerRepository == null)
                {
                    _answerRepository = new AnswerRepository(_context);
                }
                return _answerRepository;
            }
        }
        BranchRepository _branchRepository;
        public BranchRepository BranchRepository
        {
            get
            {
                if (_branchRepository == null)
                {
                    _branchRepository = new BranchRepository(_context);
                }
                return _branchRepository;
            }
        }
        CommentRepository _commentRepository;
        public CommentRepository CommentRepository
        {
         

            {
                if (_commentRepository == null)
                {
                    _commentRepository = new CommentRepository(_context);
                }
                return _commentRepository;
            }
        }
        ContentRepository _contentRepository;
        public ContentRepository ContentRepository
        {
            get
            {
                if (_contentRepository == null)
                {
                    _contentRepository = new ContentRepository(_context);
                }
                return _contentRepository;
            }
        }
        EducationBranchRepository _educationBranchRepository;
        public EducationBranchRepository EducationBranchRepository
        {
            get
            {
                if (_educationBranchRepository == null)
                {
                    _educationBranchRepository = new EducationBranchRepository(_context);
                }
                return _educationBranchReposito

            }
        }
        EducationGroupRepository _educationGroupRepository;
        public EducationGroupRepository EducationGroupRepository
        {
            get
            {
                if (_educationGroupRepository == null)
                {
                    _educationGroupRepository = new EducationGroupRepository(_context);
                }
                return _educationGroupRepository;
            }
        }
        EducationGroupStudentRepository _educationGroupStudentRepository;
        public EducationGroupStudentRepository EducationGroupStudentRepository
        {
            get
            {
                if (_educationGroupStudentRepository == null)
                {
                    _educationGroupStudentRepository = new EducationGroupStudentRepository(_context);
                }
                return _educationGroupStudentRepository;
            }
        }
        GenderRepository _genderRepository;
        public GenderRepository GenderR
namespace AnnieReplays
    class ReplayRecorder
    {
        public string GameId { get; private set; }
        public string EncKey { get; private set; }
        private Getter Getter;
        private ReplayWriter writer;
        public delegate void FinishedRecordingHandler(string gameId);
        public event FinishedRecordingHandler FinishedRecording;
        public ReplayRecorder(IRegion region, string gameId,string encKey)
        {
            GameId = gameId;
            EncKey = encKey;
            writer = new ReplayWriter(region,gameId);
            Getter = new Getter(region, gameId);
        }
        public void StartRecord()
        {
            writer.WriteVersion(Getter.GetVersion());
            #region Get Metadata
            var metadata = JObject.Parse(Getter.GetGameMetadata());
            while (true)
            {
                var chunk = JObject.Parse(Getter.GetLastChunkInfo());
                if ((int)chunk["chunkId"] > (int)metadata["endStartupChunkId"

                {
                    break;
                }
                else
                {
                    Util.Delay((int)chunk["nextAvailableChunk"]);
                    continue;
                }
            }
            var newMetadata = JObject.Parse(Getter.GetGameMetadata());
            for (int i = 1; i <= (int)newMetadata["endStartupChunkId"]; i++)
            {
                while (true)
                {
                    var chunkInfo = JObject.Parse(Getter.GetLastChunkInfo());
                    if (i > (int)chunkInfo["chunkId"])
                    {
                        Util.Delay((int)chunkInfo["nextAvailableChunk"]);
                        continue;
                    }
                    var chunkFrame = Getter.GetChunkFrame(i.ToString());
                    writer.WriteChunk(i.ToString(), chunkFrame);
                    break;
                }
            }
            #endregion
            #region GetFrames
            int firstChun

            int firstKeyFrame = 0;
            int lastChunk = 0;
            int lastKeyFrame = 0;
            while (true)
            {
                var chunkInfo = JObject.Parse(Getter.GetLastChunkInfo());
                if (firstChunk == 0)
                {
                    if ((int)chunkInfo["chunkId"] > (int)chunkInfo["startGameChunkId"])
                    {
                        firstChunk = (int)chunkInfo["chunkId"];
                    }
                    else
                    {
                        firstChunk = (int)chunkInfo["startGameChunkId"];
                    }
                    if ((int)chunkInfo["keyFrameId"] > 0)
                    {
                        firstKeyFrame = (int)chunkInfo["keyFrameId"];
                    }
                    else
                    {
                        firstKeyFrame = 1;
                    }
                    lastChunk = (int)chunkInfo["chunkId"];
                    lastKeyFrame = (int)chunkInfo[
namespace SEP.HRMIS.Bll.DiyProcesses
    public class UpdateDiyProcess : Transaction
    {
        private readonly IDiyProcessDal _IDiyProcessDal = new DiyProcessDal();
        private readonly DiyProcess _DiyProcess;
        public UpdateDiyProcess(DiyProcess diyProcess)
        {
            _DiyProcess = diyProcess;
        }
        public UpdateDiyProcess(DiyProcess diyProcess, IDiyProcessDal mockIDiyProcessDal)
        {
            _DiyProcess = diyProcess;
            _IDiyProcessDal = mockIDiyProcessDal;
        }
        protected override void Validation()
        {
            if (_IDiyProcessDal.CountDiyProcessByNameDiffPKID(_DiyProcess.ID, _DiyProcess.Name) > 0)
            {
                HrmisUtility.ThrowException(HrmisUtility._DiyProcess_Name_Repeat);
            }
        }
        protected override void ExcuteSelf()
        {
            try
            {
                _IDiyProcessDal.UpdateDiyProcess(_DiyProcess);
            }
            catch
            {
namespace SynchronousMessageSystem
    public class ActorMatch
    {
        private readonly ReceiveProcess _receiveProcess;
        private readonly string _receiveProcessName;
        public Type MessageType { get; }
        public ReceiveProcess GetReceiveProcess(Actor actor)
        {
            if (_receiveProcess != null)
                return _receiveProcess;
            ReceiveProcess r = null;
            if (!string.IsNullOrEmpty(_receiveProcessName))
                r = actor.TryGetReceiveProcess(_receiveProcessName);
            return r ?? actor.TryGetReceiveProcess(nameof(Actor.Other));
        }
        public ActorMatch(Type messageType, ReceiveProcess receiveProcess)
        {
            MessageType = messageType;
            _receiveProcess = receiveProcess;
        }
        public ActorMatch(ReceiveProcess receiveProcess)
        {
            _receiveProcess = receiveProcess;
        }
        public ActorMatch(Type messageType, string receiveProcess)
        {
namespace Bussiness
    public class DispatchData
    {
        DBDispatch dbDispatch = new DBDispatch();
        public DataSet GetAllOrdersDetails()
        {
            return dbDispatch.GetAllOrdersDetails();
        }
        public DataSet GetDispatchSearch(Dispatch dispatch)
        {
            return dbDispatch.GetDispatchSearch(dispatch);
        }
        public DataSet GetDispatchByAgentID(Dispatch dispatch)
        {
            return dbDispatch.GetDispatchByAgentID(dispatch);
        }
        public DataSet CashierGetDetails(Dispatch dispatch)
        {
            return dbDispatch.CashierGetDetails(dispatch);
        }
        public DataSet GetDetailsForSettlement(Dispatch dispatch)
        {
            return dbDispatch.GetDetailsForSettlement(dispatch);
        }
        public DataSet GetStockFromDispatch(Dispatch dispatch)
        {
            return dbDispatch.GetStockFromDispatch(dispatch);
        }
        
        public DataSet GenerateDispatchSummary(i

        {
            return dbDispatch.GenerateDispatchSummary(id);
        }
        public DataSet GetDispatchLists(Dispatch disp)
        {
            return dbDispatch.GetDispatchLists(disp);
        }
        public DataSet GetDispatchListsUser(Dispatch disp)
        {
            return dbDispatch.GetDispatchListsUser(disp);
        }
        public DataSet getStock(int id)
        {
            return dbDispatch.getStock(id);
        }
        public DataSet getDetailsbyDDid(int id)
        {
            return dbDispatch.getDetailsbyDDid(id);
        }
        public DataSet CashierGetDetailsId(int id)
        {
            return dbDispatch.CashierGetDetailsId(id);
        }
        
        public DataSet GetDispatchByID(int id)
        {
            return dbDispatch.GetDispatchByID(id);
        }
        
        public int AddDispatchInfo(Dispatch dispatch)
        {
            DBDispatch dbdispatch = new DBDispatch();
            int Result = 0;
            try
      

                Result = dbdispatch.AddDispatchInfo(dispatch);
                return Result;
            }
            catch (Exception)
            {
                throw;
            }
        }
        public int UpdateDispatch(Dispatch dispatch)
        {
            DBDispatch dbdispatch = new DBDispatch();
            int Result = 0;
            try
            {
                Result = dbdispatch.UpdateDispatch(dispatch);
                return Result;
            }
            catch (Exception)
            {
                throw;
            }
        }
        public int updateReturnItems(Dispatch dispatch)
        {
            DBDispatch dbdispatch = new DBDispatch();
            int Result = 0;
            try
            {
                Result = dbdispatch.updateReturnItems(dispatch);
                return Result;
            }
            catch (Exception)
            {
                throw;
            }
        }
        public int CashierUpdate(Dispatch dispat
namespace TradeAnalyzer
    public static class StatisticsFiles
    {
        private static readonly List <string> Files;
        private static List <TradeInstrument> _issuers; 
        static StatisticsFiles()
        {
            Files = new List <string>();
        }
        public static void Check()
        {
            bool selectFiles = SetFiles();
            if (selectFiles)
            {
                foreach (string file in Files)
                {
                    TradeInstrument instrument = new TradeInstrument(file);
                    instrument.ReadAllQuotes();
                    instrument.ReadAllRomanDeals();
                    instrument.WriteAllDeals();
                    instrument.WriteSimpleDeals();
                }
            }
            MessageBox.Show("vse!");
        }
        public static List <string> SetIssuerFiles()
        {
            string exePath = Assembly.GetExecutingAssembly().Location;
            string folder = Path.GetDirect

            string[] files = Directory.GetFiles(folder, "*.xls");
            _issuers = new List <TradeInstrument>();
            foreach (string file in files)
            {
                _issuers.Add(new TradeInstrument(file));
            }
            List <string> issuerNames = new List <string>();
            foreach (TradeInstrument issuer in _issuers)
            {
                issuerNames.Add(issuer.Name);
            }
            issuerNames.Sort();
            return issuerNames;
        }
        public static Dictionary<DateTime, Deal> GetRomanDeals(string tradeInstrumentName)
        {
            foreach (TradeInstrument tradeInstrument in _issuers)
            {
                if (tradeInstrument.Name == tradeInstrumentName)
                {
                    tradeInstrument.ReadAllRomanDeals();
                    return tradeInstrument.GetAllRomanDeals();
                }
            }
            return null;
        }
        public static Dictionary<Da

        {
            foreach (TradeInstrument tradeInstrument in _issuers)
            {
                if (tradeInstrument.Name == tradeInstrumentName)
                {
                    tradeInstrument.ReadAllSimpleDeals();
                    return tradeInstrument.GetAllSimpleDeals();
                }
            }
            return null;
        }
        private static bool SetFiles()
        {
            if (Files.Count > 0)
                return true;
            OpenFileDialog dlg = new OpenFileDialog
                {
                        FileName = "Выберите файлы",
                        Multiselect = true,
                        DefaultExt = ".xlsx",
                        Filter = "Электронные таблицы Excel (.xlsx, .xls)|*.xls;*.xlsx|All Files|*.*"
                };
            bool? result = dlg.ShowDialog();
            if (result == true)
            {
                foreach (string fileName in dlg.FileNames)
                {
                    File
﻿namespace BinarySerialization.Test.Issues.Issue12
    public class ChunkContainer
    {
        public ChunkContainer()
        {
        }
        public ChunkContainer(Chunk chunk)
        {
            Chunk = chunk;
        }
        [FieldOrder(0)]
        [FieldLength(4)]
        public string TypeId { get; set; }
        [FieldOrder(1)]
        [FieldEndianness(BinarySerialization.Endianness.Big)]
        public int ChunkLength { get; set; }
        [FieldOrder(2)]
        [FieldLength("ChunkLength")]
        [Subtype("TypeId", "FORM", typeof (FormChunk))]
        [Subtype("TypeId", "CAT ", typeof (CatChunk))]
        [Subtype("TypeId", "LIST", typeof (ListChunk))]
        [Subtype("TypeId", "REFE", typeof (RefeChunk))]
        [Subtype("TypeId", "DESC", typeof (DescChunk))]
        [Subtype("TypeId", "BEER", typeof (BeerChunk))]
        [Subtype("TypeId", "SNAX", typeof (SnaxChunk))]
        [Subtype("TypeId", "PARM", typeof (ParmChunk))]
        [Subtype("TypeId", "BODY", typ
namespace Cvv.WebUtility.Mvc
    internal class MethodSchema
    {
        private string _methodName;
#if MEDIUMLEVEL
        private MethodInfo _invokeHandler;
#else
        private FastInvokeHandler _invokeHandler;
#endif
        private ParameterInfo[] _parameters;
        private bool _isStatic;
#if MEDIUMLEVEL
        public MethodSchema(string methodName, MethodInfo invokeHandler, ParameterInfo[] parameters, bool isStatic)
        {
            _methodName = methodName;
            _invokeHandler = invokeHandler;
            _parameters = parameters;
            _isStatic = isStatic;
        }
#else
        public MethodSchema(string methodName, FastInvokeHandler invokeHandler, ParameterInfo[] parameters, bool isStatic)
        {
            _methodName = methodName;
            _invokeHandler = invokeHandler;
            _parameters = parameters;
            _isStatic = isStatic;
        }
#endif
        public string MethodName
        {
            get { return _methodName; }
namespace WoodStore.Domain.Uow
    public class UnitOfWork : IUnitOfWork
    {
        private StoresDbContext context = new StoresDbContext();
        private Repository<Bank> bankRepository;
        private Repository<Bank_Branches> bankBranchesRepository;
        private Repository<City> cityRepository;
        private Repository<Company_MainData> companyMainDataRepository;
        private Repository<Country> countryRepository;
        private Repository<Currecny_Converter> currecnyConverterRepository;
        private Repository<Currency> currencyRepository;
        private Repository<Job> jobRepository;
        private Repository<Nationality> nationalityRepository;
        private Repository<District> districtRepository;
        private Repository<Unit> unitRepository;
        private Repository<Unit_Converter> unitConverterRepository;
        private Repository<Language> languageRepository;
        private Repository<Branch> branchRepository;
        private Repository<SuppliersGr

        private Repository<Suppliers_SubGroup> suppliers_SubGroupRepository;
        private Repository<Privilege> privilegesRepository;
        private Repository<RolePrivilege> rolePrivilegeRepository;
        private Repository<Role> roleRepository;
        private Repository<User> userRepository;
        private Repository<Gender> genderRepository;
        private Repository<Job_Titles> jobTitlesRepository;
        private Repository<Career_Classes> careerClassesRepository;
        private Repository<Allowance> allowanceRepository;
        private Repository<User_Allowances> userAllowancesRepository;
        private Repository<Setting> settingRepository;
        private Repository<EmailConfig> emailConfigRepository;
        private Repository<IndustryType> industryTypeRepository;
        private Repository<Organization_Legal_Entities> organization_Legal_EntitiesRepository;
        private Repository<DryingType> dryingTypeRepository;
        private Repository<Grade> gradeRepositor

        private Repository<PaymentType> paymentTypeRepository;
        private Repository<Product> productRepository;
        private Repository<ProductDetail> productDetailRepository;
        private Repository<Store> storeRepository;
        private Repository<StoreType> storeTypeRepository;
        private Repository<Category> categoryRepository;
        private Repository<Supplier> supplierRepository;
        private Repository<SerialNoType> serialNoTypeRepository;
        private Repository<StoreTransaction> storeTransactionRepository;
        private Repository<IssuedProduct> issuedProductRepository;
        private Repository<ReceivedProduct> receivedProductRepository;
        private Repository<AdditionType> additionTypeRepository;
        private Repository<IssueType> issueTypeRepository;
        private Repository<StoreTransferenceRecord> storeTransferenceRecordRepository;
        private Repository<TransactionDocument> transactionDocumentRepository;
        private Reposito
namespace Perenis.Core.Decoupling.Multimethods
    [Flags]
    public enum DispatchStatus
    {
        Success = 1,
        NoMatch = 2,
        AmbiguousMatch = 4,
        DynamicInvoke = 8
    }
    public struct DispatchResult
    {
        private DispatchStatus _status;
        internal DispatchResult(DispatchStatus status)
            : this()
        {
            _status = status;
        }
        public object ReturnValue { get; internal set; }
        public bool Success
        {
            get { return (_status & DispatchStatus.Success) == DispatchStatus.Success; }
        }
        public bool AmbiguousMatch
        {
            get { return (_status & DispatchStatus.AmbiguousMatch) == DispatchStatus.AmbiguousMatch; }
        }
        public bool NoMatch
        {
            get { return (_status & DispatchStatus.NoMatch) == DispatchStatus.NoMatch; }
        }
        public bool IsDynamicInvoke
        {
            get { return (_status & DispatchStatus.DynamicInvo

            internal set { _status |= DispatchStatus.DynamicInvoke; }
        }
        public DispatchResult<R> Typed<R>()
        {
            var result = new DispatchResult<R>(_status);
            if (ReturnValue != null)
            {
                result.ReturnValue = (R) ReturnValue;
            }
            return result;
        }
    }
    public struct DispatchResult<R>
    {
        private readonly DispatchStatus _status;
        internal DispatchResult(DispatchStatus status)
            : this()
        {
            _status = status;
        }
        public R ReturnValue { get; internal set; }
        public bool Success
        {
            get { return (_status & DispatchStatus.Success) == DispatchStatus.Success; }
        }
        public bool AmbiguousMatch
        {
            get { return (_status & DispatchStatus.AmbiguousMatch) == DispatchStatus.AmbiguousMatch; }
        }
        public bool NoMatch
        {
            get { return (_status & Dispatch
namespace LQT.Core.DataAccess.NHibernate
    public class NHInstrumentDao : NHibernateDao<Instrument>, IInstrumentDao
    {
        public Instrument GetInstrumentByName(string name)
        {
            string hql = "from Instrument i where i.InstrumentName = :iname";
            ISession session = NHibernateHelper.OpenSession();
            IQuery q = session.CreateQuery(hql);
            q.SetString("iname", name);
            IList<Instrument> result = q.List<Instrument>();
            if (result.Count > 0)
                return result[0];
            return null;
        }
        public Instrument GetInstrumentByNameAndTestingArea(string name, int testingAreaId)
        {
            string hql = "from Instrument i where i.InstrumentName = :iname and i.TestingArea.Id = :testingAreaId";
            ISession session = NHibernateHelper.OpenSession();
            IQuery q = session.CreateQuery(hql);
            q.SetString("iname", name);
            q.SetInt32("testingAreaId", tes
public class World : MonoBehaviour {
	public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
	public GameObject chunkPrefab;
	public int newChunkX;
    public int newChunkY;
    public int newChunkZ;
  
    public bool genChunk;
	public string worldName = "world";  
	void Start(){	
	    for (int x = -2; x < 2; x++)
	    {
	        for (int y = -1; y < 0; y++)
	        {
	            for (int z = -1; z < 1; z++)
	            {
	                CreateChunk(x * 16, y * 16, z * 16);
	            }
	        }
	    }
	}
	void Update () {
		if (genChunk)
        {
            genChunk = false;
            WorldPos chunkPos = new WorldPos(newChunkX, newChunkY, newChunkZ);
            Chunk chunk = null;
  
            if (chunks.TryGetValue(chunkPos, out chunk))
            {
                DestroyChunk(chunkPos.x, chunkPos.y, chunkPos.z);
            }
            else
            {
                CreateChunk(chunkPos.x, chunkPos.y, chunkPos.z);
            }
       

	}
	public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(worldPos.x, worldPos.y, worldPos.z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
  
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
  
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        
  
        for (int xi = 0; xi < 16; xi++)
        {
            for (int yi = 0; yi < 16; yi++)
            {
                for (int zi = 0; zi < 16; zi++)
                {
                    if (yi <= 7)
                    {
                        SetBlock(x+xi, y+yi, z+zi, new BlockGrass());
                    }
                    else
                    {
                        SetBlock(x + xi, y + yi, z + zi, new BlockAir());
                    }
                }

            }
        }
        newChunk.SetBlocksUnmodified();
        Serialization.Load(newChunk);
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple ) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple ) * Chunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / multiple ) * Chunk.chunkSize;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
  
        return containerChunk;
    }
    public Block GetBlock(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null)
        {
            Block block = containerChunk.GetBlock(
                x - containerChunk.pos.x,
                y -containerChunk.pos.y,
                z - containerChunk.pos.z);
  
            return block;
        }
        else
        {
            return new BlockAir();
   
namespace Voxel.Engine.Managers
    public class ChunkManager : BaseManager
    {
        private Dictionary<Vector3, Chunk> chunks;
        public Dictionary<Vector3, Chunk> Chunks
        {
            get { return chunks; }
        }
        private Perlin perlin;
        public Perlin Perlin
        {
            get { return perlin; }
        }
        public ChunkManager(SceneGame game) : base(game)
        {
            this.chunks = new Dictionary<Vector3, Chunk>();
            this.perlin = new Perlin();
            Initialize();
        }
        protected override void Initialize()
        {
            perlin.Seed = 1414;
            perlin.OctaveCount = 1;
            perlin.Lacunarity = 1;
            perlin.Persistence = 1;
            perlin.Frequency = 0.008;
            perlin.Quality = SharpNoise.NoiseQuality.Standard;
            
            base.Initialize();
        }
        protected override string GetName()
        {
            return "Chunk";
        }
    

        {
            foreach (KeyValuePair<Vector3, Chunk> pair in chunks)
                pair.Value.Update(gameTime);
        }
        public void AddChunk(Chunk chunk)
        {
            if (!chunks.Keys.Contains(chunk.position/32))
            {
                chunks.Add(chunk.position / 32, chunk);
                UpdateSurroundingChunks((int)chunk.position.X / 32, (int)chunk.position.Y / 32, (int)chunk.position.Z / 32);
            }
        }
        public void RemoveChunk(Chunk chunk)
        {
            Chunk checkEntity = null;
            if (!chunks.TryGetValue(chunk.position, out checkEntity))
                throw new Exception("No chunk with position " + chunk.position + " exists in the scene to be removed.");
            chunks.Remove(chunk.position / 32);
        }
        public Chunk GetChunk(Vector3 chunkPosition)
        {
            Chunk chunk = null;
            chunks.TryGetValue(chunkPosition, out chunk);
            return chunk;
        }
        

        {
            Chunk chunk = null;
            Vector3 chunkPosition = new Vector3((float)Math.Floor(x / 32f), (float)Math.Floor(y / 32f), (float)Math.Floor(z / 32f));
            chunks.TryGetValue(chunkPosition, out chunk);
            return chunk;
        }
        public void UpdateSurroundingChunks(int x, int y, int z)
        {
            Chunk tempChunk = GetChunk(new Vector3(x + 1, y, z));
            if (tempChunk != null)
                tempChunk.dirty = true;
            tempChunk = GetChunk(new Vector3(x - 1, y, z));
            if (tempChunk != null)
                tempChunk.dirty = true;
            tempChunk = GetChunk(new Vector3(x, y + 1, z));
            if (tempChunk != null)
                tempChunk.dirty = true;
            tempChunk = GetChunk(new Vector3(x, y - 1, z));
            if (tempChunk != null)
                tempChunk.dirty = true;
            tempChunk = GetChunk(new Vector3(x, y, z + 1));
            if (tempChunk != null)
              
namespace VoxelWorld.Terrain
/**
 * World containing chunks of terrain.
 */
public class World : MonoBehaviour
	/** Dictionary of all the chunks in this world. */
	public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
	/** Universal prefab for the structure of a single chunk. */
	public GameObject chunkPrefab;
	/** The current terrain noise used. */
	public Noise noise;
	/** Terrain generator handling the creation of terrain. */
	public TerrainGen terrainGen;
	/** Name of this world. */
	public string worldName = "world";
	private void Awake()
	{
		Application.targetFrameRate = 60;
		Cursor.visible = false;
		new BlockList();
		noise = new Noise();
		terrainGen = new TerrainGen(noise);
	}
	private void OnApplicationQuit()
	{
		foreach(KeyValuePair<WorldPos, Chunk> chunk in chunks)
		{
			if(!chunk.Value.needsSaving){continue;}
			FileManager.SaveChunk(chunk.Value);
		}
	}
	/**
	 * Creates a new chunk at the given world position.
	 */
	public void CreateChunk(Wo

	{
		Chunk chunk = new Chunk();
		chunk.pos = pos;
		chunk.world = this;
		chunks.Add(pos, chunk);
		if(!FileManager.LoadChunk(chunk))
		{
			chunk = terrainGen.ChunkGen(chunk);
			MakePhysical(chunk);
			return;
		}
		chunk.empty = IsChunkEmpty(chunk);
		MakePhysical(chunk);
	}
	/**
	 * Create a chunk at the given coords.
	 */
	public void CreateChunk(int x, int y, int z)
	{
		CreateChunk(new WorldPos(x, y, z));
	}
	/**
	 * Create a new GameObject with a ChunkRenderer component
	 * and link it to the given chunk chunk.
	 * Returns false if the chunk is empty. In that case
	 * no visual chunk will be generated.
	 */
	bool MakePhysical(Chunk chunk)
	{
		if(!chunk.empty)
		{
			Vector3 newPos = new Vector3(chunk.pos.x, chunk.pos.y, chunk.pos.z);
			GameObject newRenderer = Instantiate(chunkPrefab, newPos, Quaternion.Euler(Vector3.zero)) as GameObject;
			ChunkRenderer renderer = newRenderer.GetComponent<ChunkRenderer>();
			renderer.chunk = chunk;
			chunk.renderer = renderer;
			newRen

			newRenderer.transform.parent = gameObject.transform;
			return true;
		}
		return false;
	}
	/**
	 * Get the chunk holding chunk at the given coords.
	 */
	public Chunk GetChunk(int x, int y, int z)
	{
		WorldPos pos = new WorldPos();
		float multiple = Chunk.chunkSize;
		pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
		pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
		pos.z = Mathf.FloorToInt(z / multiple) * Chunk.chunkSize;
		Chunk chunk = null;
		chunks.TryGetValue(pos, out chunk);
		return chunk;
	}
	/**
	 * Destroy the chunk at the given coords.
	 */
	public void DestroyChunk(int x, int y, int z)
	{
		Chunk chunk = null;
		if(chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
		{
			FileManager.SaveChunk(chunk);
			if(chunk.renderer != null)
			{
				Object.Destroy(chunk.renderer.gameObject);
			}
			chunks.Remove(new WorldPos(x, y, z));
		}
	}
	/**
	 * Get the block at the given coords. Returns BlockAir if null.
	 */
	public int GetBlock(int x, int y, 
namespace MusicalRepresentation
    public class Measure : MonoBehaviour
    {
        public Row redRow;
        public Row orangeRow;
        public Row yellowRow;
        public Row greenRow;
        public Row blueRow;
        public Row purpleRow;
        private List<Row> _rowList;
        private System.DateTime _start;
        private Score _score;
        private RectTransform _rectTransform;
        private bool _isReset = true;
        private void Awake()
        {
            _score = this.transform.GetComponentInParent<Score>();
            _rectTransform = (RectTransform) this.transform;
            _rowList = new List<Row>();
            foreach (var instrument in InstrumentHelper.GetInstrumentList())
            {
                var row = GetRowForInstrument(instrument);
                if (row != null)
                {
                    _rowList.Add(row);
                }
            }
        }
        void Start()
        {
            foreach (var instrument i

            {
                var row = GetRowForInstrument(instrument);
                row.Init(InstrumentHelper.GetColorForInstrument(instrument));
            }
        }
        public void Draw(float relativeTime)
        {
        
        }
    
        public Vector3 GetLocationForTime(float time)
        {
            var pos = this.transform.position;
            var xloc = Mathf.Lerp(_rectTransform.rect.xMin, _rectTransform.rect.xMax, time);
            pos.x += xloc;
            return pos;
        }
        public void ResetMeasure()
        {
            if (!_isReset)
            {
                _rowList.ForEach(x => x.Reset());
                _isReset = true;
            }
        }
        public bool IsMeasureCorrect()
        {
            return _rowList.TrueForAll(x => x.IsRowCorrect());
        }
        public void RecordHit(Instrument instrument, float relativeTime)
        {
            _isReset = false;
            GetRowForInstrument(instrument).RecordHi
public class World : MonoBehaviour
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public WorldPos PlayerPos;
    public GameObject Player;
    public GameObject chunkPrefab;
    const int YSTART = -1;
    const int YEND = 3;
    int newX = 0;
    int newY = 0;
    int newZ = 0;
    void Start()
    {
        Player = GameObject.Find("Player");
        PlayerPos = GetPlayerPos();
        for(int x = -(Chunk.chunkSize / 2); x < Chunk.chunkSize / 2; x++)
        {
            for(int z = -(Chunk.chunkSize / 2); z < Chunk.chunkSize / 2; z++)
            {
                for(int y = YSTART; y < YEND; y++)
                {
                    newX = (PlayerPos.x + x) * Chunk.chunkSize;
                    newY = (PlayerPos.y + y) * Chunk.chunkSize;
                    newZ = (PlayerPos.z + z) * Chunk.chunkSize;
                    CreateChunk(newX, newY, newZ);
                }
            }
        }
    }
    void Update()
    {
        WorldPos C

        if (CurrPos.z >= PlayerPos.z + (Chunk.chunkSize))
            MoveZPlus();
        if (CurrPos.x >= PlayerPos.x + (Chunk.chunkSize))
            MoveXPlus();
        if (CurrPos.x < PlayerPos.x - (Chunk.chunkSize))
            MoveXMinus();
    }
    void MoveZPlus()
    {
        PlayerPos = GetPlayerPos();
        for (int x = -(Chunk.chunkSize / 2); x < Chunk.chunkSize / 2; x++)
        {
            for (int y = YSTART; y < YEND; y++)
            {
                newX = PlayerPos.x + (x * Chunk.chunkSize);
                newY = y * Chunk.chunkSize;
                newZ = PlayerPos.z + Chunk.chunkSize * (Chunk.chunkSize / 2) - Chunk.chunkSize;
                CreateChunk(newX, newY, newZ);
                if (x == -(Chunk.chunkSize / 2))
                {
                    while (PlayerPos.x % Chunk.chunkSize != 0)
                        PlayerPos.x--;
                    while (PlayerPos.z % Chunk.chunkSize != 0)
                        PlayerPos.z++;
                

                    for (int d = x; d < Chunk.chunkSize / 2; d++)
                    {
                        DestroyChunk(
                            PlayerPos.x + (d * Chunk.chunkSize),
                            newY,
                            PlayerPos.z - Chunk.chunkSize * (Chunk.chunkSize / 2) - Chunk.chunkSize
                            );
                    }
                }
            }
        }
    }
    void MoveXPlus()
    {
        PlayerPos = GetPlayerPos();
        for (int z = -(Chunk.chunkSize / 2); z < Chunk.chunkSize / 2; z++)
        {
            for (int y = YSTART; y < YEND; y++)
            {
                newX = PlayerPos.x + Chunk.chunkSize * (Chunk.chunkSize / 2) - Chunk.chunkSize;
                newY = y * Chunk.chunkSize;
                newZ = PlayerPos.z + (z * Chunk.chunkSize);
                CreateChunk(newX, newY, newZ);
                if (z == -(Chunk.chunkSize / 2))
                {
                    while (PlayerPos.z % Chunk.ch
public class GameMenu : MonoBehaviour 
{ 
    void GetMenu ()
	{
		if(MenuControllerGenerator.controller.playWithAI)
		{
			ServerController.serverController.coins -= ServerController.serverController.prize;
			ServerController.serverController.coins = Mathf.Clamp(ServerController.serverController.coins, ServerController.serverController.minCoins, ServerController.serverController.maxCoins);
			Profile.SetUserDate(ServerController.serverController.myName + "_Coins", ServerController.serverController.coins);
			ServerController.serverController.otherCoins += ServerController.serverController.prize;
			ServerController.serverController.otherCoins = Mathf.Clamp(ServerController.serverController.otherCoins, ServerController.serverController.minCoins, ServerController.serverController.maxCoins);
			Profile.SetUserDate(ServerController.serverController.otherName + "_Coins", ServerController.serverController.otherCoins);
			MenuControllerGenerator.controller.playWithAI = false;
			MenuControl
namespace Intact.ParallelLib
    internal class ConstantInvokeSynchronisationContainer : SynchronisationContainer
    {
        private InvokePart invokePart_;
        public InvokePart InvokePart_
        {
            get { return invokePart_; }
            set { invokePart_ = value; }
        }
        #region public ForSynchronisationContainer()
        public ConstantInvokeSynchronisationContainer(ManualResetEvent manualResetEvent)
            : base(manualResetEvent)
        {            
        }
        public ConstantInvokeSynchronisationContainer(ManualResetEvent manualResetEvent, InvokePart invokePart_)
            : base(manualResetEvent)
        {
            this.invokePart_ = invokePart_;
        }
        #endregion
    }
    internal class ConstantInvokeSynchronisationContainer<T> : ConstantInvokeSynchronisationContainer
    {
        private InvokePart<T> invokePart_;
        public new InvokePart<T> InvokePart_
        {
            get { return invokePart_; }
     
namespace OldCode {
public class World : MonoBehaviour {
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public GameObject chunkPrefab;
	public bool IsLoadChunks = true;
    public string worldName = "world";
	public string SaveFileName = "";
	public int LightValueMin = 30;
	public LoadChunks ChunkLoader;
	public TerrainGen MyTerrainGen = new TerrainGen();
	public int DebugChunksLoadedCount = 0;
	public int DebugPolygonCount = 0;
	public bool IsLighting = true;
	void Start() {
		MyTerrainGen.Start ();
	}
    public void CreateChunk(int x, int y, int z) {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(x, y, z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
		newChunkObject.name = "Chunk: " + x/16f + ":" + y/16f + ":" + z/16f;
        newChun

        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
		bool HasLoadedChunk = false;
		if ((Network.isServer || (!Network.isServer && !Network.isClient)) && IsLoadChunks) 
			HasLoadedChunk = Serialization.Load(newChunk);
		if (!HasLoadedChunk) {
			newChunk = MyTerrainGen.ChunkGen(newChunk);
		}
		newChunk.transform.parent = gameObject.transform;
		newChunk.SetBlocksUnmodified();
		GetManager.GetZoneManager ().LoadZones (new Vector3 (x, y, z));
		DebugChunksLoadedCount++;
    }
    public void DestroyChunk(int x, int y, int z)
    {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
        {	
				SaveFileName = GetManager.GetGameManager().GameName;
			}
			DebugPolygonCount -= chunk.PolygonCount;
            Serialization.SaveChunk(chunk);
            Object.Destroy(chunk.gameObject);
			chunks.Remove(new WorldPos(x, y, z));
        }
		GetManager.GetZoneManager ().DestroyZonesInCubeNotCentred (new Vector3 (x, y, z), 
		   

		DebugChunksLoadedCount--;
    }
	public Chunk GetChunk(float x, float y, float z)
	{
		return GetChunk (Mathf.FloorToInt (x), Mathf.FloorToInt (y), Mathf.FloorToInt (z));
	}
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / multiple) * Chunk.chunkSize;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
	public Block GetBlock2(int x, int y, int z)
	{
		Chunk containerChunk = GetChunk(x, y, z);
		
		if (containerChunk != null)
		{
			Block block = containerChunk.GetBlock2(
				x - containerChunk.pos.x,
				y - containerChunk.pos.y,
				z - containerChunk.pos.z);
			
			return block;
		}
		else
		{
			return null;
		}
	}
	public BlockBase GetBlock(int x, int y, i
namespace Voxels
    public class WorldData
    {
        public string name = "default";
        public readonly Dictionary<WorldPos, ChunkData> chunks;
        public WorldData()
        {
            chunks = new Dictionary<WorldPos, ChunkData>();
        }
        public WorldPos GetChunkPos(int x, int y, int z)
        {
            var px = Mathf.FloorToInt(x / MapConstants.ChunkSizeFloat) * MapConstants.ChunkSize;
            var py = Mathf.FloorToInt(y / MapConstants.ChunkSizeFloat) * MapConstants.ChunkSize;
            var pz = Mathf.FloorToInt(z / MapConstants.ChunkSizeFloat) * MapConstants.ChunkSize;
            return new WorldPos(px, py, pz);
        }
        public ChunkData GetChunkData(int x, int y, int z)
        {
            var pos = GetChunkPos(x, y, z);
            ChunkData chunk;
            chunks.TryGetValue(pos, out chunk);
            return chunk;
        }
        public ChunkData CreateChunk(int x, int y, int z)
        {
            WorldPos pos = GetCh

            var chunk = new ChunkData(pos);
            chunks.Add(pos, chunk);
            return chunk;
        }
        public void DestroyChunk(int x, int y, int z)
        {
            var pos = GetChunkPos(x, y, z);
            ChunkData chunk;
            if (chunks.TryGetValue(pos, out chunk))
            {
                chunks.Remove(pos);
            }
        }
        public BlockId GetBlock(int x, int y, int z)
        {
            var chunk = GetChunkData(x, y, z);
            if (chunk == null)
            {
                return BlockId.Air;
            }
            return chunk.GetBlock(x - chunk.pos.x, y - chunk.pos.y, z - chunk.pos.z);
        }
        public void SetBlock(int x, int y, int z, BlockId blockId)
        {
            var chunk = GetChunkData(x, y, z);
            if (chunk == null)
            {
                chunk = CreateChunk(x, y, z);
            }
            chunk.SetBlock(x - chunk.pos.x, y - chunk.pos.y, z - chunk.pos.z, blockId);
  
namespace BRE.Lib.TermStructures
    public class ResultingInstrument : IEquatable<ResultingInstrument>
    {
        #region Members
        public string ResultingInstrumentNameTT;
        public string ResultingInstrumentNameDataBase;
        public bool IsRealInstrumentOnMarket;
        public InstrumentName ResultingInstrumentName;
        #region Constructors
        public ResultingInstrument()
        {
        }
        #region Properties
        public bool IsEmpty
        {
            get
            {
                return string.IsNullOrEmpty(ResultingInstrumentNameDataBase) || string.IsNullOrEmpty(ResultingInstrumentNameTT);
            }
        }
        #region no Public Methods
        #region no Private Methods
        #region no Event Handlers
        #region Public Override Methods
        public override string ToString()
        {
            return ResultingInstrumentNameTT;
        public override bool Equals(object obj)
        {
            if (obj is Resul

            {
                ResultingInstrument other = (ResultingInstrument)obj;
                return this.Equals(other);
            }
            else
                return false;
        }
        public bool Equals(ResultingInstrument other)
        {
            bool isEqual = this.ResultingInstrumentNameTT.Equals(other.ResultingInstrumentNameTT) &&
                    this.ResultingInstrumentNameDataBase.Equals(other.ResultingInstrumentNameDataBase) &&
                    this.ResultingInstrumentName.Equals(other.ResultingInstrumentName);
            return isEqual;
        }
        public static bool operator ==(ResultingInstrument a, ResultingInstrument b)
        {
            if ((object)a == null)
                return false;
            return a.Equals(b);
        }
        public static bool operator !=(ResultingInstrument a, ResultingInstrument b)
        {
            return !(a == b);
        }
        public override int GetHashCode()
        {
            ret
namespace MvvM_Appie.Model.DataService.DummyServiceLocator
    public class DummyStoreDataService : IStoreDataService
    {
        private readonly IGenericRepository<Afdeling> _afdelingRepository;
        private readonly IGenericRepository<Coupon> _couponRepository;
        private readonly IGenericRepository<Merk> _merkRepository;
        private readonly IGenericRepository<MerkProduct> _merkProductRepository;
        private readonly IGenericRepository<Product> _productRepository;
        private readonly IGenericRepository<Recept> _receptRepository;
        private readonly IGenericRepository<ReceptMerkProduct> _receptMerkProductRepository;
        public DummyStoreDataService(
            IGenericRepository<Afdeling> afdelingRepository, IGenericRepository<Coupon> couponRepository, IGenericRepository<Merk> merkRepository,
            IGenericRepository<MerkProduct> merkProductRepository, IGenericRepository<Product> productRepository,
            IGenericRepository<Recept> receptR

        {
            _afdelingRepository = afdelingRepository;
            _couponRepository = couponRepository;
            _merkRepository = merkRepository;
            _merkProductRepository = merkProductRepository;
            _productRepository = productRepository;
            _receptRepository = receptRepository;
            _receptMerkProductRepository = receptMerkProductRepository;
        }
        public IGenericRepository<Afdeling> AfdelingRepository
        {
            get
            {
                return _afdelingRepository;
            }
        }
        public IGenericRepository<Coupon> CouponRepository
        {
            get
            {
                return _couponRepository;
            }
        }
        public IGenericRepository<Merk> MerkRepository
        {
            get
            {
                return _merkRepository;
            }
        }
        public IGenericRepository<MerkProduct> MerkProductRepository
        {
            get
     
namespace APITests
    class MarketFactory
    {
        private static Btc38API btc38API;
        public static Btc38API Btc38API
        {
            get
            {
                if (btc38API == null)
                {
                    var lines = File.ReadAllLines("C:\\btc38.txt");
                    btc38API = new Btc38API(lines[0], lines[1], lines[2]);
                }
                return btc38API;
            }
        }
        private static BittrexAPI bittrexAPI;
        public static BittrexAPI BittrexAPI
        {
            get
            {
                if (bittrexAPI == null)
                {
                    var lines = File.ReadAllLines("C:\\bittrex.txt");
                    bittrexAPI = new BittrexAPI(lines[0], lines[1]);
                }
                return bittrexAPI;
            }
        }
        private static PoloniexAPI poloniexAPI;
        public static PoloniexAPI PoloniexAPI
        {
            get
            {
                i

                {
                    var lines = File.ReadAllLines("C:\\poloniex.txt");
                    poloniexAPI = new PoloniexAPI(lines[0], lines[1]);
                }
                return poloniexAPI;
            }
        }
        private static JubiAPI jubiAPI;
        public static JubiAPI JubiAPI
        {
            get
            {
                if (jubiAPI == null)
                {
                    var lines = File.ReadAllLines("C:\\jubi.txt");
                    jubiAPI = new JubiAPI(lines[0], lines[1]);
                }
                return jubiAPI;
            }
        }
        private static BterAPI bterAPI;
        public static BterAPI BterAPI
        {
            get
            {
                if (bterAPI == null)
                {
                    var lines = File.ReadAllLines("C:\\bter.txt");
                    bterAPI = new BterAPI(lines[0], lines[1]);
                }
                return bterAPI;
            }
        }
       
namespace EQueue.Broker.Storage
    public class ChunkWriter
    {
        public Chunk CurrentChunk { get { return _currentChunk; } }
        private readonly ChunkManager _chunkManager;
        private readonly IScheduleService _scheduleService;
        private readonly object _lockObj = new object();
        private bool _isClosed = false;
        private Chunk _currentChunk;
        public ChunkWriter(ChunkManager chunkManager)
        {
            Ensure.NotNull(chunkManager, "chunkManager");
            _chunkManager = chunkManager;
            _scheduleService = ObjectContainer.Resolve<IScheduleService>();
        }
        public void Open()
        {
            _currentChunk = _chunkManager.GetLastChunk();
            if (!_chunkManager.Config.SyncFlush)
            {
                _scheduleService.StartTask("FlushChunk", Flush, 1000, _chunkManager.Config.FlushChunkIntervalMilliseconds);
            }
            _isClosed = false;
        }
        public long Write(ILogR

        {
            lock (_lockObj)
            {
                if (_isClosed)
                {
                    throw new ChunkWriteException(_currentChunk.ToString(), "Chunk writer is closed.");
                }
                if (_currentChunk.IsCompleted)
                {
                    _currentChunk = _chunkManager.AddNewChunk();
                }
                var result = _currentChunk.TryAppend(record);
                if (!result.Success)
                {
                    _currentChunk.Complete();
                    _currentChunk = _chunkManager.AddNewChunk();
                    result = _currentChunk.TryAppend(record);
                    if (!result.Success)
                    {
                        throw new ChunkWriteException(_currentChunk.ToString(), "Write record to chunk failed.");
                    }
                }
                if (_chunkManager.Config.SyncFlush)
                {
                    _currentChunk.Flush();
        
namespace VoxelWars.Universe
	public partial class World
	{
		private readonly Dictionary<Position, Chunk> chunks = new Dictionary<Position, Chunk>();
		private readonly Noise noise = new Noise(new Random());
		public Chunk this[Position position]
		{
			get
			{ 
				Chunk chunk;
				if (chunks.TryGetValue(position, out chunk)) return chunk;
				chunk = new Chunk(position, noise);
				chunks.Add(position, chunk);
				foreach (Side side in SideExtensions.Sides)
				{
					Chunk sideChunk;
					SByte2 offset = side.Vector();
					if (chunks.TryGetValue(new Position(position.X + offset.X, position.Y + offset.Y), out sideChunk))
					{
						sideChunk.neighbours[(byte)side.Opposite()] = chunk;
						chunk.neighbours[(byte)side] = sideChunk;
						sideChunk.changed = true;
						chunk.changed = true;
					}
				}
				return chunk;
			}
		}
		public BlockData GetBlock(Position position)
		{
			return this[position / Chunk.ChunkSize].CurrentAccessor[AbsMod(position.X, Chunk.ChunkSize), AbsMo
namespace OceanChip.Common.Storage
    public class ChunkManagerConfig
    {
        public readonly string BasePath;
        public readonly IFileNamingStrategy FileNamingStrategy;
        public readonly int ChunkDataSize;
        public readonly int ChunkDataUnitSize;
        public readonly int ChunkDataCount;
        public readonly int FlushChunkIntervalMilliseconds;
        public readonly bool SyncFlush;
        public FlushOption FlushOption;
        public readonly bool EnableCache;
        public readonly int ChunkReaderCount;
        public readonly int MaxLogRecordSize;
        public readonly int ChunkWriteBuffer;
        public readonly int ChunkReadBuffer;
        public readonly int ChunkCacheMaxPercent;
        public readonly int ChunkCacheMinPercent;
        public readonly int PreCacheChunkCount;
        public readonly int ChunkInactiveTimeMaxSeconds;
        public readonly int ChunkLocalCacheSize;
        public readonly bool EnableChunkStatistic;
        public

                               IFileNamingStrategy fileNamingStrategy,
                               int chunkDataSize,
                               int chunkDataUnitSize,
                               int chunkDataCount,
                               int flushChunkIntervalMilliseconds,
                               bool enableCache,
                               bool syncFlush,
                               FlushOption flushOption,
                               int chunkReaderCount,
                               int maxLogRecordSize,
                               int chunkWriteBuffer,
                               int chunkReadBuffer,
                               int chunkCacheMaxPercent,
                               int chunkCacheMinPercent,
                               int preCacheChunkCount,
                               int chunkInactiveTimeMaxSeconds,
                               int chunkLocalCacheSize,
                               bool enableChunkStatist

        {
            Check.NotNullOrEmpty(basePath, "basePath");
            Check.NotNull(fileNamingStrategy, "fileNamingStrategy");
            Check.Nonnegative(chunkDataSize, "chunkDataSize");
            Check.Nonnegative(chunkDataUnitSize, "chunkDataUnitSize");
            Check.Nonnegative(chunkDataCount, "chunkDataCount");
            Check.Positive(flushChunkIntervalMilliseconds, "flushChunkIntervalMilliseconds");
            Check.Positive(maxLogRecordSize, "maxLogRecordSize");
            Check.Positive(chunkWriteBuffer, "chunkWriteBuffer");
            Check.Positive(chunkReadBuffer, "chunkReadBuffer");
            Check.Positive(chunkCacheMaxPercent, "chunkCacheMaxPercent");
            Check.Positive(chunkCacheMinPercent, "chunkCacheMinPercent");
            Check.Nonnegative(preCacheChunkCount, "preCacheChunkCount");
            Check.Nonnegative(chunkInactiveTimeMaxSeconds, "chunkInactiveTimeMaxSeconds");
            Check.Positive(chunkLocalCacheSize, "chunkLocalCach
namespace Elabcare.BloodComponentManage.UI.MainForm
    public partial class fmInstrumentManage : XtraForm, IUCInstrumentControl
    {
        #region 变量
        UCInstrumentInfo _UCInstrumentInfo = null;
        InstrumentManageBiz _biz;
        #endregion
        public fmInstrumentManage()
        {
            InitializeComponent();
            Init();
        }
        #region 初始化
        void Init()
        {
            _biz = new InstrumentManageBiz();
            #region 事件初始化
            this.InstrumentList.EditValueChanged += new EventHandler(InstrumentList_EditValueChanged);
            #endregion
            DataTable dt = _biz.GetInstrumentList();
            this.InstrumentList.Properties.DataSource = dt;
            this.InstrumentList.Properties.ValueMember = "Code";
            this.InstrumentList.Properties.DisplayMember = "Name";
            this.InstrumentList.Properties.NullText = "请选择...";
            this.InstrumentList.EditValue = "离心机";
        }
        #endr

        #region 事件
        private void sbtn_Search_Click(object sender, EventArgs e)
        {
            if (this.InstrumentList.EditValue == null)
            {
                XtraMessageBox.Show("请选择仪器");
            }
            else
            {
                _SelectedInstrument = this.InstrumentList.Text.ToString();
                CreateSampleReceiveUC();
            }
        }
        private void InstrumentList_EditValueChanged(object sender, EventArgs e)
        {
            string code = this.InstrumentList.EditValue.ToString();
            DataTable dt = _biz.GetInstrumentItemList(code);
            this.InstrumentItemList.Properties.Items.Clear();
            
            this.InstrumentItemList.Properties.DataSource = dt;
            this.InstrumentItemList.Properties.DisplayMember = "Name";
            this.InstrumentItemList.Properties.ValueMember = "Code";
            this.InstrumentItemList.Properties.NullText = "请选择...";
        }
        #endregion
       

        private void CreateSampleReceiveUC()
        {
            List<InstrumentObj> list = null;
            list = CreateTaskList();
            this.splitContainerControl1.Panel2.Controls.Clear();
            _UCInstrumentInfo = new UCInstrumentInfo(list, _SelectedInstrument, true);
            _UCInstrumentInfo.Dock = DockStyle.Fill;
            this.splitContainerControl1.Panel2.Controls.Add(_UCInstrumentInfo);
        }
        private List<InstrumentObj> CreateTaskList()
        {
            InstrumentObj obj;
            List<InstrumentObj> list = new List<InstrumentObj>();
            list = new List<InstrumentObj>();
            if (this.InstrumentItemList.EditValue != null)
            {
                string[] strArr = this.InstrumentItemList.Text.ToString().Split(',');
                for (int m = 0; m < strArr.Length; m++)
                {
                    obj = new InstrumentObj();
                    obj.Caption = _SelectedInstrument+":"+strArr[m];
            
namespace Assets.Scripts.Model.Tiles
    class TileMap
    {
        private const int ChunkSize = 1000;
        private TileChunkCache chunkCache = new TileChunkCache();
        public float Resolution { get; private set; }
        public TileMap()
        {
            Resolution = 1f;
        }
        public void LoadChunk(Coordinate position, int width, int height, Tile[] targetTiles)
        {
            var chunkId = GetChunkId(position);
            var chunk = chunkCache.LoadTileChunk(chunkId);
            var chunkX = chunk.Position.X;
            var chunkY = chunk.Position.Y;
            for (var y = 0; y < height; ++y)
            {
                for (var x = 0; x < width; ++x)
                {
                    var newChunkId = GetChunkId(new Coordinate(position.X + x, position.Y + y));
                    if (chunkId != newChunkId)
                    {
                        chunk = chunkCache.LoadTileChunk(chunkId);
                        chunkId = newChunkId;

namespace d60.Modules.Shared.ServerJob.Srv.Wrappers
    class InvokeCallbackWrapper : IWrapper
    {
        private IInvokeCallback _callback;
        public InvokeCallbackWrapper(IInvokeCallback callback)
        {
            _callback = callback;
        }
        public void Invoke(IMessageHandlerPublishBus bus)
        {
            _callback.ServerInvokeCallback(bus);
        }
    }
    class InvokeCallbackWrapper<T> : IWrapper
    {
        private IInvokeCallback<T> _callback;
        private T _arg;
        public InvokeCallbackWrapper(IInvokeCallback<T> callback, T arg)
        {
            _callback = callback;
            _arg = arg;
        }
        public void Invoke(IMessageHandlerPublishBus bus)
        {
            _callback.ServerInvokeCallback(bus, _arg);
        }
    }
    class InvokeCallbackWrapper<T1, T2> : IWrapper
    {
        private IInvokeCallback<T1, T2> _callback;
        private T1 _arg1;
        private T2 _arg2;
        public InvokeCallbackWrapp
namespace BusinessLogic
    public class DataManager
    {
        private IUsersRepository usersRepository;
        private IFriendsRepository friendsRepository;
        private IFriendRequestsRepository friendRequestsRepository;
        private IMessagesRepository messagesRepository;
        private IPicturesRepository picturesRepository;
        private PrimaryMembershipProvider provider;
        public DataManager(IUsersRepository usersRepository, IFriendsRepository friendsRepository, IFriendRequestsRepository friendRequestsRepository, IMessagesRepository messagesRepository, IPicturesRepository picturesRepository, PrimaryMembershipProvider provider)
        {
            this.usersRepository = usersRepository;
            this.friendsRepository = friendsRepository;
            this.friendRequestsRepository = friendRequestsRepository;
            this.messagesRepository = messagesRepository;
            this.picturesRepository = picturesRepository;
            this.provider = provid
namespace DL
    public class UnitOfWork
    {
        private RespuestaRepository _respuestaRepository;
        private PreguntaRepository _preguntaRepository;
        private IRepository<Candidato> _candidatoRepository;
        private SolicitudPruebaRepository _solicitudPruebaRepository;
        private PruebaRepository _pruebaRepository;
        private IRepository<Usuario> _usuarioRepository;
        private IRepository<Tecnologia> _tecnologiaRepository;
        private IRepository<Llamada> _llamadaRepository;
        private IRepository<Empleado> _empleadoRepository;
        private IRepository<Proyecto> _proyectoRepository;
        private IRepository<Cliente> _clienteRepository;
        private IRepository<ListasDesplegables> _listasRepository;
        private DatosRepository _datosRepository;
        private Bitacora _bitacora;
        private TecnologiasPorProyectoRepository _tecnologiaPorProyectoRepository;
        private EmpresaRepository _empresa;
        private Tecnolog

        private BitacoraExcepciones _excepciones;
        private PruebaPorCandidatoRepository _pruebaPorCandidatoRepository;
        private ContratarCandidatoRepository _contratarCandidatoRepository;
        private CVRepository _cvRepository;
        private PreguntasPorPruebaRepository _preguntaPorPruebaRepository;
        
        public SolicitudPruebaRepository SolicitudPruebaRepository
        {
            get
            {
                if (this._solicitudPruebaRepository == null)
                {
                    this._solicitudPruebaRepository = new SolicitudPruebaRepository();
                }
                return _solicitudPruebaRepository;
            }
        }
        public PruebaPorCandidatoRepository PruebaPorCandidatoRepository
        {
            get
            {
                if (this._pruebaPorCandidatoRepository == null)
                {
                    this._pruebaPorCandidatoRepository = new PruebaPorCandidatoRepository();
               

                return _pruebaPorCandidatoRepository;
            }
        }
        public PruebaRepository PruebaRepository
        {
            get
            {
                if (this._pruebaRepository == null)
                {
                    this._pruebaRepository = new PruebaRepository();
                }
                return _pruebaRepository;
            }
        }
        public IRepository<Candidato> CandidatoRepository
        {
            get
            {
                if (this._candidatoRepository == null)
                {
                    this._candidatoRepository = new CandidatoRepository();
                }
                return _candidatoRepository;
            }
        }
        public IRepository<Usuario> UsuarioRepository
        {
            get
            {
                if (this._usuarioRepository == null)
                {
                    this._usuarioRepository = new UsuarioRepository();
                }
                return
namespace GameRoom.GameService.Data
    public interface IGameServiceDataRepositoryFactory
    {
        GameServiceDataRepository Build();
    }
    public class GameServiceDataRepository
    {
        private readonly IPlayerRepository _PlayerRepository;
        private readonly IGameResultRepository _GameResultRepository;
        private readonly IPlayerStatusRepository _PlayerStatusRepository;
        private readonly IGameTypeRepository _GameTypeRepository;
        private readonly IPlayerStateRepository _PlayerStateRepository;
        public GameServiceDataRepository(
            IPlayerRepository playerRepository,
            IGameResultRepository gameResultRepository,
            IPlayerStatusRepository playerStatusRepository,
            IGameTypeRepository gameTypeRepository,
            IPlayerStateRepository playerStateRepository)
        {
            if (ReferenceEquals(playerRepository, null)) throw new ArgumentNullException("playerRepository");
            if (Reference

            if (ReferenceEquals(playerStatusRepository, null)) throw new ArgumentNullException("playerStatusRepository");
            if (ReferenceEquals(gameTypeRepository, null)) throw new ArgumentNullException("gameTypeRepository");
            if (ReferenceEquals(playerStateRepository, null)) throw new ArgumentNullException("playerStateRepository");
            _PlayerRepository = playerRepository;
            _GameResultRepository = gameResultRepository;
            _PlayerStatusRepository = playerStatusRepository;
            _GameTypeRepository = gameTypeRepository;
            _PlayerStateRepository = playerStateRepository;
        }
        public IPlayerRepository PlayerRepository
        {
            get { return _PlayerRepository; }
        }
        public IGameResultRepository GameResultRepository
        {
            get { return _GameResultRepository; }
        }
        public IPlayerStatusRepository PlayerStatusRepository
        {
            get { return _PlayerS
public partial class admin_editDispatchMediaType : AxiomPage
    protected void Page_Load(object sender, EventArgs e)
    {
        if (!IsPostBack)
        {
            int dispatchMediaTypeID = int.Parse(Request.QueryString["DMTID"].ToString());
            DispatchMediaType dispatchMediaType = new DispatchMediaType(dispatchMediaTypeID);
            dispatchMediaTypeTextBox.Text = dispatchMediaType.mediaTypeName;
            SetFocus(dispatchMediaTypeTextBox.ClientID);
        }
    }
    protected void deleteButton_Click(object sender, EventArgs e)
    {
        int dispatchMediaTypeID = int.Parse(Request.QueryString["DMTID"].ToString());
        string dispatchMediaTypeText = dispatchMediaTypeTextBox.Text;
        DispatchMediaType dispatchMediaType = new DispatchMediaType(dispatchMediaTypeID);
        dispatchMediaType.mediaTypeName = dispatchMediaTypeText;
        dispatchMediaType.Delete();
        Response.Redirect("dispatchMediaTypesList.aspx");
    }
    protected void backB
namespace Assets.Scripts.world {
    public class ChunkCache : IBlockAccess {
        private int chunkX;
        private int chunkZ;
        private Chunk[,] chunkArray;
        private World world;
        private bool empty;
        private bool visible = false;
        public ChunkCache(World world, int posX, int posY, int posZ, int posXPlus, int posYPlus, int posZPlus, int plus) {
		    this.world = world;
		    this.chunkX = posX - plus >> 4;
            this.chunkZ = posZ - plus >> 4;
            int var1 = posXPlus + plus >> 4;
            int var2 = posZPlus + plus >> 4;
            this.chunkArray = new Chunk[var1 - this.chunkX + 1, var2 - this.chunkZ + 1];
            this.empty = true;
            int chunkX;
            int chunkZ;
            Chunk chunk;
        
            for(chunkX = this.chunkX; chunkX <= var1; ++chunkX) {
        	    for(chunkZ = this.chunkZ; chunkZ <= var2; ++chunkZ) {
        		    chunk = this.world.getChunkFromChunkCoords(chunkX, chunkZ);
    

        			    this.chunkArray[chunkX - this.chunkX, chunkZ - this.chunkZ] = chunk;
        		    }
        	    }
            }
        
            for(chunkX = posX >> 4; chunkX <= posXPlus >> 4; ++chunkX) {
        	    for(chunkZ = posZ >> 4; chunkZ <= posZPlus >> 4; ++chunkZ) {
        		    chunk = this.chunkArray[chunkX - this.chunkX, chunkZ - this.chunkZ];
        		    if(chunk != null && !chunk.getAreLevelsEmpty(posY, posYPlus)) {
                        this.empty = false;
        		    }
        	    }
            }
            chunkX = (posX + 1) >> 4;
            chunkZ = (posZ + 1) >> 4;
            for (int testChunkX = 0; testChunkX <= 2; ++testChunkX) {
                for (int testChunkZ = 0; testChunkZ <= 2; ++testChunkZ) {
                    int var3 = chunkX + (testChunkX - 1);
                    int var4 = chunkZ + (testChunkZ - 1);
                    if (var3 == 0 && var4 == 0) {
                        int testChunkY = (posY + 1) - 16;
                    

                        if (chunk.getAreLevelsFilled(testChunkY, posYPlus - 1)) {
                            this.visible = true;
                        }
                        testChunkY = (posY + 1) + 16;
                        chunk = this.world.getChunkFromChunkCoords(var3, var4);
                        if (chunk.getAreLevelsFilled(posY + 1, testChunkY)) {
                            this.visible = true;
                        }
                    } else {
                        chunk = this.world.getChunkFromChunkCoords(var3, var4);
                        if (!chunk.getAreLevelsFilled(posY + 1, posYPlus - 1)) {
                            this.visible = true;
                        }
                    }
                }
            }
	    }
        public int getBlockID(int x, int y, int z) {
            if (y < 0) {
                return 0;
            } else if (y >= 256) {
                return 0;
            } else {
                int var4 = (x >> 4) - this.
#if NET461
#endif
namespace NetFusion.Messaging
#if NET461
    [Serializable]
#endif
    public class MessageDispatchException : NetFusionException
    {
        public MessageDispatchException() { }
        public MessageDispatchException(string message): 
            base(message) { }
        public MessageDispatchException(string message, Exception innerException) :
            base(message, innerException) { }
        public MessageDispatchException(string message, MessageDispatchInfo dispatchInfo, Exception innerException)
            : base(message, innerException)
        {
            Check.NotNull(dispatchInfo, nameof(dispatchInfo));
            Details["DispatchInfo"] = new
            {
                MessageType = dispatchInfo.MessageType.FullName,
                ConsumerType = dispatchInfo.ConsumerType.FullName,
                HandlerMethod = dispatchInfo.MessageHandlerMethod.Name
            };
        }
        public MessageDispatchException(string errorMessage, IEnu
namespace Admin.BLL.Product_BLL
   public class DispatchOrder_BLL
   {
       private static readonly IDispatchOrder factory = Admin.DALFactory.DataAccess.selectDispatchOrder();
       public static IList<DispatchOrder_MDL> selectDispatchOrder(int id, string status, string colname, string coltext, string indexs)
       {
           return factory.selectDispatchOrder(id, status, colname, coltext, indexs);
       }
       public static IList<DispatchOrder_MDL> selectDispatchOrder(int id, string status, string colname, string coltext,string Machine_Code, string indexs)
       {
           return factory.selectDispatchOrder(id, status, colname, coltext,Machine_Code, indexs);
       }
       public static DataSet selectDispatchOrderDateSet(int id, string status, string colname, string coltext, string Machine_Code, string indexs)
       {
           return factory.selectDispatchOrderDateSet(id, status, colname, coltext, Machine_Code, indexs);
       }
       public static IList<DispatchOrder

       {
           return factory.selectDispatchOrder(id, status, colname, coltext);
       }
       public static IList<DispatchOrder_MDL> selectDispatchOrder(int id,  string colname, string coltext)
       {
           return factory.selectDispatchOrder(id,  colname, coltext);
       }
       public static IList<DispatchOrder_MDL> selectDispatchOrderDetail(int id, string colname, string coltext)
       {
           return factory.selectDispatchOrderDetail(id, colname, coltext);
       }
       
       public static IList<DispatchOrder_MDL> selectDispatchOrder(string status)
       {
           return factory.selectDispatchOrder(status);
       }
       public static IList<DispatchOrder_MDL> selectDispatchOrder(string CheckStatus, string DispatchStatus)
       {
           return factory.selectDispatchOrder(CheckStatus,DispatchStatus);
       }
       public static IList<DispatchOrder_MDL> selectDispatchOrder(string MachineNo, int isBoo)
       {
           return factory.selectDisp

       }
       public static IList<DispatchOrder_MDL> existsDispatchOrder(string vDO_No)
       {
           return factory.existsDispatchOrder(vDO_No);
       }
       public static IList<DispatchOrder_MDL> existsDispatchOrder(string vDO_No,string vcolname)
       {
           return factory.existsDispatchOrder(vDO_No, vcolname);
       }
       public static IList<DispatchOrder_MDL> existsDispatchOrder(string vDO_No, string vcolname, string status)
       {
           return factory.existsDispatchOrder(vDO_No, vcolname, status);
       }
       public static IList<DispatchOrder_MDL> QueryWorkOrder()
       {
           return factory.QueryWorkOrder();
       }
       public static void ChangeDispatchOrder(int vID,
            string vDO_No, string vWorkOrderNo, string vMachineNo, string vMouldNo, string vProductNo,string vProductDesc,
            string vStartDate, string vStopDate, string vActualStartDate,
             string vActualStopDate, string vBadQty, string vDispatchDate, 
namespace Assets.Core
    public class Plane : MonoBehaviour
    {
        public static int PLANE_SIZE = 4;
        
        public static int PLANE_WIDTH = 64;
        public static int PLANE_HEIGHT = 4;
        public static int PLANE_DEPTH = 64;
        public static int XMIN = -(PLANE_WIDTH / 2);
        public static int YMIN = -(PLANE_HEIGHT / 2);
        public static int YMAX = (PLANE_HEIGHT / 2) - 1;
        public static int ZMIN = -(PLANE_DEPTH / 2);
        public static int ZMAX = (PLANE_DEPTH / 2) - 1;
    
        public string planeName = "Plane 0";
        public Dictionary<ChunkPos, Chunk> chunks = new Dictionary<ChunkPos, Chunk>();
        public GameObject chunkPreFab;
        public Plane() {}
        public void SetTile(int x, int y, int z, Tile tile) 
        {
            ChunkPos chunkPos = new TilePos(x, y, z).GetChunkPos();
            if (InXRange(chunkPos.x) && InYRange(chunkPos.y) && InZRange(chunkPos.z)) {
                Chunk chunk = GetChunk(chunkPos.

                if (chunk == null) 
                    return;
                chunk.SetTile(x, y, z, tile);
                if (x - chunkPos.GetTilePos().x == 0) {
                    Chunk neighbour = GetChunk(chunkPos.x - 1, chunkPos.y, chunkPos.z);
                    if (neighbour != null) neighbour.toUpdate = true;
                }
                if (x - chunkPos.GetTilePos().x == Chunk.CHUNK_WIDTH - 1) {
                    Chunk neighbour = GetChunk(chunkPos.x + 1, chunkPos.y, chunkPos.z);
                    if (neighbour != null) neighbour.toUpdate = true;
                }
                if (y - chunkPos.GetTilePos().y == 0) {
                    Chunk neighbour = GetChunk(chunkPos.x, chunkPos.y - 1, chunkPos.z);
                    if (neighbour != null) neighbour.toUpdate = true;
                }
                if (y - chunkPos.GetTilePos().y == Chunk.CHUNK_HEIGHT - 1) {
                    Chunk neighbour = GetChunk(chunkPos.x, chunkPos.y + 1, chunkPos.z);
        

                }
                if (z - chunkPos.GetTilePos().z == 0) {
                    Chunk neighbour = GetChunk(chunkPos.x, chunkPos.y, chunkPos.z - 1);
                    if (neighbour != null) neighbour.toUpdate = true;
                }
                if (z - chunkPos.GetTilePos().z == Chunk.CHUNK_DEPTH - 1) {
                    Chunk neighbour = GetChunk(chunkPos.x, chunkPos.y, chunkPos.z + 1);
                    if (neighbour != null) neighbour.toUpdate = true;
                }
            }
        }
        public Tile GetTile(int x, int y, int z) 
        {
            ChunkPos chunkPos = new TilePos(x, y, z).GetChunkPos();
            if (InXRange(chunkPos.x) && InYRange(chunkPos.y) && InZRange(chunkPos.z)) {
                Chunk chunk = GetChunk(chunkPos.x, chunkPos.y, chunkPos.z);
                if (chunk == null) 
                    return new AirTile(0, 0, 0);
                return chunk.GetTile(x, y, z);
            } else {
                return new A
public class DungeonBuilder : MonoBehaviour
    public List<Material> blocks = new List<Material>();
    public List<GameObject> items = new List<GameObject>();
    public List<Rule> rules = new List<Rule>();
    public int selected = 0;
    public bool autoRemesh = true;
    public bool shiftToDelete = true;
    private void Awake()
    {
        Destroy(this);
    }
    public void Clear()
    {
        for (int i = transform.childCount - 1; i >= 0; i--)
            DestroyImmediate(transform.GetChild(i).gameObject);
    }
    private Chunk GetChunk(Transform r, int chunkX, int chunkY, int chunkZ, int type, bool create)
    {
        if (r == null)
            return null;
        Chunk c;
        int childCount = r.childCount;
        for (int i = 0; i < childCount; i++)
        {
            c = r.GetChild(i).GetComponent<Chunk>();
            if (c == null)
                continue;
            if (c.chunkX == chunkX && c.chunkY == chunkY && c.chunkZ == chunkZ)
                ret

        }
        if (!create)
            return null;
        GameObject go = new GameObject();
        go.name = string.Format("Chunk [{0}, {1}, {2}]", chunkX, chunkY, chunkZ);
        go.isStatic = true;
        go.transform.SetParent(r, true);
        go.transform.localPosition = new Vector3(chunkX, chunkY, chunkZ) * Chunk.CHUNK_SIZE;
        Mesh mesh = new Mesh();
        mesh.name = string.Format("ChunkMesh [{0}, {1}, {2}; {3}]", chunkX, chunkY, chunkZ, type);
        go.AddComponent<MeshFilter>().sharedMesh = mesh;
        MeshRenderer meshRen = go.AddComponent<MeshRenderer>();
        meshRen.material = blocks[type] as Material;
        EditorUtility.SetSelectedRenderState(meshRen, EditorSelectedRenderState.Hidden);
        go.AddComponent<MeshCollider>().sharedMesh = mesh;
        c = go.AddComponent<Chunk>();
        c.chunkX = chunkX;
        c.chunkY = chunkY;
        c.chunkZ = chunkZ;
        c.dungeon = this;
        return c;
    }
    private Transform GetRegion(Tra

    {
        if (g == null)
            return null;
        
        chunkX /= 4;
        chunkY /= 4;
        chunkZ /= 4;
        BlockTypeGroup r;
        int childCount = g.childCount;
        for (int i = 0; i < childCount; i++)
        {
            r = g.GetChild(i).GetComponent<BlockTypeGroup>();
            if (r == null)
                continue;
            if (r.chunkX == chunkX && r.chunkY == chunkY && r.chunkZ == chunkZ)
                return r.transform;
        }
        if (!create)
            return null;
        GameObject go = new GameObject();
        go.name = string.Format("Region [{0}, {1}, {2}]", chunkX, chunkY, chunkZ);
        go.isStatic = true;
        go.transform.SetParent(g, true);
        r = go.AddComponent<BlockTypeGroup>();
        r.chunkX = chunkX;
        r.chunkY = chunkY;
        r.chunkZ = chunkZ;
        return go.transform;
    }
    private Transform GetGroup(int type, bool create)
    {
        Material material = blocks[type] as Mater
namespace CrazyIIS
    class IIS
    {
        public static void Stop()
        {
            Process cmdProcess = new Process();
            cmdProcess.StartInfo.FileName = "iisreset";
            cmdProcess.StartInfo.Arguments = " /stop";
            cmdProcess.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            cmdProcess.Start();
            cmdProcess.WaitForExit();
            cmdProcess.Close();
        }
        public static void Start()
        {
            Process cmdProcess = new Process();
            cmdProcess.StartInfo.FileName = "iisreset";
            cmdProcess.StartInfo.Arguments = " /start";
            cmdProcess.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            cmdProcess.Start();
            cmdProcess.WaitForExit();
            cmdProcess.Close();
        }
        public static void Reset()
        {
            Process cmdProcess = new Process();
            cmdProcess.StartInfo.FileName = "iisreset";
            cmdProcess.StartInfo
namespace NAudio.SoundFont 
	internal class InstrumentBuilder : StructureBuilder<Instrument>
	{
		private Instrument lastInstrument = null;
        public override Instrument Read(BinaryReader br) 
		{
			Instrument i = new Instrument();
			string s = Encoding.UTF8.GetString(br.ReadBytes(20), 0, 20);
			if(s.IndexOf('\0') >= 0) 
			{
				s = s.Substring(0,s.IndexOf('\0'));
			}
			i.Name = s;
			i.startInstrumentZoneIndex = br.ReadUInt16();
			if(lastInstrument != null)
			{
				lastInstrument.endInstrumentZoneIndex = (ushort) (i.startInstrumentZoneIndex - 1);
			}
			data.Add(i);
			lastInstrument = i;
			return i;
		}
        public override void Write(BinaryWriter bw, Instrument instrument) 
		{
		}
		public override int Length 
		{
			get 
			{
				return 22;
			}
		}
		public void LoadZones(Zone[] zones)
		{
			for(int instrument = 0; instrument < data.Count - 1; instrument++)
			{
				Instrument i = (Instrument) data[instrument];
				i.Zones = new Zone[i.endInstrumentZoneIndex - 
public class God : MonoBehaviour {
	private XmlRepository<World> worldRepo;
	public GameObject ActivePlayer;
	public GameObject TilePrefab;
	private Chunk CurrentChunk;
	public World worldData;
	void Start () {
		worldRepo = new XmlRepository<World>();
		worldData = worldRepo.GetById(new System.Guid("4e9b0641-b915-4259-b83e-c5ff96f86db9"));
		Debug.Log(worldData.Chunk.MinX() + "," + worldData.Chunk.MinY() + "," + worldData.Chunk.MaxX() + "," + worldData.Chunk.MaxY() + "," + worldData.Chunk.Width() + "," + worldData.Chunk.Height());
	}
	void Update () {
		if(ActivePlayer != null)
		{
			Chunk currentChunk = worldData.FindChunk(ActivePlayer.transform.position.x, ActivePlayer.transform.position.y);
			if(CurrentChunk == null || CurrentChunk != currentChunk)
			{
				ChangeChunk(currentChunk);
			}
		}
	}
	private void ChangeChunk(Chunk currentChunk)
	{
		if(currentChunk != null)
		{
			Chunk previousChunk = CurrentChunk;
			CurrentChunk = currentChunk;
			Debug.Log("Change Chunk: " + curr
namespace BRE.Lib.TermStructures
    public class HedgeOption
    {
        #region Members
        public Dictionary<InstrumentName, int> InstrumentToWeights;
        public InstrumentName QuoteInstrument;
        public int QuoteWeight;
        public List<InstrumentName> HedgeInstruments;
        public ResultingInstrument ResultingInstrument;
        public int ResultingWeight;
        #region Constructors
        public HedgeOption()
        {
            InstrumentToWeights = new Dictionary<InstrumentName, int>();
            HedgeInstruments = new List<InstrumentName>();
        }
        #region Properties
        #region Public Methods
        public bool TryAddInstrumentAndWeight(InstrumentName instrument, int weight)
        {
            bool isSuccess = false;
            if (!InstrumentToWeights.ContainsKey(instrument))
            {
                InstrumentToWeights.Add(instrument, weight);
                if (!HedgeInstruments.Contains(instrument) && QuoteInstrument !
namespace LogJoint
	public class AsyncInvokeHelper
	{
		public AsyncInvokeHelper(IInvokeSynchronization invoker, Delegate method,
			params object[] args)
		{
			this.invoker = invoker;
			this.method = method;
			this.args = args;
			this.methodToInvoke = (SimpleDelegate)InvokeInternal;
		}
		public AsyncInvokeHelper(IInvokeSynchronization invoker, Action method): 
			this(invoker, method, new object[0])
		{
		}
		public bool ForceAsyncInvocation { get; set; }
		delegate void SimpleDelegate();
		public void Invoke()
		{
			if (!invoker.InvokeRequired && !ForceAsyncInvocation)
			{
				InvokeInternal();
			}
			else
			{
				if (Interlocked.Exchange(ref methodInvoked, 1) == 0)
				{
					invoker.BeginInvoke(methodToInvoke, emptyArgs);
				}
			}
		}
		void InvokeInternal()
		{
			methodInvoked = 0;
			method.DynamicInvoke(args);
		}
		private readonly IInvokeSynchronization invoker;
		private readonly Delegate method;
		private readonly SimpleDelegate methodToInvoke;
		private readonly
namespace MiNET.Worlds
	public class FlatlandWorldProvider : IWorldProvider
	{
		private readonly ConcurrentDictionary<ChunkCoordinates, ChunkColumn> _chunkCache = new ConcurrentDictionary<ChunkCoordinates, ChunkColumn>();
		public bool IsCaching { get; private set; }
		public FlatlandWorldProvider()
		{
			IsCaching = true;
		}
		public void Initialize()
		{
		}
		Random rand = new Random();
		public ChunkColumn GenerateChunkColumn(ChunkCoordinates chunkCoordinates)
		{
			lock (_chunkCache)
			{
				ChunkColumn cachedChunk;
				if (_chunkCache.TryGetValue(chunkCoordinates, out cachedChunk))
				{
					return cachedChunk;
				}
				ChunkColumn chunk = new ChunkColumn();
				chunk.x = chunkCoordinates.X;
				chunk.z = chunkCoordinates.Z;
				int h = PopulateChunk(chunk);
				chunk.SetBlock(0, h + 1, 0, 7);
				chunk.SetBlock(1, h + 1, 0, 41);
				chunk.SetBlock(2, h + 1, 0, 41);
				chunk.SetBlock(3, h + 1, 0, 41);
				chunk.SetBlock(3, h + 1, 0, 41);
				chunk.SetBlock(0, h, 0, 31);
	

				chunk.SetBlock(0, h, 2, 18);
				chunk.SetBlock(0, h, 15, 31);
				chunk.SetBlock(0, h, 14, 161);
				chunk.SetBlock(0, h, 13, 18);
				chunk.SetBlock(6, h, 9, 63);
				chunk.SetMetadata(6, h, 9, 12);
				var blockEntity = GetBlockEntity((chunkCoordinates.X*16) + 6, h, (chunkCoordinates.Z*16) + 9);
				chunk.SetBlockEntity(blockEntity.Coordinates, blockEntity.GetCompound());
				if (chunkCoordinates.X == 1 && chunkCoordinates.Z == 1)
				{
					for (int x = 0; x < 10; x++)
					{
						for (int z = 0; z < 10; z++)
						{
							for (int y = h - 2; y < h; y++)
							{
								chunk.SetBlock(x, y, z, 8);
							}
						}
					}
				}
				if (chunkCoordinates.X == 3 && chunkCoordinates.Z == 1)
				{
					for (int x = 0; x < 10; x++)
					{
						for (int z = 0; z < 10; z++)
						{
							for (int y = h - 1; y < h; y++)
							{
								chunk.SetBlock(x, y, z, 10);
							}
						}
					}
				}
				for (int x = 0; x < 16; x++)
				{
					for (int z = 0; z < 16; z++)
					{
						fo

						{
							if (chunk.GetBlock(x, y, z) == 0x00)
							{
								chunk.SetSkylight(x, y, z, 0xff);
							}
							else
							{
								chunk.SetSkylight(x, y, z, 0x00);
							}
						}
					}
				}
				chunk.GetBatch();
				_chunkCache[chunkCoordinates] = chunk;
				return chunk;
			}
		}
		public Vector3 GetSpawnPoint()
		{
			return new Vector3(0, 12, 0);
		}
		public long GetTime()
		{
			return 0;
		}
		public int PopulateChunk(ChunkColumn chunk)
		{
			int h = 0;
			var random = new CryptoRandom();
			var stones = new byte[16*16*128];
			for (int i = 0; i < stones.Length; i = i + 128)
			{
				h = 1;
				switch (random.Next(0, 20))
				{
					case 0:
						stones[i + h++] = 3;
						break;
					case 1:
						break;
					case 2:
						break;
					case 3:
						break;
					case 4:
						break;
					case 5:
						break;
					default:
						break;
				}
			}
			chunk.blocks = stones;
			return h;
		}
		public void SaveChunks()
		{
		}
		private Sign GetBlockEntity(int x, int y
namespace CPU_Scheduling_Simulator
    public class CPU
    {
        private List<Process> allCPUProcesses;
        private List<Process> fifoSched;
        private List<Process> rrSched;
        private List<Process> normalSched;
        private Process runningProcess;
        private int currentCycle;
        public Process RunningProcess { get { return runningProcess;  } }
        public int TimeQuantum { get; set; }
        public int CurrentCycle { get { return currentCycle; } }
        public bool IsFinished 
        {
            get
            {
                foreach (Process iProcess in allCPUProcesses)
                {
                    if(!iProcess.Status.Equals(ProcessStatus.Finished))
                    {
                        return false;
                    }
                }
                return true;
            }
        }
        public Process[] FifoSched
        {
            get
            {
                return fifoSched.ToArray();
            }


        public Process[] RRSched
        {
            get
            {
                return rrSched.ToArray();
            }
        }
        public Process[] NormalSched
        {
            get
            {
                return normalSched.ToArray();
            }
        }
        public double AvgTA
        {
            get
            {                
                int sum = 0;
                foreach (Process iProcess in allCPUProcesses)
                {
                    sum += iProcess.TurnaroundTime;
                }
                return sum / allCPUProcesses.Count;
            }
        }
        public double AvgWT
        {
            get
            {
                int sum = 0;
                foreach (Process iProcess in allCPUProcesses)
                {
                    sum += iProcess.WaitingTime;
                }
                return sum / allCPUProcesses.Count;
            }
        }
        public double AvgRT
        {
            get


                int sum = 0;
                foreach (Process iProcess in allCPUProcesses)
                {
                    sum += iProcess.ResponseTime;
                }
                return sum / allCPUProcesses.Count;
            }
        }
        public CPU(List<Process> initialJobs, int timeQuantum)
        {
            this.currentCycle = 0;
            this.TimeQuantum = timeQuantum;
            this.allCPUProcesses = initialJobs;
            this.runningProcess = Process.Empty;
            fifoSched = new List<Process>();
            rrSched = new List<Process>();
            normalSched = new List<Process>();
            
            foreach(Process iProcess in allCPUProcesses)
            {
                switch (iProcess.Type)
                {
                    case ProcessType.N:
                        normalSched.Add(iProcess);
                        break;
                    case ProcessType.PR:
                        rrSched.Add(iProcess);
           
namespace SevenDigital.ApiSupportLayer.Unit.Tests.User
	[TestFixture]
	public class UserApiTests
	{
		[Test]
		public void User_does_not_exist()
		{
			var fluentApi = UserApiThatReturnsNoUsers();
			var userSignupApi = MockRepository.GenerateStub<IFluentApi<UserSignup>>();
			var userApi = new UserApi(fluentApi, userSignupApi);
			var checkUserExists = userApi.CheckUserExists("test@test.com");
			Assert.That(checkUserExists, Is.False);
		}
		[Test]
		public void User_exists()
		{
			var fluentApi = UserApiThatReturnsUser("test@test.com");
			var userSignupApi = MockRepository.GenerateStub<IFluentApi<UserSignup>>();
			var userApi = new UserApi(fluentApi, userSignupApi);
			var checkUserExists = userApi.CheckUserExists("test@test.com");
			Assert.That(checkUserExists);
		}
		[Test]
		public void Doesn_not_pass_affiliate_partner_if_not_specified()
		{
			var fluentApi = UserApiThatReturnsUser("test@test.com");
			var userSignupApi = MockRepository.GenerateStub<IFluentApi<UserSignup>>();

			userSignupApi.Stub(x => x.WithParameter("", "")).IgnoreArguments().Return(userSignupApi);
			var userApi = new UserApi(fluentApi, userSignupApi);
			userApi.Create("emailAddress", "password");
			userSignupApi.AssertWasNotCalled(x=>x.WithParameter(Arg<string>.Is.Equal("affiliatePartner"), Arg<string>.Is.Anything));
		}
		[Test]
		public void Passes_the_affililate_partner_if_specified()
		{
			var fluentApi = UserApiThatReturnsUser("test@test.com");
			var userSignupApi = MockRepository.GenerateStub<IFluentApi<UserSignup>>();
			userSignupApi.Stub(x => x.WithParameter("", "")).IgnoreArguments().Return(userSignupApi);
			var userApi = new UserApi(fluentApi, userSignupApi);
			userApi.Create("emailAddress", "password", "boo");
			userSignupApi.AssertWasCalled(x => x.WithParameter("affiliatePartner","boo"));
		}
		private static IFluentApi<Users> UserApiThatReturnsNoUsers()
		{
			var fluentApi = MockRepository.GenerateStub<IFluentApi<Users>>();
			fluentApi.Stub(x => x.WithParameter("
namespace PlantDataMVC.DAL.TestData
    public class TestUnitOfWork : IUnitOfWork
    {
        TestGenusRepository _genusRepository;
        TestJournalEntryRepository _journalEntryRepository;
        TestJournalEntryTypeRepository _journalEntryTypeRepository;
        TestPlantStockRepository _plantStockRepository;
        TestProductTypeRepository _productTypeRepository;
        TestSeedBatchRepository _seedBatchRepository;
        TestSeedTrayRepository _seedTrayRepository;
        TestSpeciesRepository _speciesRepository;
        TestSiteRepository _siteRepository;
        public IGenusRepository GenusRepository
        {
            get
            {
                if (_genusRepository == null)
                {
                    _genusRepository = new TestGenusRepository();
                }
                return _genusRepository;
            }
        }
        public IJournalEntryRepository JournalEntryRepository
        {
            get
            {
                if (_

                {
                    _journalEntryRepository = new TestJournalEntryRepository();
                }
                return _journalEntryRepository;
            }
        }
        public IJournalEntryTypeRepository JournalEntryTypeRepository
        {
            get
            {
                if (_journalEntryTypeRepository == null)
                {
                    _journalEntryTypeRepository = new TestJournalEntryTypeRepository();
                }
                return _journalEntryTypeRepository;
            }
        }
        public IPlantStockRepository PlantStockRepository
        {
            get
            {
                if (_plantStockRepository == null)
                {
                    _plantStockRepository = new TestPlantStockRepository();
                }
                return _plantStockRepository;
            }
        }
        public IProductTypeRepository ProductTypeRepository
        {
            get
            {
             

                {
                    _productTypeRepository = new TestProductTypeRepository();
                }
                return _productTypeRepository;
            }
        }
        public ISeedBatchRepository SeedBatchRepository
        {
            get
            {
                if (_seedBatchRepository == null)
                {
                    _seedBatchRepository = new TestSeedBatchRepository();
                }
                return _seedBatchRepository;
            }
        }
        public ISeedTrayRepository SeedTrayRepository
        {
            get
            {
                if (_seedTrayRepository == null)
                {
                    _seedTrayRepository = new TestSeedTrayRepository();
                }
                return _seedTrayRepository;
            }
        }
        public ISpeciesRepository SpeciesRepository
        {
            get
            {
                if (_speciesRepository == null)
                {
            
namespace SharpUtility.WinForm
    public static class FormExtensions
    {
        public static void InvokeIfRequired(this Form form, Action action)
        {
            if (!form.InvokeRequired)
            {
                action();
                return;
            }
            form.Invoke(action);
        }
        public static T InvokeIfRequired<T>(this Form form, Func<T> action)
        {
            if (!form.InvokeRequired)
            {
                return action();
            }
            return (T) form.Invoke(action);
        }
        public static void InvokeIfRequired(this Control control, Action action)
        {
            if (!control.InvokeRequired)
            {
                action();
                return;
            }
            control.Invoke(action);
        }
        public static T InvokeIfRequired<T>(this Control control, Func<T> action)
        {
            if (!control.InvokeRequired)
            {
                return action();
     
namespace SEMining.StockData.DataServices.Trades.Finam
    public class FinamInstrumentService : IInstrumentService
    {
        private readonly IInstrumentSplitter _instrumentSplitter;
        private readonly IFileManager _fileManager;
        private readonly IInfoPublisher _infoPublisher;
        public FinamInstrumentService()
        {
            _instrumentSplitter = ContainerBuilder.Container.Resolve<IInstrumentSplitter>();
            _fileManager = ContainerBuilder.Container.Resolve<IFileManager>();
            _infoPublisher = ContainerBuilder.Container.Resolve<IInfoPublisher>();
           
        }
        public void Download(Instrument instrument, CancellationToken cancellationToken)
        {
            DeleteFolder(instrument);
            CreateFolder(instrument);
            _instrumentSplitter.Split(instrument).ForEach(i =>
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    return;
                

                var downloader = ContainerBuilder.Container.Resolve<ITradesDownloader>();
                downloader.Download(i);
                _infoPublisher.PublishInfo(new DownloadInfo { Message = i + "- was downloaded" });
            });
        }
        public void SoftDownload(Instrument instrument, CancellationToken cancellationToken)
        {
            CreateFolder(instrument);
            _instrumentSplitter.Split(instrument).ForEach(i =>
            {
                if (cancellationToken.IsCancellationRequested || FileExist(i))
                {
                    return;
                }
                var downloader = ContainerBuilder.Container.Resolve<ITradesDownloader>();
                downloader.Download(i);
                _infoPublisher.PublishInfo(new DownloadInfo { Message = i + "- was soft downloaded" });
            });
        }
        public void Delete(Instrument instrument, Task download, CancellationTokenSource cancellationTokenSource)
        {

            if (download != null && !download.IsCompleted)
            {
                _infoPublisher.PublishInfo(new DownloadInfo { Message = instrument + "- cancellation will wait till download task will finish" });
                cancellationTokenSource.Cancel();
                download.Wait();
            }
            DeleteFolder(instrument);
            var instrumentsHolder = ContainerBuilder.Container.Resolve<IDownloadedInstrumentsHolder>();
            instrumentsHolder.Remove(instrument);
            _infoPublisher.PublishInfo(new DownloadInfo { Message = instrument + "- is deleted" });
        }
        public bool CheckFiles(Instrument instrument)
        {
            return _fileManager.IsDirectoryExist(instrument.DataProvider + "\\" + instrument.Path) &&
                _instrumentSplitter.Split(instrument).All(FileExist);
        }
        private bool FileExist(Instrument instrument)
        {
            return _fileManager.IsFileExist(instrument.DataProvider + 
namespace ECommerce.Data.Infrastructure
    public interface IUnitOfWork : IDisposable
    { 
        void Commit();
     
        
   
IAddressRepository AddressRepository { get; }
ICategoryRepository CategoryRepository { get; }
ICommisionRepository   CommisionRepository    { get; } 
ICreditCardRepository CreditCardRepository{ get; }
IGouvernoratRepository GouvernoratRepository { get; }
IOrderItemRepository OrderItemRepository{ get; }
IOrderRepository OrderRepository{ get; }
IPictureRepository PictureRepository{ get; }
IProductItemRepository ProductItemRepository { get; }
IProductItemSupplierRepository ProductItemSupplierRepository { get; }
IProductRepository ProductRepository { get; }
IPromotionRepository PromotionRepository{ get; }
IReclamationRepository ReclamationRepository{ get; }
IRecommendationRepository  RecommendationRepository     { get; }
IReviewRepository ReviewRepository { get; }
IShoppingCartRepository ShoppingCartRepository{ get; }
IUserRepository UserRepository { get; 
namespace DatDigger.Sections
    public delegate Chunk ChunkFactory(SectionType sectionType, Chunk parent);
    public static class ChunkLoader
    {
        private static Dictionary<int, Dictionary<int, ChunkFactory>> chunkFactories = new Dictionary<int, Dictionary<int, ChunkFactory>>();
        private static Chunk GenericChunkFactory<T>(SectionType sectionType, Chunk parent) where T : Chunk, new()
        {
            Chunk result = new T();
            result.SectionType = sectionType;
            return result;
        }
        private static void RegisterChunk<T>(SectionType sectionType, int chunkType) where T : Chunk, new()
        {
            var dict = chunkFactories[(int)sectionType];
            dict.Add(chunkType, GenericChunkFactory<T>);
        }
        private static Chunk AabbChunkFactory(SectionType sectionType, Chunk parent)
        {
            Chunk result;
            if (parent is Model.BoundingBoxContainerChunk)
            {
                result = new M

            }
            else
            {
                result = new Model.BoundingBoxContainerChunk();
            }
            result.SectionType = sectionType;
            return result;
        }
        private static Chunk HeaderChunkFactory(SectionType sectionType, Chunk parent)
        {
            Chunk result;
            if (parent is Model.MeshChunk)
            {
                result = new Model.MeshHeaderChunk();
            }
            else
            {
                result = new Model.HeaderChunk();
            }
            result.SectionType = sectionType;
            return result;
        }
        static ChunkLoader()
        {
            Dictionary<int, ChunkFactory> modelFactories = new Dictionary<int, ChunkFactory>();
            chunkFactories.Add((int)SectionType.wrb, modelFactories);
            chunkFactories.Add((int)SectionType.sdrb, new Dictionary<int, ChunkFactory>());
            RegisterChunk<Shader.ShaderChunk>(SectionType.sdrb, (int)S

            RegisterChunk<Shader.FileChunk>(SectionType.sdrb, (int)Shader.ChunkType.FILE);
            RegisterChunk<Shader.VcapChunk>(SectionType.sdrb, (int)Shader.ChunkType.VCAP);
            RegisterChunk<Shader.PcapChunk>(SectionType.sdrb, (int)Shader.ChunkType.PCAP);
            RegisterChunk<Shader.PramChunk>(SectionType.sdrb, (int)Shader.ChunkType.PRAM);
            RegisterChunk<Model.WrbChunk>(SectionType.wrb, (int)Model.ChunkType.WRB);
            RegisterChunk<Model.ModelContainerChunk>(SectionType.wrb, (int)Model.ChunkType.MDLC);
            RegisterChunk<Model.ModelChunk>(SectionType.wrb, (int)Model.ChunkType.MDL);
            RegisterChunk<Model.MeshChunk>(SectionType.wrb, (int)Model.ChunkType.MESH);
            RegisterChunk<Model.StreamChunk>(SectionType.wrb, (int)Model.ChunkType.STMS);
            RegisterChunk<Model.NameChunk>(SectionType.wrb, (int)Model.ChunkType.NAME);
            RegisterChunk<Model.StringChunk>(SectionType.wrb, (int)Model.ChunkType.STR);
        
namespace Prover.Core.Storage
    public class InstrumentStore : IProverStore<Instrument>
    {
        private readonly ProverContext _proverContext;
        public InstrumentStore(ProverContext context)
        {
            _proverContext = context;
        }
        public IQueryable<Instrument> Query()
        {
            return _proverContext.Instruments
                .Include(v => v.VerificationTests.Select(t => t.TemperatureTest))
                .Include(v => v.VerificationTests.Select(p => p.PressureTest))
                .Include(v => v.VerificationTests.Select(vo => vo.VolumeTest))
                .AsQueryable();
        }
        public Instrument Get(Guid id)
        {
            return Query().FirstOrDefault(x => x.Id == id);
        }
        public async Task<Instrument> UpsertAsync(Instrument instrument)
        {
            if (Get(instrument.Id) != null)
            {
                _proverContext.Instruments.Attach(instrument);
                _proverContext
namespace Sean.World
    
    public interface IWorldServer
    {
        ChunkCoords GetChunkCoords(Position position);
        void RegisterChunk(ChunkCoords chunkCoords, PlayerConnection player);
        void UnRegisterChunk(ChunkCoords chunkCoords, PlayerConnection player);
        Chunk GetChunk (ChunkCoords chunkCoords);
        void PutBlock (Position position, Block.BlockType blockType);
        void ChunkEvent (ChunkCoords chunkCoords, ChunkEventTarget target, ChunkEvent chunkEvent);
    }
    public class ChunkEvent
    {
    }
    public class BlockChunkEvent : ChunkEvent
    {
        Position blockLocation;
        ItemAction action;
        Block block;
    }
    public class ItemChunkEvent : ChunkEvent
    {
        Coords coords;
        ItemAction action;
    }
      
    public enum ChunkEventTarget
    {
        Block,
        Item,
        Character,
        Lighting,
        Projectile,
        Sound,
        Message
    }
    public enum ItemAction
    {
        A

        Remove,
        Update       
    }
    public class ChunkEventArgs : EventArgs
    {
    }
    public class PlayerConnection
    {
        public string user;
        public string connection;
    }
    public class WorldServer : IWorldServer
    {
        private Dictionary<ChunkCoords, List<PlayerConnection> > registrations;
        public WorldServer ()
        {
            registrations = new Dictionary<ChunkCoords, List<PlayerConnection> > ();
        }
        public ChunkCoords GetChunkCoords(Position position)
        {
            return new ChunkCoords (position.X / Chunk.CHUNK_SIZE, position.Z / Chunk.CHUNK_SIZE); 
        }
        public void RegisterChunk(ChunkCoords chunkCoords, PlayerConnection player)
        {
            var chunk = WorldData.WorldMap.Chunk (chunkCoords.X, chunkCoords.Z);
            if (!registrations.ContainsKey (chunkCoords)) {
                registrations [chunkCoords] = new List<PlayerConnection> ();
            }
            registr
namespace FarseerPhysics.Controllers
    [Flags]
    public enum ControllerType
    {
        GravityController = (1 << 0),
        VelocityLimitController = (1 << 1),
        AbstractForceController = (1 << 2)
    }
    public class FilterControllerData : FilterData
    {
        private ControllerType _type;
        public FilterControllerData(ControllerType type)
        {
            _type = type;
        }
        public override bool IsActiveOn(Body body)
        {
            if (body.ControllerFilter.IsControllerIgnored(_type))
                return false;
            return base.IsActiveOn(body);
        }
    }
    public class ControllerFilter
    {
        public ControllerType ControllerFlags;
        public void IgnoreController(ControllerType controller)
        {
            ControllerFlags |= controller;
        }
        public void RestoreController(ControllerType controller)
        {
            ControllerFlags &= ~controller;
        }
        public bool IsContr
namespace ApiFox.Migrations
    
    public partial class FixIdIssue3 : DbMigration
    {
        public override void Up()
        {
            DropForeignKey("dbo.ApiRequests", "Api_Id", "dbo.Apis");
            DropIndex("dbo.ApiRequests", new[] { "Api_Id" });
            RenameColumn(table: "dbo.ApiRequests", name: "Api_Id", newName: "ApiId");
            AlterColumn("dbo.ApiRequests", "ApiId", c => c.Int(nullable: false));
            CreateIndex("dbo.ApiRequests", "ApiId");
            AddForeignKey("dbo.ApiRequests", "ApiId", "dbo.Apis", "Id", cascadeDelete: true);
        }
        
        public override void Down()
        {
            DropForeignKey("dbo.ApiRequests", "ApiId", "dbo.Apis");
            DropIndex("dbo.ApiRequests", new[] { "ApiId" });
            AlterColumn("dbo.ApiRequests", "ApiId", c => c.Int());
            RenameColumn(table: "dbo.ApiRequests", name: "ApiId", newName: "Api_Id");
            CreateIndex("dbo.ApiRequests", "Api_Id");
            AddFore
public class InstrumentHelper : UnitySingleton<InstrumentHelper>
    private List<Instrument> _instruments;
    
    public List<Instrument> Instruments
    {
        get
        {
            if (_instruments == null)
            {
                _instruments = new List<Instrument>(System.Enum.GetValues(typeof(Instrument)).Cast<Instrument>());
            }
            
            return _instruments;
        }
    }
    public static Color GetColorForInstrument(Instrument instrument)
    {
        switch (instrument)
        {
            case Instrument.Red:
                return Color.red;
            case Instrument.Orange:
                return new Color32(255, 69, 0, 255);
            case Instrument.Yellow:
                return Color.yellow;
            case Instrument.Green:
                return Color.green;
            case Instrument.Blue:
                return Color.blue;
            case Instrument.Purple:
                return new Color32(128, 0, 128, 255);
    
namespace Perfoma.DatabaseAccessLayer
    public class DALContext
    {
        private IEmployeeRepository employeeRepository;
        public IEmployeeRepository EmployeeRepository
        {
            get { return this.employeeRepository ?? ( this.employeeRepository = new EmployeeRepository()); }
        }
        private ICustomerRepository customerRepository;
        public ICustomerRepository CustomerRepository
        {
            get { return this.customerRepository ?? (this.customerRepository = new CustomerRepository()); }
        }
        private IProjectRepository projectRepository;
        public IProjectRepository ProjectRepository
        {
            get { return this.projectRepository ?? (this.projectRepository = new ProjectRepository()); }
        }
        private IActivityRepository activityRepository;
        public IActivityRepository ActivityRepository
        {
            get { return this.activityRepository ?? (this.activityRepository = new ActivityRepositor
namespace PixelShare.Core
    public static class ChunkUtils
    {
        #region Packing Methods
        public static void Pack(BufferChunk aChunk, int x, int y)
        {
            aChunk += x;
            aChunk += y;
        }
        public static void Pack(BufferChunk aChunk, int left, int top, int right, int bottom)
        {
            aChunk += left;
            aChunk += top;
            aChunk += right;
            aChunk += bottom;
        }
        public static void Pack(BufferChunk chunk, Point aPoint)
        {
            chunk += aPoint.X;
            chunk += aPoint.Y;
        }
        public static void Pack(BufferChunk chunk, Point[] points)
        {
            chunk += points.Length;
            for (int i = 0; i < points.Length; i++)
            {
                Pack(chunk, points[i].X, points[i].Y);
            }
        }
        public static void Pack(BufferChunk chunk, Guid uniqueID)
        {
            chunk += uniqueID.ToByteArray();
        }
 

        {
            chunk += aTrans.eDx;
            chunk += aTrans.eDy;
            chunk += aTrans.eM11;
            chunk += aTrans.eM12;
            chunk += aTrans.eM21;
            chunk += aTrans.eM22;
        }
        public static void Pack(BufferChunk chunk, TRIVERTEX[] vertices)
        {
            int nVertices = vertices.Length;
            chunk += nVertices;
            for (int i = 0; i < nVertices; i++)
            {
                chunk += vertices[i].x;
                chunk += vertices[i].y;
                chunk += vertices[i].Alpha;
                chunk += vertices[i].Blue;
                chunk += vertices[i].Green;
                chunk += vertices[i].Red;
            }
        }
        public static void Pack(BufferChunk chunk, GRADIENT_RECT[] gRect)
        {
            int nRects = gRect.Length;
            chunk += nRects;
            for (int i = 0; i < nRects; i++)
            {
                chunk += gRect[i].UpperLeft;
                chunk 

            }
        }
        public static void Pack(BufferChunk chunk, IBrush aBrush)
        {
            chunk += GDI32.EMR_CREATEBRUSHINDIRECT;
            chunk += (int)aBrush.BrushStyle;
            chunk += (int)aBrush.HatchStyle;
            chunk += aBrush.Color;
            Pack(chunk, aBrush.UniqueID);
        }
        public static void Pack(BufferChunk chunk, IPen aPen)
        {
            chunk += GDI32.EMR_CREATEPEN;
            chunk += (int)aPen.Style;
            chunk += 1;
            chunk += aPen.Color;
            Pack(chunk, aPen.UniqueID);
        }
        public static void Pack(BufferChunk chunk, GDIFont aFont)
        {
            chunk += GDI32.EMR_EXTCREATEFONTINDIRECTW;
            chunk += aFont.FaceName.Length;
            chunk += aFont.FaceName;
            chunk += (int)aFont.Height;
            Pack(chunk, aFont.UniqueID);
        }
        #endregion
        #region Unpacking routines
        public static GDIPen UnpackGPen(BufferChunk ch
﻿@{
    Layout = "_ColumnsOne";
    Html.AppendPageCssClassParts("html-home-page");
<div class="page home-page">
    <div class="page-body">
        @await Component.InvokeAsync("Widget", new { widgetZone = "home_page_top" })
        @await Component.InvokeAsync("TopicBlock", new { systemName = "HomePageText" })
        @await Component.InvokeAsync("Widget", new { widgetZone = "home_page_before_categories" })
        @await Component.InvokeAsync("HomepageCategories")
        @await Component.InvokeAsync("Widget", new { widgetZone = "home_page_before_products" })
        @await Component.InvokeAsync("HomepageProducts")
        @await Component.InvokeAsync("Widget", new { widgetZone = "home_page_before_best_sellers" })
        @await Component.InvokeAsync("HomepageBestSellers")
        @await Component.InvokeAsync("Widget", new { widgetZone = "home_page_before_news" })
        @await Component.InvokeAsync("HomepageNews")
        @await Component.InvokeAsync("Widget", new { widgetZone = "
public class World : MonoBehaviour {
    public static World instance;
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public GameObject chunkPrefab;
    public Vector3 meshScale;
    public int newChunkX;
    public int newChunkY;
    public int newChunkZ;
    public bool genChunk;
    void Awake()
    {
        instance = this;
    }
    void Start()
    {
        
    }
    public void GenerateWorld()
    {
        for (int x = 0; x < TerrainManager.instance.gridDiameter/ Chunk.chunkSize; x++)
            for (int y = 0; y < 4; y++)
                for (int z = 0; z < TerrainManager.instance.gridDiameter / Chunk.chunkSize; z++)
                    CreateChunk(x * Chunk.chunkSize, y * Chunk.chunkSize, z * Chunk.chunkSize); 
        
    }
    void Update()
    {
        if (genChunk)
        {
            genChunk = false;
            WorldPos chunkPos = new WorldPos(newChunkX, newChunkY, newChunkZ);
            Chunk chunk = null;
            i

            {
                DestroyChunk(chunkPos.x, chunkPos.y, chunkPos.z);
            }
            else
            {
                CreateChunk(chunkPos.x, chunkPos.y, chunkPos.z);
            }
        }
    }
    public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(x, y, z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        newChunk = TerrainGen.ChunkGen(newChunk);
        newChunk.SetBlocksUnmodified();
        
    }
    public void DestroyChunk(int x, int y, int z)
    {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
        {
            Object.Destroy(chunk.gameObje

            chunks.Remove(new WorldPos(x, y, z));
        }
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / multiple) * Chunk.chunkSize;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Block GetBlock(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null)
        {
            Block block = containerChunk.GetBlock(
                x - containerChunk.pos.x,
                y - containerChunk.pos.y,
                z - containerChunk.pos.z);
            return block;
        }
        else
        {
            return new BlockAir();
        }
    }
    public void SetBlock(int x, int y
namespace BodeAbp.Queue.Broker.Storage
    public class ChunkWriter
    {
        public Chunk CurrentChunk { get { return _currentChunk; } }
        private readonly ChunkManager _chunkManager;
        private readonly IScheduleService _scheduleService;
        private readonly object _lockObj = new object();
        private bool _isClosed = false;
        private Chunk _currentChunk;
        public ChunkWriter(ChunkManager chunkManager)
        {
            chunkManager.CheckNotNull("chunkManager");
            _chunkManager = chunkManager;
            _scheduleService = IocManager.Instance.Resolve<IScheduleService>();
        }
        public void Open()
        {
            _currentChunk = _chunkManager.GetLastChunk();
            if (!_chunkManager.IsMemoryMode && !_chunkManager.Config.SyncFlush)
            {
                _scheduleService.StartTask("FlushChunk", Flush, 1000, _chunkManager.Config.FlushChunkIntervalMilliseconds);
            }
            _isClosed = false;
  

        public long Write(ILogRecord record)
        {
            lock (_lockObj)
            {
                if (_isClosed)
                {
                    return -1L;
                }
                if (_currentChunk.IsCompleted)
                {
                    _currentChunk = _chunkManager.AddNewChunk();
                }
                var result = _currentChunk.TryAppend(record);
                if (!result.Success)
                {
                    _currentChunk.Complete();
                    _currentChunk = _chunkManager.AddNewChunk();
                    result = _currentChunk.TryAppend(record);
                    if (!result.Success)
                    {
                        throw new ChunkWriteException(_currentChunk.ToString(), "Write record to chunk failed.");
                    }
                }
                if (!_chunkManager.IsMemoryMode && _chunkManager.Config.SyncFlush)
                {
                    _currentChunk.Flush();
    
namespace DD.ApiProxy.ApiControllers
    public class ApiProxyConfiguration : IApiProxyConfiguration
    {
        private readonly string _apiMocksPath;
        private readonly string _apiRecordingPath;
        private readonly Uri _defaultApiAddress;
        private readonly bool _fallbackToDefaultApi;
        private readonly bool _recordApiRequestResponse;
        public ApiProxyConfiguration()
        {
            _apiMocksPath = ConfigurationManager.AppSettings["ApiMocksPath"];
            var defaultApiAddress = ConfigurationManager.AppSettings["DefaultApiAddress"];
            if (!string.IsNullOrWhiteSpace(defaultApiAddress) && !defaultApiAddress.Contains("http"))
            _apiRecordingPath = ConfigurationManager.AppSettings["ApiRecordingPath"];
            var recordApiRequestResponseStr = ConfigurationManager.AppSettings["RecordApiRequestResponse"];
            _recordApiRequestResponse = false;
            bool.TryParse(recordApiRequestResponseStr, out _recordApiReques
namespace ROM.Services.Data
    public class HomeService : IHomeService
    {
        private readonly IEfRepository<Restaurant> restaurantRepository;
        private readonly IEfRepository<Table> tableRepository;
        private readonly IEfRepository<Product> productRepository;
        public HomeService(
            IEfRepository<Restaurant> restaurantRepository, 
            IEfRepository<Table> tableRepository, 
            IEfRepository<Product> productRepository)
        {
            this.restaurantRepository = restaurantRepository;
            this.tableRepository = tableRepository;
            this.productRepository = productRepository;
        }
        public IQueryable<Restaurant> GetAllRestaurants()
        {
            return this.restaurantRepository.All;
        }
        public IQueryable<Table> GetAllTables()
        {
            return this.tableRepository.All;
        }
        public IQueryable<Product> GetAllProducts()
        {
            return this.productR
﻿namespace Pigmeo.Displays.SevenSegments {
	public class Single7SegCK {
		private Delegates.SetBool WriteSegmentA;
		private Delegates.SetBool WriteSegmentB;
		private Delegates.SetBool WriteSegmentC;
		private Delegates.SetBool WriteSegmentD;
		private Delegates.SetBool WriteSegmentE;
		private Delegates.SetBool WriteSegmentF;
		private Delegates.SetBool WriteSegmentG;
		public Single7SegCK(Delegates.SetBool SegmentAWriter, Delegates.SetBool SegmentBWriter, Delegates.SetBool SegmentCWriter, Delegates.SetBool SegmentDWriter, Delegates.SetBool SegmentEWriter, Delegates.SetBool SegmentFWriter, Delegates.SetBool SegmentGWriter) {
			WriteSegmentA = SegmentAWriter;
			WriteSegmentB = SegmentBWriter;
			WriteSegmentC = SegmentCWriter;
			WriteSegmentD = SegmentDWriter;
			WriteSegmentE = SegmentEWriter;
			WriteSegmentF = SegmentFWriter;
			WriteSegmentG = SegmentGWriter;
		}
		public void TurnOFF() {
			WriteSegmentA.Invoke(false);
			WriteSegmentB.Invoke(false);
			WriteSegmentC.Invoke(fa

			WriteSegmentD.Invoke(false);
			WriteSegmentE.Invoke(false);
			WriteSegmentF.Invoke(false);
			WriteSegmentG.Invoke(false);
		}
		public void TurnAllOn() {
			WriteSegmentA.Invoke(true);
			WriteSegmentB.Invoke(true);
			WriteSegmentC.Invoke(true);
			WriteSegmentD.Invoke(true);
			WriteSegmentE.Invoke(true);
			WriteSegmentF.Invoke(true);
			WriteSegmentG.Invoke(true);
		}
		public void SetValue(char character) {
			switch(character) {
				case '0':
					WriteSegmentA.Invoke(true);
					WriteSegmentB.Invoke(true);
					WriteSegmentC.Invoke(true);
					WriteSegmentD.Invoke(true);
					WriteSegmentE.Invoke(true);
					WriteSegmentF.Invoke(true);
					WriteSegmentG.Invoke(true);
					break;
				case '1':
					WriteSegmentA.Invoke(false);
					WriteSegmentB.Invoke(true);
					WriteSegmentC.Invoke(true);
					WriteSegmentD.Invoke(false);
					WriteSegmentE.Invoke(false);
					WriteSegmentF.Invoke(false);
					WriteSegmentG.Invoke(false);
					break;
				case '2':
					WriteSegmentA.In

					WriteSegmentB.Invoke(true);
					WriteSegmentC.Invoke(false);
					WriteSegmentD.Invoke(true);
					WriteSegmentE.Invoke(true);
					WriteSegmentF.Invoke(false);
					WriteSegmentG.Invoke(true);
					break;
				case '3':
					WriteSegmentA.Invoke(true);
					WriteSegmentB.Invoke(true);
					WriteSegmentC.Invoke(true);
					WriteSegmentD.Invoke(true);
					WriteSegmentE.Invoke(false);
					WriteSegmentF.Invoke(false);
					WriteSegmentG.Invoke(true);
					break;
				case '4':
					WriteSegmentA.Invoke(false);
					WriteSegmentB.Invoke(true);
					WriteSegmentC.Invoke(true);
					WriteSegmentD.Invoke(false);
					WriteSegmentE.Invoke(false);
					WriteSegmentF.Invoke(true);
					WriteSegmentG.Invoke(true);
					break;
				case '5':
					WriteSegmentA.Invoke(true);
					WriteSegmentB.Invoke(false);
					WriteSegmentC.Invoke(true);
					WriteSegmentD.Invoke(true);
					WriteSegmentE.Invoke(false);
					WriteSegmentF.Invoke(true);
					WriteSegmentG.Invoke(true);
					break;
				case 
namespace NhhDataImport.Process
    public class NhhDataProcess
    {
        public static void Check(string fileName, List<string> sheetNames, BackgroundWorker worker)
        {
            var processList = new Dictionary<string, INhhDataProcess>();
            processList.Add("品牌", new BrandProcess());
            processList.Add("公司", new CompanyProcess());
            processList.Add("部门", new DepartmentProcess());
            processList.Add("员工", new EmployeeProcess());
            processList.Add("项目", new ProjectProcess());
            processList.Add("楼宇", new ProjectBuildingProcess());
            processList.Add("楼层", new ProjectFloorProcess());
            processList.Add("商铺筹划", new ProjectUnitProcess());
            processList.Add("商户", new MerchantProcess());
            processList.Add("商铺合约", new ContractProcess());
            foreach (var process in processList)
            {
                if (sheetNames.Exists(sheetName => process.Key == sheetName))
           

                    try
                    {
                        process.Value.CheckData(fileName, worker);
                    }
                    catch (Exception ex)
                    {
                        worker.ReportProgress(20, ex.ToString());
                    }
                }
            }
        }
        public static void Process(string fileName, List<string> sheetNames, BackgroundWorker worker)
        {
            var processList = new Dictionary<string, INhhDataProcess>();
            processList.Add("品牌", new BrandProcess());
            processList.Add("公司", new CompanyProcess());
            processList.Add("部门", new DepartmentProcess());
            processList.Add("员工", new EmployeeProcess());
            processList.Add("项目", new ProjectProcess());
            processList.Add("楼宇", new ProjectBuildingProcess());
            processList.Add("楼层", new ProjectFloorProcess());
            processList.Add("商铺筹划", new ProjectUnitProcess());
         
namespace Microsoft.AspNet.Razor.CodeGenerators.Visitors
    public abstract class ChunkVisitor<TWriter> : IChunkVisitor
        where TWriter : CodeWriter
    {
        public ChunkVisitor(TWriter writer, CodeGeneratorContext context)
        {
            if (writer == null)
            {
                throw new ArgumentNullException(nameof(writer));
            }
            if (context == null)
            {
                throw new ArgumentNullException(nameof(context));
            }
            Writer = writer;
            Context = context;
        }
        protected TWriter Writer { get; private set; }
        protected CodeGeneratorContext Context { get; private set; }
        public void Accept(IList<Chunk> chunks)
        {
            if (chunks == null)
            {
                throw new ArgumentNullException(nameof(chunks));
            }
            foreach (Chunk chunk in chunks)
            {
                Accept(chunk);
            }
        }
        publ

        {
            if (chunk == null)
            {
                throw new ArgumentNullException(nameof(chunk));
            }
            if (chunk is LiteralChunk)
            {
                Visit((LiteralChunk)chunk);
            }
            else if (chunk is ExpressionBlockChunk)
            {
                Visit((ExpressionBlockChunk)chunk);
            }
            else if (chunk is ExpressionChunk)
            {
                Visit((ExpressionChunk)chunk);
            }
            else if (chunk is StatementChunk)
            {
                Visit((StatementChunk)chunk);
            }
            else if (chunk is TagHelperChunk)
            {
                Visit((TagHelperChunk)chunk);
            }
            else if (chunk is TagHelperPrefixDirectiveChunk)
            {
                Visit((TagHelperPrefixDirectiveChunk)chunk);
            }
            else if (chunk is AddTagHelperChunk)
            {
                Visit((AddTagHelperChunk)chunk);

            }
            else if (chunk is RemoveTagHelperChunk)
            {
                Visit((RemoveTagHelperChunk)chunk);
            }
            else if (chunk is TypeMemberChunk)
            {
                Visit((TypeMemberChunk)chunk);
            }
            else if (chunk is UsingChunk)
            {
                Visit((UsingChunk)chunk);
            }
            else if (chunk is SetBaseTypeChunk)
            {
                Visit((SetBaseTypeChunk)chunk);
            }
            else if (chunk is DynamicCodeAttributeChunk)
            {
                Visit((DynamicCodeAttributeChunk)chunk);
            }
            else if (chunk is LiteralCodeAttributeChunk)
            {
                Visit((LiteralCodeAttributeChunk)chunk);
            }
            else if (chunk is CodeAttributeChunk)
            {
                Visit((CodeAttributeChunk)chunk);
            }
            else if (chunk is SectionChunk)
            {
                Visit((Se
namespace ScenarioScriptBuilder
    public class TestProcessFactory
    {
        public TestProcessFactory()
        {
        }
        public GeneralGBMProcess generalGBMProcess()
        {
            GeneralGBMProcess process = new GeneralGBMProcess();
            process.Name_ = "";
            process.X0_ = "";
            process.Mue_Curve_Value_ = "";
            process.Mue_Curve_Tenor_ = "";
            process.Mue_Curve_Interpolation_ = "";
            process.Dividend_ = "";
            process.Sigma_ = "";
            process.Shock_ = "";
            process.Addtional_Calculation_ = "";
            return process;
        }
        public GeneralHullWhiteProcess generalHullWhiteProcess()
        {
            GeneralHullWhiteProcess process = new GeneralHullWhiteProcess();
            process.Name_ = "";
            process.Fitting_Curve_Value_ = "";
            process.Fitting_Curve_Tenor_ = "";
            process.Fitting_Curve_Interpolation_ = "";
            process.A
namespace OOADExercise
    class RicksStore
    {
        public void RunSimulator()
        {
            Inventory inventory = new Inventory();
            inventory = initializeInventory(inventory);
            Dictionary<string, object> properties = new Dictionary<string, object>();
            properties.Add("builder", Builder.GIBSON);
            properties.Add("backWood", Wood.MAPLE);
            InstrumentSpec clientSpec = new InstrumentSpec(properties);
            List<Instrument> matchingInstruments = inventory.search(clientSpec);
            if (matchingInstruments.Any())
            {
                foreach (Instrument instrument in matchingInstruments)
                {
                    InstrumentSpec instrumentSpec = instrument.getSpec();
                    Console.WriteLine("We have a {0} with the following properties:", instrumentSpec.getProperty("instrumentType"));
                    var specProperties = instrumentSpec.getProperties();
                    foreac

                    {
                        if (property.Equals("instrumentType"))
                            continue;
                        Console.WriteLine("{0}: {1}", property, instrumentSpec.getProperty(property));
                    }
                    Console.WriteLine("You can have this {0} for ${1}", instrumentSpec.getProperty("instrumentType"), instrument.getPrice());
                    Console.WriteLine("---------------------------");
                }
            }
            else
                Console.WriteLine("Sorry customer, we don't have anything for you.");
        }
        private static Inventory initializeInventory(Inventory inventory)
        {
            string[] keys = {"instrumentType", "builder", "model", "type", "numStrings", "topWood", "backWood"};
            Dictionary<string, object> properties = new Dictionary<string, object>();
            properties.Add("instrumentType", InstrumentType.GUITAR);
            properties.Add("builder", Buil

            properties.Add("model", "CJ");
            properties.Add("type", PlayType.ACOUSTIC);
            properties.Add("numStrings", 6);
            properties.Add("topWood", Wood.INDIAN_ROSEWOOD);
            properties.Add("backWood", Wood.SITKA);
            InstrumentSpec instrumentSpec = new InstrumentSpec(properties);
            inventory.addInstrument("11277", 3999.95, instrumentSpec);
            properties["builder"] = Builder.MARTIN;
            properties["model"] = "D-18";
            properties["topWood"] = Wood.MAHOGANY;
            properties["backWood"] = Wood.ADIRONDACK;
            inventory.addInstrument("122784", 5495.95, new InstrumentSpec(properties));
            properties["builder"] = Builder.FENDER;
            properties["model"] = "Stratocastor";
            properties["type"] = PlayType.ELECTRIC;
            properties["topWood"] = Wood.ALDER;
            properties["backWood"] = Wood.ALDER;
            inventory.addInstrument("V95693", 1499.95, new
namespace MO.Core.Window.Core {
   public class FContextMenu : IDisposable {
      internal IntPtr _handle;
      internal IContextMenu _face;
      protected IntPtr _menuHandle = IntPtr.Zero;
      public FContextMenu() {
      }
      public void Create() {
         if (_menuHandle == IntPtr.Zero) {
            _menuHandle = RUser32.CreatePopupMenu();
            _face.QueryContextMenu(_menuHandle, 0, RWinShell.CMD_FIRST, RWinShell.CMD_LAST, ECmf.NORMAL | ECmf.EXPLORE);
         }
      }
      public void Insert(string text, bool enable) {
         EMft extraFlag = enable ? 0 : EMft.GRAYED;
         RUser32.InsertMenu(_menuHandle, 0, EMft.BYPOSITION | extraFlag, (int)(RWinShell.CMD_LAST + 1), text);
         RUser32.InsertMenu(_menuHandle, 1, EMft.BYPOSITION | EMft.SEPARATOR, 0, "-");
         RUser32.SetMenuDefaultItem(_menuHandle, 0, true);
      }
      public int Popup(IntPtr handle, int x, int y) {
         Create();
         uint cmd = RUser32.TrackPopupMenuEx(_menuHandle, ETr

         _menuHandle = IntPtr.Zero;
         if (cmd >= RWinShell.CMD_FIRST) {
            SCmInvokeCommandInfoEX invoke = new SCmInvokeCommandInfoEX();
            invoke.cbSize = Marshal.SizeOf(typeof(SCmInvokeCommandInfoEX));
            invoke.lpVerb = (IntPtr)(cmd - 1);
            invoke.lpDirectory = string.Empty;
            invoke.fMask = 0;
            invoke.ptInvoke = new SPoint();
            invoke.ptInvoke.x = x;
            invoke.ptInvoke.y = y;
            invoke.nShow = 1;
            _face.InvokeCommand(ref invoke);
         }
         return (int)cmd;
      }
      public void InvokeDefault(int x, int y) {
         Create();
         int defaultCommand = RUser32.GetMenuDefaultItem(_menuHandle, false, 0);
         if (defaultCommand != -1) {
            SCmInvokeCommandInfoEX invoke = new SCmInvokeCommandInfoEX();
            invoke.cbSize = Marshal.SizeOf(typeof(SCmInvokeCommandInfoEX));
            invoke.lpVerb = (IntPtr)(defaultCommand - RWinShell.CMD_FIRST);
 
namespace Slash.ECS.Tests
    public class ProcessManagerTest
    {
        #region Fields
        private Game game;
        #endregion
        #region Public Methods and Operators
        [SetUp]
        public void SetUp()
        {
            this.game = new Game();
            this.game.StartGame();
        }
        [Test]
        public void TestActiveWhenStarted()
        {
            WaitProcess process = new WaitProcess(3.0f);
            this.game.ProcessManager.AddProcess(process);
            Assert.IsTrue(process.Active);
        }
        [Test]
        public void TestAliveWhenStarted()
        {
            TestProcess process = new TestProcess();
            Assert.IsFalse(process.Dead);
        }
        [Test]
        public void TestDeadAfterKilled()
        {
            TestProcess process = new TestProcess();
            process.Kill();
            Assert.IsTrue(process.Dead);
        }
        [Test]
        public void TestDontStartNextProcessWhileAlive()
  

            TestProcess first = new TestProcess();
            TestProcess second = new TestProcess();
            first.Next = second;
            this.game.ProcessManager.AddProcess(first);
            this.game.Update(1.0f);
            Assert.IsTrue(first.Active);
            Assert.IsFalse(second.Active);
        }
        [Test]
        public void TestDontUpdateDeadProcess()
        {
            WaitProcess process = new WaitProcess(3.0f);
            process.Kill();
            this.game.ProcessManager.AddProcess(process);
            this.game.Update(1.0f);
            Assert.AreEqual(0.0f, process.TimeElapsed);
        }
        [Test]
        public void TestDontUpdatePausedProcess()
        {
            WaitProcess process = new WaitProcess(3.0f);
            process.TogglePause();
            this.game.ProcessManager.AddProcess(process);
            this.game.Update(1.0f);
            Assert.AreEqual(0.0f, process.TimeElapsed);
        }
        [Test]
        public vo

        {
            WaitProcess process = new WaitProcess(3.0f);
            Assert.IsFalse(process.Active);
        }
        [Test]
        public void TestInitializedWhenStarted()
        {
            TestProcess process = new TestProcess();
            this.game.ProcessManager.AddProcess(process);
            Assert.IsTrue(process.Initialized);
        }
        [Test]
        public void TestNotPausedWhenStarted()
        {
            TestProcess process = new TestProcess();
            Assert.IsFalse(process.Paused);
        }
        [Test]
        public void TestProcessThen()
        {
            TestProcess first = new TestProcess();
            TestProcess second = new TestProcess();
            TestProcess third = new TestProcess();
            first.Then(second).Then(third);
            Assert.AreEqual(second, first.Next);
            Assert.AreEqual(third, second.Next);
        }
        [Test]
        public void TestStartNextProcess()
        {
            TestPro
namespace TheBall.CORE
    public class DeleteProcessImplementation
    {
        public static Process GetTarget_Process(string processId)
        {
            return ObjectStorage.RetrieveFromOwnerContent<Process>(InformationContext.CurrentOwner, processId);
        }
        public static ProcessContainer GetTarget_OwnerProcessContainer()
        {
            return ObjectStorage.RetrieveFromOwnerContent<ProcessContainer>(InformationContext.CurrentOwner, "default");
        }
        public static void ExecuteMethod_ObtainLockRemoveFromContainerAndDeleteProcess(string processID, Process process, ProcessContainer ownerProcessContainer)
        {
            if (process == null)
            {
                if (ownerProcessContainer != null && ownerProcessContainer.ProcessIDs != null)
                {
                    ownerProcessContainer.ProcessIDs.Remove(processID);
                    ownerProcessContainer.StoreInformation();
                }
            }
            else
namespace TrabalhoASW.Models.Repository
    public class UnidadeDeTrabalho
    {
        private bool disposed = false;
        ContextoBD context = new ContextoBD();
        private AlunoRepository alunoRepository;
        private AvaliacaoRepository avaliacaoRepository;
        private CoordenadorRepository coordenadorRepository;
        private CursoRepository cursoRepository;
        private DisciplinaRepository disciplinaRepository;
        private EnderecoRepository enderecoRepository;
        private MatriculaRepository matriculaRepository;
        private NotaRepository notaRepository;
        private PeriodoRepository periodoRepository;
        private PessoaRepository pessoaRepository;
        private ProfessorRepository professorRepository;
        private TurmaRepository turmaRepository;
        private UniversidadeRepository universidadeRepository;
        public AlunoRepository AlunoRepository
        {
            get
            {
                if (alunoRepository == 

                {
                    alunoRepository = new AlunoRepository(context);
                }
                return alunoRepository;
            }
        }
        public AvaliacaoRepository AvaliacaoRepository
        {
            get
            {
                if (avaliacaoRepository == null)
                {
                    avaliacaoRepository = new AvaliacaoRepository(context);
                }
                return avaliacaoRepository;
            }
        }
        public CoordenadorRepository CoordenadorRepository
        {
            get
            {
                if (coordenadorRepository == null)
                {
                    coordenadorRepository = new CoordenadorRepository(context);
                }
                return coordenadorRepository;
            }
        }
        public CursoRepository CursoRepository
        {
            get
            {
                if (cursoRepository == null)
                {
                    c

                }
                return cursoRepository;
            }
        }
        public DisciplinaRepository DisciplinaRepository
        {
            get
            {
                if (disciplinaRepository == null)
                {
                    disciplinaRepository = new DisciplinaRepository(context);
                }
                return disciplinaRepository;
            }
        }
        public EnderecoRepository EnderecoRepository
        {
            get
            {
                if (enderecoRepository == null)
                {
                    enderecoRepository = new EnderecoRepository(context);
                }
                return enderecoRepository;
            }
        }
        public MatriculaRepository MatriculaRepository
        {
            get
            {
                if (matriculaRepository == null)
                {
                    matriculaRepository = new MatriculaRepository(context);
                }
             
namespace DataAccessLibrary.Repository
    public class EFUnitOfWork : IUnitOfWork
    {
        private readonly DatabaseContext context;
        private bool disposed = false;
        private AuthorRepository authorRepository;
        private BookRepository bookRepository;
        private CollectionRepository collectionRepository;
        private UserRepository userRepository;
        private ListRepository listRepository;
        private TagRepository tagRepository;
        private RoleRepository roleRepository;
        private GenreRepository genreRepository;
        private CommentRepository commentRepository;
        private ContentRepository contentRepository;
        private ReviewRepository reviewRepository;
        private LikeRepository likeRepository;
        public IAuthorRepository Authors => authorRepository ?? (authorRepository = new AuthorRepository(context));
        public IBookRepository Books => bookRepository ?? (bookRepository = new BookRepository(context));
    

        public ICommentRepository Comments => commentRepository ?? (commentRepository = new CommentRepository(context));
        public IContentRepository Contents => contentRepository ?? (contentRepository = new ContentRepository(context));
        public IGenreRepository Genres => genreRepository ?? (genreRepository = new GenreRepository(context));
        public ILikeRepository Likes => likeRepository ?? (likeRepository = new LikeRepository(context));
        public IListRepository Lists => listRepository ?? (listRepository = new ListRepository(context));
        public ITagRepository Tags => tagRepository ?? (tagRepository = new TagRepository(context));
        public IUserRepository Users => userRepository ?? (userRepository = new UserRepository(context));
        public IReviewRepository Reviews => reviewRepository ?? (reviewRepository = new ReviewRepository(context));
        public IRoleRepository Roles => roleRepository ?? (roleRepository = new RoleRepository(context));
     
public class World : MonoBehaviour {
	public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
	public GameObject chunkPrefab;
	public string worldName = "world";
	public string seed = "hello world";
	public PhotonView photonView;
	void Start() {
		photonView = PhotonView.Get(gameObject);
		
		if(photonView.instantiationData != null) {
			object[] data = photonView.instantiationData;
			worldName = (string)data[0];
			gameObject.name = (string)data[0];
			seed = (string)data[1];
		} 
	}
	public Chunk LoadChunk(int x, int y, int z) {
		WorldPos worldPos = new WorldPos(x, y, z);
		Chunk newChunk = new Chunk();
		
		newChunk.pos = worldPos;
		newChunk.world = this;
		
		chunks.Add(worldPos, newChunk);
		
		TerrainGen terrainGen = new TerrainGen();
		newChunk = terrainGen.ChunkGen(newChunk);
		newChunk.InitBlocks();
		
		Serialization.LoadChunk(newChunk);
		return newChunk;
	}
	public void CreateChunk(Chunk chunk) {
		GameObject newChunkObj = Instantiate(chunkPrefab, 

		ChunkContainer newChunkContainer = newChunkObj.GetComponent<ChunkContainer>();
		newChunkContainer.chunk = chunk;
		newChunkContainer.chunk.container = newChunkContainer;
	}
	public void DestroyChunk(int x, int y, int z) {
		Chunk chunk = null;
		if(chunks.TryGetValue(new WorldPos(x, y, z), out chunk)) {
			Serialization.SaveChunk(chunk);
			Object.Destroy(chunk.container.gameObject);
			chunks.Remove(new WorldPos(x, y, z));
		}
	}
	public Chunk GetChunk(int x, int y, int z) {
		WorldPos pos = new WorldPos();
		float multiple = Chunk.chunkSize;
		pos.x = Mathf.FloorToInt(x/multiple) * Chunk.chunkSize;
		pos.y = Mathf.FloorToInt(y/multiple) * Chunk.chunkSize;
		pos.z = Mathf.FloorToInt(z/multiple) * Chunk.chunkSize;
		Chunk containerChunk = null;
		chunks.TryGetValue(pos, out containerChunk);
		return containerChunk;
	}
	public Block GetBlock(int x, int y, int z) {
		Chunk containerChunk = GetChunk(x, y, z);
		if(containerChunk == null)
			return new BlockAir();
		return block;
	}
	p
namespace InstrumentViewer.Tests.Instrument.Services
    public class CachingInstrumentPriceServiceScenarios
    {
        public static IEnumerable<object[]> ObserveInstrumentPricesTestData
        {
            get
            {
                yield return new object[]
                {
                    new[] { new InstrumentPrice("A", 10M), new InstrumentPrice("B", 20M) },
                    new[] { new InstrumentPrice("A", 10M), new InstrumentPrice("B", 20M) }
                };
                yield return new object[]
                {
                    new[] { new InstrumentPrice("A", 10M), new InstrumentPrice("A", 20M) },
                    new[] { new InstrumentPrice("A", 20M) }
                };
            }
        }
        [Scenario]
        [PropertyData("ObserveInstrumentPricesTestData")]
        public void ObserveInstrumentPrices(IEnumerable<InstrumentPrice> prices, IEnumerable<InstrumentPrice> expectedPrices, CachingInstrumentPriceService service)
        {

namespace VIPER.Migrations
    
    public partial class CompositeUnique : DbMigration
    {
        public override void Up()
        {
            DropForeignKey("dbo.JobProcess", new[] { "ProcessTime_ProcessTimeID", "ProcessTime_ProcessID", "ProcessTime_RepairTypeID", "ProcessTime_SizeID" }, "dbo.ProcessTime");
            DropIndex("dbo.JobProcess", new[] { "ProcessTime_ProcessTimeID", "ProcessTime_ProcessID", "ProcessTime_RepairTypeID", "ProcessTime_SizeID" });
            DropIndex("dbo.ProcessTime", new[] { "ProcessID" });
            DropIndex("dbo.ProcessTime", new[] { "RepairTypeID" });
            DropIndex("dbo.ProcessTime", new[] { "SizeID" });
            DropColumn("dbo.JobProcess", "ProcessTimeID");
            RenameColumn(table: "dbo.JobProcess", name: "ProcessTime_ProcessTimeID", newName: "ProcessTimeID");
            DropPrimaryKey("dbo.ProcessTime");
            AlterColumn("dbo.JobProcess", "ProcessTimeID", c => c.Int(nullable: false));
            AddPrimaryKey("

            CreateIndex("dbo.JobProcess", "ProcessTimeID");
            CreateIndex("dbo.ProcessTime", new[] { "ProcessID", "RepairTypeID", "SizeID" }, unique: true, name: "IX_ProcRepairSize");
            DropColumn("dbo.JobProcess", "ProcessTime_ProcessID");
            DropColumn("dbo.JobProcess", "ProcessTime_RepairTypeID");
            DropColumn("dbo.JobProcess", "ProcessTime_SizeID");
        }
        
        public override void Down()
        {
            AddColumn("dbo.JobProcess", "ProcessTime_SizeID", c => c.Int());
            AddColumn("dbo.JobProcess", "ProcessTime_RepairTypeID", c => c.Int());
            AddColumn("dbo.JobProcess", "ProcessTime_ProcessID", c => c.Int());
            DropIndex("dbo.ProcessTime", "IX_ProcRepairSize");
            DropIndex("dbo.JobProcess", new[] { "ProcessTimeID" });
            DropPrimaryKey("dbo.ProcessTime");
            AlterColumn("dbo.JobProcess", "ProcessTimeID", c => c.Int());
            AddPrimaryKey("dbo.ProcessTime", ne
namespace OpenQbit.Insurance.Presentation.Web.Controllers
    public class InsuranceController : Controller
    {
        public ActionResult Index()
        {
            return View();
        }
        
        public ActionResult AddInsurance(ApiInsuranceModel apiInsurance, ApiClientModel apiClient, ApiDocumentModel apiDocument, ApiPolicyCoverageDetailModel apiPolicyCoverageDetail, ApiCoverageModel apiCoverage)
        {
            ApiInsuranceModel insurance = new ApiInsuranceModel
            {
                ID = apiInsurance.ID,
                Joining_Date = apiInsurance.Joining_Date,
                End_Date = apiInsurance.End_Date,
                Total_Value = apiInsurance.Total_Value,
                InsuranceType = apiInsurance.InsuranceType,
                AgentID = apiInsurance.AgentID,
                Client = new ApiClientModel
                {
                    ID = apiClient.ID,
                    First_Name = apiClient.First_Name,
                    Middle_

                    Last_Name = apiClient.Middle_Name,
                    Age = apiClient.Age,
                    Address = apiClient.Address,
                    Date_of_Birth = apiClient.Date_of_Birth,
                    Gender = apiClient.Gender,
                    Nationality = apiClient.Nationality,
                    Religion = apiClient.Religion,
                    BloodGroup = apiClient.BloodGroup,
                    Email = apiClient.Email,
                    Mobile = apiClient.Mobile,
                    Telephone = apiClient.Mobile,
                },
                
                Documents = new ApiDocumentModel
                {
                    ID = apiDocument.ID,
                    InsuranceID = apiDocument.InsuranceID,
                    Authuorization = apiDocument.Authuorization,
                    Document = apiDocument.Document,
                },
                PolicyDetails=new ApiPolicyCoverageDetailModel
                {
                    
namespace WindowsFormsApplication8
    public class InaccuracyOfPositioningPart
    {
        public DataStuctures.InaccuracyOfPositioningPart.Instrument[] instruments { get; set; }
        public string[] getListInstruments()
        {
            int lengthListInstruments = instruments.Length;
            string[] listInstruments = new string[lengthListInstruments];
            for(int i = 0; i < lengthListInstruments; i++)
            {
                listInstruments[i] = instruments[i].getInstrument();
            }
            return listInstruments;
        }
        public double getDeviationOfInstallation(double requiredSize, int idOperation, string typeOfInstrument)
        {
            double deviationOfInstallation = 0;
            bool isSelectedInstrument = false;
            foreach (DataStuctures.InaccuracyOfPositioningPart.Instrument instrument in instruments)
            {
                if (instrument.isSelectedInstrument(typeOfInstrument))
                {
      
﻿namespace CloneDeploy_ApiCalls
    public interface IAPICall
    {
        ActiveImagingTaskAPI ActiveImagingTaskApi { get; }
        ActiveMulticastSessionAPI ActiveMulticastSessionApi { get; }
        AlternateServerIpAPI AlternateServerIpApi { get; }
        AuthorizationAPI AuthorizationApi { get; }
        BootEntryAPI BootEntryApi { get; }
        BootTemplateAPI BootTemplateApi { get; }
        BuildingAPI BuildingApi { get; }
        CdVersionAPI CdVersionApi { get; }
        UserAPI CloneDeployUserApi { get; }
        ClusterGroupAPI ClusterGroupApi { get; }
        ClusterGroupDistributionPointAPI ClusterGroupDistributionPointApi { get; }
        ClusterGroupServerAPI ClusterGroupServerApi { get; }
        ComputerAPI ComputerApi { get; }
        ComputerBootMenuAPI ComputerBootMenuApi { get; }
        ComputerLogAPI ComputerLogApi { get; }
        ComputerMunkiAPI ComputerMunkiApi { get; }
        ComputerProxyReservationAPI ComputerProxyReservationApi { get; }
        Dist

        FileFolderAPI FileFolderApi { get; }
        FilesystemAPI FilesystemApi { get; }
        GroupAPI GroupApi { get; }
        GroupBootMenuAPI GroupBootMenuApi { get; }
        GroupMembershipAPI GroupMembershipApi { get; }
        GroupMunkiAPI GroupMunkiApi { get; }
        GroupPropertyAPI GroupPropertyApi { get; }
        ImageAPI ImageApi { get; }
        ImageClassificationAPI ImageClassificationApi { get; }
        ImageProfileAPI ImageProfileApi { get; }
        ImageProfileFileFolderAPI ImageProfileFileFolderApi { get; }
        ImageProfileScriptAPI ImageProfileScriptApi { get; }
        ImageProfileSysprepTagAPI ImageProfileSysprepTagApi { get; }
        ImageSchemaAPI ImageSchemaApi { get; }
        MunkiManifestCatalogAPI MunkiManifestCatalogApi { get; }
        MunkiManifestIncludedManifestAPI MunkiManifestIncludedManifestApi { get; }
        MunkiManifestManagedInstallAPI MunkiManifestManagedInstallApi { get; }
        MunkiManifestManagedUnInstallAPI MunkiManife

        MunkiManifestManagedUpdateAPI MunkiManifestManagedUpdateEntityApi { get; }
        MunkiManifestOptionInstallAPI MunkiManifestOptionInstallEntity { get; }
        MunkiManifestTemplateAPI MunkiManifestTemplateApi { get; }
        NbiEntryAPI NbiEntryApi { get; }
        NetBootProfileAPI NetBootProfileApi { get; }
        OnlineKernelAPI OnlineKernelApi { get; }
        PortAPI PortApi { get; }
        RoomAPI RoomApi { get; }
        ScriptAPI ScriptApi { get; }
        SecondaryServerAPI SecondaryServerApi { get; }
        ServiceAccountAPI ServiceAccountApi { get; }
        SettingAPI SettingApi { get; }
        SiteAPI SiteApi { get; }
        SysprepTagAPI SysprepTagApi { get; }
        TokenApi TokenApi { get; }
        UserGroupAPI UserGroupApi { get; }
        UserGroupGroupManagementAPI UserGroupGroupManagementApi { get; }
        UserGroupImageManagementAPI UserGroupImageManagementApi { get; }
        UserGroupManagementAPI UserGroupManagementApi { get; }
        Use
namespace Assets.Scripts.voxel
    public class LoadChunks : MonoBehaviour
    {
        private readonly List<WorldPos> _buildList = new List<WorldPos>();
        private readonly List<WorldPos> _updateList = new List<WorldPos>();
        public World World;
        private WorldPos _initialPos;
        private int _timer;
        private void Start()
        {
            _initialPos = new WorldPos(
                Mathf.FloorToInt(transform.position.x/Chunk.ChunkSize)*Chunk.ChunkSize,
                Mathf.FloorToInt(transform.position.y/Chunk.ChunkSize)*Chunk.ChunkSize,
                Mathf.FloorToInt(transform.position.z/Chunk.ChunkSize)*Chunk.ChunkSize
                );
            PushChunkToBuildList(_initialPos);
            LoadAndRenderChunks();
        }
        private void Update()
        {
            DeleteChunks();
            FindChunksToLoad();
            LoadAndRenderChunks();
        }
        private void DeleteChunks()
        {
            if (_timer == 10)


                var chunksToDelete = new List<WorldPos>();
                foreach (var chunk in World.Chunks)
                {
                    var distance = Vector3.Distance(
                        new Vector3(chunk.Value.WorldPos.X, 0, chunk.Value.WorldPos.Z),
                        new Vector3(transform.position.x, 0, transform.position.z));
                    if (distance > 256)
                        chunksToDelete.Add(chunk.Key);
                }
                foreach (var chunk in chunksToDelete)
                    World.DestroyChunk(chunk.X, chunk.Y, chunk.Z);
                _timer = 0;
            }
            _timer++;
        }
        private void BuildChunk(WorldPos pos)
        {
            if (World.GetChunk(pos.X, pos.Y, pos.Z) == null)
                World.CreateChunk(pos.X, pos.Y, pos.Z);
            _updateList.Add(pos);
        }
        private void LoadAndRenderChunks()
        {
            for (var i = 0; i < 4; i++)
            {
            

                    continue;
                BuildChunk(_buildList[0]);
                _buildList.RemoveAt(0);
            }
            for (var i = 0; i < _updateList.Count; i++)
            {
                var chunk = World.GetChunk(_updateList[0].X, _updateList[0].Y, _updateList[0].Z);
                if (chunk != null)
                    chunk.ShouldUpdate = true;
                _updateList.RemoveAt(0);
            }
        }
        private void FindChunksToLoad()
        {
            var playerPos = new WorldPos(
                Mathf.FloorToInt(transform.position.x/Chunk.ChunkSize)*Chunk.ChunkSize,
                Mathf.FloorToInt(transform.position.y/Chunk.ChunkSize)*Chunk.ChunkSize,
                Mathf.FloorToInt(transform.position.z/Chunk.ChunkSize)*Chunk.ChunkSize
                );
            if (_buildList.Count != 0)
                return;
            for (var x = -1; x < 3; x++)
            {
                for (var z = -1; z < 3; z++)
                {
  
namespace Tandorosti.Persistence.Repository
    public interface IInstrumentRepository
    {
        IQueryable<Instrument> GetAll();
        void Update(Instrument Instrument);
        void Create(Instrument Instrument);
        void Delete(Instrument Instrument);
      
    }
    public class InstrumentRepository : BaseRepository, IInstrumentRepository
    {
        public InstrumentRepository(IUnitOfWork unitOfWork) : base(unitOfWork)
        {
        }
        public IQueryable<Instrument> GetAll()
        {
            return  GetDbSet<Instrument>();                   
        }
        public void Update(Instrument Instrument)
        {
            SetCurrentValues(GetDbSet<Instrument>().FirstOrDefault(x => x.Id == Instrument.Id), Instrument);
            UnitOfWork.SaveChanges();
        }
        public void Create(Instrument Instrument)
        {
            GetDbSet<Instrument>().Add(Instrument);
            UnitOfWork.SaveChanges();
        }
        public void Delete(Inst
public class World : NetworkBehaviour {
    public static World currentWorld;
    public bool server;
    [SyncVar]
    public int chunkWidth = 20, chunkHeight = 20, seed = 0;
	public float viewRange = 100;
	public Chunk chunkFab;
	void Start () {
        currentWorld = this;
        if (server)
        {
            if (seed == 0)
                seed = Random.Range(0, int.MaxValue);
        }
	}
	void Update () {
        if (server)
        {
            for (float x = -2 * chunkWidth; x < 2 * chunkWidth; x += chunkWidth)
            {
                for (float y = transform.position.y - viewRange; y < transform.position.y + viewRange; y += chunkHeight)
                {
                    for (float z = -2 * chunkWidth; z < 2 * chunkWidth; z += chunkWidth)
                    {
                        Vector3 pos = new Vector3(x, y, z);
                        pos.x = Mathf.Floor(pos.x / (float)chunkWidth) * chunkWidth;
                        pos.y = Mathf.Floor(pos.y / (float)ch
namespace Robot.Application.Services.DataServices
    public class BaseDataService
    {
        private IManufacturerRepository _manufacturerRepository { get; set; }
        public IManufacturerRepository ManufacturerRepository
        {
            get { return _manufacturerRepository ?? (_manufacturerRepository = new ManufacturerRepository()); }
        }
        private ICountryRepository _countryRepository { get; set; }
        public ICountryRepository CountryRepository
        {
            get { return _countryRepository ?? (_countryRepository = new CountryRepository()); }
        }
        private IModelRepository _modelRepository { get; set; }
        public IModelRepository ModelRepository
        {
            get { return _modelRepository ?? (_modelRepository = new ModelRepository()); }
        }
        private ISetPointRepository _setPointRepository { get; set; }
        public ISetPointRepository SetPointRepository
            {
                get
                {
   
namespace WorkItemHistory.DataCollection.LeadTime
    public class WeekRecord
    {
        public WeekRecord(int week)
        {
            this.Week = week;
        }
        public WeekRecord(int week, IEnumerable<ProcessAmount> processAmounts)
        {
            this.Week = week;
            this.AddProcessAmountCollection(processAmounts);
        }
        public int Week { get; set; }
        private List<ProcessAmount> _processAmounts;
        public List<ProcessAmount> ProcessAmounts
        {
            get
            {
                if (_processAmounts == null)
                    _processAmounts = new List<ProcessAmount>();
                return _processAmounts;
            }
        }
        public void AddProcessAmount(ProcessAmount processAmount)
        {
            this.ProcessAmounts.Add(processAmount);
        }
        public void AddProcessAmountCollection(IEnumerable<ProcessAmount> processAmounts)
        {
            this.ProcessAmounts.AddRange(proces
namespace Model.UnitOfWork
    public class UnitOfWork
    {
        private LoggerUtility.ILogger appLogger = LoggerUtility.Logger.GetInstance();
        #region Eventos Repositories
        private Repositories.CatColoniaRepository _catColoniaRepository;
        private Repositories.DerivadoRepository _derivadoRepository;
        public Repositories.DerivadoRepository DerivadoRepository
        {
            get { return _derivadoRepository ?? (_derivadoRepository = new DerivadoRepository(_entities)); }
        }
        private Repositories.CatEstadoRepository _catEstadoRepository;
        public Repositories.CatEstadoRepository CatEstadoRepository
        {
            get { return _catEstadoRepository ?? (_catEstadoRepository = new CatEstadoRepository(_entities)); }
           
        }
        private Repositories.CatMunicipioRepository _catMunicipioRepository;
        public Repositories.CatMunicipioRepository CatMunicipioRepository
        {
            get { return _catMunici

        }
        private Repositories.CatPaisRepository _catPaisRepository;
        public Repositories.CatPaisRepository CatPaisRepository
        {
            get { return _catPaisRepository ?? (_catPaisRepository = new CatPaisRepository(_entities)); }
        }
        private Repositories.CatRolesRepository _catRolesRepository;
        public Repositories.CatRolesRepository CatRolesRepository
        {
            get { return _catRolesRepository ?? (_catRolesRepository = new CatRolesRepository(_entities)); }
        }
        private Repositories.CitasRepository _citasRepository;
        public Repositories.CitasRepository CitasRepository
        {
            get { return _citasRepository ?? (_citasRepository = new CitasRepository(_entities)); }
        }
        private Repositories.CobroConsultaRepository _CobroConsultaRepository;
        public Repositories.CobroConsultaRepository CobroConsultaRepository
        {
            get { return _CobroConsultaRepository ?? (_Cobro

        }
        private Repositories.ConsultoriosRepository _ConsultoriosRepository;
        public Repositories.ConsultoriosRepository ConsultoriosRepository
        {
            get { return _ConsultoriosRepository ?? (_ConsultoriosRepository = new ConsultoriosRepository(_entities)); }
        }
        private Repositories.ConsultoriosTiposRepository _ConsultoriosTiposRepository;
        public Repositories.ConsultoriosTiposRepository ConsultoriosTiposRepository
        {
            get { return _ConsultoriosTiposRepository ?? (_ConsultoriosTiposRepository = new ConsultoriosTiposRepository(_entities)); }
        }
        private Repositories.CostosConsultasFijasRepository _CostosConsultasFijasRepository;
        public Repositories.CostosConsultasFijasRepository CostosConsultasFijasRepository
        {
            get { return _CostosConsultasFijasRepository ?? (_CostosConsultasFijasRepository = new CostosConsultasFijasRepository(_entities)); }
        }
        private Reposi
@{
    ViewBag.Title = "UpdateData";
<h2>Update Data</h2>
<div class="table-responsive">
    <table class="table">
        <thead>
            <tr>
                <th>First Name</th>
                <th>Last Name</th>
                <th>Address</th>
                <th>City</th>
                <th>State</th>
                <th>Phone NUmber</th>
                <th>Instrument Name</th>
                <th>Type</th>
                <th>Price</th>
            </tr>
        </thead>
   
@foreach (var instrument in ViewBag.instruments)
    if (instrument.Client != null)
    {
        <tbody>
            <tr>
                <td>@instrument.Client.Firstname</td>
           
           
                <td>@instrument.Client.Lastname</td>
            
            
                <td>@instrument.Client.Address</td>
           
           
                <td>@instrument.Client.City</td>
            
           
                <td>@instrument.Client.State</td>
          
          
      
namespace Warden.Tests.Watchers.Process
    public class ProcessWatcher_specs
    {
        protected static ProcessWatcher Watcher { get; set; }
        protected static ProcessWatcherConfiguration Configuration { get; set; }
        protected static IWatcherCheckResult CheckResult { get; set; }
        protected static ProcessWatcherCheckResult ProcessCheckResult { get; set; }
        protected static Exception Exception { get; set; }
        protected static int ProcessId { get; set; } = 1;
        protected static string ProcessName { get; set; } = "Process";
        protected static bool ProcessResponding { get; set; } = true;
        protected static bool ProcessExists { get; set; } = true;
    }
    [Subject("Process watcher initialization")]
    public class when_initializing_without_configuration : ProcessWatcher_specs
    {
        Establish context = () => Configuration = null;
        Because of = () => Exception = Catch.Exception((() => Watcher = ProcessWatcher.Create("tes

        It should_fail = () => Exception.Should().BeOfType<ArgumentNullException>();
        It should_have_a_specific_reason = () => Exception.Message.Should().Contain("Process Watcher configuration has not been provided.");
    }
    [Subject("Process watcher execution")]
    public class when_invoking_execute_async_method_with_valid_configuration : ProcessWatcher_specs
    {
        static Mock<IProcessService> ProcessMock;
        static ProcessInfo ProcessInfo;
        Establish context = () =>
        {
            ProcessMock = new Mock<IProcessService>();
            ProcessInfo = ProcessInfo.Create(ProcessId, ProcessName, null, ProcessExists, ProcessResponding);
            ProcessMock.Setup(x =>
                x.GetProcessInfoAsync(Moq.It.IsAny<string>(), null))
                .ReturnsAsync(ProcessInfo);
            Configuration = ProcessWatcherConfiguration
                .Create(ProcessName)
                .WithProcessServiceProvider(() => ProcessMock.Object)
        

            Watcher = ProcessWatcher.Create("Process watcher", Configuration);
        };
        Because of = async () =>
        {
            CheckResult = await Watcher.ExecuteAsync().Await().AsTask;
            ProcessCheckResult = CheckResult as ProcessWatcherCheckResult;
        };
        It should_invoke_process_get_process_info_async_method_only_once = () =>
            ProcessMock.Verify(x => x.GetProcessInfoAsync(Moq.It.IsAny<string>(), null), Times.Once);
        It should_have_valid_check_result = () => CheckResult.IsValid.Should().BeTrue();
        It should_have_check_result_of_type_process = () => ProcessCheckResult.Should().NotBeNull();
        It should_have_set_values_in_process_check_result = () =>
        {
            ProcessCheckResult.WatcherName.Should().NotBeEmpty();
            ProcessCheckResult.WatcherType.Should().NotBeNull();
            ProcessCheckResult.ProcessInfo.Should().NotBeNull();
            ProcessCheckResult.ProcessInfo.Id.ShouldBeEquivalent
namespace BeerHouse.Database {
    public class UnitOfWork : IDisposable {
        private readonly BeerHouseEntities _context = new BeerHouseEntities();
        private Repository<Album> _albumRepository;
        private Repository<Article> _articleRepository;
        private Repository<Category> _categoryRepository;
        private Repository<Comment> _commentRepository;
        private Repository<Department> _departmentRepository;
        private bool _disposed;
        private Repository<Event> _eventRepository;
        private Repository<Forum> _forumRepository;
        private Repository<Newsletter> _newsletterRepository;
        private Repository<OrderItem> _orderItemRepository;
        private Repository<Order> _orderRepository;
        private Repository<OrderStatus> _orderStatusRepository;
        private Repository<PollOption> _pollOptionRepository;
        private Repository<Poll> _pollRepository;
        private Repository<Post> _postRepository;
        private Repository

        private Repository<ShippingMethod> _shippingMethodRepository;
        public Repository<Article> ArticleRepository
            => _articleRepository ??
               (_articleRepository = new Repository<Article>( _context ));
        public Repository<Album> AlbumRepository
            => _albumRepository ??
               (_albumRepository = new Repository<Album>( _context ));
        public Repository<Category> CategoryRepository
            => _categoryRepository ??
               (_categoryRepository = new Repository<Category>( _context ));
        public Repository<Comment> CommentRepository
            => _commentRepository ??
               (_commentRepository = new Repository<Comment>( _context ));
        public Repository<Department> DepartmentRepository
            => _departmentRepository ??
               (_departmentRepository = new Repository<Department>( _context ));
        public Repository<Event> EventRepository
            => _eventRepository ??
          

        public Repository<Forum> ForumRepository
            => _forumRepository ??
               (_forumRepository = new Repository<Forum>( _context ));
        public Repository<Newsletter> NewsletterRepository
            => _newsletterRepository ??
               (_newsletterRepository = new Repository<Newsletter>( _context ));
        public Repository<Order> OrderRepository
            => _orderRepository ??
               (_orderRepository = new Repository<Order>( _context ));
        public Repository<OrderItem> OrderItemRepository
            => _orderItemRepository ??
               (_orderItemRepository = new Repository<OrderItem>( _context ));
        public Repository<OrderStatus> OrderStatusRepository
            => _orderStatusRepository ??
               (_orderStatusRepository = new Repository<OrderStatus>( _context ));
        public Repository<Poll> PollRepository
            => _pollRepository ??
               (_pollRepository = new Repository<Poll>( _context ));
public class SampleSimpleChunkLoader : ChunkLoader
	public override void LoadChunk(Chunk chunk)
	{
		WorldChunk wChunk = chunk as WorldChunk;
		if (wChunk == null)
			return;
		chunk.InitBlocks(wChunk.World.ChunkSizeX, wChunk.World.ChunkSizeY, wChunk.World.ChunkSizeZ);
		for (int x = 0; x < wChunk.SizeX; x++)
			for (int z = 0; z < wChunk.SizeZ; z++)
			{
				if (x == 0 && z != 0)
					wChunk.SetBlock(x, 0, z, new Block { Color = new Color32() { a = 255, r = 0, g = 0, b = 255 }, Type = Block.BlockTypes.Solid }, false);
				else if (z == 0 && x != 0)
					wChunk.SetBlock(x, 0, z, new Block { Color = new Color32() { a = 255, r = 255, g = 0, b = 0 }, Type = Block.BlockTypes.Solid }, false);
				else if ((x + z) % 2 == 0)
					wChunk.SetBlock(x, 0, z, new Block { Color = new Color32() { a = 255, r = 127, g = 127, b = 127 }, Type = Block.BlockTypes.Solid }, false);
				else
					wChunk.SetBlock(x, 0, z, new Block { Color = new Color32() { a = 255, r = 50, g = 255, b = 50 }, Type = Block.Blo
namespace Web.Services
    public class K8sServices
    {
        public K8sServices() { }
        public K8sServices(string kubeApiAddress)
        {
            ApiAddress = kubeApiAddress;
        }
        public string ApiAddress { get; set; }
        public BindingApi Binding { get { return new BindingApi(ApiAddress); } }
        public ComponentStatusApi ComponentStatus { get { return new ComponentStatusApi(ApiAddress); } }
        public ConfigMapApi ConfigMap { get { return new ConfigMapApi(ApiAddress); } }
        public EndpointApi Endpoint { get { return new EndpointApi(ApiAddress); } }
        public EventApi Event { get { return new EventApi(ApiAddress); } }
        public LimitRangeApi LimitRange { get { return new LimitRangeApi(ApiAddress); } }
        public NamespaceApi Namespace { get { return new NamespaceApi(ApiAddress); } }
        public NodeApi Node { get { return new NodeApi(ApiAddress); } }
        public PersistentVolumeApi PersistentVolume { get { return new
namespace BookMarket.Services
    {
        protected CommonRepository _commonRepository = new CommonRepository();
        protected IDbModelRepository _addressRepository =
            new AddressRepository();
        protected IDbModelRepository _authorRepository =
            new AuthorRepository();
        protected IDbModelRepository _basketRepository = 
            new BasketRepository();
        protected IDbModelRepository _basketItemRepository =
            new BasketItemRepository();
        protected IDbModelRepository _bookRepository = new BookRepository();
        protected IDbModelRepository _bookTagRepository =
            new BookTagRepository();
        protected IDbModelRepository _bookVariableInfoRepository =
            new BookVariableInfoRepository();
        protected IDbModelRepository _cityRepository = new CityRepository();
        protected IDbModelRepository _individualRepository =
            new IndividualRepository();
        protected IDbModelRepository _l
namespace WcfRestContrib.ServiceModel.Description
    public class WebDispatchFormatterAttribute : Attribute, IOperationBehavior
    {
        private readonly WebDispatchFormatterBehavior _behavior;
        public WebDispatchFormatterAttribute() : this(WebDispatchFormatter.FormatterDirection.Both)
        {
        }
        public WebDispatchFormatterAttribute(WebDispatchFormatter.FormatterDirection direction)
        {
            _behavior = new WebDispatchFormatterBehavior(direction);
        }
        public void ApplyDispatchBehavior(OperationDescription operationDescription, DispatchOperation dispatchOperation)
        {
            _behavior.ApplyDispatchBehavior(operationDescription, dispatchOperation);
        }
        public void ApplyClientBehavior(OperationDescription operationDescription, ClientOperation clientOperation)
        {
            _behavior.ApplyClientBehavior(operationDescription, clientOperation);
        }
        public void AddBindingParameters(Operatio
namespace YourMdb.Client.Entities
    public partial class TrackArtistInstrument : ObjectBase
    {
        private int _trackArtistInstrumentId;
        private int _trackArtistId;
        private int _instrumentId;
        private Instrument _instrument;
        private TrackArtist _trackArtist;
        public int TrackArtistInstrumentId
        {
            get { return _trackArtistInstrumentId; }
            set
            {
                if (value == _trackArtistInstrumentId) return;
                _trackArtistInstrumentId = value;
                OnPropertyChanged();
            }
        }
        public int TrackArtistId
        {
            get { return _trackArtistId; }
            set
            {
                if (value == _trackArtistId) return;
                _trackArtistId = value;
                OnPropertyChanged();
            }
        }
        public int InstrumentId
        {
            get { return _instrumentId; }
            set
            {
       
namespace TournamentWebApi.DAL.UnitsOfWorks
    public class UnitOfWork : IUnitOfWork
    {
        private readonly IRepositoryFactory _repositoryFactory;
        private IGenericRepository<Account> _accountRepository;
        private IGenericRepository<Match> _matchRepository;
        private IGenericRepository<Player> _playerRepository;
        private IGenericRepository<Role> _roleRepository;
        public UnitOfWork(IRepositoryFactory repositoryFactory)
        {
            _repositoryFactory = repositoryFactory;
        }
        public IGenericRepository<Account> AccountRepository
        {
            get { return _accountRepository ?? (_accountRepository = _repositoryFactory.GetRepository<Account>()); }
        }
        public IGenericRepository<Match> MatchRepository
        {
            get { return _matchRepository ?? (_matchRepository = _repositoryFactory.GetRepository<Match>()); }
        }
        public IGenericRepository<Player> PlayerRepository
        {
         
namespace Portal
    public class PortalFacade
    {
        #region[Instancia]
        private static PortalFacade mSingleton;
        public static PortalFacade Singleton
        {
            get
            {
                if (mSingleton == null) mSingleton = new PortalFacade();
                return mSingleton;
            }
        }
        #endregion
        #region[Controladores]
        private PortalController mPortalController;
        public PortalController PortalController
        {
            get
            {
                if (mPortalController == null) mPortalController = new PortalController();
                return mPortalController;
            }
        }
        private AutenticacionController mAutenticacionController;
        public AutenticacionController AutenticacionController
        {
            get
            {
                if (mAutenticacionController == null) mAutenticacionController = new AutenticacionController();
                return mAu

            }
        }
        private PaginaController mPaginaController;
        public PaginaController PaginaController
        {
            get
            {
                if (mPaginaController == null) mPaginaController = new PaginaController();
                return mPaginaController;
            }
        }
        private MenuController mMenuController;
        public MenuController MenuController
        {
            get
            {
                if (mMenuController == null) mMenuController = new MenuController();
                return mMenuController;
            }
        }
        private PermisoController mPermisoController;
        public PermisoController PermisoController
        {
            get
            {
                if (mPermisoController == null) mPermisoController = new PermisoController();
                return mPermisoController;
            }
        }
        private PerfilController mPerfilController;
        public PerfilController Perfi

        {
            get
            {
                if (mPerfilController == null) mPerfilController = new PerfilController();
                return mPerfilController;
            }
        }
        private SistemaController mSistemaController;
        public SistemaController SistemaController
        {
            get
            {
                if (mSistemaController == null) mSistemaController = new SistemaController();
                return mSistemaController;
            }
        }
        private UsuarioController musuarioController;
        public UsuarioController UsuarioController
        {
            get
            {
                if (musuarioController == null) musuarioController = new UsuarioController();
                return musuarioController;
            }
        }
        private PerfilPermisoController mPerfilPermisoController;
        public PerfilPermisoController PerfilPermisoController
        {
            get
            {
                if (m
﻿#region
#endregion
namespace WorldGeneration.Core
    public class GeneratorChunkLoader
    {
        private readonly int _biomeSizeInChunks;
        private readonly int _chunkSize;
        private readonly Dictionary<IntVector2, GeneratorChunk> _chunks = new Dictionary<IntVector2, GeneratorChunk>();
        private readonly World _world;
        private Task _activeTask = null;
        public GeneratorChunkLoader(World world)
        {
            _world = world;
            _chunkSize = world.ChunkSize;
            _biomeSizeInChunks = world.BiomeSizeInChunks;
        }
        public GeneratorChunk GetChunk(IntVector2 gridPosition)
        {
            int x = Mathx.DivideRoundDown(gridPosition.x, _chunkSize);
            int y = Mathx.DivideRoundDown(gridPosition.y, _chunkSize);
            IntVector2 chunkIndex = new IntVector2(x, y);
            return GetChunkByIndex(chunkIndex);
        }
        public GeneratorChunk GetChunk(GeneratorChunk chunk, Direction direction)
    

            return GetChunkByIndex(chunk.ChunkIndex + direction.Offset());
        }
        public GeneratorChunk GetBiomeChunk(GeneratorChunk chunk)
        {
            return GetBiomeChunk(chunk, IntVector2.ZERO);
        }
        public GeneratorChunk GetBiomeChunk(GeneratorChunk chunk, Direction direction)
        {
            return GetBiomeChunk(chunk, direction.Offset());
        }
        private GeneratorChunk GetBiomeChunk(GeneratorChunk chunk, IntVector2 offset)
        {
            int x = Mathx.DivideRoundDown(chunk.ChunkIndex.x, _biomeSizeInChunks);
            int y = Mathx.DivideRoundDown(chunk.ChunkIndex.y, _biomeSizeInChunks);
            IntVector2 chunkIndex = new IntVector2(x, y);
            chunkIndex += offset;
            chunkIndex *= _biomeSizeInChunks;
            return GetChunkByIndex(chunkIndex);
        }
        private GeneratorChunk GetChunkByIndex(IntVector2 chunkIndex)
        {
            if (!_chunks.ContainsKey(chunkIndex))
            {


            }
            return _chunks[chunkIndex];
        }
        public GeneratorChunk GetFullyGeneratedChunk(IntVector2 gridPosition)
        {
            GeneratorChunk chunk = GetChunk(gridPosition);
            if (chunk.CurrentState != GeneratorChunk.State.Done)
            {
                
                if (_activeTask != null)
                {
                    if (chunk.CurrentState != GeneratorChunk.State.ReadyToTriggerNeighbours)
                    {
                        _activeTask.Wait();
                    }
                    if (_activeTask.IsCompleted)
                    {
                        _activeTask = null;
                    }
                }
                if (_activeTask == null)
                {
                    chunk.GenerateToState(GeneratorChunk.State.Done);
                    _activeTask = Task.Run(() => PrepareNeighbours(chunk));
                }
            }
            return chunk;
        }
        private void Pre
namespace NAJAudio.FileFormats.SoundFont 
	internal class InstrumentBuilder : StructureBuilder<Instrument>
	{
		private Instrument lastInstrument = null;
        public override Instrument Read(BinaryReader br) 
		{
			Instrument i = new Instrument();
			string s = Encoding.UTF8.GetString(br.ReadBytes(20), 0, 20);
			if(s.IndexOf('\0') >= 0) 
			{
				s = s.Substring(0,s.IndexOf('\0'));
			}
			i.Name = s;
			i.startInstrumentZoneIndex = br.ReadUInt16();
			if(lastInstrument != null)
			{
				lastInstrument.endInstrumentZoneIndex = (ushort) (i.startInstrumentZoneIndex - 1);
			}
			data.Add(i);
			lastInstrument = i;
			return i;
		}
        public override void Write(BinaryWriter bw, Instrument instrument) 
		{
		}
		public override int Length 
		{
			get 
			{
				return 22;
			}
		}
		public void LoadZones(Zone[] zones)
		{
			for(int instrument = 0; instrument < data.Count - 1; instrument++)
			{
				Instrument i = (Instrument) data[instrument];
				i.Zones = new Zone[i.endInstrume
namespace MinecraftClient.Mapping
    public class World
    {
        private Dictionary<int, Dictionary<int, ChunkColumn>> chunks = new Dictionary<int, Dictionary<int, ChunkColumn>>();
        public ChunkColumn this[int chunkX, int chunkZ]
        {
            get
            {
                if (chunks.ContainsKey(chunkX))
                    if (chunks[chunkX].ContainsKey(chunkZ))
                        return chunks[chunkX][chunkZ];
                return null;
            }
            set
            {
                if (value != null)
                {
                    if (!chunks.ContainsKey(chunkX))
                        chunks[chunkX] = new Dictionary<int, ChunkColumn>();
                    chunks[chunkX][chunkZ] = value;
                }
                else
                {
                    if (chunks.ContainsKey(chunkX))
                    {
                        if (chunks[chunkX].ContainsKey(chunkZ))
                        {
                         

                            if (chunks[chunkX].Count == 0)
                                chunks.Remove(chunkX);
                        }
                    }
                }
            }
        }
        public ChunkColumn GetChunkColumn(Location location)
        {
            return this[location.ChunkX, location.ChunkZ];
        }
        public Block GetBlock(Location location)
        {
            ChunkColumn column = GetChunkColumn(location);
            if (column != null)
            {
                Chunk chunk = column.GetChunk(location);
                if (chunk != null)
                    return chunk.GetBlock(location);
            }
            return new Block(Material.Air);
        }
        public void SetBlock(Location location, Block block)
        {
            ChunkColumn column = this[location.ChunkX, location.ChunkZ];
            if (column != null)
            {
                Chunk chunk = column[location.ChunkY];
                if (chunk == null
﻿namespace VRTK.UnityEventHelper
    [AddComponentMenu("VRTK/Scripts/Utilities/Unity Events/VRTK_HeadsetControllerAware_UnityEvents")]
    public sealed class VRTK_HeadsetControllerAware_UnityEvents : VRTK_UnityEvents<VRTK_HeadsetControllerAware>
    {
        [Serializable]
        public sealed class HeadsetControllerAwareEvent : UnityEvent<object, HeadsetControllerAwareEventArgs> { }
        public HeadsetControllerAwareEvent OnControllerObscured = new HeadsetControllerAwareEvent();
        public HeadsetControllerAwareEvent OnControllerUnobscured = new HeadsetControllerAwareEvent();
        public HeadsetControllerAwareEvent OnControllerGlanceEnter = new HeadsetControllerAwareEvent();
        public HeadsetControllerAwareEvent OnControllerGlanceExit = new HeadsetControllerAwareEvent();
        protected override void AddListeners(VRTK_HeadsetControllerAware component)
        {
            component.ControllerObscured += ControllerObscured;
            component.ControllerUnobscure

            component.ControllerGlanceEnter += ControllerGlanceEnter;
            component.ControllerGlanceExit += ControllerGlanceExit;
        }
        protected override void RemoveListeners(VRTK_HeadsetControllerAware component)
        {
            component.ControllerObscured -= ControllerObscured;
            component.ControllerUnobscured -= ControllerUnobscured;
            component.ControllerGlanceEnter -= ControllerGlanceEnter;
            component.ControllerGlanceExit -= ControllerGlanceExit;
        }
        private void ControllerObscured(object o, HeadsetControllerAwareEventArgs e)
        {
            OnControllerObscured.Invoke(o, e);
        }
        private void ControllerUnobscured(object o, HeadsetControllerAwareEventArgs e)
        {
            OnControllerUnobscured.Invoke(o, e);
        }
        private void ControllerGlanceEnter(object o, HeadsetControllerAwareEventArgs e)
        {
            OnControllerGlanceEnter.Invoke(o, e);
        }
        
namespace MVVMCalcPrism.ViewModel
    public class CalculateTypeViewModel : ViewModelBase
    {
        public CalculateType CalculateType { get; private set; }
        public string Label { get; private set; }
        public CalculateTypeViewModel(CalculateType calculateType, string label)
        {
            this.CalculateType = calculateType;
            this.Label = label;
        }
        private static Dictionary<CalculateType, string> typeLabelMap = new Dictionary<CalculateType, string>
        {
            {CalculateType.None, "未選択"},
            {CalculateType.Add, "足し算"},
            {CalculateType.Sub, "引き算"},
            {CalculateType.Mul, "掛け算"},
            {CalculateType.Div, "割り算"}
        };
        public static CalculateTypeViewModel Create(CalculateType type)
        {
            return new CalculateTypeViewModel(type, typeLabelMap[type]);
        }
        public static IEnumerable<CalculateTypeViewModel> Create()
        {
            foreach(CalculateType e
namespace JobProcessor.Implementation
    class CacheJobChunkRegistrator : IJobChunkRegistrator
    {
        #region Consts
        private const string JobSumKeyPrefix = "Job_";
        private const string JobChunkKeyPrefix = "Chunk_";
        #endregion Consts
        #region Events
        public event Action<object, string> JobMapComplete;
        public event Action<object, string> JobReduceComplete;
        #endregion Events
        #region Public Methods
        public void RegisterNewMapChunk(JobChunkUid chunkUid)
        {
            Logger.Log.Instance.Info(string.Format("CacheJobChunkRegistrator. Register new map chunk. JobId '{0}', ChunkId '{1}'",
                chunkUid.JobId,
                chunkUid.ChunkId));
            UpdateJobSummeryInCache(chunkUid);
            AddChunkToCache(chunkUid, ProcessingMode.Map);
        }
        
        public void RegisterNewReduceChunk(JobChunkUid chunkUid)
        {
            Logger.Log.Instance.Info(string.Format("CacheJobC

                chunkUid.JobId,
                chunkUid.ChunkId));
            UpdateJobSummeryInCache(chunkUid);
            AddChunkToCache(chunkUid, ProcessingMode.Reduce);
        }
        public void UpdateChunkMapSent(JobChunkUid chunkUid)
        {
            Logger.Log.Instance.Info(string.Format("CacheJobChunkRegistrator. Map chunk sent. JobId '{0}', ChunkId '{1}'",
                chunkUid.JobId,
                chunkUid.ChunkId));
            UpdateChunkStatusInCache(chunkUid, ChunkStatus.MapSent, ProcessingMode.Map);
        }
        public void UpdateChunkMapComplete(JobChunkUid chunkUid)
        {
            Logger.Log.Instance.Info(string.Format("CacheJobChunkRegistrator. Map chunk complete. JobId '{0}', ChunkId '{1}'",
                chunkUid.JobId,
                chunkUid.ChunkId));
            
            UpdateChunkStatusInCache(chunkUid, ChunkStatus.MapCompleted, ProcessingMode.Map);
            if (AllJobChunksCompleted(chunkUid.JobId, ProcessingMode.Map))

            {
                Logger.Log.Instance.Info(string.Format("CacheJobChunkRegistrator. Map of all job chunks complete. JobId '{0}'",
                    chunkUid.JobId));
                
                var jobMapComplete = JobMapComplete;
                if (jobMapComplete != null)
                {
                    Logger.Log.Instance.Info(string.Format("CacheJobChunkRegistrator. Raise job map complete event for JobId '{0}'",
                        chunkUid.JobId));
                    jobMapComplete(this, chunkUid.JobId);
                }
            }
        }
        public void UpdateChunkReduceSent(JobChunkUid chunkUid)
        {
            Logger.Log.Instance.Info(string.Format("CacheJobChunkRegistrator. Reduce chunk sent. JobId '{0}', ChunkId '{1}'",
                chunkUid.JobId,
                chunkUid.ChunkId));
            UpdateChunkStatusInCache(chunkUid, ChunkStatus.ReduceSent, ProcessingMode.Reduce);
        }
        public void UpdateChunkReduceCo
namespace ECommon.Storage
    public class ChunkWriter
    {
        public Chunk CurrentChunk { get { return _currentChunk; } }
        private readonly ChunkManager _chunkManager;
        private readonly IScheduleService _scheduleService;
        private readonly object _lockObj = new object();
        private bool _isClosed = false;
        private Chunk _currentChunk;
        public ChunkWriter(ChunkManager chunkManager)
        {
            Ensure.NotNull(chunkManager, "chunkManager");
            _chunkManager = chunkManager;
            _scheduleService = ObjectContainer.Resolve<IScheduleService>();
        }
        public void Open()
        {
            _currentChunk = _chunkManager.GetLastChunk();
            if (!_chunkManager.IsMemoryMode && !_chunkManager.Config.SyncFlush)
            {
                _scheduleService.StartTask("FlushChunk", Flush, 1000, _chunkManager.Config.FlushChunkIntervalMilliseconds);
            }
            _isClosed = false;
        }
      

        {
            lock (_lockObj)
            {
                if (_isClosed)
                {
                    return -1L;
                }
                if (_currentChunk.IsCompleted)
                {
                    _currentChunk = _chunkManager.AddNewChunk();
                }
                var result = _currentChunk.TryAppend(record);
                if (!result.Success)
                {
                    _currentChunk.Complete();
                    _currentChunk = _chunkManager.AddNewChunk();
                    result = _currentChunk.TryAppend(record);
                    if (!result.Success)
                    {
                        throw new ChunkWriteException(_currentChunk.ToString(), "Write record to chunk failed.");
                    }
                }
                if (!_chunkManager.IsMemoryMode && _chunkManager.Config.SyncFlush)
                {
                    _currentChunk.Flush();
                }
                return result.P
namespace w_Apartments.DAL
    public class UnitOfWork : IUnitOfWork, IDisposable
    {
        private readonly ApartmentContext _context = new ApartmentContext();
        private GenericRepository<Amenities> amenitiesRepository;
        private GenericRepository<Apartment> apartmentRepository;
        private GenericRepository<Description> descriptionRepository;
        private GenericRepository<FilePath> filePathRepository;
        private GenericRepository<HouseRules> houseRulesRepository;
        private GenericRepository<Location> locationRepository;
        private GenericRepository<Prices> pricesRepository;
        private GenericRepository<TheSpace> theSpaceRepository;
        private GenericRepository<User> userRepository;
        #region GenericRepository<Amenities> AmenitiesRepository
        public GenericRepository<Amenities> AmenitiesRepository
        {
            get
            {
                if (this.amenitiesRepository == null)
                    this.amenities

                return amenitiesRepository;
            }
        #endregion
        #region GenericRepository<Apartment> ApartmentRepository
        public GenericRepository<Apartment> ApartmentRepository
        {
            get
            {
                if (this.apartmentRepository == null)
                    this.apartmentRepository = new GenericRepository<Apartment>(_context);
                return apartmentRepository;
            }
        #endregion
        #region GenericRepository<Description> DescriptionRepository
        public GenericRepository<Description> DescriptionRepository
        {
            get
            {
                return this.descriptionRepository ??
                       (this.descriptionRepository = new GenericRepository<Description>(_context));
            }
        }
        #endregion
        #region GenericRepository<FilePath> FilePathRepository
        public GenericRepository<FilePath> FilePathRepository
        {
            get
       

                return this.filePathRepository ?? (this.filePathRepository = new GenericRepository<FilePath>(_context));
            }
        }
        #endregion
        #region GenericRepository<HouseRules> houseRulesRepository
        public GenericRepository<HouseRules> HouseRulesRepository
        {
            get
            {
                return this.houseRulesRepository ??
                       (this.houseRulesRepository = new GenericRepository<HouseRules>(_context));
            }
        }
        #endregion
        #region GenericRepository<Location> LocationRepository
        public GenericRepository<Location> LocationRepository
        {
            get { return this.locationRepository ?? (this.locationRepository = new GenericRepository<Location>(_context)); }
        }
        #endregion
        #region  GenericRepository<Prices> PricesRepository
        public GenericRepository<Prices> PricesRepository
        {
            get { return this.pricesRepository ?? (t
namespace TransitionsDemo
	public partial class NavigationController : UINavigationController
	{
		[Export ("initWithCoder:")]
		public NavigationController (NSCoder coder) : base (coder)
		{
			WeakDelegate = this;
		}
		[Export ("navigationController:animationControllerForOperation:fromViewController:toViewController:")]
		public IUIViewControllerAnimatedTransitioning GetAnimationControllerForOperation (UINavigationController navigationController,
		                                                                                  UINavigationControllerOperation operation,
		                                                                                  UIViewController fromViewController,
		                                                                                  UIViewController toViewController)
		{
			if (AppDelegate.NavigationControllerInteractionController != null) {
				AppDelegate.NavigationControllerInteractionController.WireToViewController (toViewController,
				 
namespace FreeQuant.Instruments
    public class Pricer : IPricer
    {
        public virtual double Price(Instrument instrument)
        {
            if (instrument.Trade.DateTime != DateTime.MinValue && instrument.Trade.DateTime >= instrument.Bar.DateTime)
                return instrument.Trade.Price;
            if (instrument.Bar.DateTime != DateTime.MinValue)
                return instrument.Bar.Close;
            Daily last = (Daily)(instrument.GetDailySeries()).Last;
            if (last != null)
                return last.Close;
            else
                return 0.0;
        }
        public virtual double Volatility(Instrument instrument)
        {
            return 0.0;
        }
        public virtual double Delta(Instrument instrument)
        {
            return 0.0;
        }
        public virtual double Gamma(Instrument instrument)
        {
            return 0.0;
        }
        public virtual double Theta(Instrument instrument)
        {
            re

        }
        public virtual double Vega(Instrument instrument)
        {
            return 0.0;
        }
        public virtual double Rho(Instrument instrument)
        {
            return 0.0;
        }
        public virtual double Price(Instrument instrument, DateTime dateTime)
        {
            return instrument.GetDailySeries()[dateTime.Date, EIndexOption.Prev].Close;
        }
        public virtual double Volatility(Instrument instrument, DateTime dateTime1, DateTime dateTime2)
        {
            return 0.0;
        }
        public virtual double Delta(Instrument instrument, DateTime dateTime)
        {
            return 0.0;
        }
        public virtual double Gamma(Instrument instrument, DateTime dateTime)
        {
            return 0.0;
        }
        public virtual double Theta(Instrument instrument, DateTime dateTime)
        {
            return 0.0;
        }
        public virtual double Vega(Instrument instrument, DateTime dateTime)
        {
﻿namespace CannedBytes.Media.IO
    [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix", Justification = "It is a stack, lets call it a stack.")]
    public class FileChunkStack
    {
        private Stack<FileChunk> chunkStack = new Stack<FileChunk>();
        public void Clear()
        {
            this.chunkStack.Clear();
        }
        public FileChunk RootChunk
        {
            get
            {
                if (this.chunkStack.Count >= 1)
                {
                    return this.chunkStack.ToArray()[0];
                }
                return null;
            }
            set
            {
                if (this.chunkStack.Count != 0)
                {
                    throw new InvalidOperationException("Root Chunk has already been set.");
                }
                this.PushChunk(value);
            }
        }
        public FileChunk CurrentChunk
        {
            get
            {
                if (
namespace VideoRentDAL.Persistence
    public class UnitOfWork : IUnitOfWork
    {
        private readonly VideoRentContext _context;
        private ICustomerRepository _customerRepository;
        private IGenreRepository _genreRepository;
        private IMembershipTypeRepository _membershipTypeRepository;
        private IMovieRepository _movieMovieRepository;
        private IRentalRepository _rentalRepository;
        public UnitOfWork(string connString)
        {
            _context = new VideoRentContext(connString);
            
        }
        public IMovieRepository MoviesRepository => _movieMovieRepository ??
                                                   (_movieMovieRepository = new MovieRepository(_context));
        public ICustomerRepository CustomersRepository => _customerRepository ??
                                                   (_customerRepository = new CustomerRepository(_context));
        public IMembershipTypeRepository MembershipTypeRepository => 
namespace ControllerHiding.Routing
    public class HomeActionResult : ActionResult
    {
        public override void ExecuteResult(ControllerContext context)
        {
            var factory = ControllerBuilder.Current.GetControllerFactory();
            var homeControllerName = context.RouteData.Values["controller"]?.ToString();
            ControllerBase controller = null;
            try
            {
                controller = factory.CreateController(context.RequestContext, homeControllerName) as ControllerBase;
                if (controller == null)
                {
                    throw new InvalidOperationException("Could not create controller with name " + homeControllerName + ".");
                }
                CopyControllerData(context, controller);
                ExecuteController(context, controller);
            }
            finally
            {
                DisposeController(controller, factory);
            }
        }
        private static void D

        {
            if (controller != null)
            {
                factory.ReleaseController(controller);
            }
            if (controller == null)
            {
                return;
            }
            var disposable = controller as IDisposable;
            disposable?.Dispose();
        }
        private static void ExecuteController(ControllerContext context, IController controller)
        {
            controller.Execute(context.RequestContext);
        }
        private static void CopyControllerData(ControllerContext context, ControllerBase controller)
        {
            controller.ViewData.ModelState.Merge(context.Controller.ViewData.ModelState);
            foreach (var data in context.Controller.ViewData)
            {
                controller.ViewData[data.Key] = data.Value;
            }
            var target = controller as Controller;
            var source = context.Controller as ChildController;
            if (target == null || source =
namespace IITAcademicAutomationSystem.DAL
    public class UnitOfWork : IDisposable
    {
        private ApplicationDbContext context = new ApplicationDbContext();
        private IUserRepository userRepository;
        private IRoleRepository roleRepository;
        private IStudentRepository studentRepository;
        private IProgramRepository programRepository;
        private IBatchRepository batchRepository;
        private IBatchCoordinatorRepository batchCoordinatorRepository;
        private ISemesterRepository semesterRepository;
        private ICourseRepository courseRepository;
        private ICourseContentRepository courseContentRepository;
        private ICourseSemesterRepository courseSemesterRepository;
        private IStudentCourseRepository studentCourseRepository;
        private IStudentSemesterRepository studentSemesterRepository;
        public IUserRepository UserRepository
        {
            get
            {
                if (userRepository == null)
 

                    userRepository = new UserRepository(context);
                }
                return userRepository;
            }
        }
        public IRoleRepository RoleRepository
        {
            get
            {
                if (roleRepository == null)
                {
                    roleRepository = new RoleRepository(context);
                }
                return roleRepository;
            }
        }
        public IStudentRepository StudentRepository
        {
            get
            {
                if (studentRepository == null)
                {
                    studentRepository = new StudentRepository(context);
                }
                return studentRepository;
            }
        }
        public IProgramRepository ProgramRepository
        {
            get
            {
                if (programRepository == null)
                {
                    programRepository = new ProgramRepository(context);
               

                return programRepository;
            }
        }
        public IBatchRepository BatchRepository
        {
            get
            {
                if (batchRepository == null)
                {
                    batchRepository = new BatchRepository(context);
                }
                return batchRepository;
            }
        }
        public IBatchCoordinatorRepository BatchCoordinatorRepository
        {
            get
            {
                if (batchCoordinatorRepository == null)
                {
                    batchCoordinatorRepository = new BatchCoordinatorRepository(context);
                }
                return batchCoordinatorRepository;
            }
        }
        public ISemesterRepository SemesterRepository
        {
            get
            {
                if (semesterRepository == null)
                {
                    semesterRepository = new SemesterRepository(context);
                }
             
namespace BusinessLogic
    public partial class UnitOfWork
    {
        private ListingRepository _ListingRepository;
        public ListingRepository ListingRepository
        {
            get
            {
                if (_ListingRepository == null)
                {
                    _ListingRepository = new ListingRepository();
                }
                return _ListingRepository;
            }
        }
        private UserProfileRepository _UserProfileRepository;
        public UserProfileRepository UserProfileRepository
        {
            get
            {
                if (_UserProfileRepository == null)
                {
                    _UserProfileRepository = new UserProfileRepository();
                }
                return _UserProfileRepository;
            }
        }
        private EvaluationRepository _EvaluationRepository;
        public EvaluationRepository EvaluationRepository
        {
            get
            {
                if (_
namespace ManagerConsole.ViewModel
    public class VmQuotationManager
    {
        public static VmQuotationManager Instance = new VmQuotationManager();
        private ObservableCollection<VmQuotationSource> _QuotationSources = new ObservableCollection<VmQuotationSource>();
        private ObservableCollection<VmInstrument> _Instruments = new ObservableCollection<VmInstrument>();
        private VmAbnormalQuotationManager _abnormalQuotationManager = new VmAbnormalQuotationManager();
        private VmQuotationManager() { }
        public ObservableCollection<VmQuotationSource> QuotationSources
        {
            get
            {
                return this._QuotationSources;
            }
        }
        public ObservableCollection<VmInstrument> Instruments
        {
            get
            {
                return this._Instruments;
            }
        }
        public VmAbnormalQuotationManager AbnormalQuotationManager { get { return this._abnormalQuotationManager; } }

        public void Reset()
        {
            this._QuotationSources.Clear();
            this._Instruments.Clear();
            this._abnormalQuotationManager.Reset();
        }
        public void AddAbnormalQuotation(AbnormalQuotationMessage message)
        {
            this._abnormalQuotationManager.AddAbnormalQuotation(message);
        }
        public void Initialize()
        {
            try
            {
                    ConfigMetadata metadata = ConsoleClient.Instance.GetConfigMetadata();
                    
                    this._QuotationSources.Clear();
                    foreach (var source in metadata.QuotationSources.Values)
                    {
                        this._QuotationSources.Add(new VmQuotationSource(source));
                    }
                    this._Instruments.Clear();
                    foreach (var instrument in metadata.Instruments.Values)
                    {
                        VmInstrument vmInstrument = new VmInst

                        if (instrument.IsDerivative)
                        {
                            vmInstrument.VmDerivativeRelation = new VmDerivativeRelation(metadata.DerivativeRelations[instrument.Id]);
                        }
                        else
                        {
                            foreach (Dictionary<string, InstrumentSourceRelation> dict in metadata.InstrumentSourceRelations.Values)
                            {
                                var relation = dict.Values.SingleOrDefault(r => r.InstrumentId == instrument.Id);
                                if (relation != null)
                                {
                                    VmQuotationSource vmQuotationSource = this._QuotationSources.Single(s => s.Id == relation.SourceId);
                                    vmInstrument.SourceRelations.Add(new VmInstrumentSourceRelation(relation, vmInstrument, vmQuotationSource));
                                }
                       
namespace training
    public class MyInstrumentRepository : IInstrumentRepository
    {
        private readonly Dictionary<string, Instrument> _instruments;
        public MyInstrumentRepository()
        {
            _instruments = new Dictionary<string, Instrument>();
        }
        public int Size()
        {
            return _instruments.Count;
        }
        void IInstrumentRepository.AddInstrument(Instrument instrument)
        {
            if (_instruments.ContainsKey(instrument.Name))
            {
                throw new InvalidOperationException();
            }
            else
            {
                _instruments.Add(instrument.Name, instrument);
            }
        }
     
        Instrument IInstrumentRepository.GetInstrument(string name)
        {
            if (_instruments.ContainsKey(name))
            {
                return _instruments[name];
            }
            throw new InvalidOperationException();
        }
    
        IEnumerable<
namespace RiskAnalysisTool.MobileApp.Converters
    class InstrumentTitleConverter : DynamicVisitor<Instrument>, IValueConverter
    {
        private object _result;
        public string ConvertSymbol(string symbol)
        {
            if (symbol == null)
            {
                return "";
            }
            return symbol.Trim().Trim('$');
        }
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            Instrument instrument = value as Instrument;
            if (instrument == null)
            {
                return null;
            }
            this.Visit(instrument);
            return _result;
        }
        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotSupportedException();
        }
        protected void OnVisit(InterestRateSwap instrument)
        {
            _result = string.Format("Interest Rate Swap 

        }
        protected void OnVisit(CrossCurrencySwap instrument)
        {
            _result = string.Format("Cross Currency Swap - {0} {1}",
                instrument.PaySymbol == null ? "Receive" : "Pay",
                this.ConvertSymbol(instrument.PaySymbol ?? instrument.ReceiveSymbol));
        }
        protected void OnVisit(EquitySwap instrument)
        {
            _result = string.Format("Equity Swap: {0}",
                this.ConvertSymbol(instrument.PaySymbol ?? instrument.ReceiveSymbol)
                );
        }
        protected void OnVisit(Bond instrument)
        {
            _result = string.Format("Bond: {0}", this.ConvertSymbol(instrument.Symbol));
        }
        protected void OnVisit(CreditDefaultSwap instrument)
        {
            _result = string.Format("Credit Default Swap: {0}", this.ConvertSymbol(instrument.Symbol));
        }
        protected void OnVisit(ImpliedVolatility instrument)
        {
            _result = string.Format("Im
namespace Tests.Unit.Entities
    [TestFixture]
    public class AchPaymentInstrumentUnitTests
    {
        [Test]
        public void TestConstructIsInstanceOfEntity()
        {
            var PaymentInstrument = new AchPaymentInstrument();
            Assert.IsInstanceOf<AchPaymentInstrument>(PaymentInstrument);
        }
        [Test]
        public void TestMethodIsEqualTo()
        {
            var PaymentInstrument = new AchPaymentInstrument();
            Assert.AreEqual("ach", PaymentInstrument.Method);
        }
        [Test]
        public void TestBankAccountIdDefaultIsEqualTo()
        {
            var PaymentInstrument = new AchPaymentInstrument();
            Assert.IsNull(PaymentInstrument.BankAccountId);
        }
        [Test]
        public void TestBankAccountIdIsEqualTo()
        {
            var PaymentInstrument = new AchPaymentInstrument();
            PaymentInstrument.BankAccountId = "test2";
            Assert.AreEqual("test2", PaymentInstrument.BankAc
namespace BasicallyMe.RobinhoodNet.Helpers
    public class InstrumentCache
    {
        readonly RobinhoodClient _client;
        readonly Dictionary<string, Instrument> _symbolToInstrument;
        readonly Dictionary<string, Instrument> _instrumentKeyToIntrument;
        public InstrumentCache (RobinhoodClient client)
        {
            _client = client;
            _symbolToInstrument = new Dictionary<string, Instrument>();
            _instrumentKeyToIntrument = new Dictionary<string, Instrument>();
        }
        void addInstrument (Instrument instrument)
        {
            _symbolToInstrument[instrument.Symbol] = instrument;
            _instrumentKeyToIntrument[instrument.InstrumentUrl.ToString()] = instrument;
        }
        public async Task<Instrument> GetInstrument (Url<Instrument> instrumentUrl)
        {
            Instrument instrument = null;
            if (!_instrumentKeyToIntrument.TryGetValue(instrumentUrl.ToString(), out instrument))
            {
   

                addInstrument(instrument);
            }
            return instrument;
        }
        public async Task<Instrument> GetInstrument (string symbol)
        {
            Instrument instrument = null;
            if (!_symbolToInstrument.TryGetValue(symbol, out instrument))
            {
                var list = await _client.FindInstrument(symbol);
                instrument = list.First(i => i.Symbol == symbol);
                addInstrument(instrument);
            }
            return instrument;
        }
        public Task<string> GetSymbol (Url<Instrument> instrumentUrl)
        {
            return this.GetSymbol(instrumentUrl.ToString());
        }
        public async Task<string> GetSymbol (string instrumentUrl)
        {
            Instrument instrument = null;
            if (!_instrumentKeyToIntrument.TryGetValue(instrumentUrl, out instrument))
            {
                instrument = await _client.DownloadInstrument(new Url<Instrument>(instrumentU
namespace Samurai_CMS.DAL
    public class UnitOfWork : IDisposable
    {
        private readonly ApplicationDbContext _context = new ApplicationDbContext();
        private Repository<AuthorPaper> _paperRepository;
        private Repository<Conference> _conferenceRepository;
        private Repository<Edition> _editionRepository;
        private Repository<Enrollment> _enrollmentRepository;
        private Repository<ReviewAssignment> _paperReviewRepository;
        private Repository<Session> _sessionRepository;
        private Repository<User> _userRepository;
        private Repository<UserRole> _roleRepository;
        public Repository<AuthorPaper> PaperRepository => _paperRepository ?? (_paperRepository = new Repository<AuthorPaper>(_context));
        public Repository<Conference> ConferenceRepository => _conferenceRepository ?? (_conferenceRepository = new Repository<Conference>(_context));
        public Repository<Edition> EditionRepository => _editionRepository ?? (_editi

        public Repository<Enrollment> EnrollmentRepository => _enrollmentRepository ?? (_enrollmentRepository = new Repository<Enrollment>(_context)); 
        public Repository<ReviewAssignment> PaperReviewRepository => _paperReviewRepository ?? (_paperReviewRepository = new Repository<ReviewAssignment>(_context)); 
        public Repository<Session> SessionRepository => _sessionRepository ?? (_sessionRepository = new Repository<Session>(_context));
        public Repository<User> UserRepository => _userRepository ?? (_userRepository = new Repository<User>(_context));
        public Repository<UserRole> RoleRepository => _roleRepository ?? (_roleRepository = new Repository<UserRole>(_context));
        public void Complete()
        {
            _context.SaveChanges();  
        }
        private bool _disposed ;
        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                if (disposing)
                {
                
namespace amis._DataLayer.GeneratedCode
    public partial class DcDispatchProviderDocumentItem
    {
        public void Copy(DispatchProviderDocumentItem objSource, ref DispatchProviderDocumentItem objDestination)
        {
            objDestination.DispatchProviderDocumentItemId = objSource.DispatchProviderDocumentItemId;
            objDestination.DispatchProviderDocumentId = objSource.DispatchProviderDocumentId;
            objDestination.AssetUniqueIdentificationId = objSource.AssetUniqueIdentificationId;
            objDestination.ManufacturerYear = objSource.ManufacturerYear;
            objDestination.DeclaratedAmount = objSource.DeclaratedAmount;
            objDestination.ReceptionAmount = objSource.ReceptionAmount;
            objDestination.DispatchProviderDocumentStateId = objSource.DispatchProviderDocumentStateId;
            objDestination.Observation = objSource.Observation;
            objDestination.ItemCost = objSource.ItemCost;
            objDestination.AssignedA

            objDestination.ApplicationId = objSource.ApplicationId;
            objDestination.Dot = objSource.Dot;
        }
        public DispatchProviderDocumentItem Save(DispatchProviderDocumentItem objSource, out string errorMessage)
        {
            errorMessage = "";
            try
            {
                {
                    CommonEnums.PageActionEnum action = new CommonEnums.PageActionEnum();
                    {
                        
                        DispatchProviderDocumentItem row = context.DispatchProviderDocumentItem.Where(r => r.DispatchProviderDocumentItemId == objSource.DispatchProviderDocumentItemId).FirstOrDefault();
                        if (row == null)
                        {
                            row = new DispatchProviderDocumentItem();
                            Copy(objSource, ref row);
                            context.DispatchProviderDocumentItem.Add(row);
                            action = CommonEnums.PageActionEnum.

                        }
                        else
                        {
                            Copy(objSource, ref row);
                            action = CommonEnums.PageActionEnum.Update;
                        }
                        context.SaveChanges();
                        transaction.Complete();
                        return row;
                    }
                }
            }
            catch (Exception ex)
            {
                errorMessage = ErrorController.GetErrorMessage(ex);
                return null;
            }
        }
        public bool ExistsDispatchProviderDocumentItem(int DispatchProviderDocumentItemId, out string errorMessage)
        {
            errorMessage = "";
            try
            {
                DispatchProviderDocumentItem obj = null;
                {
                    obj = context.DispatchProviderDocumentItem.Where(r => r.DispatchProviderDocumentItemId != DispatchProviderDocumentItemId).FirstOrDe
﻿namespace TaskCounter.Models.Raw {
    public class sortie_battle {
        public int api_dock_id {
            get; set;
        }
        public int[] api_ship_ke {
            get; set;
        }
        public int[] api_ship_lv {
            get; set;
        }
        public int[] api_nowhps {
            get; set;
        }
        public int[] api_maxhps {
            get; set;
        }
        public int api_midnight_flag {
            get; set;
        }
        public int[][] api_eSlot {
            get; set;
        }
        public int[][] api_eKyouka {
            get; set;
        }
        public int[][] api_fParam {
            get; set;
        }
        public int[][] api_eParam {
            get; set;
        }
        public int[] api_search {
            get; set;
        }
        public int[] api_formation {
            get; set;
        }
        public int[] api_stage_flag {
            get; set;
        }
        public Api_Kouku api_kouku {
            get
namespace Pixelator.Api.Codec.Layout
    class ChunkLayoutBuilder
    {
        private readonly IList<KeyValuePair<ChunkConfiguration, Task<Stream>>> _chunks = new List<KeyValuePair<ChunkConfiguration, Task<Stream>>>();
        public void Prepend<TBody>(Chunk<TBody> chunk, ChunkWriter chunkWriter, Serializer<TBody> serializer) where TBody : class
        {
            Prepend(chunk.Configuration, chunkWriter.ChunkToStreamAsync(chunk, serializer));
        }
        public void Prepend(ChunkConfiguration chunkConfiguration, Stream chunkDataStream)
        {
            InsertAt(0, chunkConfiguration, chunkDataStream);
        }
        public void Prepend(ChunkConfiguration chunkConfiguration, Task<Stream> chunkDataStream)
        {
            InsertAt(0, chunkConfiguration, chunkDataStream);
        }
        public void InsertAt(int index, ChunkConfiguration chunkConfiguration, Stream chunkDataStream)
        {
            _chunks.Insert(index, CreateKeyValuePair(chunkConfiguration

        }
        public void InsertAt(int index, ChunkConfiguration chunkConfiguration, Task<Stream> chunkDataStream)
        {
            _chunks.Insert(index, CreateKeyValuePair(chunkConfiguration, chunkDataStream));
        }
        public void Append<TBody>(Chunk<TBody> chunk, ChunkWriter chunkWriter, Serializer<TBody> serializer) where TBody : class
        {
            Append(chunk.Configuration, chunkWriter.ChunkToStreamAsync(chunk, serializer));
        }
        public void Append(ChunkConfiguration chunkConfiguration, Task<Stream> chunkDataStream)
        {
            _chunks.Add(CreateKeyValuePair(chunkConfiguration, chunkDataStream));
        }
        public void Append(ChunkConfiguration chunkConfiguration, Stream chunkDataStream)
        {
            _chunks.Add(CreateKeyValuePair(chunkConfiguration, chunkDataStream));
        }
        public async Task<ChunkLayout> BuildAsync()
        {
            return new ChunkLayout((await LoadChunksAsync()).Select(item =>

        }
        public async Task<IEnumerable<KeyValuePair<ChunkInfo, Stream>>> LoadChunksAsync()
        {
            var chunks = new List<KeyValuePair<ChunkInfo, Stream>>();
            await Task.WhenAll(_chunks.Select(i => i.Value));
            foreach (KeyValuePair<ChunkConfiguration, Task<Stream>> chunkData in _chunks)
            {
                Stream stream = chunkData.Value.Result;
                chunks.Add(new KeyValuePair<ChunkInfo, Stream>(new ChunkInfo(chunkData.Key, stream.Length), stream));
            }
            return chunks;
        }
        private KeyValuePair<ChunkConfiguration, Task<Stream>> CreateKeyValuePair(ChunkConfiguration chunkConfiguration, Stream chunkDataStream)
        {
            return CreateKeyValuePair(chunkConfiguration, Task.FromResult(chunkDataStream));
        }
        private KeyValuePair<ChunkConfiguration, Task<Stream>> CreateKeyValuePair(ChunkConfiguration chunkConfiguration, Task<Stream> chunkDataStream)
        {
         
namespace ApiGateway.Domain.Services
    public class ApiService
    {
        private readonly IApiRepository _apiRepository;
        private readonly IApiCachingProvider _apiCachingProvider;
        public ApiService(IApiCachingProvider apiCachingProvider, IApiRepository apiRepository)
        {
            _apiCachingProvider = apiCachingProvider;
            _apiRepository = apiRepository;
        }
        public async Task<IEnumerable<Api>> Get()
        {
            return await _apiRepository.Get();
        }
        public async Task<Api> GetFromCache(string apiName)
        {
            return await _apiCachingProvider.Get(apiName);
        }
        public async Task Load()
        {
            var apis = await _apiRepository.GetWithAccountsAndServices();
            await _apiCachingProvider.Load(apis);
        }
        public async Task Create(Api api, int[] serviceIds)
        {
            await _apiRepository.Create(api, serviceIds);
            await _apiCachingPro
namespace UniFramework.Fsm
	public  abstract class GameFSMState : FSMState
	{
		class InvokeData
		{
			public string key = "default";
			public bool isRepeat = false;
			public float delay = 0;
			public float time;
			public float repeatTime = 0;
			public System.Action callback = null;
			public bool remove = false;
		}
		public float TimeScale = 1;
		private List<InvokeData> invokeList= new List<InvokeData> (); 
		private float currentInvokeTime;
		public override void Awake ()
		{
			base.Awake ();
		}
		public override void OnEnter (IDictionary paramDic)
		{
			base.OnEnter (paramDic);
			invokeList = new List<InvokeData> (); 
			currentInvokeTime = 0;
		}
		public override void OnExit ()
		{
			base.OnExit ();
			CancelInvoke ();
		}
		public override void OnUpdate ()
		{
			base.OnUpdate ();
			currentInvokeTime +=  Time.deltaTime *TimeScale;
			for (int i = 0; i < invokeList.Count; i++) {
				InvokeData data = invokeList [i];
				if (currentInvokeTime - data.time >= data.delay

					if (data.isRepeat) {
						data.delay += data.repeatTime;
					} else {
						data.remove = true;
					}
					if (data.callback != null) {
						data.callback ();
					}
				}
			}
			invokeList.RemoveAll ((o) => {
				return o.remove;
			});
		}
		public void Invoke (float delay, System.Action callback)
		{
			InvokeData invoke = new InvokeData ();
			invoke.delay = delay;
			invoke.isRepeat = false;
			invoke.callback = callback;
			invoke.time = currentInvokeTime;
			invokeList.Add (invoke);
		}
		public void Invoke (string methodKey, float delay, System.Action callback)
		{
			InvokeData invoke = new InvokeData ();
			invoke.key = methodKey; 
			invoke.delay = delay;
			invoke.isRepeat = false;
			invoke.callback = callback;
			invoke.time = currentInvokeTime;
			invokeList.Add (invoke);
		}
		public void InvokeRepeating (float delay, float repeatTime, System.Action callback)
		{
			InvokeData invoke = new InvokeData ();
			invoke.delay = delay;
			invoke.isRepeat = true;
			
namespace Discore.WebSocket.Net
    partial class Gateway
    {
        delegate void DispatchSynchronousCallback(DiscordApiData data);
        delegate Task DispatchAsynchronousCallback(DiscordApiData data);
        class DispatchCallback
        {
            public DispatchSynchronousCallback Synchronous { get; }
            public DispatchAsynchronousCallback Asynchronous { get; }
            public DispatchCallback(DispatchSynchronousCallback synchronous)
            {
                Synchronous = synchronous;
            }
            public DispatchCallback(DispatchAsynchronousCallback asynchronous)
            {
                Asynchronous = asynchronous;
            }
        }
        [AttributeUsage(AttributeTargets.Method)]
        class DispatchEventAttribute : Attribute
        {
            public string EventName { get; }
            public DispatchEventAttribute(string eventName)
            {
                EventName = eventName;
            }
        }
        Dic

        void InitializeDispatchHandlers()
        {
            dispatchHandlers = new Dictionary<string, DispatchCallback>();
            Type taskType = typeof(Task);
            Type gatewayType = typeof(Gateway);
            Type dispatchSynchronousType = typeof(DispatchSynchronousCallback);
            Type dispatchAsynchronousType = typeof(DispatchAsynchronousCallback);
            foreach (MethodInfo method in gatewayType.GetTypeInfo().GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
            {
                DispatchEventAttribute attr = method.GetCustomAttribute<DispatchEventAttribute>();
                if (attr != null)
                {
                    DispatchCallback dispatchCallback;
                    if (method.ReturnType == taskType)
                    {
                        Delegate callback = method.CreateDelegate(dispatchAsynchronousType, this);
                        dispatchCallback = new DispatchCallback((DispatchAsynchronousCallback)ca
namespace FormBuilder.Data
    public class ApplicationUnit: IApplicationUnit
    {
        private FormBuilderContext _context;
        private IGenericRepository<User> _userRepository;
        private IGenericRepository<Role> _roleRepository;
        private IGenericRepository<Group> _groupRepository;
        private IGenericRepository<Event> _eventRepository;
        private IGenericRepository<JoinGroupRequest> _joinGroupRequestRepository;
        private IGenericRepository<Sponsor> _sponsorRepository;
        private IGenericRepository<GroupPhoto> _groupPhotoRepository;
        private IGenericRepository<PersonalMessage> _personalMessageRepository; 
        public ApplicationUnit(IGenericRepository<User> userRepository, 
                               IGenericRepository<Role> roleRepository,
                               IGenericRepository<Group> groupRepository,
                               IGenericRepository<Event> eventRepository,
                               IGenericReposi

                               IGenericRepository<JoinGroupRequest> joinGroupRequestRepository,
                               IGenericRepository<GroupPhoto> groupPhotoRepository,
                               IGenericRepository<PersonalMessage> personalMessageRepository,
                               FormBuilderContext formBuilderContext)
        {
            _userRepository = userRepository;
            _roleRepository = roleRepository;
            _groupRepository = groupRepository;
            _eventRepository = eventRepository;
            _sponsorRepository = sponsorRepository;
            _joinGroupRequestRepository = joinGroupRequestRepository;
            _groupPhotoRepository = groupPhotoRepository;
            _personalMessageRepository = personalMessageRepository;
            _context = formBuilderContext;
        }
        public IGenericRepository<PersonalMessage> PersonalMessageRepository
        {
            get { return this._personalMessageRepository; }
        }

        public IGenericRepository<GroupPhoto> GroupPhotoRepository
        {
            get { return this._groupPhotoRepository; }
        }
        public IGenericRepository<Sponsor> SponsoRepository
        {
            get { return this._sponsorRepository; }
        }
        public IGenericRepository<JoinGroupRequest> JoinGroupRequestRepository
        {
            get { return this._joinGroupRequestRepository; }
        }
        public IGenericRepository<Event> EventRepository
        {
            get { return this._eventRepository; }
        }
        public IGenericRepository<Group> GroupRepository
        {
            get { return this._groupRepository; }
        }
        public IGenericRepository<User> UserRepository
        {
            get { return this._userRepository; }
        }
        public IGenericRepository<Role> RoleRepository
        {
            get { return this._roleRepository; }
        }
        public void SaveChanges()
        {
            _contex
namespace Repository.UnitOfWork.Abstractions
    public interface IUnitOfWork : IDisposable
    {
        IContoRepository GetContoRepository();
        IBusinessPartnerBankAccountRepository GetBusinessPartnerBankAccountRepository();
        IBusinessPartnerLocationRepository GetBusinessPartnerLocationRepository();
        IBusinessPartnerPhoneRepository GetBusinessPartnerPhoneRepository();
        IBusinessPartnerRepository GetBusinessPartnerRepository();
        ICalculationsRepository GetInputCalculationsRepository();
        IPriceLevelingRepository GetPriceLevelingRepository();
        IPricingRepository GetPricingRepository();
        ICashierRepository GetCashierRepository();
        IClawbackFromBuyerRepository GetClawbackFromBuyerRepository();
        IClawbackFromSupplierRepository GetClawbackFromSupplierRepository();
        ILoanRepository GetLoanRepository();
        IWritingOffRepository GetWritingOffRepository();
        ICompanyBankAccountRepository GetCompanyBankAccoun

        ICompanyPhoneRepository GetCompanyPhoneRepository();
        ICompanyRepository GetCompanyRepository();
        IDeliveryNoteRepository GetDeliveryNoteRepository();
        IInternalDeliveryNoteRepository GetInternalDeliveryNoteRepository();
        IInputNoteRepository GetInputNoteRepository();
        IPassportRepository GetPassportRepository();
        IExchangeRateRepository GetExchangeRateRepository();
        IAuthenticationRepository GetAuthenticationRepository();
        IUserRepository GetUserRepository();
        IAccountStatementRepository GetAccountStatementRepository();
        IBookOfOutputInvoicesRepository GetBookOfOutputInvoicesRepository();
        ICreditNoteRepository GetCreditNoteRepository();
        IOutputInvoiceRepository GetOutputInvoiceRepository();
        IOutputProInvoiceRepository GetOutputProInvoiceRepository();
        IInputInvoiceRepository GetInputInvoiceRepository();
        IAdvanceOutputInvoiceRepository GetAdvanceOutputInvoiceRepository(

        ICountryRepository GetCountryRepository();
        ICityRepository GetCityRepository();
        IExpenseLocationRepository GetExpenseLocationRepository();
        IMunicipalityRepository GetMunicipalityRepository();
        IOrganizationUnitRepository GetOrganizationUnitRepository();
        ISectionRepository GetSectionRepository();
        IProductCardRepository GetProductCardRepository();
        IProductGroupRepository GetProductGroupRepository();
        IProductSubGroupRepository GetProductSubGroupRepository();
        IProductRepository GetProductRepository();
        IProductSubItemRepository GetProductSubItemRepository();
        IAnimalTypeRepository GetAnimalTypeRepository();
        IAnimalSubTypeRepository GetAnimalSubTypeRepository();
        IUnitOfMeasurementRepository GetUnitOfMeasurementRepository();
        IPalletRepository GetPalletRepository();
        IProductTypeRepository GetProductTypeRepository();
        IProductVatPercentRepository GetProductVatPer
namespace KiraNet.GutsMvc.Implement
    public class ControllerBuilder : IControllerBulider
    {
        private ControllerContext _controllerContext;
        private IControllerFactoryProvider _controllerFactoryProvider;
        private Controller _controller;
        private IServiceProvider _services;
        public ControllerBuilder(ControllerContext controllerContext)
        {
            _controllerContext = controllerContext ?? throw new ArgumentNullException(nameof(controllerContext));
            _controllerFactoryProvider = new ControllerFactoryProvider(new ControllerProvider());
            _services = controllerContext.HttpContext.Service;
        }
        public Controller ControllerBuild()
        {
            var route = _controllerContext.RouteEntity;
            _controller = _controllerFactoryProvider
                .CreateControllerFactory(new ControllerDescriptor { ControllerName = route.Controller.ToLower(), Services = _services })(_controllerContext);
       
namespace BookingSystem.DataAccess.Concrete
    public class UnitOfWork : IUnitOfWork, IDisposable
    {
        #region Fields
        private readonly BookingSystemContext _context = new BookingSystemContext();
        private BusRepository _busRepository;
        private DriverRepository _driverRepository;
        private JourneyRepository _journeyRepository;
        private PassengerRepository _passengerRepository;
        private RoutePointRepository _routePointRepository;
        private RouteRepository _routeRepository;
        private TicketRepository _ticketRepository;
        private TrafficRepository _trafficRepository;
        private AdministratorRepository _administratorRepository;
        private bool _disposed;
        #endregion
        #region Properties
        public IBusRepository BusRepository => _busRepository ?? (_busRepository = new BusRepository(_context));
        public IDriverRepository DriverRepository => _driverRepository ??
                              

        public IJourneyRepository JourneyRepository => _journeyRepository ??
                                                       (_journeyRepository = new JourneyRepository(_context));
        public IPassengerRepository PassengerRepository => _passengerRepository ??
                                                           (_passengerRepository = new PassengerRepository(_context));
        public IRoutePointRepository RoutePointRepository => _routePointRepository ??
                                                             (_routePointRepository = new RoutePointRepository(_context));
        public IRouteRepository RouteRepository => _routeRepository ??
                                                   (_routeRepository = new RouteRepository(_context));
        public ITicketRepository TicketRepository => _ticketRepository ??
                                                     (_ticketRepository = new TicketRepository(_context));
        public ITrafficRepository TrafficRepo
@model IEnumerable<MMApp.Domain.Models.Instrument>
@{
    ViewBag.Title = "Index";
<h2>List of Instruments</h2>
<p>
    @Html.ActionLink("Add Instrument", "AddInstrument", "Instrument")
</p>
@Html.ValidationSummary(true)
<table>
    <tr>
        <th class="width200">
            @Html.DisplayNameFor(model => model.InstrumentName)
        </th>
        <th class="width200">
            @Html.DisplayNameFor(model => model.Website)
        </th>
        <th class="width100">Update</th>
        <th class="width100">Remove</th>
    </tr>
    @foreach(var item in Model)
    {
        <tr>
            <td>
                @Html.DisplayFor(modelItem => item.InstrumentName)
            </td>
            <td>
                @Html.WebsiteLink(item.Website, item.InstrumentName)
            </td>
            <td>
                @Html.ActionLink("Update", "UpdateInstrument", "Instrument", new { instrumentId = item.Id}, null)
            </td>
            <td>
                @Html.ActionLink("Remo
﻿namespace Allors.Web.Database
    public class InvokeResponseBuilder
    {
        private readonly ISession session;
        private readonly InvokeRequest invokeRequest;
        private User user;
        public InvokeResponseBuilder(ISession session, User user, InvokeRequest invokeRequest)
        {
            this.session = session;
            this.user = user;
            this.invokeRequest = invokeRequest;
        }
        public InvokeResponse Build()
        {
            if (this.invokeRequest.M == null || this.invokeRequest.I == null || this.invokeRequest.V == null)
            {
                throw new ArgumentException();
            }
            var obj = this.session.Instantiate(this.invokeRequest.I);
            var composite = (Composite)obj.Strategy.Class;
            var methodTypes = composite.WorkspaceMethodTypes;
            var methodType = methodTypes.FirstOrDefault(x => x.Name.Equals(this.invokeRequest.M));
            if (methodType == null)
            

                throw new Exception("Method " + this.invokeRequest.M + " not found.");   
            }
            
            var invokeResponse = new InvokeResponse();
            if (!this.invokeRequest.V.Equals(obj.Strategy.ObjectVersion.ToString()))
            {
                invokeResponse.AddVersionError(obj);
            }
            else
            {
                var acl = new AccessControlList(obj, this.user);
                if (acl.CanExecute(methodType))
                {
                    var method = obj.GetType().GetMethod(methodType.Name, new Type[] { });
                    try
                    {
                        method.Invoke(obj, null);
                    }
                    catch (Exception e)
                    {
                        var innerException = e;
                        while (innerException.InnerException != null)
                        {
                            innerException = innerException.InnerException;
        
public class TerrainGen {
    float stoneBaseHeight = -24;
    float stoneBaseNoise = 0.05f;
    float stoneBaseNoiseHeight = 4;
    float stoneMountainHeight = 48;
    float stoneMountainFrequency = 0.008f;
    float stoneMinHeight = -12;
    float dirtBaseHeight = 1;
    float dirtNoise = 0.04f;
    float dirtNoiseHeight = 3;
    
    public Chunk ChunkGen(Chunk chunk)
    {
        for (int x = chunk.pos.x; x < chunk.pos.x + Chunk.chunkSize; x++)
        {
            for (int z = chunk.pos.z; z < chunk.pos.z + Chunk.chunkSize; z++)
            {
                chunk = ChunkColumnGen(chunk, x, z);
            }
        }
        return chunk;
    }
    public Chunk ChunkColumnGen(Chunk chunk, int x, int z)
    {
        int stoneHeight = Mathf.FloorToInt(stoneBaseHeight);
        stoneHeight += GetNoise(x, 0, z, stoneMountainFrequency, Mathf.FloorToInt(stoneMountainHeight));
        if (stoneHeight < stoneMinHeight)
            stoneHeight = Mathf.FloorToInt(stoneMinHeight);
      
public class Lightmap {
	private Grid<SunLightChunk> sunChunks = new Grid<SunLightChunk>();
	private Grid<LightChunk> chunks = new Grid<LightChunk>();
	public void SetSunHeight(int height, int x, int z) {
		Vector3i chunkPos = Chunk.ToChunkPosition(x, 0, z);
		Vector3i localPos = Chunk.ToLocalPosition(x, 0, z);
		
		SunLightChunk chunk = GetSunChunkInstance(chunkPos.x, chunkPos.z);
		chunk.SetSunHeight( height, localPos.x, localPos.z );
	}
	public int GetSunHeight(int x, int z) {
		Vector3i chunkPos = Chunk.ToChunkPosition(x, 0, z);
		Vector3i localPos = Chunk.ToLocalPosition(x, 0, z);
		SunLightChunk chunk = GetSunChunk(chunkPos.x, chunkPos.z);
		if(chunk != null) return chunk.GetSunHeight(localPos.x, localPos.z);
		return Map.maxChunkY;
	}
	public bool IsSunLight(int x, int y, int z) {
		Vector3i chunkPos = Chunk.ToChunkPosition(x, y, z);
		Vector3i localPos = Chunk.ToLocalPosition(x, y, z);
		SunLightChunk chunk = GetSunChunk(chunkPos.x, chunkPos.z);
		if(chunk != null) return chunk

		return false;
	}
	public bool SetMaxLight(byte light, int x, int y, int z) {
		Vector3i chunkPos = Chunk.ToChunkPosition(x, y, z);
		Vector3i localPos = Chunk.ToLocalPosition(x, y, z);
		
		SunLightChunk sunChunk = GetSunChunk(chunkPos.x, chunkPos.z);
		if(sunChunk != null && sunChunk.IsLight(localPos.x, y, localPos.z)) {
			return false;
		}
		
		LightChunk lightChunk = GetLightChunkInstance(chunkPos);
		return lightChunk.SetMaxLight(light, localPos);
	}
	public void SetLight(byte light, Vector3i pos) {
		SetLight(light, pos.x, pos.y, pos.z);
	}
	public void SetLight(byte light, int x, int y, int z) {
		Vector3i chunkPos = Chunk.ToChunkPosition(x, y, z);
		Vector3i localPos = Chunk.ToLocalPosition(x, y, z);
		SetLight(light, chunkPos, localPos);
	}
	public void SetLight(byte light, Vector3i chunkPos, Vector3i localPos) {
		LightChunk lightChunk = GetLightChunk(chunkPos);
		if(lightChunk == null) {
			if(light == LightComputer.MIN_LIGHT) return;
			lightChunk = GetLightChunkInstance

		}
		lightChunk.SetLight(light, localPos);
	}
	public byte GetLight(Vector3i pos) {
		return GetLight(pos.x, pos.y, pos.z);
	}
	public byte GetLight(int x, int y, int z) {
		Vector3i chunkPos = Chunk.ToChunkPosition(x, y, z);
		Vector3i localPos = Chunk.ToLocalPosition(x, y, z);
		return GetLight(chunkPos, localPos);
	}
	public byte GetLight(Vector3i chunkPos, Vector3i localPos) {
		SunLightChunk sunChunk = GetSunChunk(chunkPos.x, chunkPos.z);
		int worldY = (chunkPos.y << Chunk.SIZE_Y_BITS) + localPos.y;
		if(sunChunk != null && sunChunk.IsLight(localPos.x, worldY, localPos.z)) return LightComputer.MAX_LIGHT;
		
		LightChunk lightChunk = GetLightChunk(chunkPos);
		if(lightChunk != null) return lightChunk.GetLight(localPos);
		return LightComputer.MIN_LIGHT;
	}
	private SunLightChunk GetSunChunkInstance(int x, int z) {
		SunLightChunk chunk = GetSunChunk(x, z);
		if(chunk == null) {
			chunk = new SunLightChunk();
			sunChunks.AddOrReplace(chunk, x, 0, z);
		}
		return chunk;
	}
	pri
namespace Client
    public sealed partial class World
    {
        public readonly int Length;
        public readonly int Width;
        public readonly int Height;
        private Chunk[, ,] Chunks;
        public BlockID this[Vector3I pos]
        {
            get { return this[pos.X, pos.Y, pos.Z]; }
            set { this[pos.X, pos.Y, pos.Z] = value; }
        }
        public BlockID this[int x, int y, int z]
        {
            get
            {
                int chunkX = x / Chunk.Size.X;
                int chunkY = y / Chunk.Size.Y;
                int chunkZ = z / Chunk.Size.Z;
                if (chunkX < 0 || chunkX >= Chunks.GetLength(0)
                    || chunkY < 0 || chunkY >= Chunks.GetLength(1)
                    || chunkZ < 0 || chunkZ >= Chunks.GetLength(2))
                Chunk chunk = Chunks[chunkX, chunkY, chunkZ];
                int levelX = x % Chunk.Size.X;
                int levelY = y % Chunk.Size.Y;
                int levelZ = z % Chunk.Si

                return chunk[levelX, levelY, levelZ];
            }
            set
            {
                    return;
                int chunkX = (x / Chunk.Size.X);
                int chunkY = (y / Chunk.Size.Y);
                int chunkZ = (z / Chunk.Size.Z);
                if (chunkX < 0 || chunkX > Chunks.GetLength(0))
                    throw new Exception("Cannot modify world outside visible area");
                if (chunkY < 0 || chunkY > Chunks.GetLength(1))
                    throw new Exception("Cannot modify world outside visible area");
                if (chunkZ < 0 || chunkZ > Chunks.GetLength(2))
                    throw new Exception("Cannot modify world outside visible area");
                Chunk chunk = Chunks[chunkX, chunkY, chunkZ];
                int lx = x % Chunk.Size.X;
                int ly = y % Chunk.Size.Y;
                int lz = z % Chunk.Size.Z;
                chunk[lx, ly, lz] = value;
            }
        }
        public World(

        {
            Length = length;
            Width = width;
            Height = height;
            Chunks = new Chunk[Length / Chunk.Size.X, Width / Chunk.Size.Y, Height / Chunk.Size.Z];
            for (int x = 0; x < Chunks.GetLength(0); x++)
                for (int y = 0; y < Chunks.GetLength(1); y++)
                    for (int z = 0; z < Chunks.GetLength(2); z++)
                    {
                        Chunks[x, y, z] = new Chunk(this, new Vector3I(x * Chunk.Size.X, y * Chunk.Size.Y, z * Chunk.Size.Z));
                    }
            
            Spawn = new Vector3I(Length / 2 + 5, Width / 2 + 5, 5);
            Client.OnUpdate += Update;
            Client.OnDraw3D += Draw;
        }
        public Vector3I Spawn
        {
            get;
            private set;
        }
        public void Update(object sender, UpdateEventArgs e)
        {
            for (int x = 0; x < Chunks.GetLength(0); x++)
                for (int y = 0; y < Chunks.GetLength(1); y+
namespace Domain.Repository
    public class UnitOfWork : IUnitOfWork
    {
        private readonly LibraryDbContext _context = new LibraryDbContext();
        private Repository<User> _userRepository;
        private Repository<Author> _authorRepository;
        private Repository<Book> _bookRepository;
        private Repository<BorrowInfo> _borrowInfoRepository;
        private Repository<Genre> _genreRepository;
        private Repository<Language> _languageRepository;
        private Repository<Publisher> _publisherRepository;
        private Repository<Reader> _readerRepository;
        public Repository<User> UserRepository 
            => _userRepository ?? (_userRepository = new Repository<User>(_context));
        public Repository<Author> AuthorRepository
            => _authorRepository ?? (_authorRepository = new Repository<Author>(_context));
        public Repository<Book> BookRepository
            => _bookRepository ?? (_bookRepository = new Repository<Book>(_context)

        public Repository<BorrowInfo> BorrowInfoRepository
            => _borrowInfoRepository ?? (_borrowInfoRepository = new Repository<BorrowInfo>(_context));
        public Repository<Genre> GenreRepository
            => _genreRepository ?? (_genreRepository = new Repository<Genre>(_context));
        public Repository<Language> LanguageRepository
            => _languageRepository ?? (_languageRepository = new Repository<Language>(_context));
        public Repository<Publisher> PublisherRepository
            => _publisherRepository ?? (_publisherRepository = new Repository<Publisher>(_context));
        public Repository<Reader> ReaderRepository
            => _readerRepository ?? (_readerRepository = new Repository<Reader>(_context));
        public void Save()
        {
            _context.SaveChanges();
        }
        private bool _disposed;
        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                if (di
public class World : MonoBehaviour {
    
    public int chunkSize = 10;
    public int chunkHeight = 10;
    public int LOD;
    public float noiseScaleFactor = 20;
    public float voxelSize = 1;
    Chunk[,] worldChunks;
    public Material meshMaterial;
    public Vector3 worldStartPosition;
    float timer;
    public int RenderDistance;
    public List<Chunk> chunks;
    public Chunk[,] chunksArray;
    public GameObject Player;
    public int seed;
    public Vector2 Tree_Pos;
    public bool CreateTreeBool;
    List<Chunk> chunksToUpdate;
    public GameObject treePrefab;
    public int SetLOD;
    public bool SetLODBool;
    int low_lod = 4;
    int med_lod = 2;
    int high_lod = 1;
    public float mediumLodDistance;
    public float farLodDistance;
    GameObject Terrain;
	void Start () {
        chunksToUpdate = new List<Chunk>();
        worldStartPosition = new Vector3(0, 0, 0);
        chunksArray = new Chunk[5000, 5000];
        chunks = new List<Chunk>();
        Terr

    }
    Chunk CreateChunk(int x, int z)
    {
        return new Chunk(new Vector3(x * chunkSize * voxelSize, 0, z * chunkSize * voxelSize), chunkSize, chunkHeight, noiseScaleFactor, voxelSize, meshMaterial, seed, low_lod);
    }
    public void AddChunkToUpdate(Chunk chunk)
    {
        if (!chunksToUpdate.Contains(chunk))
        {
            chunksToUpdate.Add(chunk);
        }
    }
    public void AddDensity(int x, int y, int z, float val, bool doVoxelSize)
    {
        if (doVoxelSize)
        {
            x /= (int)voxelSize;
            y /= (int)voxelSize;
            z /= (int)voxelSize;
        }
        int xChunk = x / chunkSize;
        int zChunk = z / chunkSize;
        int xVert = x % chunkSize;
        int zVert = z % chunkSize;
        if (xVert < 0)
        {
            xVert = chunkSize + xVert;
            xChunk--;
        }
        if (zVert < 0)
        {
            zVert = chunkSize + zVert;
            zChunk--;
        }
        chunksArray[xChunk +

        AddChunkToUpdate(chunksArray[xChunk + chunkOffset, zChunk + chunkOffset]);
        if (xVert == 0)
        {
            chunksArray[xChunk - 1 + chunkOffset, zChunk + chunkOffset].addIsoLevel(chunkSize, y, zVert, val);
            AddChunkToUpdate(chunksArray[xChunk - 1 + chunkOffset, zChunk + chunkOffset]);
        }
        if (xVert == chunkSize)
        {
            chunksArray[xChunk + 1 + chunkOffset, zChunk + chunkOffset].addIsoLevel(0, y, zVert, val);
            AddChunkToUpdate(chunksArray[xChunk + 1 + chunkOffset, zChunk + chunkOffset]);
        }
        if (zVert == 0)
        {
            chunksArray[xChunk + chunkOffset, zChunk - 1 + chunkOffset].addIsoLevel(xVert, y, chunkSize, val);
            AddChunkToUpdate(chunksArray[xChunk + chunkOffset, zChunk - 1 + chunkOffset]);
        }
        if (zVert == chunkSize)
        {
            chunksArray[xChunk + chunkOffset, zChunk + 1 + chunkOffset].addIsoLevel(xVert, y, 0, val);
            AddChunkToUpdate(chun
namespace Peto.Test.Models {
    [TestFixture]
    class ChunkModel_Test {
        private ChunkModel chunkModel;
        [SetUp]
        public void SetUp() {
            this.chunkModel = new ChunkModel();
        }
        [TearDown]
        public void TearDown() {
            this.chunkModel = null;
        }
        [Test]
        public void ChunkModel_Id_AreEqual() {
            this.chunkModel.Id = 1;
            Assert.AreEqual(1, this.chunkModel.Id);
        }
        [Test]
        public void ChunkModel_ChunkTypeId_AreEqual() {
            this.chunkModel.ChunkTypeId = 1;
            Assert.AreEqual(1, this.chunkModel.ChunkTypeId);
        }
        [Test]
        public void ChunkModel_ChunkType_IsNotNull() {
            this.chunkModel.ChunkType = new ChunkTypeModel();
            Assert.IsNotNull(this.chunkModel.ChunkType);
        }
        [Test]
        public void ChunkModel_ChunkType_IsInstanceOf() {
            this.chunkModel.ChunkType = new ChunkTypeModel();
   
namespace BradGame3D
    class World
    {
        public const int seed = 567898765;
        public const int chunkCount = 7;
        Game1 game;
        public Chunk[][] chunks = new Chunk[chunkCount][];
        public World(Game1 g)
        {
            game = g;
            
            for(int i = 0; i < chunkCount; i++)
                chunks[i] = new Chunk[chunkCount];
            init();
            
        }
        public void init()
        {
            for (int i = 0; i < chunkCount*chunkCount; i++)
            {
               
                
                /*
                Random r = new Random();
                for (int a = 0; a < Chunk.xSize * Chunk.ySize * Chunk.zSize; i++)
                {
                    chunks[i/chunkCount][i%chunkCount].blocks[a].setSolid(false);
                    if (r.Next(10) >= 9)
                        chunks[i/chunkCount][i%chunkCount].blocks[a].setSolid(true);
                }
                 */
            }
            d

            
            for (int i = 0; i < chunkCount*chunkCount; i++)
            {
                chunks[i / chunkCount][i % chunkCount].doVisible();
                chunks[i / chunkCount][i % chunkCount].buildList();
            }
        }
    
        public void draw(GraphicsDeviceManager g)
        {
            for (int i = 0; i < chunkCount*chunkCount; i++)
            {
                if(chunks[i/chunkCount][i%chunkCount].faceCount!=0)
                    g.GraphicsDevice.DrawUserPrimitives<VertexPositionNormalTexture>(PrimitiveType.TriangleList, chunks[i/chunkCount][i%chunkCount].verticesArray, 0, chunks[i/chunkCount][i%chunkCount].faceCount * 2);
            }
        }
        public Block2 getBlockAt(int x, int y, int z)
        {
            int cx = x / Chunk.xSize;
            int cz = z / Chunk.zSize;
            if (cz >= 0 && cz < chunkCount && cx >= 0 && cx < chunkCount && z>=0 && x>=0 && y>=0 && y<Chunk.ySize && (x-cx*Chunk.xSize)<Chunk.xSize && (z-cz*Chunk.z
﻿namespace SDK.Lib
    /**
     * @brief 全局委托，只要初始化后，就可以注册和使用这些委托，不用等到哪一个资源创建完成
     */
    public class GlobalDelegate
    {
        public AddOnceEventDispatch mMainChildMassChangedDispatch;
        public AddOnceEventDispatch mCameraOrientChangedDispatch;
        public AddOnceEventDispatch mMainChildChangedDispatch;
        public GlobalDelegate()
        {
            this.mMainChildMassChangedDispatch = new AddOnceEventDispatch();
            this.mCameraOrientChangedDispatch = new AddOnceEventDispatch();
            this.mMainOrientChangedDispatch = new AddOnceEventDispatch();
            this.mMainPosChangedDispatch = new AddOnceEventDispatch();
            this.mMainOrientStopChangedDispatch = new AddOnceEventDispatch();
            this.mMainPosStopChangedDispatch = new AddOnceEventDispatch();
            this.mMainChildChangedDispatch = new AddOnceEventDispatch();
        }
        public void addMainChildChangedHandle(ICalleeObject pThis, MAction<IDispatchObject> handle)
  
namespace FileSystemDAL.Tests
    [TestFixture]
    public class AdminTest
    {
        private List<string> repositoryNameList;
        private Admin admin;
        [SetUp]
        public void Init()
        {
            this.repositoryNameList = new List<string>() { "Anonymus", "Anonymus2", "Anonymus3" };
            this.admin = new Admin();
        }
        [Test]
        public void DeleteRepositoryTest()
        {
            var addedRepository = new List<Repository>();
            
            foreach (var repositoryName in this.repositoryNameList)
            {
                addedRepository.Add(this.AddRepository(new Repository { RepositoryName = repositoryName, DateAttach = DateTime.Now, IsActive = false }));
            }
            var listRepository = this.admin.GetListRepository();
            foreach (var repository in addedRepository)
            {
                Assert.AreEqual(true, listRepository.Any(x => x.RepositoryName == repository.RepositoryName));
      

            foreach (var repository in addedRepository)
            {
                this.admin.DeleteRepository(repository.RepositoryId);
            }
            listRepository = this.admin.GetListRepository();
            foreach (var repository in addedRepository)
            {
                Assert.AreEqual(false, listRepository.Any(x => x.RepositoryName == repository.RepositoryName));
            }
        }
        [Test]
        public void ActiveRepositoryTest()
        {
            this.AddRepository(new Repository { RepositoryName = this.repositoryNameList[0], DateAttach = DateTime.Now, IsActive = false });
            var listRepository = this.admin.GetListRepository();
            var repository = listRepository.Single(x => x.RepositoryName == this.repositoryNameList[0]);
            Assert.AreEqual(repository.IsActive, false);
            this.admin.ActiveRepository(repository.RepositoryId);
            listRepository = this.admin.GetListRepository();
            rep

            Assert.AreEqual(repository.IsActive, true);
            this.admin.DeleteRepository(repository.RepositoryId);
        }
        [Test]
        public void DeactiveRepositoryTest()
        {
            this.AddRepository(new Repository { RepositoryName = this.repositoryNameList[0], DateAttach = DateTime.Now, IsActive = true });
            var listRepository = this.admin.GetListRepository();
            var repository = listRepository.Single(x => x.RepositoryName == this.repositoryNameList[0]);
            Assert.AreEqual(repository.IsActive, true);
            this.admin.DeactiveRepository(repository.RepositoryId);
            listRepository = this.admin.GetListRepository();
            repository = listRepository.Single(x => x.RepositoryName == this.repositoryNameList[0]);
            Assert.AreEqual(repository.IsActive, false);
            this.admin.DeleteRepository(repository.RepositoryId);
        }
        private Repository AddRepository(Repository repository)
    
namespace NginxService
    public class NginxMasterProcess
    {
        private readonly NginxExeLocator _nginxExeLocator = new NginxExeLocator();
        private Process _nginxProcess;
        public void StartMasterProcess()
        {
            if (_nginxProcess == null)
            {
                _nginxProcess = new Process();
                _nginxProcess.StartInfo.FileName = _nginxExeLocator.GetNginxExePath();
                _nginxProcess.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
                _nginxProcess.Start();
            }
        }
        public void StopMasterProcess()
        {
            var signalProcess = new NginxSignalProcess();
            signalProcess.SendShutdownCommand();
            if (_nginxProcess != null)
            {
                _nginxProcess.Close();
                _nginxProcess = null;
            }
        }
        public bool IsRunning()
        {
            return File.Exists(_nginxExeLocator.GetNginxPidPath());
        }

namespace Project290.Physics.Controllers
    [Flags]
    public enum ControllerType
    {
        GravityController = (1 << 0),
        VelocityLimitController = (1 << 1),
        AbstractForceController = (1 << 2)
    }
    public class FilterControllerData : FilterData
    {
        private ControllerType _type;
        public FilterControllerData(ControllerType type)
        {
            _type = type;
        }
        public override bool IsActiveOn(Body body)
        {
            if (body.ControllerFilter.IsControllerIgnored(_type))
                return false;
            return base.IsActiveOn(body);
        }
    }
    public class ControllerFilter
    {
        public ControllerType ControllerFlags;
        public void IgnoreController(ControllerType controller)
        {
            ControllerFlags |= controller;
        }
        public void RestoreController(ControllerType controller)
        {
            ControllerFlags &= ~controller;
        }
        public bool IsC
namespace Microsoft.AspNetCore.Razor.CodeGenerators.Visitors
    public abstract class ChunkVisitor<TWriter> : IChunkVisitor
        where TWriter : CodeWriter
    {
        public ChunkVisitor(TWriter writer, CodeGeneratorContext context)
        {
            if (writer == null)
            {
                throw new ArgumentNullException(nameof(writer));
            }
            if (context == null)
            {
                throw new ArgumentNullException(nameof(context));
            }
            Writer = writer;
            Context = context;
        }
        protected TWriter Writer { get; private set; }
        protected CodeGeneratorContext Context { get; private set; }
        public void Accept(IList<Chunk> chunks)
        {
            if (chunks == null)
            {
                throw new ArgumentNullException(nameof(chunks));
            }
            foreach (Chunk chunk in chunks)
            {
                Accept(chunk);
            }
        }
        

        {
            if (chunk == null)
            {
                throw new ArgumentNullException(nameof(chunk));
            }
            if (chunk is LiteralChunk)
            {
                Visit((LiteralChunk)chunk);
            }
            else if (chunk is ParentLiteralChunk)
            {
                Visit((ParentLiteralChunk)chunk);
            }
            else if (chunk is ExpressionBlockChunk)
            {
                Visit((ExpressionBlockChunk)chunk);
            }
            else if (chunk is ExpressionChunk)
            {
                Visit((ExpressionChunk)chunk);
            }
            else if (chunk is StatementChunk)
            {
                Visit((StatementChunk)chunk);
            }
            else if (chunk is TagHelperChunk)
            {
                Visit((TagHelperChunk)chunk);
            }
            else if (chunk is TagHelperPrefixDirectiveChunk)
            {
                Visit((TagHelperPrefixDirectiveChunk)chunk

            }
            else if (chunk is AddTagHelperChunk)
            {
                Visit((AddTagHelperChunk)chunk);
            }
            else if (chunk is RemoveTagHelperChunk)
            {
                Visit((RemoveTagHelperChunk)chunk);
            }
            else if (chunk is TypeMemberChunk)
            {
                Visit((TypeMemberChunk)chunk);
            }
            else if (chunk is UsingChunk)
            {
                Visit((UsingChunk)chunk);
            }
            else if (chunk is SetBaseTypeChunk)
            {
                Visit((SetBaseTypeChunk)chunk);
            }
            else if (chunk is DynamicCodeAttributeChunk)
            {
                Visit((DynamicCodeAttributeChunk)chunk);
            }
            else if (chunk is LiteralCodeAttributeChunk)
            {
                Visit((LiteralCodeAttributeChunk)chunk);
            }
            else if (chunk is CodeAttributeChunk)
            {
                Visit
namespace SSGL.Voxel
    public class ChunkManager
    {
        public List<Chunk> Chunks;
        public List<Chunk> ChunkLoadList;
        public List<Chunk> ChunkRenderList;
        public List<Chunk> ChunkRebuildList;
        public List<Chunk> ChunkUnLoadList;
        public List<Chunk> ChunkVisibilityList;
        public List<Chunk> ChunkSetupList;
        public List<Chunk> ChunkUpdateFlagsList;
        public List<Chunk> ChunkAsyncList;
        private Vector3 _cameraPosition;
        private Matrix _cameraView;
        private bool _forceVisibilityUpdate;
        private const int ASYNC_NUM_CHUNKS_PER_FRAME = 16;
        private Vector3 _size;
        public ChunkManager(int x, int y, int z)
        {
            Chunks = new List<Chunk>();
            ChunkLoadList = new List<Chunk>();
            ChunkUnLoadList = new List<Chunk>();
            ChunkVisibilityList = new List<Chunk>();
            ChunkRenderList = new List<Chunk>();
            ChunkRebuildList = new List<C

            ChunkSetupList = new List<Chunk>();
            ChunkUpdateFlagsList = new List<Chunk>();
            ChunkAsyncList = new List<Chunk>();
            this._size = new Vector3(x, y, z);
            for (int i = 0; i < x; i++)
            {
                for (int j = 0; j < y; j++)
                {
                    for (int k = 0; k < z; k++)
                    {
                        this.Chunks.Add(new Chunk(new Vector3(i * Chunk.CHUNK_SIZE, j * Chunk.CHUNK_SIZE, k * Chunk.CHUNK_SIZE)) { Manager = this });
                    }
                }
            }
        }
        public void UpdateAsyncChunker()
        {
            this.ChunkAsyncList.Clear();
            int sizex = (int)Math.Ceiling(this._cameraPosition.X) / 10;
            sizex += (int)this._cameraPosition.X / 45;
            int sizez = (int)Math.Ceiling(this._cameraPosition.Z) / 10;
            sizez += (int)this._cameraPosition.Z / 45;
            if (sizex >= 10 && sizez >= 10)
            

                for (int x = sizex - 10; x < sizex; x++)
                {
                    for (int y = 0; y < this._size.Y; y++)
                    {
                        for (int z = sizez - 10; z < sizez; z++)
                        {
                            this.ChunkAsyncList.Add(this.Chunks[(int)(x + this._size.X * (y + this._size.Y * z))]);
                        }
                    }
                }
            }
            Console.WriteLine(this.ChunkAsyncList.Count);
        }
        public void UpdateLoadList()
        {
            int numOfChunksLoaded = 0;
            Chunk chunk;
            for(int i = 0; i < ChunkLoadList.Count && numOfChunksLoaded != ASYNC_NUM_CHUNKS_PER_FRAME; i++)
            {
                chunk = ChunkLoadList[i];
                if (!chunk.IsLoaded && numOfChunksLoaded != ASYNC_NUM_CHUNKS_PER_FRAME)
                {
                    chunk.Load();
                    numOfChunksLoaded++;
                    this._forceV
namespace PhotoHistory.API
	public class APIRegistration : AreaRegistration
	{
		public override string AreaName
		{
			get { return "API"; }
		}
		public override void RegisterArea(AreaRegistrationContext context)
		{
			context.MapRoute(
				"API test",
				"api/test",
				new { controller = "API_API", action = "Hello" } );
			context.MapRoute(
				"API verify credentials",
				"api/users/verify_credentials",
				new { controller = "API_Users", action = "VerifyCredentials" } );
			context.MapRoute(
				"API describe user",
				"api/users/{userName}",
				new { controller = "API_Users", action = "Describe" } );
			context.MapRoute(
				"API describe album",
				"api/albums/{id}",
				new { controller = "API_Albums", action = "Describe" } );
			context.MapRoute(
				"API describe photo",
				"api/photos/{id}",
				new { controller = "API_Photos", action = "Describe" } );
			context.MapRoute(
				"API upload photo",
				"api/photos",
				new { controller = "API_Photos", action = "Upload
namespace Engine.Implementations.ActionManagers
    internal class DispatchManager
    {
        private Player player;
        private IEnumerable<Player> players;
        internal IEnumerable<DispatchItem> Destinations { get; private set; }
        internal DispatchManager(Player player, IEnumerable<Player> players)
        {
            if (player is Dispatcher)
            {
                this.player = player;
                this.players = players;
                this.player.Moved += PlayerMoved;
                this.player.ActionCounter.ActionUsed += ActionUsed;
                foreach (Player sub in players)
                {
                    sub.Moved += PlayerMoved;
                }
                Update();
            }
        }
        private void Update()
        {
            Destinations = GetDispatchDestinations();
        }
        private void PlayerMoved(object sender, PlayerMovedEventArgs e)
        {
            Update();
        }
        private void Act

        {
            Update();
        }
        internal bool CanDispatch(DispatchItem dispatchItem)
        {
            return dispatchItem != null;
        }
        internal void Dispatch(DispatchItem dispatchItem)
        {
            if(CanDispatch(dispatchItem))
            {
                dispatchItem.Player.Move(dispatchItem.DispatchDestination);
                player.ActionCounter.UseAction(dispatchItem.Cost);
            }
        }
        private IEnumerable<DispatchItem> GetDispatchDestinations()
        {
            List<DispatchItem> destinations = new List<DispatchItem>();
            if (player.ActionCounter.Count == 0)
                return destinations;
            foreach (Player player in players)
            {
                DriveManager dm = new DriveManager(player);
                foreach (DriveDestinationItem ddi in dm.GetDestinations(this.player.ActionCounter.Count))
                {
                    if (ddi.Node.Players.Count() == 0)
        
namespace GT
  public static partial class Extensions
  {
    public static void Raise(this EventHandler ev, 
      object sender = default(object), object eventArgs = default(EventArgs))
    {
      bool bFired = false;
      if (ev != null)
      {
        foreach (System.Delegate singleCast in ev.GetInvocationList())
        {
          bFired = false;
          try
          {
            ISynchronizeInvoke syncInvoke = 
              (ISynchronizeInvoke)singleCast.Target;
            if (syncInvoke != null && syncInvoke.InvokeRequired)
            {
              bFired = true;
              syncInvoke.Invoke(singleCast, new object[] { sender, eventArgs });
            }
            else
            {
              bFired = true;
              singleCast.DynamicInvoke(new object[] { sender, eventArgs });
            }
          }
          catch
          {
            if (!bFired)
            {
              try
              {
                singleCast.DynamicInvoke(new object[

              }
              catch
              {
                throw;
              }
            }
            else
            {
              throw;
            }
          }
        }
      }
    }
    public static void Raise<T>(this EventHandler<T> ev, 
      object sender = default(object), object eventArgs = default(EventArgs)) 
      where T : EventArgs
    {
      bool bFired = false;
      if (ev != null)
      {
        foreach (System.Delegate singleCast in ev.GetInvocationList())
        {
          bFired = false;
          try
          {
            ISynchronizeInvoke syncInvoke = (ISynchronizeInvoke)singleCast.Target;
            if (syncInvoke != null && syncInvoke.InvokeRequired)
            {
              bFired = true;
              syncInvoke.Invoke(singleCast, new object[] { sender, eventArgs });
            }
            else
            {
              bFired = true;
              singleCast.DynamicInvoke(new object[] { sender, eventArgs });
           

          }
          catch
          {
            if (!bFired)
            {
              try
              {
                singleCast.DynamicInvoke(new object[] { sender, eventArgs });
              }
              catch
              {
                throw;
              }
            }
            else
            {
              throw;
            }
          }
        }
      }
    }
    public static void Raise(this Delegate ev, object[] args)
    {
      bool bFired = false;
      if (ev != null)
      {
        foreach (System.Delegate singleCast in ev.GetInvocationList())
        {
          bFired = false;
          try
          {
            ISynchronizeInvoke syncInvoke = (ISynchronizeInvoke)singleCast.Target;
            if (syncInvoke != null && syncInvoke.InvokeRequired)
            {
              bFired = true;
              syncInvoke.Invoke(singleCast, args);
            }
            else
            {
              bFired = true;
              singleCast.Dy
namespace Polygon.Connector.InteractiveBrokers
    internal class TickerContainer
    {
        protected readonly ILockObject syncRoot = DeadlockMonitor.Cookie<TickerContainer>();
        private readonly Dictionary<int, Instrument> instrumentByTicker = new Dictionary<int, Instrument>();
        private readonly Dictionary<Instrument, int> tickerByInstrument = new Dictionary<Instrument, int>();
        public void Store(int tickerId, Instrument instrument)
        {
            {
                instrumentByTicker[tickerId] = instrument;
                tickerByInstrument[instrument] = tickerId;
            }
        }
        public bool TryGetTickerId(Instrument instrument, out int tickerId)
        {
            {
                return tickerByInstrument.TryGetValue(instrument, out tickerId);
            }
        }
        public bool TryGetInstrument(int tickerId, out Instrument instrument)
        {
            {
                return instrumentByTicker.TryGetValue(tickerId, o

            }
        }
        public virtual void RemoveTickerId(int tickerId)
        {
            {
                Instrument instrument;
                if (instrumentByTicker.TryGetValue(tickerId, out instrument))
                {
                    tickerByInstrument.Remove(instrument);
                }
                instrumentByTicker.Remove(tickerId);
            }
        }
    }
    internal sealed class PendingResultTickerContainer : TickerContainer
    {
        private readonly Dictionary<int, PendingTestResult> testResultByTicker = new Dictionary<int, PendingTestResult>();
        public bool TryGetInstrumentAndPendingTestResult(int tickerId, out Instrument instrument, out PendingTestResult pendingTestResult)
        {
            {
                if (TryGetInstrument(tickerId, out instrument))
                {
                    if (testResultByTicker.TryGetValue(tickerId, out pendingTestResult))
                    {
                        testResultByTicke
namespace DataAccess
	public class UnitOfWork : IDisposable
	{
		private RequestRepository requestRepository;
		private RequestRowRepository requestRowRepository;
		private StatesRepository stateRepository;
		private UsersRepository userRepository;
		private PostsRepository postRepository;
		private BuyersRepository buyersRepository;
		private GoodsRepository goodsRepository;
		private LeftoversRepository leftoversRepository;
		private PostofficeRepository postofficeRepository;
		private WarehousesRepository warehousesRepository;
		private DataContext db;
		private bool disposed = false;
		public UnitOfWork()
		{
			db = new DataContext();
			db.Configuration.LazyLoadingEnabled = false;
		}
		public UnitOfWork(string connectionString)
		{
			db = new DataContext();
		}
		public RequestRepository Requests
		{
			get
			{
				if (requestRepository == null)
					requestRepository = new RequestRepository(db);
				return requestRepository;
			}
		}
		public RequestRowRepository RequestRows


			get
			{
				if (requestRowRepository == null)
					requestRowRepository = new RequestRowRepository(db);
				return requestRowRepository;
			}
		}
		public StatesRepository States
		{
			get
			{
				if (stateRepository == null)
					stateRepository = new StatesRepository(db);
				return stateRepository;
			}
		}
		public UsersRepository Users
		{
			get
			{
				if (userRepository == null)
					userRepository = new UsersRepository(db);
				return userRepository;
			}
		}
		public PostsRepository Posts
		{
			get
			{
				if (postRepository == null)
					postRepository = new PostsRepository(db);
				return postRepository;
			}
		}
		public BuyersRepository Buyers
		{
			get
			{
				if (buyersRepository == null)
					buyersRepository = new BuyersRepository(db);
				return buyersRepository;
			}
		}
		public GoodsRepository Goods
		{
			get
			{
				if (goodsRepository == null)
					goodsRepository = new GoodsRepository(db);
				return goodsRepository;
			}
		}
		public LeftoversRep
namespace LibMCRcon.WorldData
    public class Region : Voxel
    {
        public Region() : base() { Chunk = OffsetVoxel(16, 16); }
        public Region(Voxel Voxel) : base(Voxel) { Chunk = OffsetVoxel(16, 16); }
        public Voxel Chunk { get; private set; }
        
        NbtChunk nbtChunk;
        NbtChunkSection[] nbtChunkSection = new NbtChunkSection[16];
        int lastChunkIdx = int.MaxValue;
        int lastYSect = int.MaxValue;
        private void ChunkLoad(RegionMCA mca, Voxel Chunk)
        {
            int idx = Chunk.ChunkIdx();
            if (idx != lastChunkIdx)
            {
                nbtChunk = new NbtChunk(mca[idx].chunkNBT);
                lastYSect = int.MaxValue;
                lastChunkIdx = idx;
            }
        }
        private void ChunkYSectLoad(RegionMCA mca, Voxel Chunk)
        {
            int idx = Chunk.Ys;
            if (idx != lastYSect)
            {
                NbtCompound nbtComp = nbtChunk.Section(idx);
              

                lastYSect = idx;
            }
        }
        public NbtChunk NbtChunk(RegionMCA mca, Voxel Chunk)
        {
            ChunkLoad(mca, Chunk);
            return nbtChunk;
        }
        public NbtChunk NbtChunk(RegionMCA mca)
        {
            ChunkLoad(mca, Chunk);
            return nbtChunk;
        }
        public NbtChunkSection NbtChunkSection(RegionMCA mca, Voxel Chunk)
        {
            ChunkLoad(mca, Chunk);
            ChunkYSectLoad(mca, Chunk);
            return nbtChunkSection[lastYSect];
        }
        public NbtChunkSection NbtChunkSection(RegionMCA mca)
        {
            ChunkLoad(mca, Chunk);
            ChunkYSectLoad(mca, Chunk);
            return nbtChunkSection[lastYSect];
        }
        public NbtChunkSection NbtChunkLastSection() 
        {
            return nbtChunkSection[lastYSect];
        }
        public void RefreshChunk()
        {
            Chunk.SetVoxel(Y, Xo, Zo, 16, 16);
        }
        public void M
namespace OceanChip.Common.Storage
    public class ChunkReader
    {
        private readonly ChunkManager _chunkManager;
        private readonly ChunkWriter _chunkWriter;
        public ChunkReader(ChunkManager manager,ChunkWriter writer)
        {
            this._chunkManager = manager;
            this._chunkWriter = writer;
        }
        public T TryReadAt<T>(long position,Func<byte[],T> readRecordFunc,bool autoCache=true)where T :class, ILogRecord
        {
            var lastChunk = _chunkWriter.CurrentChunk;
            var maxPosition = lastChunk.GlobalDataPosition;
            if (position >= maxPosition)
                return null;
            var chunkNum = _chunkManager.GetChunkNum(position);
            var chunk = _chunkManager.GetChunk(chunkNum);
            if (chunk == null)
                throw new ChunkNotExistException(position, chunkNum);
            var localPosition = chunk.ChunkHeader.GetLocalDataPosition(position);
            return chunk.TryReadAt(
namespace ASPire_Training
    public class Instrument
    {
        private int instrumentID;
        private string instrumentName;
        private int weigth;
        private string type;
        #region properties
        public int InstrumentId
        {
            get { return instrumentID; }
            set { instrumentID = value; }
        }
        public string InstrumentName
        {
            get { return instrumentName; }
            set { instrumentName = value; }
        }
        public int Weigth
        {
            get { return weigth; }
            set { weigth = value; }
        }
        public string Type
        {
            get { return type; }
            set { type = value; }
        }
        #endregion
        public Instrument(int instrumentID, string instrumentName, int weigth, string type)
        {
            this.instrumentID = instrumentID;
            this.instrumentName = instrumentName;
            this.weigth = weigth;
            this.type 
namespace Alachisoft.NosDB.Common.Server.Engine.Impl
    public class GetChunkResponse:DatabaseResponse,IGetChunkResponse
    {
        private Alachisoft.NosDB.Common.Protobuf.GetChunkResponse.Builder _getChunkResponse;
        private DataChunk _dataChunkBuilder;
        public GetChunkResponse()
        {
            _getChunkResponse = new Alachisoft.NosDB.Common.Protobuf.GetChunkResponse.Builder();
            _dataChunkBuilder = new DataChunk();
            base.ResponseMessage = this;
        }
        public GetChunkResponse(Alachisoft.NosDB.Common.Protobuf.Response response):base(response.ToBuilder())
        {
            _getChunkResponse = response.GetChunkResponse.ToBuilder();
            _dataChunkBuilder = new DataChunk();
            _dataChunkBuilder.ChunkId = _getChunkResponse.DataChunk.ChunkId;
            _dataChunkBuilder.ReaderUID = _getChunkResponse.DataChunk.ReaderUId;
            _dataChunkBuilder.IsLastChunk = _getChunkResponse.DataChunk.IsLastChunk;
         

                _dataChunkBuilder.Documents.Add(JSONDocument.Parse(document));
            base.ResponseMessage = this;
        }
        internal override void BuildInternal()
        {
            Alachisoft.NosDB.Common.Protobuf.DataChunk.Builder protoDataChunk;
            protoDataChunk = new Alachisoft.NosDB.Common.Protobuf.DataChunk.Builder();
            protoDataChunk.SetChunkId(_dataChunkBuilder.ChunkId);
            protoDataChunk.SetReaderUId(_dataChunkBuilder.ReaderUID);
            foreach (IJSONDocument document in _dataChunkBuilder.Documents)
                protoDataChunk.AddDocuments(document.ToString());
            protoDataChunk.SetIsLastChunk(_dataChunkBuilder.IsLastChunk);
            _getChunkResponse.SetDataChunk(protoDataChunk);
            base._response.SetGetChunkResponse(_getChunkResponse);
            base._response.SetType(Alachisoft.NosDB.Common.Protobuf.Response.Types.Type.GET_CHUNK);
        }
        public IDataChunk DataChunk
        {
           
namespace CourseProvider.Providers
    public class DispatchStudentProvider : Provider
    {
        public const int RC_GET_ALL = 0x1;
        public EventHandler<DispatchStudentEventArgs> DispatchStudentEvent;
        public void GetAll(string sessionId)
        {
            ProviderCarrier carrier = new ProviderCarrier() { Route = "/dispatch/student" };
            carrier.AddAuth(sessionId);
            Bridge.Connect(RC_GET_ALL, carrier);
        }
        public override void ProviderLoaded(object sender, ProviderLoadedEventArgs e)
        {
            base.ProviderLoaded(sender, e);
            List<DispatchInfo> dispatchStudentList = null;
            if (e.IsSuccess)
            {
                switch (e.RequestCode)
                {
                    case RC_GET_ALL:
                        dispatchStudentList = Parser.Serialize<List<DispatchInfo>>();
                        break;
                    default:
                        break;
                }
          
﻿namespace SDK.Lib
    /**
     * @brief 触碰后事件分发系统
     */
    public class TouchDispatchSystem
    {
        private bool mHasTouch;
        private bool mHasMultiTouch;
        public TouchDispatchSystem()
        {
            this.mOnTouchBeganDispatch = new AddOnceEventDispatch();
            this.mOnTouchMovedDispatch = new AddOnceEventDispatch();
            this.mOnTouchStationaryDispatch = new AddOnceEventDispatch();
            this.mOnTouchEndedDispatch = new AddOnceEventDispatch();
            this.mOnTouchCanceledDispatch = new AddOnceEventDispatch();
            this.mOnMultiTouchBeganDispatch = new AddOnceEventDispatch();
            this.mOnMultiTouchMovedDispatch = new AddOnceEventDispatch();
            this.mOnMultiTouchStationaryDispatch = new AddOnceEventDispatch();
            this.mOnMultiTouchEndedDispatch = new AddOnceEventDispatch();
            this.mOnMultiTouchCanceledDispatch = new AddOnceEventDispatch();
        }
        public void init()
        {
    

        public void dispose()
        {
        }
        public void addTouchListener(EventId evtID, MAction<IDispatchObject> handle)
        {
            if (EventId.TOUCHBEGIN_EVENT == evtID)
            {
                this.mOnTouchBeganDispatch.addEventHandle(null, handle);
            }
            else if (EventId.TOUCHMOVED_EVENT == evtID)
            {
                this.mOnTouchMovedDispatch.addEventHandle(null, handle);
            }
            else if (EventId.TOUCHSTATIONARY_EVENT == evtID)
            {
                this.mOnTouchStationaryDispatch.addEventHandle(null, handle);
            }
            else if (EventId.TOUCHENDED_EVENT == evtID)
            {
                this.mOnTouchEndedDispatch.addEventHandle(null, handle);
            }
            else if (EventId.TOUCHCANCELED_EVENT == evtID)
            {
                this.mOnTouchCanceledDispatch.addEventHandle(null, handle);
            }
            this.mHasTouch = true;
        }
        publi

        {
            if (EventId.TOUCHBEGIN_EVENT == evtID)
            {
                this.mOnTouchBeganDispatch.removeEventHandle(null, handle);
            }
            else if (EventId.TOUCHMOVED_EVENT == evtID)
            {
                this.mOnTouchMovedDispatch.removeEventHandle(null, handle);
            }
            else if (EventId.TOUCHSTATIONARY_EVENT == evtID)
            {
                this.mOnTouchStationaryDispatch.removeEventHandle(null, handle);
            }
            else if (EventId.TOUCHENDED_EVENT == evtID)
            {
                this.mOnTouchEndedDispatch.removeEventHandle(null, handle);
            }
            else if (EventId.TOUCHCANCELED_EVENT == evtID)
            {
                this.mOnTouchCanceledDispatch.removeEventHandle(null, handle);
            }
            this.mHasTouch = this.hasEventHandle();
        }
        public bool hasEventHandle()
        {
            if (this.mOnTouchBeganDispatch.hasEventHandle())
        
namespace DrumKitUtilTest
    [TestFixture]
    public class Beats
    {
        private DrumBeat _drumBeat;
        [TestFixtureSetUp]
        public void TestFixtureSetup()
        {
            
        }
        [TestFixtureTearDown]
        public void TestFixtureTeardown()
        {
        }
        [SetUp]
        public void Setup()
        {
            _drumBeat = new DrumBeat(InstrumentType.SnareDrum, 1000);
        }
        [Test]
        public void HasInstrumentTest()
        {
            Assert.True(_drumBeat.HasInstrument(), "Drumbeat has no instrument");
        }
        [Test]
        public void ClearInstrumentTest()
        {
            _drumBeat.Clear();
            Assert.False(_drumBeat.HasInstrument(), "Drumbeat has no instrument");
            Assert.AreEqual(_drumBeat.Instrument, InstrumentType.None);
        }
        [Test]
        public void PlayInstrumentTest()
        {
            _drumBeat.Play();
        }
        [Test]
        public void Check
namespace Yavsc.Controllers
    public class InstrumentsController : Controller
    {
        private ApplicationDbContext _context;
        public InstrumentsController(ApplicationDbContext context)
        {
            _context = context;    
        }
        public IActionResult Index()
        {
            return View(_context.Instrument.ToList());
        }
        public IActionResult Details(long? id)
        {
            if (id == null)
            {
                return HttpNotFound();
            }
            Instrument instrument = _context.Instrument.Single(m => m.Id == id);
            if (instrument == null)
            {
                return HttpNotFound();
            }
            return View(instrument);
        }
        public IActionResult Create()
        {
            return View();
        }
        [HttpPost]
        [ValidateAntiForgeryToken]
        public IActionResult Create(Instrument instrument)
        {
            if (ModelState.IsValid)
     

                _context.Instrument.Add(instrument);
                _context.SaveChanges(User.GetUserId());
                return RedirectToAction("Index");
            }
            return View(instrument);
        }
        public IActionResult Edit(long? id)
        {
            if (id == null)
            {
                return HttpNotFound();
            }
            Instrument instrument = _context.Instrument.Single(m => m.Id == id);
            if (instrument == null)
            {
                return HttpNotFound();
            }
            return View(instrument);
        }
        [HttpPost]
        [ValidateAntiForgeryToken]
        public IActionResult Edit(Instrument instrument)
        {
            if (ModelState.IsValid)
            {
                _context.Update(instrument);
                _context.SaveChanges(User.GetUserId());
                return RedirectToAction("Index");
            }
            return View(instrument);
        }
        [ActionN
namespace DevDay2016SmartGallery.DAL
    public class UnitOfWork : IDisposable
    {
        public AppDbContext Context;
        public UnitOfWork()
        {
            Context = AppDbContext.Create();
        }
        private PictureRepository _pictureRepository;
        public PictureRepository PictureRepository =>
            _pictureRepository ?? (_pictureRepository = new PictureRepository(Context));
        private TagRepository _tagRepository;
        public TagRepository TagRepository =>
            _tagRepository ?? (_tagRepository = new TagRepository(Context));
        private PersonRepository _personRepository;
        public PersonRepository PersonRepository =>
            _personRepository ?? (_personRepository = new PersonRepository(Context));
        private FaceRepository _faceRepository;
        public FaceRepository FaceRepository =>
            _faceRepository ?? (_faceRepository = new FaceRepository(Context));
        public void Dispose()
        {
            C
[TestFixture]
public class PlayerControllerTest : MonoBehaviour {
	[Test]
	public void Incantate_Test()
	{
		var animatorController = GetAnimatorControllerMock();
		var controller = GetPlayerControllerMock (animatorController);
		controller.IncantatePrimary();
		animatorController.Received().SetBool ("Incantate", true);
	}
	[Test]
	public void StopIncantating_Test()
	{
		var animatorController = GetAnimatorControllerMock ();
		var controller = GetPlayerControllerMock (animatorController);
		controller.StopIncantating();
		animatorController.Received ().SetBool ("Incantate", false);
	}
	[Test]
	public void SetPosition_Test_SamePosition()
	{
		var movementController = GetPlayerMovementControllerMock();
		var animatorController = GetAnimatorControllerMock();
		var gridcontroller = GetGridControllerMock ();
		var controller = GetPlayerControllerMock (animatorController, movementController, gridcontroller);
		var square = GetSquareMock ();
		square.GetSubPosition (0).ReturnsForAnyArgs (new 

		square.GetResources ().Returns (new SquareContent());
		gridcontroller.GetSquare (0, 0).Returns(square);
		controller.SetPosition (0, 0, gridcontroller);
		movementController.Received ().SetDestination (new Vector3(0, 0, 0));
	}
	[Test]
	public void SetPosition_Test_DifferentPosition()
	{
		var movementController = GetPlayerMovementControllerMock();
		var animatorController = GetAnimatorControllerMock();
		var gridcontroller = GetGridControllerMock ();
		var controller = GetPlayerControllerMock (animatorController, movementController, gridcontroller);
		var square = GetSquareMock ();
		square.GetSubPosition (0).ReturnsForAnyArgs (new Vector3(3, 3, 3));
		gridcontroller.GetSquare (3, 3).Returns(square);
		controller.SetPosition (3, 3, gridcontroller);
		movementController.Received ().SetDestination (new Vector3(3, 3, 3));
	}
	[Test]
	public void GoToDestination_Test_North()
	{
		var movementController = GetPlayerMovementControllerMock();
		var animatorController = GetAnimatorControll

		var controller = GetPlayerControllerMock (animatorController, movementController, GetGridControllerMock());
		controller.GoToDestination (Orientation.NORTH);
		animatorController.Received ().SetBool ("Walk", true);
		animatorController.Received ().SetInteger ("Orientation", 1);
		movementController.Received ().MoveToDestination (Arg.Any<Vector3>(), Arg.Any<float>());
	}
	[Test]
	public void GoToDestination_Test_East()
	{
		var movementController = GetPlayerMovementControllerMock();
		var animatorController = GetAnimatorControllerMock ();
		var controller = GetPlayerControllerMock (animatorController, movementController, GetGridControllerMock());
		controller.GoToDestination (Orientation.EAST);
		animatorController.Received ().SetBool ("Walk", true);
		animatorController.Received ().SetInteger ("Orientation", 2);
		movementController.Received ().MoveToDestination (Arg.Any<Vector3>(), Arg.Any<float>());
	}
	[Test]
	public void GoToDestination_Test_South()
	{
		var movementController =
namespace HuaHaoERP.Helper.DataDefinition
    static class Process
    {
        public static List<string> ProcessListWithNull
        {
            get 
            {
                List<string> ProcessList = new List<string>();
                ProcessList.Add("无");
                ProcessList.Add("圆片");
                ProcessList.Add("液压");
                ProcessList.Add("冲孔");
                ProcessList.Add("卷边");
                ProcessList.Add("抛光");
                return ProcessList; 
            }
        }
        public static List<string> ProcessListWithAll
        {
            get
            {
                List<string> ProcessList = new List<string>();
                ProcessList.Add("全部工序");
                ProcessList.Add("圆片");
                ProcessList.Add("液压");
                ProcessList.Add("冲孔");
                ProcessList.Add("卷边");
                ProcessList.Add("抛光");
                return ProcessList;
            }
        }
        public static
namespace LongRunningProcess.Tests.Process
    [Subject(typeof(LongRunningProcess.Process))]
    public class When_duration_is_default
    {
        Establish Context = () => Process = new LongRunningProcess.Process(string.Empty, null);
        It Should_be_indeterminate_by_default = () => Process.DurationType.ShouldEqual(ProcessDurationType.Indeterminate);
        static IProcess Process;
    }
    [Subject(typeof(LongRunningProcess.Process))]
    public class When_duration_is_set
    {
        Establish Context = () => Process = new LongRunningProcess.Process(string.Empty, null);
        Because Of = () => Process.DurationType = ProcessDurationType.Determinate;
        It Should_be_determinate = () => Process.DurationType.ShouldEqual(ProcessDurationType.Determinate);
        static IProcess Process;
    }
    [Subject(typeof(LongRunningProcess.Process))]
    public class When_process_is_over_100_but_not_complete
    {
        Establish Context = () =>
        {
            Process = 

            Process.DurationType = ProcessDurationType.Determinate;
        };
        Because Of = () => Process.Report(101);
        It Should_become_indeterminate = () => Process.DurationType.ShouldEqual(ProcessDurationType.Indeterminate);
        static IProcess Process;
    }
    [Subject(typeof(LongRunningProcess.Process))]
    public class When_process_is_over_100_but_complete
    {
        Establish Context = () =>
        {
            Process = new LongRunningProcess.Process(string.Empty, null);
            Process.DurationType = ProcessDurationType.Determinate;
            Process.Completed = true;
        };
        Because Of = () => Process.Report(101);
        It Should_be_determinate = () => Process.DurationType.ShouldEqual(ProcessDurationType.Determinate);
        static IProcess Process;
    }
    [Subject(typeof(LongRunningProcess.Process))]
    public class When_children_exceed_100_weighting : WithFakes
    {
        Establish Context = () =>
        {
            
namespace PSAEC.Web.Front.Controllers.Data
    public class ControllerData: IControllerData
    {
        public IFormsAuthentication FormsAuthentication { get; set; }
        public IAccountRepository AccountRepository { get; set; }
        public IArticlesRepository ArticlesRepository { get; set; }
        public IStaticPagesRepository StaticPagesRepository { get; set; }
        public IFilesRepository FilesRepository { get; set; }
        public ILecturersRepository LecturersRepository { get; set; }
        public IEventsRepository EventsRepository { get; set; }
        public ISettingsRepository SettingsRepository { get; set; }
        public ICommitteeRepository CommitteeRepository { get; set; }
        public ISlideshowRepository SlideshowRepository { get; set; }
        public IAlbumRepository AlbumRepository { get; set; }
        public IGalleryRepository GalleryRepository { get; set; }
        public IFeedbackRepository FeedbackRepository { get; set; }
        public ISessions

        public IBannersRepository BannersRepository { get; set; }
        public ControllerData(IFormsAuthentication formsAuthentication, IAccountRepository accountRepository, IArticlesRepository articlesRepository,
            IStaticPagesRepository staticPagesRepository, IFilesRepository filesRepository, ILecturersRepository lecturersRepository,
            IEventsRepository eventsRepository, ISettingsRepository settingsRepository, ICommitteeRepository committeeRepository,
            ISlideshowRepository slideshowRepository, IAlbumRepository albumRepository, IGalleryRepository galleryRepository,
            IFeedbackRepository feedbackRepository, ISessionsRepository sessionsRepository, IBannersRepository bannersRepository)
        {
            this.FormsAuthentication = formsAuthentication;
            this.AccountRepository = accountRepository;
            this.ArticlesRepository = articlesRepository;
            this.StaticPagesRepository = staticPagesRepository;
            thi
namespace FxConnectProxy.Tests.Validators
    [TestClass]
    public class TradingSettingsProviderValidatorTests
    {
        [TestMethod]
        public void ValidateInstrumentBaseRequest()
        {
            {
                var v = new TradingSettingsProviderValidator();
                InstrumentBaseRequest r = null;
                AssertEx.Throws<ArgumentNullException>(() =>
                    {
                        v.Validate(r);
                    });
            }
            {
                var v = new TradingSettingsProviderValidator();
                InstrumentBaseRequest r = new InstrumentBaseRequest();
                r.Instrument = null;
                AssertEx.Throws<ArgumentNullException>(() =>
                {
                    v.Validate(r);
                });
            }
            {
                var v = new TradingSettingsProviderValidator();
                InstrumentBaseRequest r = new InstrumentBaseRequest();
                r.Instrument 

                AssertEx.Throws<ArgumentNullException>(() =>
                {
                    v.Validate(r);
                });
            }
            {
                var v = new TradingSettingsProviderValidator();
                InstrumentBaseRequest r = new InstrumentBaseRequest();
                r.Instrument = "Test";
                v.Validate(r);
            }
        }
        [TestMethod]
        public void ValidateInstrumentAccountBaseRequest()
        {
            {
                var v = new TradingSettingsProviderValidator();
                InstrumentAccountBaseRequest r = null;
                AssertEx.Throws<ArgumentNullException>(() =>
                    {
                        v.Validate(r);
                    });
            }
            {
                var v = new TradingSettingsProviderValidator();
                InstrumentAccountBaseRequest r = new InstrumentAccountBaseRequest();
                r.Instrument = null;
                AssertEx.

                {
                    v.Validate(r);
                });
            }
            {
                var v = new TradingSettingsProviderValidator();
                InstrumentAccountBaseRequest r = new InstrumentAccountBaseRequest();
                r.Instrument = "";
                AssertEx.Throws<ArgumentNullException>(() =>
                {
                    v.Validate(r);
                });
            }
            {
                var v = new TradingSettingsProviderValidator();
                InstrumentAccountBaseRequest r = new InstrumentAccountBaseRequest();
                r.Instrument = "Test";
                r.Account = null;
                AssertEx.Throws<ArgumentNullException>(() =>
                {
                    v.Validate(r);
                });
            }
            {
                var v = new TradingSettingsProviderValidator();
                InstrumentAccountBaseRequest r = new InstrumentAccountBaseRequest();
                r.I
namespace EQueue.Broker.Storage
    public class ChunkWriter
    {
        public Chunk CurrentChunk { get { return _currentChunk; } }
        private readonly ChunkManager _chunkManager;
        private readonly IScheduleService _scheduleService;
        private readonly object _lockObj = new object();
        private bool _isClosed = false;
        private Chunk _currentChunk;
        public ChunkWriter(ChunkManager chunkManager)
        {
            Ensure.NotNull(chunkManager, "chunkManager");
            _chunkManager = chunkManager;
            _scheduleService = ObjectContainer.Resolve<IScheduleService>();
        }
        public void Open()
        {
            _currentChunk = _chunkManager.GetLastChunk();
            if (!_chunkManager.Config.SyncFlush)
            {
                _scheduleService.StartTask("FlushChunk", Flush, 1000, _chunkManager.Config.FlushChunkIntervalMilliseconds);
            }
            _isClosed = false;
        }
        public long Write(ILogR

        {
            lock (_lockObj)
            {
                if (_isClosed)
                {
                    throw new ChunkWriteException(_currentChunk.ToString(), "Chunk writer is closed.");
                }
                if (_currentChunk.IsCompleted)
                {
                    _currentChunk = _chunkManager.AddNewChunk();
                }
                var result = _currentChunk.TryAppend(record);
                if (!result.Success)
                {
                    _currentChunk.Complete();
                    _currentChunk = _chunkManager.AddNewChunk();
                    result = _currentChunk.TryAppend(record);
                    if (!result.Success)
                    {
                        throw new ChunkWriteException(_currentChunk.ToString(), "Write record to chunk failed.");
                    }
                }
                if (_chunkManager.Config.SyncFlush)
                {
                    _currentChunk.Flush();
        
namespace TheBall.CORE
    public class CreateProcessImplementation
    {
        public static Process GetTarget_Process(string processDescription, string executingOperationName, SemanticInformationItem[] initialArguments)
        {
            Process process = new Process
                {
                    ProcessDescription = processDescription,
                    ExecutingOperation = new SemanticInformationItem(executingOperationName, null),
                };
            process.InitialArguments.AddRange(initialArguments);
            process.SetLocationAsOwnerContent(InformationContext.CurrentOwner, process.ID);
            return process;
        }
        public static ProcessContainer GetTarget_OwnerProcessContainer()
        {
            var processContainer = ObjectStorage.RetrieveFromOwnerContent<ProcessContainer>(InformationContext.CurrentOwner, "default");
            if (processContainer == null)
            {
                processContainer = new ProcessContainer
namespace RPG.src
    class MapManager
    {
        List<Chunk> chunkList = new List<Chunk>();
        internal Point playerRegion;
        internal Point loadedRegion;
        private RenderTarget2D miniMapRenderTarget2D;
        internal Texture2D miniMapTexture2d;
        internal Rectangle miniMapAuxRetangle;
        public MapManager()
        {
            miniMapRenderTarget2D = new RenderTarget2D(Game1.graphicsDeviceManager.GraphicsDevice, 200, 200);
            miniMapAuxRetangle = new Rectangle(0, 0, 1, 1);
        }
        internal void update()
        {
            playerRegion.X = (int)(Game1.mission.player.position.X / Config.chunkSize);
            playerRegion.Y = (int)(Game1.mission.player.position.Y / Config.chunkSize);
            if (playerRegion != loadedRegion)
            {
                loadMap();
                loadedRegion = playerRegion;
            }
        }
        private void loadMap()
        {
            if (playerRegion.X < loadedRegion.X)
   

                loadA();
            }
            if (playerRegion.Y < loadedRegion.Y)
            {
                loadS();
            }
            if (playerRegion.X > loadedRegion.X)
            {
                loadD();
            }
            if (playerRegion.Y > loadedRegion.Y)
            {
                loadW();
            }
            reloadMiniMap();
        }
        private void reloadMiniMap()
        {
            Game1.graphicsDeviceManager.GraphicsDevice.SetRenderTarget(miniMapRenderTarget2D);
            Game1.spriteBatch.Begin();
            foreach (var chunk in chunkList)
            {
                chunk.drawOnMiniMap();
            }
            Game1.spriteBatch.End();
            Game1.graphicsDeviceManager.GraphicsDevice.SetRenderTarget(null);
            Game1.graphicsDeviceManager.GraphicsDevice.ScissorRectangle =  Game1.display.centerViewport.Bounds;
            Game1.graphicsDeviceManager.GraphicsDevice.Viewport = Game1.display.centerViewport;

            miniMapTexture2d = (Texture2D)miniMapRenderTarget2D;
        }
        private void loadW()
        {
            chunkList[6] = chunkList[3];
            chunkList[7] = chunkList[4];
            chunkList[8] = chunkList[5];
            chunkList[3] = chunkList[0];
            chunkList[4] = chunkList[1];
            chunkList[5] = chunkList[2];
            chunkList[0] = new Chunk(playerRegion.X - 1, playerRegion.Y + 1);
            chunkList[1] = new Chunk(playerRegion.X + 0, playerRegion.Y + 1);
            chunkList[2] = new Chunk(playerRegion.X + 1, playerRegion.Y + 1);
        }
        private void loadD()
        {
            chunkList[0] = chunkList[1];
            chunkList[3] = chunkList[4];
            chunkList[6] = chunkList[7];
            chunkList[1] = chunkList[2];
            chunkList[4] = chunkList[5];
            chunkList[7] = chunkList[8];
            chunkList[2] = new Chunk(playerRegion.X + 1, playerRegion.Y + 1);
            chunkList[5] = new C
namespace FastQuant
    public class Subscription
    {
        private ObjectTable fields;
        [Parameter]
        public string Symbol { get; set; } = string.Empty;
        [Parameter]
        public Instrument Instrument { get; set; }
        [Parameter]
        public int InstrumentId { get; set; } = -1;
        [Parameter]
        public IDataProvider Provider { get; set; }
        [Parameter]
        public int ProviderId { get; set; } = -1;
        [Parameter]
        public int RequestId { get; set; } = -1;
        [Parameter]
        public int SourceId { get; set; } = -1;
        [Parameter]
        public int RouteId { get; set; } = -1;
        public ObjectTable Fields => this.fields = this.fields ?? new ObjectTable();
        public object this[int index]
        {
            get
            {
                return Fields[index];
            }
            set
            {
                Fields[index] = value;
            }
        }
        public Subscription()
  

        }
        public Subscription(Instrument instrument, IDataProvider provider, int sourceId = -1)
        {
            SourceId = sourceId;
            Instrument = instrument;
            InstrumentId = instrument?.Id ?? InstrumentId;
            Provider = provider;
            ProviderId = provider?.Id ?? ProviderId;
        }
    }
    public class SubscriptionList : IEnumerable<Subscription>
    {
        private List<Subscription> subscriptions = new List<Subscription>();
        private IdArray<IdArray<int>> subscriptionsByIIdAndPId = new IdArray<IdArray<int>>();
        private IdArray<int> subscriptionsByIId = new IdArray<int>();
        public int Count => this.subscriptions.Count;
        public void Clear()
        {
            this.subscriptions.Clear();
            this.subscriptionsByIIdAndPId.Clear();
        }
        public Subscription Get(Instrument instrument, IDataProvider provider = null) => Get(instrument.Id, provider?.Id ?? 0);
        public Subscript

        {
            if (this.subscriptionsByIIdAndPId[instrumentId] == null)
                return null;
            if (this.subscriptionsByIIdAndPId[instrumentId][providerId] == 0)
                return null;
            return this.subscriptions.FirstOrDefault(s => s.InstrumentId == instrumentId && s.ProviderId == providerId);
        }
        public void Add(Instrument instrument, IDataProvider provider) => Add(new Subscription(instrument, provider, -1));
        public void Add(Subscription subscription)
        {
            var iId = subscription.Instrument.Id;
            this.subscriptionsByIIdAndPId[iId] = this.subscriptionsByIIdAndPId[iId] ?? new IdArray<int>();
            if (this.subscriptionsByIIdAndPId[iId][subscription.ProviderId] == 0)
                this.subscriptions.Add(subscription);
            this.subscriptionsByIId[iId] += 1;
            this.subscriptionsByIIdAndPId[iId][subscription.ProviderId] += 1;
        }
        public void Remove(Subscription s
namespace fluidedotnet
  public delegate void MyCallbackDelegate(SceneParam param);
  public partial class FormParam : Form
  {
    MyCallbackDelegate callback;
    Instrument instrument= new Instrument();
    public FormParam()
    {
      InitializeComponent();
    }
    public void InitParam(string path,MyCallbackDelegate c)
    {
      callback = c;
      var files = from file in Directory.GetFiles(path)
                  orderby file where file.EndsWith(".geo")
                  select file;
      foreach (var file in files)
      {
        FileList.Items.Add(Path.GetFileNameWithoutExtension(file));
      }
      XTrack.Value = 1;
      instrument.zoom = true;
      instrument.zoomx = XTrack.Value;
      instrument.changeinstrument = true;
      SetParams(true);
    }
    private void FormParam_Load(object sender, EventArgs e)
    {
    }
    public void SetParams(bool reinit)
    {
      SceneParam param = new SceneParam();
      param.reinit = reinit;
      if(FileList.SelectedI

        param.file = FileList.SelectedItem.ToString();
      else
      param.file = "triangle";
      param.instrument = instrument;
      callback(param);
    }
    private void FileList_SelectedIndexChanged(object sender, EventArgs e)
    {
      instrument = new Instrument();
      SetParams(true);
    }
    private void XTrack_Scroll(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.zoom = true;
      instrument.zoomx = XTrack.Value;
      instrument.changeinstrument = true;
      SetParams(false);
    }
    private void ButDrop_Click(object sender, EventArgs e)
    {
      instrument = new  Instrument();
      instrument.changeinstrument = true;
      instrument.drop = true;
      SetParams(false);
    }
    private void butPipe_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.pipe = true;
      SetParams(false);
    }
    private void butObstacle_Click(ob

    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.setter = true;
      SetParams(false);
    }
    private void butDelate_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.remover = true;
      SetParams(false);
    }
    private void butForce_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.forceup = true;
      SetParams(false);
    }
    private void butForceDown_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.forcedown = true;
      SetParams(false);
    }
    private void butPush_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.push = true;
      SetParams(false);
    }
    private void 
﻿namespace Microsoft.Web.Http.Description
    public class ApiDescriptionGroupCollectionTest
    {
        [Fact]
        public void versions_should_return_sorted_values()
        {
            var collection = new ApiDescriptionGroupCollection()
            {
                new ApiDescriptionGroup( new ApiVersion( 3, 0 ) ),
                new ApiDescriptionGroup( new ApiVersion( 1, 0 ) ),
                new ApiDescriptionGroup( new ApiVersion( 2, 0 ) )
            };
            var versions = collection.ApiVersions;
            versions.Should().BeEquivalentTo( new ApiVersion( 1, 0 ), new ApiVersion( 2, 0 ), new ApiVersion( 3, 0 ) );
        }
        [Fact]
        public void flatten_should_return_denormalized_api_descriptions_in_order()
        {
            var collection = new ApiDescriptionGroupCollection()
            {
                new ApiDescriptionGroup( new ApiVersion( 3, 0 ) )
                {
                    ApiDescriptions =
                    {
           

                        new VersionedApiDescription() { ApiVersion = new ApiVersion( 3, 0 ), RelativePath = "api/orders" }
                    }
                },
                new ApiDescriptionGroup( new ApiVersion( 1, 0 ) )
                {
                    ApiDescriptions =
                    {
                        new VersionedApiDescription() { ApiVersion = new ApiVersion( 1, 0 ), RelativePath = "api/people" },
                        new VersionedApiDescription() { ApiVersion = new ApiVersion( 1, 0 ), RelativePath = "api/orders" }
                    }
                },
                new ApiDescriptionGroup( new ApiVersion( 2, 0 ) )
                {
                    ApiDescriptions =
                    {
                        new VersionedApiDescription() { ApiVersion = new ApiVersion( 2, 0 ), RelativePath = "api/values" },
                        new VersionedApiDescription() { ApiVersion = new ApiVersion( 2, 0 ), RelativePath = "api/people" },
           

                    }
                }
            };
            var descriptions = collection.Flatten().Cast<VersionedApiDescription>();
            descriptions.ShouldBeEquivalentTo(
                new Collection<VersionedApiDescription>()
                {
                    new VersionedApiDescription() { ApiVersion = new ApiVersion( 1, 0 ), RelativePath = "api/people" },
                    new VersionedApiDescription() { ApiVersion = new ApiVersion( 1, 0 ), RelativePath = "api/orders" },
                    new VersionedApiDescription() { ApiVersion = new ApiVersion( 2, 0 ), RelativePath = "api/values" },
                    new VersionedApiDescription() { ApiVersion = new ApiVersion( 2, 0 ), RelativePath = "api/people" },
                    new VersionedApiDescription() { ApiVersion = new ApiVersion( 2, 0 ), RelativePath = "api/orders" },
                    new VersionedApiDescription() { ApiVersion = new ApiVersion( 3, 0 ), RelativePath = "api/values" },
                
﻿@{
    Layout = "_ColumnsOne";
    Html.AppendPageCssClassParts("html-home-page");
<div class="page home-page">
    <div class="page-body">
        @await Component.InvokeAsync("Widget", new { widgetZone = "home_page_top" })
        @await Component.InvokeAsync("TopicBlock", new { systemName = "HomePageText" })
        @await Component.InvokeAsync("Widget", new { widgetZone = "home_page_before_categories" })
        @await Component.InvokeAsync("HomepageCategories")
        @await Component.InvokeAsync("Widget", new { widgetZone = "home_page_before_products" })
        @await Component.InvokeAsync("HomepageProducts")
        @await Component.InvokeAsync("Widget", new { widgetZone = "home_page_before_best_sellers" })
        @await Component.InvokeAsync("HomepageBestSellers")
        @await Component.InvokeAsync("Widget", new { widgetZone = "home_page_before_news" })
        @await Component.InvokeAsync("HomepageNews")
        @await Component.InvokeAsync("Widget", new { widgetZone = "
namespace Test
    public class ProcessProcessDAO
    {
        public ProcessProcessModel selectProcessModelByidorder(int pid,int order)
        {
            {
                Process process = selectProcessbyIdorder(pid, order,db);
                ProcessProcessModel processmodel = processToProcessModel(process);
                return processmodel;
            }
        }
        public List<ProcessProcessModel> selectProcessModelByid(int pid)
        {
                var selectstring = from p in db.Process where p.pid == pid select p;
                List<Process> processs = selectstring.ToList();
                List<ProcessProcessModel> processmodels = new List<ProcessProcessModel>();
                processs.ForEach(process =>
                {
                    ProcessProcessModel processmodel = processToProcessModel(process);
                    processmodels.Add(processmodel);
                });
                return processmodels;
            }
        }
        public

        {
            {
                Process process = selectProcessbyIdorder(processmodel.Pid, processmodel.Order,db);
                processModelToProcess(processmodel, process);
                int i = db.SaveChanges();
                return i;
            }
        }
        public int updateProcesslist(List<ProcessProcessModel> processlist)
        {
            {
                
                processlist.ForEach(processmodel =>
                {
                    Process process = selectProcessbyIdorder(processmodel.Pid, processmodel.Order, db);
                    processModelToProcess(processmodel, process);
                });
                int i= db.SaveChanges();
                return i;
            }
        }
        public void insertProcessModel(ProcessProcessModel processmodel)
        {
            {
                Process process = processModelToProcess(processmodel);
                db.Process.Add(process);
                db.SaveChanges();
           

        }
        public void insertProcessModelList(List<ProcessProcessModel> processmodellist)
        {
            {
                processmodellist.ForEach(processmodel =>
                {
                    Process process = processModelToProcess(processmodel);
                    db.Process.Add(process);
                });
                db.SaveChanges();
            }
        }
        private ProcessProcessModel processToProcessModel(Process process)
        {
            ProcessProcessModel processmodel = new ProcessProcessModel();
            processmodel.Pid = (int)process.pid;
            processmodel.Bid = (int)process.bid;
            processmodel.Order = (int)process.steps;
            processmodel.Handler = process.hanlder;
            processmodel.Nexthandler = process.nexthanlder;
            processmodel.Lasthandler = process.lasthanlder;
            processmodel.State = (ProcessState)Enum.Parse(typeof(ProcessState), process.state);
            return processm
namespace com.espertech.esper.regression.multithread.dispatchmodel
    public class UpdateDispatchViewOrderEnforcingModel : UpdateDispatchViewModel
    {
        private DispatchService dispatchService;
        private DispatchListener dispatchListener;
    
        private DispatchFuture currentFuture;
        internal class ThreadLocalData
        {
            public bool IsDispatchWaiting;
            public LinkedList<int[]> Received;
            internal ThreadLocalData()
            {
                IsDispatchWaiting = false;
                Received = new LinkedList<int[]>();
            }
        }
        private readonly IThreadLocal<ThreadLocalData> threadLocalData =
            ThreadLocalManager.Create<ThreadLocalData>(() => new ThreadLocalData());
    
        private ThreadLocalData LocalData
        {
            get { return threadLocalData.GetOrCreate(); }
        }
    
        public UpdateDispatchViewOrderEnforcingModel(DispatchService dispatchService, DispatchLi

        {
            this.dispatchService = dispatchService;
            this.dispatchListener = dispatchListener;
        }
    
        public void Add(int[] payload)
        {
            var local = LocalData;
            local.Received.AddLast(payload);
            if (!local.IsDispatchWaiting)
            {
                DispatchFuture nextFuture;
                lock(this)
                {
                    nextFuture = new DispatchFuture(this, currentFuture);
                    currentFuture.Later = nextFuture;
                    currentFuture = nextFuture;
                }
                dispatchService.AddExternal(nextFuture);
                local.IsDispatchWaiting = true;
            }
        }
    
        public void Execute()
        {
            var local = LocalData;
            LinkedList<int[]> payloads = local.Received;
            int[][] result = new int[payloads.Count][];
    
            int count = 0;
            foreach (int[] entry in payloads)
 
public struct ChunkLoader
	public Chunk chunk;
public struct ChunkUnloader
	public Chunk chunk;
public class LevelManager : MonoBehaviour
	private string[] OldChunkFilePrefix = { "null" };
	private string[] OldChunkFileSuffixes = { "_Data.chunk" };
	private const string ChunkFilePrefix = "Chunk_";
	private const string ChunkFileSuffix = "_Info.chunk";
	private const string ChunkFolder = "Level";
	public int ChunkSize = 16;
	public float GenerationRange = 10f;
	public float LoadingRange = 10f;
	public Dictionary<string, Chunk> LoadedChunks = new Dictionary<string, Chunk>();
	public Dictionary<string, ChunkLoader> LoadingChunks = new Dictionary<string, ChunkLoader>();
	public Dictionary<string, ChunkUnloader> UnloadingChunks = new Dictionary<string, ChunkUnloader>();
	public Dictionary<string, ChunkGenerator> GeneratingChunks = new Dictionary<string, ChunkGenerator>();
	public Dictionary<string, Chunk> GeneratedChunks = new Dictionary<string, Chunk>();
	void Awake()
	{
		ChunkFolderStruc

		UpdateChunkFileNames();
	}
	private void ChunkFolderStructure()
	{
		if (!Directory.Exists(ChunkSavePath()))
		{
			Directory.CreateDirectory(ChunkSavePath());
		}
	}
	private void UpdateChunkFileNames()
	{
		DirectoryInfo chunkFolder = new DirectoryInfo(ChunkSavePath());
		string tmpFileName = "";
		foreach (var file in chunkFolder.GetFiles())
		{
			tmpFileName = file.Name;
			foreach (var oldChunkFilePrefix in OldChunkFilePrefix)
			{
				foreach (var oldChunkFileSuffix in OldChunkFileSuffixes)
				{
					tmpFileName = tmpFileName.Replace(oldChunkFilePrefix, ChunkFilePrefix);
					tmpFileName = tmpFileName.Replace(oldChunkFileSuffix, ChunkFileSuffix);
				}
			}
			if (!tmpFileName.Contains(ChunkFilePrefix))
			{
				tmpFileName = tmpFileName.Insert(0, ChunkFilePrefix);
			}
			if (!tmpFileName.Contains(ChunkFileSuffix))
			{
				tmpFileName = tmpFileName.Insert(tmpFileName.Length - 1, ChunkFileSuffix);
			}
			file.MoveTo(string.Format("{0}/{1}", file.DirectoryName, tmpFileName)

		}
	}
	void Start()
	{
		LoadChunk(0, 0);
	}
	private void LoadChunk(int x, int z)
	{
		if (IsChunkLoaded(x, z) && IsChunkLoading(x, z))
			return;
		bool generateChunk = false;
		Debug.Log(string.Format("Checking chunk folder for {0},{1} : {2}", x, z, ChunkSavePath()));
		if (System.IO.Directory.Exists(ChunkSavePath()))
		{
			Debug.Log(string.Format("Checking chunk file for {0}", ChunkFileSavePath(x, z)));
			if (System.IO.File.Exists(ChunkFileSavePath(x, z)))
			{
			}
		}
		if (generateChunk && !IsChunkGenerating(x, z) && !IsChunkGenerating(x, z))
		{
			StartGeneratingChunk(x, z);
		}
	}
	private void StartGeneratingChunk(int x, int z)
	{
		if (IsChunkGenerated(x, z) || IsChunkGenerating(x, z))
			return;
		ChunkGenerator gen = new ChunkGenerator(x, z, ChunkSize);
		gen.StartGenerating();
		GeneratingChunks.Add(GetChunkKey(x, z), gen);
	}
	private void StartLoadingChunk(int x, int z)
	{
		if (!IsChunkLoading(x, z) && IsChunkGenerated(x, z))
			LoadingChunks.Add(GetChunkKey(x, z)
namespace SOS.FunctionalServices.Models.CentralStation
	public class FnsMsDispatchAgencyView : IFnsMsDispatchAgencyView
	{
		#region .ctor
		public FnsMsDispatchAgencyView(MS_DispatchAgenciesView viewItem)
		{
			DispatchAgencyID = viewItem.DispatchAgencyID;
			DispatchAgencyTypeId = viewItem.DispatchAgencyTypeId;
			MonitoringStationOSId = viewItem.MonitoringStationOSId;
			DispatchAgencyOsId = viewItem.DispatchAgencyOsId;
			DispatchAgencyName = viewItem.DispatchAgencyName;
			MsAgencyNumber = viewItem.MsAgencyNumber;
			Address1 = viewItem.Address1;
			Address2 = viewItem.Address2;
			City = viewItem.City;
			State = viewItem.State;
			ZipCode = viewItem.ZipCode;
			Phone1 = viewItem.Phone1;
			Phone2 = viewItem.Phone2;
			DispatchAgencyType = viewItem.DispatchAgencyType;
		}
		#endregion .ctor
		#region Properties
		public int DispatchAgencyID { get; private set; }
		public short DispatchAgencyTypeId { get; private set; }
		public string MonitoringStationOSId { get; private set; }

namespace CommonSupport
    internal class InvokeWatchDog
    {
        System.Timers.Timer _invokeWatchTimer = new System.Timers.Timer(250);
        List<WinFormsHelper.AsyncResultInfo> _invokeResults = new List<WinFormsHelper.AsyncResultInfo>();
        public InvokeWatchDog()
        {
        }
        
        ~InvokeWatchDog()
        {
            _invokeWatchTimer.Stop();
            _invokeWatchTimer = null;
        }
        public void Start()
        {
            lock (this)
            {
                _invokeWatchTimer.Elapsed += new System.Timers.ElapsedEventHandler(_invokeWatchTimer_Elapsed);
                _invokeWatchTimer.Start();
            }
        }
        public void Add(WinFormsHelper.AsyncResultInfo info)
        {
            if (_invokeWatchTimer.Enabled)
            {
                lock (this)
                {
                    _invokeResults.Add(info);
                }
            }
        }
        void _invokeWatchTimer_Elapsed(object sender,
namespace Voxels.Objects
    public class GeneratedVoxelVolume : VoxelVolume
    {
        public IntVector3 SizeInVoxels { get; set; }
        public VoxelGenerator Generator { get; set; }
        public void Generate()
        {
        }
		/*
        public Task GenerateAsync()
        {
            return Task.Factory.StartNew(() =>
            {
                var chunkStart = new IntVector3();
                var chunkEnd = new IntVector3();
                var step = 10;
                var chunks = new List<Task<Chunk>>();
                for (chunkStart.X = 0; SizeInVoxels.X > chunkEnd.X; chunkStart.X += step)
                {
                    chunkEnd.X = chunkStart.X + step - 1;
                    for (chunkStart.Y = 0; SizeInVoxels.Y > chunkEnd.Y; chunkStart.Y += step)
                    {
                        chunkEnd.Y = chunkStart.Y + step - 1;
                        for (chunkStart.Z = 0; SizeInVoxels.Z > chunkEnd.Z; chunkStart.Z += step)
                    
﻿#region Using
#endregion
namespace Noctua.Models
    public struct ChunkBlock
    {
        Chunk chunk;
        IntVector3 position;
        public Chunk Chunk
        {
            get { return chunk; }
        }
        public IntVector3 Position
        {
            get { return position; }
        }
        public ChunkBlock(Chunk chunk, IntVector3 position)
        {
            if (chunk == null) throw new ArgumentNullException("chunk");
            if (!chunk.Contains(position)) throw new ArgumentOutOfRangeException("position");
            this.chunk = chunk;
            this.position = position;
        }
        public ChunkBlock GetNeighbor(Side side)
        {
            if (chunk == null)
                throw new InvalidOperationException("Chunk is null.");
            ChunkBlock neighbor;
            neighbor.chunk = chunk;
            neighbor.position = position + side.Direction;
            if (!neighbor.chunk.Contains(neighbor.position))
            {
           
public class ProcessManager : Singleton<ProcessManager>
    public bool IsLoop = true;
    private readonly List<Process> _processList = new List<Process>();
    private int _processPointer;
    private Process _currentProcess;
    protected override void Awake()
    {
        base.Awake();
        _processList.Clear();
        _processList.Add(new SpawnWaveProcess(asteroids: 10));
        _processList.Add(new WaitProcess(waitTime: 10f));
        _processList.Add(new SpawnWaveProcess(asteroids: 30));
        _processList.Add(new WaitProcess(waitTime: 10f));
        _currentProcess = _processList[_processPointer];
    }
    public int ProcessCount
    {
        get { return _processList.Count; }
    }
    public void Attach(Process process)
    {
        _processList.Add(process);
    }
    public void AbortAll()
    {
        foreach (Process process in _processList)
        {
            process.State = ProcessState.Aborted;
        }
    }
    private void FixedUpdate()
    {
       

            return;
        if (_currentProcess.State == ProcessState.Uninitialized)
        {
            _currentProcess.OnInit();
        }
        if (_currentProcess.State == ProcessState.Running)
        {
            _currentProcess.OnUpdate(Time.fixedDeltaTime);
        }
        if (_currentProcess.IsDead)
        {
            switch (_currentProcess.State)
            {
                case ProcessState.Succeeded:
                    _currentProcess.OnSuccess();
                    IEnumerable<Process> children = _currentProcess.PeekChildren();
                    if (children != null)
                    {
                        foreach (Process child in children)
                        {
                            Attach(child);
                            child.OnAttach();
                        }
                    }
                    break;
                case ProcessState.Failed:
                    _currentProcess.OnFail();
                    break;
        
namespace ShowIt
    public static class ChunkUtils
    {
        #region Packing Methods
        public static void Pack(BufferChunk aChunk, int x, int y)
        {
            aChunk += x;
            aChunk += y;
        }
        public static void Pack(BufferChunk aChunk, int left, int top, int right, int bottom)
        {
            aChunk += left;
            aChunk += top;
            aChunk += right;
            aChunk += bottom;
        }
        public static void Pack(BufferChunk chunk, Point aPoint)
        {
            chunk += aPoint.X;
            chunk += aPoint.Y;
        }
        public static void Pack(BufferChunk chunk, Point[] points)
        {
            chunk += points.Length;
            for (int i = 0; i < points.Length; i++)
            {
                Pack(chunk, points[i].X, points[i].Y);
            }
        }
        public static void Pack(BufferChunk chunk, Guid uniqueID)
        {
            chunk += uniqueID.ToByteArray();
        }
        pu

        {
            chunk += aTrans.eDx;
            chunk += aTrans.eDy;
            chunk += aTrans.eM11;
            chunk += aTrans.eM12;
            chunk += aTrans.eM21;
            chunk += aTrans.eM22;
        }
        public static void Pack(BufferChunk chunk, TRIVERTEX[] vertices)
        {
            int nVertices = vertices.Length;
            chunk += nVertices;
            for (int i = 0; i < nVertices; i++)
            {
                chunk += vertices[i].x;
                chunk += vertices[i].y;
                chunk += vertices[i].Alpha;
                chunk += vertices[i].Blue;
                chunk += vertices[i].Green;
                chunk += vertices[i].Red;
            }
        }
        public static void Pack(BufferChunk chunk, GRADIENT_RECT[] gRect)
        {
            int nRects = gRect.Length;
            chunk += nRects;
            for (int i = 0; i < nRects; i++)
            {
                chunk += gRect[i].UpperLeft;
                chunk 

            }
        }
        public static void Pack(BufferChunk chunk, GDIBrush aBrush)
        {
            chunk += GDI32.EMR_CREATEBRUSHINDIRECT;
            chunk += (int)aBrush.Style;
            chunk += (int)aBrush.Hatching;
            chunk += aBrush.Color;
            Pack(chunk, aBrush.UniqueID);
        }
        public static void Pack(BufferChunk chunk, GDIPen aPen)
        {
            chunk += GDI32.EMR_CREATEPEN;
            chunk += (int)aPen.Style;
            chunk += 1;
            chunk += aPen.Color;
            Pack(chunk, aPen.UniqueID);
        }
        public static void Pack(BufferChunk chunk, GDIFont aFont)
        {
            chunk += GDI32.EMR_EXTCREATEFONTINDIRECTW;
            chunk += aFont.FaceName.Length;
            chunk += aFont.FaceName;
            chunk += (int)aFont.Height;
            Pack(chunk, aFont.UniqueID);
        }
        #endregion
        #region Unpacking routines
        public static GDIPen UnpackGPen(BufferChunk chunk
namespace Voxels.Universe.Chunks {
    public class ChunkSide {
        private bool loaded = false;
        private Chunk chunk;
        private ChunkType chunkType;
        private ChunkProvider provider;
        private Dictionary<CubeFace, Chunk> chunks;
        private Dictionary<CubeFace, Position> positions;
        public ChunkSide(Chunk chunk, ChunkProvider provider) {
            this.chunk = chunk;
            this.provider = provider;
            chunks = new Dictionary<CubeFace, Chunk>() {
                { CubeFace.TOP,     null },
                { CubeFace.BOTTOM,  null },
                { CubeFace.FRONT,   null },
                { CubeFace.BACK,    null },
                { CubeFace.LEFT,    null },
                { CubeFace.RIGHT,   null },
            };
            positions = new Dictionary<CubeFace, Position>() {
                { CubeFace.TOP,     chunk.Position + Position.Up },
                { CubeFace.BOTTOM,  chunk.Position + Position.Down },
            

                { CubeFace.BACK,    chunk.Position + Position.Back },
                { CubeFace.LEFT,    chunk.Position + Position.Left },
                { CubeFace.RIGHT,   chunk.Position + Position.Right },
            };
            chunkType = chunk.ChunkType;
        }
        public Chunk Fetch(CubeFace side) {
            return chunks[side];
        }
        public void Attach() {
            loaded = true;
            foreach (KeyValuePair<CubeFace, Position> keyValue in positions) {
                if (chunks[keyValue.Key] != null)
                    continue;
                Chunk side = provider.GetChunk(keyValue.Value);
                if (side != null && side.IsAvailable) {
                    if (chunkType != side.ChunkType)
                        chunkType = side.ChunkType;
                    chunks[keyValue.Key] = side;
                    side.Attach();
                } else {
                    loaded = false;
                }
            }
            if (
namespace SmsMis.Models.Console.Handlers.Fee
    public class hdlInstrumentSerial : DbContext
    {public hdlInstrumentSerial() : base("name=ValencySGIEntities") { }
        public IList<InstrumentSerial> SelectAll()
        {
            SmsMis.Models.Console.Handlers.Admin.SmsMisDB db = new SmsMis.Models.Console.Handlers.Admin.SmsMisDB();
            return db.InstrumentSerial.ToList();
        }
        public void save(InstrumentSerial InstrumentSerial, string userId)
        {
            try
            {
                {
                    var entry = context.Entry(InstrumentSerial);
                    if (entry != null)
                    {
                        InstrumentSerial.AddDateTime = DateTime.Now;
                        InstrumentSerial.AddByUserId = userId;
                        if (InstrumentSerial.InstrumentTypeSerial == 0)
                        {
                            InstrumentSerial.InstrumentTypeSerial = Functions.getNextPk("InstrumentSerial", "

                            entry.State = EntityState.Added;
                        }
                        else entry.State = EntityState.Modified;
                        context.SaveChanges();
                    }
                }
            }
            catch (System.Data.Entity.Validation.DbEntityValidationException ex)
            {
            }
            catch (Exception ex)
            {
            }
        }
        public void delete(InstrumentSerial InstrumentSerial)
        {
            try
            {
                var context = new SmsMisDB();
                context.InstrumentSerial.Attach(InstrumentSerial);
                var entry = context.Entry(InstrumentSerial);
                if (entry != null)
                {
                    entry.State = EntityState.Deleted;
                    context.SaveChanges();
                }
            }
            catch (System.Data.Entity.Validation.DbEntityValidationException ex)
            {
            
public class GenerationController : MonoBehaviour {
	private byte curBlockSelection = 1;
	private Texture dirtTexture;
	private Texture stoneTexture;
	private Texture sandTexture;
	private List<Thread> threads = new List<Thread> ();
	public int maxThreads = 8;
	public int viewDistance = 6;
	private int generationDistance;
	private int initializeDistance;
	public int ChunkSizeX = 8;
	public int ChunkSizeY = 64;
	public int ChunkSizeZ = 8;
	public static Material material;
	public GameObject player;
	public Camera camera;
	public GeneratorSpec[] generators;
	private int seed;
	public static Dictionary<string, Chunk> chunkMap;
	private bool initializing;
	void Start () {
		generationDistance = viewDistance +2;
		initializeDistance = generationDistance + 1;
		material = Resources.Load("Materials/GameWorld", typeof(Material)) as Material;
		dirtTexture = Resources.Load ("textures/dirt", typeof(Texture)) as Texture;
		stoneTexture = Resources.Load ("textures/stone", typeof(Texture)) as Textu

		sandTexture = Resources.Load ("textures/sand", typeof(Texture)) as Texture;
		initializing = true;
		seed = Random.Range(int.MinValue , int.MaxValue);
		chunkMap = new Dictionary<string, Chunk>();
		BlockUVLibrary.Initialize ();
		BlockLibrary.initialize ();
		generators = new GeneratorSpec[1];
		GeneratorSpec testGenerator = new GeneratorSpec (seed, new byte[] {0,1,2,3,4,5});
		generators [0] = testGenerator;
		StartCoroutine( InitialGenerate () );
	}
	private void OnGUI()
	{
		if (GUI.Button (new Rect (10, 10, 60, 60), "empty")) {
			curBlockSelection = 0;
		}
		if (GUI.Button (new Rect (80, 10, 60, 60), dirtTexture)) {
			curBlockSelection = 1;
		}
		if (GUI.Button (new Rect (150, 10, 60, 60), stoneTexture)) {
			curBlockSelection = 2;
		}
		if (GUI.Button (new Rect (220, 10, 60, 60), sandTexture)) {
			curBlockSelection = 3;
		}
	}
	IEnumerator InitialGenerate()
	{
		player.SetActive (false);
		chunkMap.Add("0,0", new Chunk(0, 0, ChunkSizeX, ChunkSizeY, ChunkSizeZ));
		chunkMap.

		chunkMap.Add("0,1", new Chunk(0, 1, ChunkSizeX, ChunkSizeY, ChunkSizeZ));
		chunkMap.Add("-1,0", new Chunk(-1, 0, ChunkSizeX, ChunkSizeY, ChunkSizeZ));
		chunkMap.Add("0,-1", new Chunk(0, -1, ChunkSizeX, ChunkSizeY, ChunkSizeZ));
		GenerateChunk (0, 0);
		GenerateChunk (1, 0);
		GenerateChunk (0, 1);
		GenerateChunk (-1, 0);
		GenerateChunk (0, -1);
		yield return StartCoroutine (ShowChunk (0, 0));
		Debug.Log ("INITIALIZATION COMPLETE!!!");
		player.SetActive (true);
		player.transform.position = new Vector3 (ChunkSizeX * .5f, ChunkSizeY + 10, ChunkSizeZ * .5f);
		initializing = false;
	}
	int frameCount =0;
	void Update () {
		frameCount ++;
		if (frameCount == 4)
			frameCount = 0;
		if (initializing)
			return;
		int chunkX =  player.transform.position.x >= 0 ? (int)((player.transform.position.x / ChunkSizeX)) : ((int)(player.transform.position.x / ChunkSizeX)) - 1;
		int chunkZ =  player.transform.position.z >= 0 ? (int)((player.transform.position.z / ChunkSizeZ)) : ((int)(play
namespace AdminMigrationUtility.Helpers.Rsapi.Interfaces
	public interface IRsapiRepositoryGroup
	{
		IGenericRepository<Batch> BatchRepository { get; set; }
		IGenericRepository<BatchSet> BatchSetRepository { get; set; }
		IGenericRepository<Choice> ChoiceRepository { get; set; }
		IGenericRepository<Client> ClientRepository { get; set; }
		IGenericRepository<Document> DocumentRepository { get; set; }
		IGenericRepository<Error> ErrorRepository { get; set; }
		IGenericRepository<Field> FieldRepository { get; set; }
		IGenericRepository<Group> GroupRepository { get; set; }
		IGenericRepository<Layout> LayoutRepository { get; set; }
		IGenericRepository<MarkupSet> MarkupSetRepository { get; set; }
		IGenericRepository<ObjectType> ObjectTypeRepository { get; set; }
		IGenericRepository<RDO> RdoRepository { get; set; }
		IGenericRepository<RelativityApplication> RelativityApplicationRepository { get; set; }
		IGenericRepository<RelativityScript> RelativityScriptRepository { get; set; }
		
﻿namespace Grabacr07.KanColleViewer.Plugins.Models.Raw
    public class combined_battle_airbattle
    {
        public int api_deck_id { get; set; }
        public int[] api_ship_ke { get; set; }
        public int[] api_ship_lv { get; set; }
        public int[] api_nowhps { get; set; }
        public int[] api_maxhps { get; set; }
        public int[] api_nowhps_combined { get; set; }
        public int[] api_maxhps_combined { get; set; }
        public int api_midnight_flag { get; set; }
        public int[][] api_eSlot { get; set; }
        public int[][] api_eKyouka { get; set; }
        public int[][] api_fParam { get; set; }
        public int[][] api_eParam { get; set; }
        public int[][] api_fParam_combined { get; set; }
        public int[] api_search { get; set; }
        public int[] api_formation { get; set; }
        public int[] api_stage_flag { get; set; }
        public Api_Kouku api_kouku { get; set; }
        public int api_support_flag { get; set; }
        pub
namespace Routecraft.Minecraft
    public class Dimension
    {
        private World World;
        public DimensionType Type { get; private set; }
        public string Path { get; private set; }
        private Region[,] Regions = new Region[1024, 1024];
        private Dictionary<Vector2I, Chunk> LoadedChunkMap = new Dictionary<Vector2I, Chunk>();
        public Dimension(World world, DimensionType type)
        {
            this.World = world;
            this.Type = type;
            switch (this.Type)
            {
                case DimensionType.Normal:
                    this.Path = this.World.Path;
                    break;
                case DimensionType.Nether:
                    this.Path = this.World.Path + "\\DIM-1";
                    break;
                case DimensionType.End:
                    this.Path = this.World.Path + "\\DIM1";
                    break;
            }
        }
        #region Serialization
        public void Save()
        {
   

            {
                for (int x = 0; x < 1024; x++)
                {
                    if (this.Regions[y, x] != null)
                    {
                        this.Regions[y, x].Save();
                    }
                }
            }
            Debug.WriteLine("Dimension " + this.Type.ToString() + " saved.");
        }
        #endregion
        #region Regions
        private Region GetRegion(Vector2I regionPos)
        {
            Vector2I indexedPos = regionPos + new Vector2I(512, 512);
            if (this.Regions[indexedPos.y, indexedPos.x] == null)
            {
                Region Region = new Region(this.World, this, regionPos);
                this.Regions[indexedPos.y, indexedPos.x] = Region;
            }
            return this.Regions[indexedPos.y, indexedPos.x];
        }
        public bool IsRegionLoaded(Vector2I regionPos)
        {
            Vector2I indexedPos = regionPos + new Vector2I(512, 512);
            return this.Regions[index

        }
        public void UnloadRegion(Vector2I regionPos)
        {
            Vector2I indexedPos = regionPos + new Vector2I(512, 512);
            if (this.Regions[indexedPos.y, indexedPos.x] == null)
            {
                return;
            }
            this.Regions[indexedPos.y, indexedPos.x].Save();
            this.Regions[indexedPos.y, indexedPos.x] = null;
        }
        #endregion
        #region Chunks
        public Chunk GetChunk(Vector2I chunkPos)
        {
            if (!this.IsChunkLoaded(chunkPos))
            {
                return this.LoadChunk(chunkPos);
            }
            Vector2I regionPos = this.ChunkPosToRegionPos(chunkPos);
            Vector2I localChunkPos = this.WorldChunkPosToRegionChunkPos(chunkPos);
            Region Region = this.GetRegion(regionPos);
            return Region.GetChunk(localChunkPos);
        }
        public bool IsChunkLoaded(Vector2I chunkPos)
        {
            Vector2I regionPos = this.ChunkPosToRe
namespace Brainf
    public class Memory
    {
        const int ChunkSize = 0x1000;
        const int ChunkIndexShift = 12;
        Dictionary<int, byte[]> chunks = new Dictionary<int, byte[]>();        
        internal Memory()
        {
        }
        public byte this[int index]
        {
            get
            {
                int indexInChunk = index & (ChunkSize - 1);
                int chunkIndex = index >> ChunkIndexShift;
                byte[] chunk;
                if (chunks.TryGetValue(chunkIndex, out chunk))
                    return chunk[indexInChunk];
                else
                    return 0;
            }
            set
            {
                int indexInChunk = index & (ChunkSize - 1);
                int chunkIndex = index >> ChunkIndexShift;
                byte[] chunk;
                if (!chunks.TryGetValue(chunkIndex, out chunk))
                    chunks.Add(chunkIndex, chunk = new byte[ChunkSize]);
                chunk[indexInChu
namespace Roomie.Web.Persistence.Repositories
    public class CompositeImplementationRepositoryFactory : IRepositoryFactory
    {
        private IRepositoryFactory[] _repositoryFactories;
        private IComputerRepository _computerRepository;
        private IDeviceRepository _deviceRepository;
        private INetworkGuestRepository _networkGuestRepository;
        private INetworkRepository _networkRepository;
        private IScriptRepository _scriptRepository;
        private ISessionRepository _sessionRepository;
        private ITaskRepository _taskRepository;
        private IUserRepository _userRepository;
        
        public CompositeImplementationRepositoryFactory(params IRepositoryFactory[] repositoryFactories)
        {
            _repositoryFactories = repositoryFactories;
        }
        public IComputerRepository GetComputerRepository()
        {
            if (_computerRepository == null)
            {
                _computerRepository = GetRepository(x =>

            }
            return _computerRepository;
        }
        
        public IDeviceRepository GetDeviceRepository()
        {
            if (_deviceRepository == null)
            {
                _deviceRepository = GetRepository(x => x.GetDeviceRepository());
            }
            return _deviceRepository;
        }
        public INetworkGuestRepository GetNetworkGuestRepository()
        {
            if (_networkGuestRepository == null)
            {
                _networkGuestRepository = GetRepository(x => x.GetNetworkGuestRepository());
            }
            return _networkGuestRepository;
        }
        public INetworkRepository GetNetworkRepository()
        {
            if (_networkRepository == null)
            {
                _networkRepository = GetRepository(x => x.GetNetworkRepository());
            }
            return _networkRepository;
        }
        public IScriptRepository GetScriptRepository()
        {
            if (_scriptR

            {
                _scriptRepository = GetRepository(x => x.GetScriptRepository());
            }
            return _scriptRepository;
        }
        public ISessionRepository GetSessionRepository()
        {
            if (_sessionRepository == null)
            {
                _sessionRepository = GetRepository(x => x.GetSessionRepository());
            }
            return _sessionRepository;
        }
        public ITaskRepository GetTaskRepository()
        {
            if (_taskRepository == null)
            {
                _taskRepository = GetRepository(x => x.GetTaskRepository());
            }
            return _taskRepository;
        }
        public IUserRepository GetUserRepository()
        {
            if (_userRepository == null)
            {
                _userRepository = GetRepository(x => x.GetUserRepository());
            }
            return _userRepository;
        }
        private T GetRepository<T>(Func<IRepositoryFactory, T> se
namespace eLibrary.DAL
    public class UnitOfWork : IDisposable
    {
        private eLContext context = new eLContext();
        private CourseRepository courseRepository;
        private LevelRepository levelRepository;
        private ChapterRepository chapterRepository;
        private TextBookRepository textBookRepository;
        private AdditionalChapterTextRepository additionalChapterTextRepository;
        private LibraryUserRepository libraryUserRepository;
        private QuestionRepository questionRepository;
        private ExamRepository examRepository;
        private ChoiceRepository choiceRepository;
        private BookRepository bookRepository;
        private ColumnRepository columnRepository;
        private RowRepository rowRepository;
        private ShelfRepository shelfRepository;
        private SubjectAreaRepository subjectAreaRepository;
        private PhotoRepository photoRepository;
        private BorrowedItemRepository borrowedItemRepository;
        

        private UserPhotoRepository userPhotoRepository;
        private FinanceRepository financeRepository;
        public FinanceRepository FinanceRepository
        {
            get
            {
                if (this.financeRepository == null)
                {
                    this.financeRepository = new FinanceRepository(context);
                }
                return financeRepository;
            }
        }
        public UserPhotoRepository UserPhotoRepository
        {
            get
            {
                if (this.userPhotoRepository == null)
                {
                    this.userPhotoRepository = new UserPhotoRepository(context);
                }
                return userPhotoRepository;
            }
        }
        public MyRoleRepository MyRoleRepository
        {
            get
            {
                if (this.myRoleRepository == null)
                {
                    this.myRoleRepository = new MyRoleRepository(context);


                return myRoleRepository;
            }
        }
        
        public BorrowedItemRepository BorrowedItemRepository
        {
            get
            {
                if (this.borrowedItemRepository == null)
                {
                    this.borrowedItemRepository = new BorrowedItemRepository(context);
                }
                return borrowedItemRepository;
            }
        }
        public PhotoRepository PhotoRepository
        {
            get
            {
                if (this.photoRepository == null)
                {
                    this.photoRepository = new PhotoRepository(context);
                }
                return photoRepository;
            }
        }
        public SubjectAreaRepository SubjectAreaRepository
        {
            get
            {
                if (this.subjectAreaRepository == null)
                {
                    this.subjectAreaRepository = new SubjectAreaRepository(context);
     
#region license
#endregion
namespace Cecil.FlowAnalysis.Utilities {
	public class InstructionDispatcher {
		public static void Dispatch (Instruction instruction, IInstructionVisitor visitor)
		{
			InstructionVisitorDelegate handler = (InstructionVisitorDelegate)_handlers[instruction.OpCode.Value];
			if (null == handler) throw new ArgumentException (Formatter.FormatInstruction (instruction), "instruction");
			handler (visitor, instruction);
		}
		delegate void InstructionVisitorDelegate (IInstructionVisitor visitor, Instruction instruction);
		static IDictionary _handlers = new Hashtable ();
		static InstructionDispatcher ()
		{
			Bind (new InstructionVisitorDelegate (DispatchNop), OpCodes.Nop);
			Bind (new InstructionVisitorDelegate (DispatchBreak), OpCodes.Break);
			Bind (new InstructionVisitorDelegate (DispatchLdarg_0), OpCodes.Ldarg_0);
			Bind (new InstructionVisitorDelegate (DispatchLdarg_1), OpCodes.Ldarg_1);
			Bind (new InstructionVisitorDelegate (DispatchLdarg_2), OpCode

			Bind (new InstructionVisitorDelegate (DispatchLdarg_3), OpCodes.Ldarg_3);
			Bind (new InstructionVisitorDelegate (DispatchLdloc_0), OpCodes.Ldloc_0);
			Bind (new InstructionVisitorDelegate (DispatchLdloc_1), OpCodes.Ldloc_1);
			Bind (new InstructionVisitorDelegate (DispatchLdloc_2), OpCodes.Ldloc_2);
			Bind (new InstructionVisitorDelegate (DispatchLdloc_3), OpCodes.Ldloc_3);
			Bind (new InstructionVisitorDelegate (DispatchStloc_0), OpCodes.Stloc_0);
			Bind (new InstructionVisitorDelegate (DispatchStloc_1), OpCodes.Stloc_1);
			Bind (new InstructionVisitorDelegate (DispatchStloc_2), OpCodes.Stloc_2);
			Bind (new InstructionVisitorDelegate (DispatchStloc_3), OpCodes.Stloc_3);
			Bind (new InstructionVisitorDelegate (DispatchLdarg), OpCodes.Ldarg, OpCodes.Ldarg_S);
			Bind (new InstructionVisitorDelegate (DispatchLdarga), OpCodes.Ldarga, OpCodes.Ldarga_S);
			Bind (new InstructionVisitorDelegate (DispatchStarg), OpCodes.Starg, OpCodes.Starg_S);
			Bind (new InstructionVisitorDe

			Bind (new InstructionVisitorDelegate (DispatchLdloca), OpCodes.Ldloca, OpCodes.Ldloca_S);
			Bind (new InstructionVisitorDelegate (DispatchStloc), OpCodes.Stloc, OpCodes.Stloc_S);
			Bind (new InstructionVisitorDelegate (DispatchLdnull), OpCodes.Ldnull);
			Bind (new InstructionVisitorDelegate (DispatchLdc_I4_M1), OpCodes.Ldc_I4_M1);
			Bind (new InstructionVisitorDelegate (DispatchLdc_I4_0), OpCodes.Ldc_I4_0);
			Bind (new InstructionVisitorDelegate (DispatchLdc_I4_1), OpCodes.Ldc_I4_1);
			Bind (new InstructionVisitorDelegate (DispatchLdc_I4_2), OpCodes.Ldc_I4_2);
			Bind (new InstructionVisitorDelegate (DispatchLdc_I4_3), OpCodes.Ldc_I4_3);
			Bind (new InstructionVisitorDelegate (DispatchLdc_I4_4), OpCodes.Ldc_I4_4);
			Bind (new InstructionVisitorDelegate (DispatchLdc_I4_5), OpCodes.Ldc_I4_5);
			Bind (new InstructionVisitorDelegate (DispatchLdc_I4_6), OpCodes.Ldc_I4_6);
			Bind (new InstructionVisitorDelegate (DispatchLdc_I4_7), OpCodes.Ldc_I4_7);
			Bind (new InstructionVisi
namespace BodeAbp.Queue.Broker.Storage
    public class ChunkHeader
    {
        public const int Size = 128;
        public readonly int ChunkNumber;
        public readonly int ChunkDataTotalSize;
        public readonly long ChunkDataStartPosition;
        public readonly long ChunkDataEndPosition;
        public ChunkHeader(int chunkNumber, int chunkDataTotalSize)
        {
            chunkNumber.CheckGreaterThan("chunkNumber", 0, true);
            chunkDataTotalSize.CheckGreaterThan("chunkDataTotalSize", 0);
            ChunkNumber = chunkNumber;
            ChunkDataTotalSize = chunkDataTotalSize;
            ChunkDataStartPosition = ChunkNumber * (long)ChunkDataTotalSize;
            ChunkDataEndPosition = (ChunkNumber + 1) * (long)ChunkDataTotalSize;
        }
        public byte[] AsByteArray()
        {
            var array = new byte[Size];
            {
                {
                    writer.Write(ChunkNumber);
                    writer.Write(ChunkDataTotalSize);

                }
            }
            return array;
        }
        public static ChunkHeader FromStream(BinaryReader reader, Stream stream)
        {
            var chunkNumber = reader.ReadInt32();
            var chunkDataTotalSize = reader.ReadInt32();
            return new ChunkHeader(chunkNumber, chunkDataTotalSize);
        }
        public int GetLocalDataPosition(long globalDataPosition)
        {
            if (globalDataPosition < ChunkDataStartPosition || globalDataPosition > ChunkDataEndPosition)
            {
                throw new Exception(string.Format("globalDataPosition {0} is out of chunk data positions [{1}, {2}].", globalDataPosition, ChunkDataStartPosition, ChunkDataEndPosition));
            }
            return (int)(globalDataPosition - ChunkDataStartPosition);
        }
        public override string ToString()
        {
            return string.Format("[ChunkNumber:{0}, ChunkDataTotalSize:{1}, ChunkDataStartPosition:{2}, ChunkDataEndPosition:
namespace WIMARTS.DB.BLL
	public partial class DispatchDetailsBLL
	{
		private DispatchDetailsDAO _DispatchDetailsDAO;
		public DispatchDetailsDAO DispatchDetailsDAO
		{
			get { return _DispatchDetailsDAO; }
			set { _DispatchDetailsDAO = value; }
		}
		public DispatchDetailsBLL()
		{
			DispatchDetailsDAO = new DispatchDetailsDAO();
		}
		public List<DispatchDetails> GetDispatchDetailss()
		{
			try
			{
				return DispatchDetailsDAO.GetDispatchDetailss();
			}
			catch(Exception ex)
			{
				throw ex;
			}
		}
		public DispatchDetails GetDispatchDetails(int DispDetailsID)
		{
			try
			{
				return DispatchDetailsDAO.GetDispatchDetails(DispDetailsID);
			}
			catch(Exception ex)
			{
				throw ex;
			}
		}
		public int AddDispatchDetails(DispatchDetails oDispatchDetails)
		{
			try
			{
				return DispatchDetailsDAO.AddDispatchDetails(oDispatchDetails);
			}
			catch (Exception ex)
			{
				throw ex;
			}
		}
		public int UpdateDispatchDetails(DispatchDetails oDispatchDetails)
		{
	

			{
				return DispatchDetailsDAO.UpdateDispatchDetails(oDispatchDetails);
			}
			catch (Exception ex)
			{
				throw ex;
			}
		}
		public int RemoveDispatchDetails(DispatchDetails oDispatchDetails)
		{
			try
			{
				return DispatchDetailsDAO.RemoveDispatchDetails(oDispatchDetails);
			}
			catch (Exception ex)
			{
				throw ex;
			}
		}
		public int RemoveDispatchDetails(int DispDetailsID)
		{
			try
			{
				return DispatchDetailsDAO.RemoveDispatchDetails(DispDetailsID);
			}
			catch (Exception ex)
			{
				throw ex;
			}
		}
		public List<DispatchDetails> DeserializeDispatchDetailss(string Path)
		{
			try
			{
				return GenericXmlSerializer<List<DispatchDetails>>.Deserialize(Path);
			}
			catch (Exception ex)
			{
				throw ex;
			}
		}
		public void SerializeDispatchDetailss(string Path, List<DispatchDetails> DispatchDetailss)
		{
			try
			{
				GenericXmlSerializer<List<DispatchDetails>>.Serialize(DispatchDetailss, Path);
			}
			catch (Exception ex)
			{
				throw ex;
namespace Umbra.Structures
    public class ChunkQueue
    {
        List<Chunk> ChunkList;
        public int Count
        {
            get { return ChunkList.Count; }
        }
        public ChunkQueue()
        {
            ChunkList = new List<Chunk>();
        }
        public Chunk this[int i]
        {
            get
            {
                if (i >= 0 || i < Count)
                {
                    return ChunkList.ElementAt(i);
                }
                else
                {
                    throw new Exception("Index was out of bounds!");
                }
            }
            set
            {
                if (i >= 0 && i < Count)
                {
                    Chunk chunk = ChunkList.ElementAt(i);
                    ChunkList.Remove(chunk);
                    ChunkList.Insert(i, chunk);
                }
                else
                {
                    throw new Exception("Index was out of bounds!");
                }
   

        }
        public void AddSorted(Chunk chunk)
        {
            if (Contains(chunk))
            {
                return;
            }
            if (Count == 0 || chunk == null)
            {
                Enqueue(chunk);
                return;
            }
            for (int i = 0; i < Count; i++)
            {
                Chunk tempChunk;
                try
                {
                    tempChunk = this[i];
                }
                catch (Exception e)
                {
                    Popup.Post("EXCEPTION!!!!! " + e.Message);
                    Enqueue(chunk);
                    return;
                }
                ChunkIndex modified = chunk.Index * new ChunkIndex(1, 1, 1);
                if (tempChunk != null)
                {
                    int val = ((modified.Position - Constants.Engine_Physics.Player.Position).LengthSquared()).CompareTo((tempChunk.Index.Position - Constants.Engine_Physics.Player.Position).LengthSqua

                    if (val > 0)
                    {
                        ChunkList.Insert(i, chunk);
                        return;
                    }
                    else if (val <= 0)
                    {
                        continue;
                    }
                }
            }
            Enqueue(chunk);
        }
        public void Enqueue(Chunk chunk)
        {
            ChunkList.Add(chunk);
        }
        public Chunk Dequeue()
        {
            Chunk chunk = ChunkList.Last();
            ChunkList.RemoveAt(ChunkList.Count - 1);
            return chunk;
        }
        public bool Contains(Chunk chunk)
        {
            return ChunkList.Contains(chunk);
        }
        public void Remove(Chunk chunk)
        {
            if (ChunkList.Contains(chunk))
            {
                ChunkList.Remove(chunk);
            }
        }
        public Chunk RemoveAt(int index)
        {
            Chunk chunk = ChunkList.ElementAt(index
public class World : MonoBehaviour {
	public const int CHUNKSIZE = 16;
	public const int WORLDSIZE = 3;
	public static Dictionary<Vector3, Chunk> chunks = new Dictionary<Vector3, Chunk>();
	public List<Chunk> chunksToUpdate = new List<Chunk>();
	public GameObject chunkPrefab;
	void Start () 
	{
		StartCoroutine ("TestGeneration");
	}
	IEnumerator TestGeneration() 
	{
		for(int dist = 0;dist<WORLDSIZE;dist++) {
			yield return new WaitForSeconds (1);
			if(dist == 0) {
				addChunk (0, 0);
				continue;
			}
			yield return new WaitForSeconds (1);
			for(int x=-dist;x<=dist;x++) {
				addChunk (x, dist);
			}
			yield return new WaitForSeconds (1);
			for(int y=dist-1;y>-dist;y--) {
				addChunk (dist, y);
			}
			yield return new WaitForSeconds (1);
			for(int x=dist;x>=-dist;x--) {
				addChunk (x, -dist);
			}
				
			yield return new WaitForSeconds (1);
			for(int y=-dist+1;y<dist;y++) {
				addChunk (-dist, y);
			}
		}
	}
	public void addChunk(int x, int z) 
	{
		Vector3 chunkPos 

		GameObject chunkObject = (GameObject) Instantiate (chunkPrefab, chunkPos, Quaternion.identity);
		chunkObject.transform.name = "[" + x + "," + z + "]";
		Chunk chunk = chunkObject.GetComponent<Chunk> ();
		chunksToUpdate.Add (chunk);
		chunks.Add(chunkPos, chunk);
	}
		
	public static Chunk getChunk(Vector3 pos) 
	{
		Vector3 floorPos = new Vector3 (Mathf.Floor (pos.x), Mathf.Floor (pos.y), Mathf.Floor (pos.z));
		int chunkXPos =  (int) Mathf.Floor(floorPos.x / CHUNKSIZE) * CHUNKSIZE;
		int chunkZPos =  (int) Mathf.Floor(floorPos.z / CHUNKSIZE) * CHUNKSIZE;
		Vector3 chunkPos = new Vector3 (chunkXPos, 0, chunkZPos);
		if(chunks.ContainsKey(chunkPos)) {
			return chunks [chunkPos];
		} else {
			return null;
		}
	}
	public static Block getBlock(Vector3 pos) 
	{
		Vector3 floorPos = new Vector3 (Mathf.Floor (pos.x), Mathf.Floor (pos.y), Mathf.Floor (pos.z));
		Chunk chunk = getChunk (floorPos);
		if(chunk != null) {
			Vector3 blockPos;
			blockPos.x = floorPos.x - chunk._chunkPos.x;

/**
 *  Block class
 */
public enum Block_Type{
	DIRT
public class Block{
	protected Block_Type type;
	public int x; 
	public int y;
	public int z; 
	public int chunk_x;
	public int chunk_y; 
	public int chunk_z;
	public int block_size; 
	protected Chunk chunk;
	public MeshData meshdata;
	public Tile tile;
	public Block(Block_Type type, int x, int y, int z, Chunk chunk, int chunk_x, int chunk_y, int chunk_z, Tile tile){
		this.type = type;
		this.x = x; 
		this.y = y;
		this.z = z; 
		this.chunk = chunk;
		this.block_size = chunk.world.block_size;
		this.chunk_x = chunk_x;
		this.chunk_y = chunk_y; 
		this.chunk_z = chunk_z;
		this.tile = tile;
	}
	public bool isSolid(int chunk_x, int chunk_y, int chunk_z){
		Block b = this.chunk.GetBlock (chunk_x, chunk_y, chunk_z);
		if (b == null)
			return false; 
		return true;
	}
	public void generateMesh(MeshData meshdata){
		if (isSolid (chunk_x - 1, chunk_y, chunk_z) == false) {
			meshdata.FaceDataXNegative (this);
		}
		if (isSolid (chunk_x 
namespace WorktileSDK
    public class APIResource
    {
        public UserAPI UserAPI { get; private set; }
        public TeamAPI TeamAPI { get; private set; }
        public ProjectAPI ProjectAPI { get; private set; }
        public EntryAPI EntryAPI { get; private set; }
        public EventAPI EventAPI { get; private set; }
        public FileAPI FileAPI { get; private set; }
        public PageAPI PageAPI { get; private set; }
        public PostAPI PostAPI { get; private set; }
        public TaskAPI TaskAPI { get; private set; }
        public APIResource(Client client)
        {
            this.UserAPI = new UserAPI(client);
            this.TeamAPI = new TeamAPI(client);
            this.ProjectAPI = new ProjectAPI(client);
            this.EntryAPI = new EntryAPI(client);
            this.EventAPI = new EventAPI(client);
            this.FileAPI = new FileAPI(client);
            this.PageAPI = new PageAPI(client);
            this.PostAPI = new PostAPI(client);
          
namespace Model
    public interface IUnitOfWork:IDisposable
    {
        IGenericRepository<Address> AdressRepository { get; }
        IGenericRepository<Area> AreaRepository { get; }
        IGenericRepository<Booking> BookingRepository { get; }
        IGenericRepository<Company> CompanyRepository { get; }
        IGenericRepository<Contact> ContactRepository { get; }
        IGenericRepository<Category> CategoryRepository { get; }
        IGenericRepository<Detail> DetailRepository { get; }
        IGenericRepository<DetailAllocation> DetailAllocationRepository { get; }
        IGenericRepository<Event> EventRepository { get; }
        IGenericRepository<Lecturer> LectureRepository { get; }
        IGenericRepository<Location> LocationRepository { get; }
        IGenericRepository<Person> PersonRepository { get; }
        IGenericRepository<Presentation> PresentationRepository { get; }
        IGenericRepository<Representative> RepresentativeRepository { get; }
        IGenericRep
namespace ProcessServiceWorker
    public class ProcessWorker
    {
        public static Action<string> LogEvent;
        public static List<string> stopped_processes = new List<string>();
        private static void Log(string message)
        {
            if (null != LogEvent)
            {
                LogEvent(message);
            }
        }
        public static void StopProcess(string process)
        {
            Process[] prc = null;
            Log("Ищем процессы");
            prc = System.Diagnostics.Process.GetProcesses();
            Log("Всего нашли "+ prc.Count());
            Log("Ищем процесс " + process);
            prc = System.Diagnostics.Process.GetProcessesByName(process);
            Log("Всего нашли " + prc.Count());
            if (prc!=null){
                Log("Начинаем вырубать " + prc.Count() + " " + process);
                prc.ToList<Process>().ForEach(a =>
                {
                    try
                    {
                        

                        a.Kill();
                        Log("Process Stopped: " + name);
                        File.AppendAllText(Program.successPath, "1");
                    }
                    catch (Exception ex)
                    {
                        Log("Process Stopped Error: " + a.ProcessName + "Error: " + ex.Message);
                    }
                });
            }
        }
        public static void StopProcess(List<string> process)
        {
            process.ForEach(a => StopProcess(a));
        }
        public static void StartProcess(string process_name)
        {
            Process process = null;
            try
            {
                process = new Process();
                process.StartInfo.FileName = process_name;
                process.StartInfo.CreateNoWindow = false;
                process.StartInfo.WindowStyle = ProcessWindowStyle.Normal;
                process.StartInfo.UseShellExecute = false;
                process.Start(
namespace LendingLibrary_Library_Tests
    [TestClass]
    public class ChoralInstrument_Tests
    {
        [TestMethod]
        public void TestChoralInstrumentConstructor_InitialzesFieldIsIncludedInChoralScoreCorrectly()
        {
            ChoralInstrument myChoralInstrument;
            myChoralInstrument = new ChoralInstrument("Oboe", false, true);
            Assert.AreEqual(true, myChoralInstrument.IsIncludedInChoralScore);
        }
        [TestMethod]
        public void TestChoralInstrumentConstructor_InitialzesFieldInstrumentNameCorrectly()
        {
            ChoralInstrument myChoralInstrument;
            myChoralInstrument = new ChoralInstrument(instrumentName: "Oboe", createdByAdministrator: false, isIncludedInChoralScore: true);
            Assert.AreEqual("oboe", myChoralInstrument.InstrumentName);
        }
        [TestMethod]
        public void TestChoralInstrumentConstructor_InitialzesFieldApprovedAsFalse()
        {
            ChoralInstrument myChoralIns

            myChoralInstrument = 
                new ChoralInstrument(instrumentName: "Oboe", createdByAdministrator: false, isIncludedInChoralScore: true);
            Assert.AreEqual(false, myChoralInstrument.Approved);
        }
        [TestMethod]
        public void TestChoralInstrumentConstructor_InitialzesFieldApprovedAsTrue()
        {
            ChoralInstrument myChoralInstrument;
            myChoralInstrument = 
                new ChoralInstrument(instrumentName: "Oboe",createdByAdministrator: true, isIncludedInChoralScore: false);
            Assert.AreEqual(true, myChoralInstrument.Approved);
        }
        [TestMethod]
        public void TestChoralInstrumentConstructor_InitialzesFieldNumberOfTimesUsedAsOne()
        {
            ChoralInstrument myChoralInstrument;
            myChoralInstrument =
                new ChoralInstrument(instrumentName: "Oboe", createdByAdministrator: false, isIncludedInChoralScore: false);
            Assert.AreEqual(1, myChoralIn
namespace Debugger
	public partial class NDebugger
	{
		List<Process> processCollection = new List<Process>();
		
		public event EventHandler<ProcessEventArgs> ProcessStarted;
		public event EventHandler<ProcessEventArgs> ProcessExited;
		
		public IList<Process> Processes {
			get {
				return processCollection.AsReadOnly();
			}
		}
		
		public Process DebugActiveProcess(uint handle, string filename)
		{
			
			InitDebugger(GetProgramVersion(filename));
			Process p = new Process(this,this.CorDebug.DebugActiveProcess(handle,0));
			AddProcess(p);
			return p;
		}
		
		private Process debugActiveProcess(uint handle, string filename)
		{
			InitDebugger(GetProgramVersion(filename));
			Process p = new Process(this,this.CorDebug.DebugActiveProcess(handle,0));
			AddProcess(p);
			return p;
		}
		
		internal Process GetProcess(ICorDebugProcess corProcess)
		{
			foreach (Process process in Processes) {
				if (process.CorProcess == corProcess) {
					return process;
				}
			}
			return 
namespace StorageControl.DataAccess.Builders
    public static class ParameterBuilder
    {
        public static object ToParameterizedObject(this Instrument instrument, bool withoutId)
        {
            if (withoutId)
                return new
                {
                    @manufacturer = instrument.Manufacturer,
                    @model = instrument.Model,
                    @unit_price = instrument.UnitPrice,
                    @amount = instrument.Amount,
                    @category_id = instrument.Category.Id,
                    @type_id = instrument.Type.Id
                };
            else
                return new
                {
                    @id = instrument.Id,
                    @manufacturer = instrument.Manufacturer,
                    @model = instrument.Model,
                    @unit_price = instrument.UnitPrice,
                    @amount = instrument.Amount,
                    @category_id = instrument.Category.Id,
               
namespace WedderburnTestReportsWeb.Models
    public class Instrument
    {
        [Key]
        public int Id { get; set; }
        [Required]
        [Display(Name ="UOM")]
        public UnitOfMeasure UnitOfMeasure { get; set; }
        [Display(Name ="Location")]
        public string InstrumentLocation { get; set; }
        [Required]
        [Display(Name ="Make")]
        public string InstrumentMake { get; set; }
        [Required]
        [Display(Name = "Model")]
        public string InstrumentModel { get; set; }
        [Required]
        [Display(Name = "Type")]
        public string InstrumentType { get; set; }
        [Required]
        [Display(Name = "Class")]
        public InstrumentClass InstrumentClass { get; set; }
        [Required]
        [Display(Name = "Capacity")]
        public int InstrumentCapacity { get; set; }
        [Required]
        [Display(Name = "e/d")]
        public int InstrumentGraduation { get; set; }
        [Required]
        [Display(Nam
﻿namespace _04.Logistics
    public class Program
    {
        private static void Main()
        {
            int loadCount = int.Parse(Console.ReadLine());
            double totalLoad = 0;
            double microbusLoad = 0;
            double truckLoad = 0;
            double trainLoad = 0;
            double avrageLoad = 0;
            for (int i = 0; i < loadCount; i++)
            {
                int load = int.Parse(Console.ReadLine());
                totalLoad += load;
                if (load <= 3)
                {
                    microbusLoad += load;
                }
                else if (load >= 4 && load <= 11)
                {
                    truckLoad += load;
                }
                else
                {
                    trainLoad += load;
                }
            }
            avrageLoad = (microbusLoad * 200 + truckLoad * 175 + trainLoad * 120) / totalLoad;
            Console.WriteLine("{0:F2}", avrageLoad);
            Console
namespace MSGorilla.Controllers
    public class DocumentController : Controller
    {
        [TokenAuthAttribute]
        public ActionResult Index()
        {
            IApiExplorer apiExplorer = GlobalConfiguration.Configuration.Services.GetApiExplorer();
            return View(GetAllAPI());
        }
        private Dictionary<string, List<ApiDescription>> GetAllAPI()
        {
            Dictionary<string, List<ApiDescription>> dict = new Dictionary<string, List<ApiDescription>>();
            dict["api/base"] = FindControllerApi("api/base");
            dict["api/account"] = FindControllerApi("api/account");
            dict["api/attachment"] = FindControllerApi("api/attachment");
            dict["api/message"] = FindControllerApi("api/message");
            dict["api/reply"] = FindControllerApi("api/reply");
            dict["api/topic"] = FindControllerApi("api/topic");
            dict["api/group"] = FindControllerApi("api/group");
            dict["api/metricchart"] = F
namespace SharpWired.Controller {
    public class SharpWiredController {
        private ChatController chatController;
        private UserController userController;
        private NewsController newsController;
        private FileListingController fileListingController;
        private FileTransferController fileTransferController;
        private GroupController groupController;
        private PrivateMessageController privateMessagesController;
        private readonly SharpWiredModel model;
        private Server Server { get; set; }
        private static SharpWiredController instance;
        public static SharpWiredController Instance {
            get { return instance; }
            set {
                if (instance == null) {
                    instance = value;
                } else {
                    throw new SingletonException("Singleton already created");
                }
            }
        }
        public FileTransferController FileTransferController { ge

        public FileListingController FileListingController { get { return fileListingController; } }
        public ChatController ChatController { get { return chatController; } }
        public UserController UserController { get { return userController; } }
        public SharpWiredController(SharpWiredModel model) {
            this.model = model;
            this.model.Connected += OnConnected;
        }
        private void OnConnected(Server server) {
            Server = server;
            Server.Online += OnOnline;
        }
        private void OnOnline() {
            Server.Offline += OnOffline;
            chatController = new ChatController(model);
            userController = new UserController(model);
            groupController = new GroupController(model);
            newsController = new NewsController(model);
            fileListingController = new FileListingController(model);
            fileTransferController = new FileTransferController(model);
            pri
namespace CreVox
	[Serializable]
	public class Save
	{
		public int chunkX = 1;
		public int chunkY = 1;
		public int chunkZ = 1;
		public Dictionary<WorldPos, Block> blocks = new Dictionary<WorldPos, Block>();
		public Save()
		{
		}
		public Save(Volume volume)
		{
			chunkX = volume.chunkX;
			chunkY = volume.chunkY;
			chunkZ = volume.chunkZ;
			for (int x = 0; x < chunkX; x++) {
				for (int y = 0; y < chunkY; y++) {
					for (int z = 0; z < chunkZ; z++) {
						Chunk chunk = volume.GetChunk(x * Chunk.chunkSize, y * Chunk.chunkSize, z * Chunk.chunkSize);
						if (chunk)
							AddChunk(x, y, z, chunk);
					}
				}
			}
		}
		public void AddChunk(int _x, int _y, int _z, Chunk chunk)
		{
			int cx = _x * Chunk.chunkSize;
			int cy = _y * Chunk.chunkSize;
			int cz = _z * Chunk.chunkSize;
			for (int x = 0; x < Chunk.chunkSize; x++) {
				for (int y = 0; y < Chunk.chunkSize; y++) {
					for (int z = 0; z < Chunk.chunkSize; z++) {
						Block block = chunk.GetBlock (x, y, z);
						
namespace Cats.Services.Hub
    public class DispatchService : IDispatchService
    {
        private readonly IUnitOfWork _unitOfWork;
        public DispatchService(IUnitOfWork unitOfWork)
        {
            this._unitOfWork = unitOfWork;
        }
        #region Default Service Implementation
        public bool AddDispatch(Dispatch dispatch)
        {
            _unitOfWork.DispatchRepository.Add(dispatch);
            _unitOfWork.Save();
            return true;
        }
        public bool EditDispatch(Dispatch dispatch)
        {
            _unitOfWork.DispatchRepository.Edit(dispatch);
            _unitOfWork.Save();
            return true;
        }
        public bool DeleteDispatch(Dispatch dispatch)
        {
            if (dispatch == null) return false;
            _unitOfWork.DispatchRepository.Delete(dispatch);
            _unitOfWork.Save();
            return true;
        }
        public bool DeleteById(int id)
        {
            var entity = _unitOfWork

            if (entity == null) return false;
            _unitOfWork.DispatchRepository.Delete(entity);
            _unitOfWork.Save();
            return true;
        }
        public List<Dispatch> GetAllDispatch()
        {
            return _unitOfWork.DispatchRepository.GetAll();
        }
        public Dispatch FindById(int id)
        {
            return _unitOfWork.DispatchRepository.FindById(id);
        }
        public Dispatch FindById(System.Guid id)
        {
            return _unitOfWork.DispatchRepository.GetAll().FirstOrDefault(t => t.DispatchID == id);
        }
        public Dispatch FindByAllocationId(System.Guid id)
        {
            return _unitOfWork.DispatchRepository.GetAll().FirstOrDefault(t => t.DispatchAllocationID == id);
        }
        public List<Dispatch> FindBy(Expression<Func<Dispatch, bool>> predicate)
        {
            return _unitOfWork.DispatchRepository.FindBy(predicate);
        }
        #endregion
        public Dispatch GetD

        {
            return _unitOfWork.DispatchRepository.Get(t => t.GIN == ginNo).FirstOrDefault();
        }
        public Transaction GetDispatchTransaction(Guid dispatchId)
        {
            var transactionGroup =
                _unitOfWork.DispatchDetailRepository.Get(t => t.DispatchID == dispatchId).Select(t => t.TransactionGroup)
                    .FirstOrDefault();
            if (transactionGroup != null && transactionGroup.Transactions.Count > 0)
            {
                return transactionGroup.Transactions.First();
            }
            return null;
        }
        public FDPBalance GetFDPBalance(int FDPID, string RequisitionNo)
        {
            var query =
                _unitOfWork.DispatchAllocationRepository.Get(t => t.FDPID == FDPID && t.RequisitionNo == RequisitionNo);
                        
            FDPBalance balance = new FDPBalance();
            if (query.Count() > 0)
            {
                var total = query.Select(t => t.Am
namespace Microsoft.AspNet.Mvc.Razor.Directives
    public class InjectChunkMerger : IChunkMerger
    {
        private readonly HashSet<string> _addedMemberNames = new HashSet<string>(StringComparer.Ordinal);
        private string _modelType;
        public InjectChunkMerger(string modelType)
        {
            if (modelType == null)
            {
                throw new ArgumentNullException(nameof(modelType));
            }
            _modelType = "<" + modelType + ">";
        }
        public void VisitChunk(Chunk chunk)
        {
            if (chunk == null)
            {
                throw new ArgumentNullException(nameof(chunk));
            }
            var injectChunk = chunk as InjectChunk;
            if (injectChunk != null)
            {
                injectChunk.TypeName = ChunkHelper.ReplaceTModel(injectChunk.TypeName, _modelType);
                _addedMemberNames.Add(injectChunk.MemberName);
            }
        }
        public void MergeInheritedChun

        {
            if (chunkTree == null)
            {
                throw new ArgumentNullException(nameof(chunkTree));
            }
            if (inheritedChunks == null)
            {
                throw new ArgumentNullException(nameof(inheritedChunks));
            }
            for (var i = inheritedChunks.Count - 1; i >= 0; i--)
            {
                var injectChunk = inheritedChunks[i] as InjectChunk;
                if (injectChunk != null &&
                    _addedMemberNames.Add(injectChunk.MemberName))
                {
                    chunkTree.Children.Add(TransformChunk(injectChunk));
                }
            }
        }
        private InjectChunk TransformChunk(InjectChunk injectChunk)
        {
            var typeName = ChunkHelper.ReplaceTModel(injectChunk.TypeName, _modelType);
            if (typeName != injectChunk.TypeName)
            {
                return new InjectChunk(typeName, injectChunk.MemberName)
                {
   
namespace Core.TransactionServer.Agent.Market
    internal sealed class InstrumentStatusTester
    {
        internal static readonly InstrumentStatusTester Default = new InstrumentStatusTester();
        private TradingInfo _tradingInfo;
        private Dictionary<Guid, Protocal.TradingInstrument.InstrumentDayOpenCloseParams> _instrumentDict = new Dictionary<Guid, Protocal.TradingInstrument.InstrumentDayOpenCloseParams>();
        static InstrumentStatusTester() { }
        private InstrumentStatusTester() { }
        internal TradingInfo TradingInfo { get { return _tradingInfo; } }
        internal void Initialize(DataSet ds)
        {
            this.LoadTradingInfo(ds);
            var table = ds.Tables["TradingTime"];
            foreach (DataRow dr in table.Rows)
            {
                Guid InstrumentId = (Guid)dr["InstrumentID"];
                Protocal.TradingInstrument.InstrumentDayOpenCloseParams instrument;
                if (!_instrumentDict.TryGetValue(Instrument

                {
                    TradingTime tradingTIme = Settings.Setting.Default.GetTradingTime(InstrumentId);
                    instrument = new Protocal.TradingInstrument.InstrumentDayOpenCloseParams
                    {
                        Id = InstrumentId,
                        TradeDay = tradingTIme.DayOpenTime.Date,
                        DayOpenTime = tradingTIme.DayOpenTime,
                        DayCloseTime = tradingTIme.DayCloseTime,
                        IsTrading = true
                    };
                    _instrumentDict.Add(InstrumentId, instrument);
                }
                DateTime beginTime = (DateTime)dr["BeginTime"];
                DateTime endTime = (DateTime)dr["EndTime"];
                var session = new Protocal.TradingInstrument.TradingSession
                {
                    BeginTime = beginTime,
                    EndTime = endTime
                };
                instrument.AddSession(session);
            }


        private void LoadTradingInfo(DataSet ds)
        {
            _tradingInfo = new Protocal.TradingInstrument.TradingInfo();
            _tradingInfo.TradingTimeList = new List<InstrumentTradingTime>();
            Dictionary<Guid, InstrumentTradingTime> tradingTimeDict = new Dictionary<Guid, InstrumentTradingTime>();
            var table = ds.Tables["TradingTime"];
            foreach (DataRow dr in table.Rows)
            {
                Guid instrumentId = (Guid)dr["InstrumentID"];
                InstrumentTradingTime instrumentTradingTime;
                if (!tradingTimeDict.TryGetValue(instrumentId, out instrumentTradingTime))
                {
                    instrumentTradingTime = new InstrumentTradingTime();
                    tradingTimeDict.Add(instrumentId, instrumentTradingTime);
                    instrumentTradingTime.Id = instrumentId;
                    instrumentTradingTime.Sessions = new List<TradingSession>();
                }
                Da
namespace Q400Calculator.Models.CalculatorViewModels
    public class ClimbVewModel : ClimbData , CalculateInterface
    {
        
        CalculateInterface Calculate { get; }
        int CalculateInterface.heading
        {
            get
            {
                return Calculate.heading;
            }
            set
            {
                Calculate.heading = value;
            }
        }
        int CalculateInterface.windSpeed
        {
            get
            {
                return Calculate.windSpeed;
            }
            set
            {
                Calculate.windSpeed = value;
            }
        }
        int CalculateInterface.windDirection
        {
            get
            {
                return Calculate.windDirection;
            }
            set
            {
                Calculate.windDirection = value;
            }
        }
        int CalculateInterface.distance
        {
            get
            {
                return

            }
            set
            {
                Calculate.distance = value;
            }
        }
        int CalculateInterface.fuel
        {
            get
            {
                return Calculate.fuel;
            }
            set
            {
                Calculate.fuel = value;
            }
        }
        bool CalculateInterface.rain
        {
            get
            {
                return Calculate.rain;
            }
            set
            {
                Calculate.rain = value;
            }
        }
        bool CalculateInterface.snow
        {
            get
            {
                return Calculate.snow;
            }
            set
            {
                Calculate.snow = value;
            }
        }
        bool CalculateInterface.icing
        {
            get
            {
                return Calculate.icing;
            }
            set
            {
                Calculate.icing = value;
            }

        }
        bool CalculateInterface.headwind
        {
            get
            {
                return Calculate.headwind;
            }
            set
            {
                Calculate.headwind = value;
            }
        }
        bool CalculateInterface.tailwind
        {
            get
            {
                return Calculate.tailwind;
            }
            set
            {
                Calculate.tailwind = value;
            }
        }
        int heading;
        int windSpeed;
        int windDirection;
        int distance;
        int fuel;
        bool rain;
        bool snow;
        bool icing;
        bool headwind;
        bool tailwind;
        
        public ClimbVewModel(int weight, int vfri5, int vfri10,
                             int vfri15, int vClmb)
                             :base( weight, vfri5, vfri10, vfri15, vClmb)
        {
            if(rain == true)
            {
            }
            if(snow == true)
       
﻿﻿﻿﻿
/* *******************************************************
 * author :  qi luo
 * email  :  408176274@qq.com  
 * history:  created by qi luo   2014/03/05 01:58:24 
 * function: 宠物显示
 * *******************************************************/
namespace com.u3d.bases.display.character
    public class PetDisplay : ActionDisplay
    {
        override protected string SortingLayer { get { return "Player"; } }
        /**添加控制脚本**/
        override protected void AddScript(GameObject go)
        {
            if (go.GetComponent<ActionControler>() != null) return;
            Controller = go.AddComponent<ActionControler>();
            Controller.Me = this;
            Controller.Me.Animator = Controller.Me.GoCloth.GetComponent<Animator>();
            var statuController = go.AddComponent<StatuControllerBase>();
            Controller.StatuController = statuController;
            statuController.MeControler = Controller as ActionControler;
            Controller.SkillController = go

            Controller.SkillController.MeController = Controller as ActionControler;
            var attackController = go.AddComponent<PetAttackController>();
            attackController.MeController = Controller as ActionControler;
            Controller.AttackController = attackController;
            var beAttackedController = go.AddComponent<BeAttackedControllerBase>();
            beAttackedController.meController = Controller as ActionControler;
            Controller.BeAttackedController = beAttackedController;
            Controller.AnimationEventController = GoCloth.GetComponent<AnimationEventController>() ?? GoCloth.AddComponent<AnimationEventController>();
            Controller.AnimationEventController.skillController = Controller.SkillController;
            var monsterMoveController = go.AddComponent<MoveControllerBase>();
            monsterMoveController.AnimationEventController = Controller.AnimationEventController;
            monsterMoveController.MeController = C
public static class ProcessExtensions
    {
    private static string ProcessIndexedNameFromProcessId(int processId)
        {
            {
            string processName        = processPid.ProcessName;
            Process[] processesByName = Process.GetProcessesByName(processName);
            string processIndexdName  = null;
            try {
                for (var index = 0; index < processesByName.Length; index++)
                    {
                    processIndexdName = index == 0 ? processName : processName + "#" + index;
                    var processIdFinder = new PerformanceCounter("Process", "ID Process", processIndexdName);
                    if ((int)processIdFinder.NextValue() == processId)
                        {
                        return processIndexdName;
                        }
                    }
                return processIndexdName;
                }
            finally
                {
                foreach (Process p in processesByName)
namespace SmartQuant.FIXApplication
	public static class FIXTypeConverter
	{
		public static class SecurityType
		{
			public static string Convert (InstrumentType? value)
			{
				if (!value.HasValue)
					return (string)null;
				switch (value.Value) {
				case InstrumentType.Stock:
					return "CS";
				case InstrumentType.Future:
					return "FUT";
				case InstrumentType.Option:
					return "OPT";
				case InstrumentType.FutureOption:
					return "FOP";
				case InstrumentType.Bond:
					return "BOND";
				case InstrumentType.FX:
					return "FOR";
				case InstrumentType.Index:
					return "IDX";
				case InstrumentType.ETF:
					return "ETF";
				case InstrumentType.MultiLeg:
					return "MLEG";
				default:
					return (string)null;
				}
			}
			public static InstrumentType? Convert (string value)
			{
				if (value == null)
					return new InstrumentType? ();
				switch (value) {
				case "CS":
					return new InstrumentType? (InstrumentType.Stock);
				case "FUT":
					retur

				case "OPT":
					return new InstrumentType? (InstrumentType.Option);
				case "FOP":
					return new InstrumentType? (InstrumentType.FutureOption);
				case "IDX":
					return new InstrumentType? (InstrumentType.Index);
				case "FOR":
					return new InstrumentType? (InstrumentType.FX);
				case "ETF":
					return new InstrumentType? (InstrumentType.ETF);
				case "MLEG":
					return new InstrumentType? (InstrumentType.MultiLeg);
				case "BOND":
					return new InstrumentType? (InstrumentType.Bond);
				default:
					return new InstrumentType? ();
				}
			}
		}
		public static class PutOrCall
		{
			public static int? Convert (PutCall? value)
			{
				if (!value.HasValue)
					return new int? ();
				switch (value.Value) {
				case PutCall.Put:
					return new int? (0);
				case PutCall.Call:
					return new int? (1);
				default:
					return new int? ();
				}
			}
			public static PutCall? Convert (int? value)
			{
				if (!value.HasValue)
					return new PutCall? ();
				swi
namespace MultiAlign.ViewModels.Instruments
    public class InstrumentPresetFactory
    {
        public static IEnumerable<InstrumentPresetViewModel> Create()
        {
            var presets = new List<InstrumentPresetViewModel>
            {
                Create(InstrumentPresets.Tof),
                Create(InstrumentPresets.Velos),
                Create(InstrumentPresets.LtqOrbitrap)
            };
            return presets;
        }
        public static InstrumentPresetViewModel Create(InstrumentPresets preset)
        {
            InstrumentPresetViewModel model = null;
            switch (preset)
            {
                case InstrumentPresets.Tof:
                    model = new InstrumentPresetViewModel("TOF",
                        12,
                        .03,
                        50,
                        .5,
                        8);
                    break;
                case InstrumentPresets.Velos:
                    model = new Instrument
namespace WebApplication1.Models
	public static class RepositoryHelper
	{
		public static IUnitOfWork GetUnitOfWork()
		{
			return new EFUnitOfWork();
		}		
		
		public static ClientRepository GetClientRepository()
		{
			var repository = new ClientRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static ClientRepository GetClientRepository(IUnitOfWork unitOfWork)
		{
			var repository = new ClientRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OccupationRepository GetOccupationRepository()
		{
			var repository = new OccupationRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OccupationRepository GetOccupationRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OccupationRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OrderRepository GetOrderRepository()
		{
			var repository = new Orde

			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OrderRepository GetOrderRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OrderRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OrderLineRepository GetOrderLineRepository()
		{
			var repository = new OrderLineRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OrderLineRepository GetOrderLineRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OrderLineRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static ProductRepository GetProductRepository()
		{
			var repository = new ProductRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static ProductRepository GetProductRepository(IUnitOfWork unitOfWork)
		{
			var repository = new ProductRepository();
			repository.UnitOfWork = unitOfWork;
			return repo
namespace InstrumentAppV2
	class MainClass
	{
		public static void Main (string[] args)
		{
			Inventory inventory = new Inventory ();
			initializeInventory(inventory);
			Dictionary<string,object> properties = new Dictionary<string,object>();
			properties.Add("builder", Builder.GIBSON);
			properties.Add("backWood", Wood.MAPLE);
			InstrumentSpec whatBryanLikes = new InstrumentSpec(properties);
			List<Instrument> matchingInstruments = inventory.search(whatBryanLikes);
			if (matchingInstruments.Count != 0) {
				Console.WriteLine ("Bryan, you might like these instruments:");
				foreach (Instrument instrument in matchingInstruments) {
					InstrumentSpec instrumentSpec = instrument.Spec;
					Console.WriteLine("  We have a " + instrumentSpec.getProperty("instrumentType") + " with the following properties:");
					foreach (KeyValuePair<string,object> kvproperty in instrumentSpec.getProperties()) {
						if (kvproperty.Key == "instrumentType")
							continue;
						Console.WriteLine

					}
							Console.WriteLine("  You can have this " +
								instrumentSpec.getProperty("instrumentType") + " for $" + 
								instrument.Price + "\n---");
				}
			} else {
				Console.WriteLine("Sorry, Erin, we have nothing for you.");
			}
			Console.ReadKey();
		}
		private static void initializeInventory(Inventory inventory) {
			Dictionary<string,object> properties = new Dictionary<string,object>();
			properties.Add("instrumentType", InstrumentType.GUITAR);
			properties.Add("builder", Builder.COLLINGS);
			properties.Add("model", "CJ");
			properties.Add("type", Typeg.ACOUSTIC);
			properties.Add("numStrings", 6);
			properties.Add("topWood", Wood.INDIAN_ROSEWOOD);
			properties.Add("backWood", Wood.SITKA);
			inventory.addInstrument("11277", 3999.95, new InstrumentSpec(properties));
			properties["builder"] = Builder.MARTIN;
			properties["model"] = "D-18";
			properties["topWood"] = Wood.MAHOGANY;
			properties["backWood"] =  Wood.ADIRONDACK;
			inventory.addInstrument(

			properties["builder"] = Builder.FENDER;
			properties["model"] = "Stratocastor";
			properties["type"] = Typeg.ELECTRIC;
			properties["topWood"] = Wood.ALDER;
			properties["backWood"] = Wood.ALDER;
			inventory.addInstrument("V95693", 1499.95, new InstrumentSpec(properties));
			inventory.addInstrument("V9512", 1549.95, new InstrumentSpec(properties));
			properties["builder"] = Builder.GIBSON;
			properties["model"] =  "Les Paul";
			properties["topWood"] = Wood.MAPLE;
			properties["backWood"] =  Wood.MAPLE;
			inventory.addInstrument("70108276", 2295.95, new InstrumentSpec(properties));
			properties["model"] =  "SG '61 Reissue";
			properties["topWood"] = Wood.MAHOGANY;
			properties["backWood"] = Wood.MAHOGANY;
			inventory.addInstrument("82765501", 1890.95, new InstrumentSpec(properties));
			properties["instrumentType"] = InstrumentType.MANDOLIN;
			properties["type"] = Typeg.ACOUSTIC;
			properties["model"] = "F-5G";
			properties["backWood"] = Wood.MAPLE;
			properties["
namespace Cats.Services.Hub
    public interface IDispatchService
    {
        bool AddDispatch(Dispatch dispatch);
        bool DeleteDispatch(Dispatch dispatch);
        bool DeleteById(int id);
        bool EditDispatch(Dispatch dispatch);
        Dispatch FindById(int id);
        Dispatch FindById(System.Guid id);
        Dispatch FindByAllocationId(System.Guid id);
        List<Dispatch> GetAllDispatch();
        List<Dispatch> FindBy(Expression<Func<Dispatch, bool>> predicate);
        bool RejectToHubs(Dispatch dispatch);
        Dispatch GetDispatchByGIN(string ginNo);
        Transaction GetDispatchTransaction(Guid dispatchId);
        FDPBalance GetFDPBalance(int FDPID, string SINumber);
        List<Commodity> GetAvailableCommodities(string SINumber, int hubID);
        List<DispatchModelModelDto> ByHubIdAndAllocationIDetached(int hubId, Guid dispatchAllocationId);
        List<DispatchModelModelDto> ByHubIdAndOtherAllocationIDetached(int hubId, Guid otherDispatchAllocatio
namespace MWV.Controllers
    public class Truck_dispatch_detailController : Controller
    {
        private MWVDBContext db = new MWVDBContext();
        [HandleModelStateException]
        protected override void OnActionExecuting(ActionExecutingContext context)
        {
            base.OnActionExecuting(context);
            if (!Request.IsAuthenticated)
            {
                this.ModelState.AddModelError("440", "Session Timeout");
                throw new ModelStateException(this.ModelState);
            }
        }
        [HandleModelStateException]
        public ActionResult Index()
        {
            var truck_dispatch_details = db.Truck_dispatch_details.Include(t => t.Order).Include(t => t.Order_products).Include(t => t.Truck_dispatches);
            return View(truck_dispatch_details.ToList());
        }
        [HandleModelStateException]
        public ActionResult Details(int? id)
        {
            if (id == null)
            {
                return ne

            }
            Truck_dispatch_details truck_dispatch_details = db.Truck_dispatch_details.Find(id);
            if (truck_dispatch_details == null)
            {
                return HttpNotFound();
            }
            return View(truck_dispatch_details);
        }
        [HandleModelStateException]
        public ActionResult Create()
        {
            ViewBag.order_id = new SelectList(db.Orders, "order_id", "order_id");
            ViewBag.order_product_id = new SelectList(db.Order_products, "order_product_id", "product_code");
            ViewBag.truck_dispatch_id = new SelectList(db.Truck_dispatches, "truck_dispatch_id", "truck_dispatch_id");
            return View();
        }
        [HttpPost]
        [HandleModelStateException]
        [ValidateAntiForgeryToken]
        public ActionResult Create([Bind(Include = "truck_dispatch_id,order_id,order_product_id,qty")] Truck_dispatch_details truck_dispatch_details)
        {
            truck_dispatch_details

            truck_dispatch_details.order_id = Convert.ToInt16(Request["order_id"]);
            truck_dispatch_details.order_product_id = Convert.ToInt16(Request["order_product_id"]);
            truck_dispatch_details.qty = Convert.ToInt16(Request["qty"]);
            if (ModelState.IsValid)
            {
                db.Truck_dispatch_details.Add(truck_dispatch_details);
                db.SaveChanges();
            }
            ViewBag.order_id = new SelectList(db.Orders, "order_id", "status", truck_dispatch_details.order_id);
            ViewBag.order_product_id = new SelectList(db.Order_products, "order_product_id", "product_code", truck_dispatch_details.order_product_id);
            ViewBag.truck_dispatch_id = new SelectList(db.Truck_dispatches, "truck_dispatch_id", "truck_no", truck_dispatch_details.truck_dispatch_id);
            return RedirectToAction("Edit", "Truck_dispatch", new { id = truck_dispatch_details.truck_dispatch_id });
        }
        [HandleModelStateExc
﻿namespace Telerik.Core
    internal class Message
    {
        private static int counter;
        private MessageDispatchMode dispatchMode;
        private MessageDispatchPhase dispatchPhase;
        private bool handled;
        private bool stopDispatch;
        private int id;
        private object data;
        public Message(int id, object data) : this(id, data, MessageDispatchMode.Bubble)
        {
        }
        public Message(int id, object data, MessageDispatchMode dispatchMode)
        {
            this.id = id;
            this.data = data;
            this.dispatchMode = dispatchMode;
        }
        public bool Handled
        {
            get
            {
                return this.handled;
            }
            set
            {
                this.handled = value;
            }
        }
        public bool StopDispatch
        {
            get
            {
                return this.stopDispatch;
            }
            set
            {
        
namespace QuickConnectPlugin.Commons {
    public static class ProcessUtils {
        public static void StartDetached(String processCommand, TimeSpan delay) {
            ThreadStart threadStart = delegate() {
                Thread.Sleep(delay);
                StartDetached(processCommand);
            };
            Thread thread = new Thread(threadStart);
            thread.Start();
        }
        public static void StartDetached(String processCommand) {
                process.StartInfo.FileName = "cmd.exe";
                process.StartInfo.RedirectStandardInput = true;
                process.StartInfo.RedirectStandardOutput = true;
                process.StartInfo.CreateNoWindow = true;
                process.StartInfo.UseShellExecute = false;
                process.Start();
                process.StandardInput.WriteLine(processCommand);
                process.StandardInput.Flush();
                process.StandardInput.Close();
            }
        }
        public s
namespace CSharpUtils.Common
    public class Instrument : StrongTyped<string>
    {
        public static readonly Instrument CrudeOil = new Instrument("CL", "Light Crude Oil", 0);
        public static readonly Instrument EurUsd = new Instrument("EURUSD", "FX Euro US Dollar", 4);
        public static readonly Instrument Indu = new Instrument("INDU", "Dow Jones Industrial Average", 0);
        public static readonly Instrument Spx500 = new Instrument("SPX500", "S&P500 Index", 0);
        public static readonly Instrument Test = new Instrument("TEST", "Test data only", 0);
        public Instrument(string value, string instrumentName, int decimalPlaces) : base(value)
        {
            InstrumentName = instrumentName;
            DecimalPlaces = decimalPlaces;
        }
        public int DecimalPlaces { get; }
        public string InstrumentName { get; }
        public string Symbol => Value;
        public static Instrument Parse(string instrumentString)
        {
            re
namespace myMVC5Couse.Models
	public static class RepositoryHelper
	{
		public static IUnitOfWork GetUnitOfWork()
		{
			return new EFUnitOfWork();
		}		
		
		public static ClientRepository GetClientRepository()
		{
			var repository = new ClientRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static ClientRepository GetClientRepository(IUnitOfWork unitOfWork)
		{
			var repository = new ClientRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OccupationRepository GetOccupationRepository()
		{
			var repository = new OccupationRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OccupationRepository GetOccupationRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OccupationRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OrderRepository GetOrderRepository()
		{
			var repository = new OrderRep

			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OrderRepository GetOrderRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OrderRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OrderLineRepository GetOrderLineRepository()
		{
			var repository = new OrderLineRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OrderLineRepository GetOrderLineRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OrderLineRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static ProductRepository GetProductRepository()
		{
			var repository = new ProductRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static ProductRepository GetProductRepository(IUnitOfWork unitOfWork)
		{
			var repository = new ProductRepository();
			repository.UnitOfWork = unitOfWork;
			return repo
public class TerrainGenerator : MonoBehaviour {
	public Chunk previousChunk;	
	public Chunk currentChunk;
	public Chunk nextChunk;
	public GameObject character;
	void Start(){
		RepositionChunks ();
		currentChunk.CreateGaps ();
	}
	private void RepositionChunks(){
		float widthPrefabs = previousChunk.WidthGroundPrefab;
		
		
		previousChunk.RepositionChunk (new Vector3 (-widthPrefabs * Chunk.CHUNK_SIZE, 0, 0));
		currentChunk.RepositionChunk (Vector3.zero);
		nextChunk.RepositionChunk (new Vector3 (widthPrefabs * Chunk.CHUNK_SIZE, 0, 0));
	}
	void Update(){
		if (PlayerReachedNextChunk ()) {
			ReassginChunks();
		}
	}
	private bool PlayerReachedNextChunk(){
		bool playerReachedNextChunk = false;
		float distance = character.transform.position.x - nextChunk.transform.position.x;
		if(distance > 0){
			playerReachedNextChunk = true;
		}
		return playerReachedNextChunk;
	}
	private void ReassginChunks(){
		Chunk refToPrev = previousChunk;
		previousChunk = currentChunk;
		currentChunk =
namespace Voxelist.Utilities
    public struct WorldPosition
    {
        public int chunkX;
        public int chunkZ;
        public float inChunkX;
        public float inChunkY;
        public float inChunkZ;
        public Vector3 InChunkPosition
        {
            get { return new Vector3(inChunkX, inChunkY, inChunkZ); }
            set
            {
                inChunkX = value.X;
                inChunkY = value.Y;
                inChunkZ = value.Z;
                fixChunking();
            }
        }
        public ChunkCoordinate ChunkCoordinate
        {
            get { return new ChunkCoordinate(chunkX, chunkZ); }
            set
            {
                chunkX = value.X;
                chunkZ = value.Z;
            }
        }
        public static WorldPosition operator +(WorldPosition wp, Vector3 position)
        {
            return new WorldPosition(wp.chunkX, wp.chunkZ, wp.inChunkX + position.X, wp.inChunkY + position.Y, wp.inChunkZ + position.Z);


        public static Vector3 operator -(WorldPosition a, WorldPosition b)
        {
            Vector3 change = a.InChunkPosition - b.InChunkPosition;
            change.X += GameConstants.CHUNK_X_WIDTH * (a.chunkX - b.chunkX);
            change.Z += GameConstants.CHUNK_Z_LENGTH * (a.chunkZ - b.chunkZ);
            return change;
        }
        public WorldPosition(int chunkX, int chunkZ, float inChunkX, float inChunkY, float inChunkZ)
        {
            this.chunkX = chunkX;
            this.chunkZ = chunkZ;
            this.inChunkX = inChunkX;
            this.inChunkY = inChunkY;
            this.inChunkZ = inChunkZ;
            fixChunking();
        }
        private void fixChunking()
        {
            while (inChunkX < 0)
            {
                chunkX--;
                inChunkX += GameConstants.CHUNK_X_WIDTH;
            }
            while (inChunkX >= GameConstants.CHUNK_X_WIDTH)
            {
                chunkX++;
                inChunkX -= GameCon
namespace Codebreak.Service.World.Database
    public sealed class WorldDbMgr : DbManager<WorldDbMgr>
    {
        public void Initialize(string dbConnection = "")
        {
            AddRepository(ExperienceTemplateRepository.Instance);
            AddRepository(ItemSetRepository.Instance);
            AddRepository(ItemTemplateRepository.Instance);
            AddRepository(CraftEntryRepository.Instance);
            AddRepository(InventoryItemRepository.Instance);
            AddRepository(SpellBookEntryRepository.Instance);
            AddRepository(GuildRepository.Instance);
            AddRepository(TaxCollectorRepository.Instance);
            AddRepository(PaddockRepository.Instance);
            AddRepository(MountTemplateRepository.Instance);
            AddRepository(MountRepository.Instance);
            AddRepository(CharacterWaypointRepository.Instance);
            AddRepository(CharacterGuildRepository.Instance);
            AddRepository(CharacterAlignmentRepository

            AddRepository(CharacterJobRepository.Instance);
            AddRepository(CharacterRepository.Instance);
            AddRepository(CharacterQuestRepository.Instance);
            AddRepository(SocialRelationRepository.Instance);
            AddRepository(BankRepository.Instance);
            AddRepository(MapTriggerRepository.Instance);
            AddRepository(MapTemplateRepository.Instance);
            AddRepository(NpcTemplateRepository.Instance);
            AddRepository(NpcInstanceRepository.Instance);
            AddRepository(NpcQuestionRepository.Instance);
            AddRepository(NpcResponseRepository.Instance);
            AddRepository(MonsterSpawnRepository.Instance);
            AddRepository(MonsterSuperRaceRepository.Instance);
            AddRepository(MonsterRaceRepository.Instance);
            AddRepository(MonsterRepository.Instance);
            AddRepository(MonsterGradeRepository.Instance);
            AddRepository(DropTemplateRepository.Instan
﻿namespace PaintDotNet.Dynamic
    public static class DynamicInvokeUtil
    {
        public static IDynamicInvoke Adapt(object target, bool allowPrivate)
        {
            Validate.IsNotNull<object>(target, "target");
            return new DynamicInvokeViaReflectionDispatch(target, (BindingFlags.Public | BindingFlags.Instance) | (allowPrivate ? BindingFlags.NonPublic : BindingFlags.Default));
        }
        public static IDynamicInvoke TryGetOrWrap(object target)
        {
            Validate.IsNotNull<object>(target, "target");
            IDynamicInvoke invoke = target as IDynamicInvoke;
            if (invoke != null)
            {
                return invoke;
            }
            Type[] types = new Type[] { typeof(string), typeof(object[]) };
            MethodInfo invokeMethodInfo = target.GetType().GetMethod("OnInvokeDynamicMethod", BindingFlags.NonPublic | BindingFlags.Instance, null, types, null);
            if (invokeMethodInfo == null)
            {
       

            }
            return new DynamicInvokeViaPrivateOnInvokeDynamicMethod(target, invokeMethodInfo);
        }
        private sealed class DynamicInvokeViaPrivateOnInvokeDynamicMethod : IDynamicInvoke
        {
            private readonly MethodInfo invokeMethodInfo;
            private readonly object target;
            public DynamicInvokeViaPrivateOnInvokeDynamicMethod(object target, MethodInfo invokeMethodInfo)
            {
                this.target = target;
                this.invokeMethodInfo = invokeMethodInfo;
            }
            public object InvokeDynamicMethod(string name, object[] args)
            {
                object[] parameters = new object[] { name, args };
                return this.invokeMethodInfo.Invoke(this.target, parameters);
            }
        }
        private sealed class DynamicInvokeViaReflectionDispatch : IDynamicInvoke
        {
            private readonly BindingFlags bindingFlags;
            private readonly object targe
namespace Umbra.Structures
    public class ChunkQueue
    {
        List<Chunk> ChunkList;
        public int Count
        {
            get { return ChunkList.Count; }
        }
        public ChunkQueue()
        {
            ChunkList = new List<Chunk>();
        }
        public Chunk this[int i]
        {
            get
            {
                if (i >= 0 || i < Count)
                {
                    return ChunkList.ElementAt(i);
                }
                else
                {
                    throw new Exception("Index was out of bounds!");
                }
            }
            set
            {
                if (i >= 0 && i < Count)
                {
                    Chunk chunk = ChunkList.ElementAt(i);
                    ChunkList.Remove(chunk);
                    ChunkList.Insert(i, chunk);
                }
                else
                {
                    throw new Exception("Index was out of bounds!");
                }
   

        }
        public void AddSorted(Chunk chunk)
        {
            if (Contains(chunk))
            {
                return;
            }
            if (Count == 0 || chunk == null)
            {
                Enqueue(chunk);
                return;
            }
            for (int i = 0; i < Count; i++)
            {
                Chunk tempChunk;
                try
                {
                    tempChunk = this[i];
                }
                catch (Exception e)
                {
                    Popup.Post("EXCEPTION!!!!! " + e.Message);
                    Enqueue(chunk);
                    return;
                }
                ChunkIndex modified = chunk.Index * new ChunkIndex(1, 1, 1);
                if (tempChunk != null)
                {
                    int val = ((modified.Position - Constants.Engines.Physics.Player.Position).LengthSquared).CompareTo((tempChunk.Index.Position - Constants.Engines.Physics.Player.Position).LengthSqua

                    if (val > 0)
                    {
                        ChunkList.Insert(i, chunk);
                        return;
                    }
                    else if (val <= 0)
                    {
                        continue;
                    }
                }
            }
            Enqueue(chunk);
        }
        public void Enqueue(Chunk chunk)
        {
            ChunkList.Add(chunk);
        }
        public Chunk Dequeue()
        {
            Chunk chunk = ChunkList.Last();
            ChunkList.RemoveAt(ChunkList.Count - 1);
            return chunk;
        }
        public bool Contains(Chunk chunk)
        {
            return ChunkList.Contains(chunk);
        }
        public void Remove(Chunk chunk)
        {
            if (ChunkList.Contains(chunk))
            {
                ChunkList.Remove(chunk);
            }
        }
        public Chunk RemoveAt(int index)
        {
            Chunk chunk = ChunkList.ElementAt(index
namespace Lua {
  public abstract class CLRFunctionN : Closure {
    public override object[] InvokeM() {
      return this.InvokeM(new object[] {});
    }
    public override object[] InvokeM(object a1) {
      return this.InvokeM(new object[] { a1 });
    }
    public override object[] InvokeM(object a1, object a2) {
      return this.InvokeM(new object[] { a1, a2 });
    }
    public override object[] InvokeM(object a1, object a2, object a3) {
      return this.InvokeM(new object[] { a1, a2, a3 });
    }
    public override object[] InvokeM(object a1, object a2, object a3,
				    object a4) {
      return this.InvokeM(new object[] { a1, a2, a3, a4 });
    }
    public override object[] InvokeM(object a1, object a2, object a3,
				    object a4, object a5) {
      return this.InvokeM(new object[] { a1, a2, a3, a4, a5 });
    }
    public override object[] InvokeM(object a1, object a2, object a3,
				    object a4, object a5, object a6) {
      return this.InvokeM(new object[] { a1, 

    }
    public override object[] InvokeM(object a1, object a2, object a3,
				    object a4, object a5, object a6,
				    object a7) {
      return this.InvokeM(new object[] { a1, a2, a3, a4, a5, a6, a7 });
    }
    public override object InvokeS() {
      return this.InvokeS(new object[] {});
    }
    public override object InvokeS(object a1) {
      return this.InvokeS(new object[] { a1 });
    }
    public override object InvokeS(object a1, object a2) {
      return this.InvokeS(new object[] { a1, a2 });
    }
    public override object InvokeS(object a1, object a2, object a3) {
      return this.InvokeS(new object[] { a1, a2, a3 });
    }
    public override object InvokeS(object a1, object a2, object a3,
				  object a4) {
      return this.InvokeS(new object[] { a1, a2, a3, a4 });
    }
    public override object InvokeS(object a1, object a2, object a3,
				  object a4, object a5) {
      return this.InvokeS(new object[] { a1, a2, a3, a4, a5 });
    }
    public override ob

				  object a4, object a5, object a6) {
      return this.InvokeS(new object[] { a1, a2, a3, a4, a5, a6 });
    }
    public override object InvokeS(object a1, object a2, object a3,
				  object a4, object a5, object a6,
				  object a7) {
      return this.InvokeS(new object[] { a1, a2, a3, a4, a5, a6, a7 });
    }
  }    
  public abstract class CLRFunction0 : Closure {
    public override object[] InvokeM(object[] args) {
      int l = args.Length - 1;
      return this.InvokeM();
    }
    public override object[] InvokeM(object a1) {
      return this.InvokeM();
    }
    public override object[] InvokeM(object a1, object a2) {
      return this.InvokeM();
    }
    public override object[] InvokeM(object a1, object a2, object a3) {
      return this.InvokeM();
    }
    public override object[] InvokeM(object a1, object a2, object a3, object a4) {
      return this.InvokeM();
    }
    public override object[] InvokeM(object a1, object a2, object a3, object a4, object a5) {
   
public class CreateNewTrackOverlay : UIMenu
	public event Action<TrackData> OnCreate;
	public event Action OnCancel;
	public InputField trackNameInput;
	public UIButton instrumentButton;
	public TrackInstrumentList instrumentList;
	private InstrumentId currentInstrumentId;
	public UIButton createButton;
	public UIButton cancelButton;
	public void Init()
	{
		trackNameInput.text = "VOCALS";
		instrumentList.Init();
		instrumentList.gameObject.SetActive(false);
		currentInstrumentId = InstrumentId.Vocals;
		instrumentButton.setText(currentInstrumentId.ToString().ToUpper());
		instrumentButton.onClick += OnInstrumentButtonClick;
		createButton.onClick += OnCreateButtonClick;
		cancelButton.onClick += OnCancelButtonClick;
	}
	private void OnInstrumentButtonClick()
	{
		instrumentList.gameObject.SetActive(true);
		instrumentList.OnSelect += OnInstrumentSelect;
	}
	private void OnInstrumentSelect(InstrumentId instrumentId)
	{
		instrumentList.OnSelect -= OnInstrumentSelect;
		currentInstrume
namespace Shiny
    [StructLayout(LayoutKind.Sequential)]
    public struct ParentProcessUtilities
    {
        internal IntPtr Reserved1;
        internal IntPtr PebBaseAddress;
        internal IntPtr Reserved2_0;
        internal IntPtr Reserved2_1;
        internal IntPtr UniqueProcessId;
        internal IntPtr InheritedFromUniqueProcessId;
        [DllImport("ntdll.dll")]
        private static extern int NtQueryInformationProcess(IntPtr processHandle, int processInformationClass, ref ParentProcessUtilities processInformation, int processInformationLength, out int returnLength);
        public static Process GetParentProcess()
        {
            return GetParentProcess(Process.GetCurrentProcess().Handle);
        }
        public static Process GetParentProcess(int id)
        {
            var process = Process.GetProcessById(id);
            return GetParentProcess(process.Handle);
        }
        public static Process GetParentProcess(IntPtr handle)
        {
           
namespace UnityOps.UnityAsync
    [Serializable]
    public class InvokeAfterFrame : AsyncOperationScript<OperationOutputs, AsyncOperationErrors, OperationProgress>
    {
        #region properties
        protected Action delayInvokeCallback;
        int delayFrame;
        int startFrame;
        #endregion
        #region public methods
        public static InvokeAfterFrame Call(Action callback)
        {
            InvokeAfterFrame asyncOps = new InvokeAfterFrame(callback);
            asyncOps.Execute();
            return asyncOps;
        }
        public static InvokeAfterFrame Call(Action callback, int delayFrame)
        {
            InvokeAfterFrame asyncOps = new InvokeAfterFrame(callback, delayFrame);
            asyncOps.Execute();
            return asyncOps;
        }
        public static InvokeAfterFrame Call(int delayFrame, Action callback)
        {
            InvokeAfterFrame asyncOps = new InvokeAfterFrame(delayFrame, callback);
            asyncOps.Execute();

            return asyncOps;
        }
        public static InvokeAfterFrame Call(string name, Action callback, int delayFrame)
        {
            InvokeAfterFrame asyncOps = new InvokeAfterFrame(name, callback, delayFrame);
            asyncOps.Execute();
            return asyncOps;
        }
        public static InvokeAfterFrame Call(string name, int delayFrame, Action callback)
        {
            InvokeAfterFrame asyncOps = new InvokeAfterFrame(name, delayFrame, callback);
            asyncOps.Execute();
            return asyncOps;
        }
        public InvokeAfterFrame(Action callback) : this(callback, 1)
        {
        }
        public InvokeAfterFrame(int delayFrame, Action callback) : this(callback, delayFrame)
        {
        }
        public InvokeAfterFrame(Action callback, int delayFrame) : this("InvokeAfterFrame", callback, delayFrame)
        {
        }
        public InvokeAfterFrame(string name, int delayFrame, Action callback) : this(name, callback, 
namespace NAudio.SoundFont 
    internal class InstrumentBuilder : StructureBuilder<Instrument>
    {
        private Instrument lastInstrument = null;
        public override Instrument Read(BinaryReader br) 
        {
            Instrument i = new Instrument();
            string s = Encoding.UTF8.GetString(br.ReadBytes(20), 0, 20);
            if(s.IndexOf('\0') >= 0) 
            {
                s = s.Substring(0,s.IndexOf('\0'));
            }
            i.Name = s;
            i.startInstrumentZoneIndex = br.ReadUInt16();
            if(lastInstrument != null)
            {
                lastInstrument.endInstrumentZoneIndex = (ushort) (i.startInstrumentZoneIndex - 1);
            }
            data.Add(i);
            lastInstrument = i;
            return i;
        }
        public override void Write(BinaryWriter bw, Instrument instrument) 
        {
        }
        public override int Length 
        {
            get 
            {
                return 22;
       
namespace MistRidge
    public static class ChunkMath
    {
        public static int Depth(ChunkRequest chunkRequest)
        {
            return Mathf.FloorToInt((3 + Mathf.Sqrt((12 * chunkRequest.chunkNum) - 3)) / 6);
        }
        public static int Side(ChunkRequest chunkRequest)
        {
            int depth = Depth(chunkRequest);
            return Mathf.CeilToInt((float)chunkRequest.chunkNum / depth) - (3 * depth) + 2;
        }
        public static int DepthStartChunkNum(ChunkRequest chunkRequest)
        {
            int depth = Depth(chunkRequest);
            return (3 * depth * (depth - 1)) + 1;
        }
        public static int DepthEndChunkNum(ChunkRequest chunkRequest)
        {
            int depth = Depth(chunkRequest);
            return 3 * depth * (depth + 1);
        }
        public static int SideStartChunkNum(ChunkRequest chunkRequest)
        {
            int depth = Depth(chunkRequest);
            int side = Side(chunkRequest);
            return
namespace Bd.Icm.Migrations.Scripts
    [Migration(201603110005)]
    public class CreateTableInstrument : Migration
    {
        public override void Up()
        {
            Create.Table("Instrument")
                .WithColumn("Id").AsInt32().NotNullable().PrimaryKey()
                .WithRowVersionIdentity()
                .WithColumn("Type").AsString(150).NotNullable()
                .WithColumn("NickName").AsString(150).Nullable()
                .WithColumn("SerialNumber").AsString(100).NotNullable()
                .WithAuditFields()
                .WithVersioningFields();
            this.CreateUserForeignKeys("Instrument");
            
            Create.ForeignKey("FK_Instrument_InstrumentVersion")
                .FromTable("Instrument").InSchema("dbo").ForeignColumn("Id")
                .ToTable("InstrumentVersion").InSchema("dbo").PrimaryColumn("InstrumentId");
        }
        public override void Down()
        {
            this.DeleteUserForeignKeys("Instru
namespace Plasma_Rev
    public class Map
    {
        public Player player = new Player(0, 0);
        public List<Chunk> loadedChunks = new List<Chunk>();
        public Map()
        {
            player = new Player(0, 0);
            checkChunks();
        }
        public Map(Player newPlayer)
        {
            player = newPlayer;
            checkChunks();
        }
        public void checkChunks()
        {
            int playerChunkX = MathHelper.fastFloor(player.posX / (double)Ref.tileAmountX);
            int playerChunkY = MathHelper.fastFloor(player.posY / (double)Ref.tileAmountY);
            /** Unload chunks */
            unloadChunks(playerChunkX, playerChunkY);
            /** Load chunks */
            loadChunks(playerChunkX, playerChunkY);
        }
        public void Draw(SpriteBatch spriteBatch)
        {
            loadedChunks.ForEach(chunk => chunk.Draw(spriteBatch));
        }
        private void unloadChunks(int playerChunkX, int playerChunkY)
   

            Chunk chunk = new Chunk(0, 0);
            loadedChunks.ForEach(thisChunk => chunk = thisChunk);
            if(chunk.chunkX > playerChunkX + (Ref.chunkAmountX - 1) / 2 || chunk.chunkX < playerChunkX - (Ref.chunkAmountX - 1) / 2 || chunk.chunkY > playerChunkY + (Ref.chunkAmountY - 1) / 2 || chunk.chunkY < playerChunkY - (Ref.chunkAmountY  -1) / 2)
                loadedChunks.Remove(chunk);
        }
        private void loadChunks(int playerChunkX, int playerChunkY)
        {
            for (int x = playerChunkX - (Ref.chunkAmountX - 1) / 2; x <= playerChunkX + (Ref.chunkAmountX - 1) / 2; x++)
            {
                for (int y = playerChunkY - (Ref.chunkAmountY - 1) / 2; y <= playerChunkY + (Ref.chunkAmountY - 1) / 2; y++)
                {
                    if (!loadedChunks.Contains(new Chunk(x, y)))
                    {
                        Chunk chunk = new Chunk(x, y);
                        chunk.populate();
                        loadedChunks.Add(ch
public class World : MonoBehaviour 
    /* Fields */
    [System.Serializable] public struct WorldGenData
    {
        [Header("World Settings")]
        [Range(16,124)]
        public int chunkSize;
        [Range(32, 64)]
        public int spriteResolution;
    }
    [SerializeField] WorldGenData _worldGenData;
    public WorldGenData worldGenData
    {
        get { return _worldGenData; }
    }
    ChunkGenerator _chunkGenerator;
    /* Base */
    void Start()
    {
        _chunkGenerator = new ChunkGenerator(this);
        int chunkSize = worldGenData.chunkSize;
        for (int i = 0; i < 9; i++)
        {
            Chunk newChunk = _chunkGenerator.GenerateChunk();
            switch (i)
            {
                case 0:
                    newChunk.gameObject.transform.position = new Vector3(-chunkSize, chunkSize,0);
                    break;
                case 1:
                    newChunk.gameObject.transform.position = new Vector3(0,          chunkSize, 0);
   

                case 2:
                    newChunk.gameObject.transform.position = new Vector3(chunkSize,  chunkSize, 0);
                    break;
                case 3:
                    newChunk.gameObject.transform.position = new Vector3(-chunkSize, 0, 0);
                    break;
                case 4:
                    newChunk.gameObject.transform.position = new Vector3(0,          0, 0);
                    break;
                case 5:
                    newChunk.gameObject.transform.position = new Vector3(chunkSize,  0, 0);
                    break;
                case 6:
                    newChunk.gameObject.transform.position = new Vector3(-chunkSize, -chunkSize, 0);
                    break;
                case 7:
                    newChunk.gameObject.transform.position = new Vector3(0,          -chunkSize, 0);
                    break;
                case 8:
                    newChunk.gameObject.transform.position = new Vector3(chunkSize,  -chunk
namespace PRSP_1Ejemplo
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
            Process[] procesos = Process.GetProcesses();
            foreach (Process item in procesos)
            {
                listBoxProcesos.Items.Add(item.ProcessName);
            }
            
        }
        private void button1_Click(object sender, EventArgs e)
        {
            Process notepadProcess = new Process();
            string processName = "Notepad";
            notepadProcess.StartInfo.FileName = processName;
            notepadProcess.StartInfo.WindowStyle = ProcessWindowStyle.Maximized;
            if (Process.GetProcessesByName(notepadProcess.ProcessName).Length > 0)
                notepadProcess.Start();
            else
                notepadProcess.Kill();
        }
        private void button2_Click(object sender, EventArgs e)
        {
            Process wordProcess = new Process();
            string process
namespace BeeGame.Terrain.Chunks
    public class LoadChunks : MonoBehaviour
    {
        #region Data
        public World world;
        private List<ChunkWorldPos> buildList = new List<ChunkWorldPos>();
        private static ChunkWorldPos[] chunkPositions = new ChunkWorldPos[] {   new ChunkWorldPos( 0, 0,  0), new ChunkWorldPos(-1, 0,  0), new ChunkWorldPos( 0, 0, -1), new ChunkWorldPos( 0, 0,  1), new ChunkWorldPos( 1, 0,  0),
                             new ChunkWorldPos(-1, 0, -1), new ChunkWorldPos(-1, 0,  1), new ChunkWorldPos( 1, 0, -1), new ChunkWorldPos( 1, 0,  1), new ChunkWorldPos(-2, 0,  0),
                             new ChunkWorldPos( 0, 0, -2), new ChunkWorldPos( 0, 0,  2), new ChunkWorldPos( 2, 0,  0), new ChunkWorldPos(-2, 0, -1), new ChunkWorldPos(-2, 0,  1),
                             new ChunkWorldPos(-1, 0, -2), new ChunkWorldPos(-1, 0,  2), new ChunkWorldPos( 1, 0, -2), new ChunkWorldPos( 1, 0,  2), new ChunkWorldPos( 2, 0, -1),
                          

                             new ChunkWorldPos(-3, 0,  0), new ChunkWorldPos( 0, 0, -3), new ChunkWorldPos( 0, 0,  3), new ChunkWorldPos( 3, 0,  0), new ChunkWorldPos(-3, 0, -1),
                             new ChunkWorldPos(-3, 0,  1), new ChunkWorldPos(-1, 0, -3), new ChunkWorldPos(-1, 0,  3), new ChunkWorldPos( 1, 0, -3), new ChunkWorldPos( 1, 0,  3),
                             new ChunkWorldPos( 3, 0, -1), new ChunkWorldPos( 3, 0,  1), new ChunkWorldPos(-3, 0, -2), new ChunkWorldPos(-3, 0,  2), new ChunkWorldPos(-2, 0, -3),
                             new ChunkWorldPos(-2, 0,  3), new ChunkWorldPos( 2, 0, -3), new ChunkWorldPos( 2, 0,  3), new ChunkWorldPos( 3, 0, -2), new ChunkWorldPos( 3, 0,  2),
                             new ChunkWorldPos(-4, 0,  0), new ChunkWorldPos( 0, 0, -4), new ChunkWorldPos( 0, 0,  4), new ChunkWorldPos( 4, 0,  0), new ChunkWorldPos(-4, 0, -1),
                             new ChunkWorldPos(-4, 0,  1), new ChunkWorldPos(-1, 0, -4), new ChunkWorldP

                             new ChunkWorldPos( 4, 0, -1), new ChunkWorldPos( 4, 0,  1), new ChunkWorldPos(-3, 0, -3), new ChunkWorldPos(-3, 0,  3), new ChunkWorldPos( 3, 0, -3),
                             new ChunkWorldPos( 3, 0,  3), new ChunkWorldPos(-4, 0, -2), new ChunkWorldPos(-4, 0,  2), new ChunkWorldPos(-2, 0, -4), new ChunkWorldPos(-2, 0,  4),
                             new ChunkWorldPos( 2, 0, -4), new ChunkWorldPos( 2, 0,  4), new ChunkWorldPos( 4, 0, -2), new ChunkWorldPos( 4, 0,  2), new ChunkWorldPos(-5, 0,  0),
                             new ChunkWorldPos(-4, 0, -3), new ChunkWorldPos(-4, 0,  3), new ChunkWorldPos(-3, 0, -4), new ChunkWorldPos(-3, 0,  4), new ChunkWorldPos( 0, 0, -5),
                             new ChunkWorldPos( 0, 0,  5), new ChunkWorldPos( 3, 0, -4), new ChunkWorldPos( 3, 0,  4), new ChunkWorldPos( 4, 0, -3), new ChunkWorldPos( 4, 0,  3),
                             new ChunkWorldPos( 5, 0,  0), new ChunkWorldPos(-5, 0, -1), new ChunkWorldP
namespace OpenQuant.Shared.Instruments
	class GroupNode : TreeNode
	{
		protected Dictionary<Instrument, InstrumentNode> instrumentNodes;
		public Instrument[] Instruments
		{
			get
			{
				return new List<Instrument>((IEnumerable<Instrument>)this.instrumentNodes.Keys).ToArray();
			}
		}
		public GroupNode()
		{
			this.instrumentNodes = new Dictionary<Instrument, InstrumentNode>();
			this.SetText("Undefined");
			this.UpdateIcon();
		}
		public void UpdateIcon()
		{
			this.ImageIndex = this.SelectedImageIndex = this.IsExpanded ? 2 : 1;
		}
		public void AddInstrument(Instrument instrument)
		{
			if (this.instrumentNodes.ContainsKey(instrument))
				return;
			InstrumentNode instrumentNode = new InstrumentNode(instrument);
			this.instrumentNodes.Add(instrument, instrumentNode);
			this.Nodes.Add(instrumentNode);
			this.UpdateToolTipText();
		}
		public void RemoveInstrument(Instrument instrument)
		{
			if (!this.instrumentNodes.ContainsKey(instrument))
				return;
			Instrumen
public class LoadChunks : MonoBehaviour
    World world;
    int deleteTimer = 0;
    int chunkGenTimer = 0;
    void Start()
    {
        world = World.instance;
    }
    void Update()
    {
        if (deleteTimer == Config.Env.WaitBetweenDeletes)
        {
            DeleteChunks();
            deleteTimer = 0;
            return;
        }
        else
        {
            deleteTimer++;
        }
        if (chunkGenTimer == Config.Env.WaitBetweenChunkGen)
        {
            FindChunksAndLoad();
            chunkGenTimer = 0;
            return;
        }
        else
        {
            chunkGenTimer++;
        }
    }
    void DeleteChunks()
    {
        var chunksToDelete = new List<BlockPos>();
        foreach (var chunk in world.chunks)
        {
            Vector3 chunkPos = chunk.Key; 
            float distance = Vector3.Distance(
                new Vector3(chunkPos.x, 0, chunkPos.z),
                new Vector3(transform.position.x, 0, transform.position.z));


                chunksToDelete.Add(chunk.Key);
        }
        foreach (var chunk in chunksToDelete)
            world.DestroyChunk(chunk);
    }
    bool FindChunksAndLoad()
    {
        for (int i = 0; i < Data.chunkLoadOrder.Length; i++)
        {
            BlockPos playerPos = ((BlockPos)transform.position).ContainingChunkCoordinates();
            BlockPos newChunkPos = new BlockPos(
                Data.chunkLoadOrder[i].x * Config.Env.ChunkSize + playerPos.x,
                0,
                Data.chunkLoadOrder[i].z * Config.Env.ChunkSize + playerPos.z
                );
            Chunk newChunk = world.GetChunk(newChunkPos);
            if (newChunk != null && newChunk.GetFlag(Chunk.Flag.loaded))
                continue;
            LoadChunkColumn(newChunkPos);
            return true;
        }
        return false;
    }
    public void LoadChunkColumn(BlockPos columnPosition)
    {
        for (int y = Config.Env.WorldMinY; y <= Config.Env.WorldMaxY; y += Config.

        {
            for (int x = columnPosition.x - Config.Env.ChunkSize; x <= columnPosition.x + Config.Env.ChunkSize; x += Config.Env.ChunkSize)
            {
                for (int z = columnPosition.z - Config.Env.ChunkSize; z <= columnPosition.z + Config.Env.ChunkSize; z += Config.Env.ChunkSize)
                {
                    BlockPos pos = new BlockPos(x, y, z);
                    Chunk chunk = world.GetChunk(pos);
                    if (chunk == null)
                    {
                        world.CreateChunk(pos);
                    }
                }
            }
        }
        for (int y = Config.Env.WorldMaxY; y >= Config.Env.WorldMinY; y -= Config.Env.ChunkSize)
        {
            BlockPos pos = new BlockPos(columnPosition.x, y, columnPosition.z);
            Chunk chunk = world.GetChunk(pos);
            if (chunk != null)
            {
                chunk.SetFlag(Chunk.Flag.loaded, true);
            }
        }
        if (Config.Toggle.UseM
namespace DRMFSS.BLL.Repository
    public partial class DispatchDetailRepository :GenericRepository<CTSContext,DispatchDetail>, IDispatchDetailRepository
    {
        public DispatchDetailRepository(CTSContext _db, IUnitOfWork uow)
        {
            db = _db;
            repository = uow;
        }
        public List<BLL.DispatchDetail> GetDispatchDetail(int partitionID, Guid dispatchId)
        {
            return (from p in db.DispatchDetails
                       where ( p.DispatchID == dispatchId)
                       select p).ToList();
            
        }
        public List<DispatchDetail> GetDispatchDetail(Guid dispatchId)
        {
            return (from p in db.DispatchDetails
                    where (p.DispatchID == dispatchId)
                    select p).ToList();
        }
        public List<DispatchDetailModelDto> ByDispatchIDetached(Guid dispatchId, string PreferedWeightMeasurment)
        {
            List<DispatchDetailModelDto> dispatchDetais = n

            var query = (from rD in db.DispatchDetails
                         where rD.DispatchID == dispatchId
                         select rD);
            foreach (var dispatchDetail in query)
            {
                var DDMD = new DispatchDetailModelDto();
                DDMD.DispatchID = dispatchDetail.DispatchID;
                DDMD.DispatchDetailID = dispatchDetail.DispatchDetailID;
                DDMD.CommodityName = dispatchDetail.Commodity.Name;
                DDMD.UnitName = dispatchDetail.Unit.Name;
                DDMD.RequestedQuantityInUnit = Math.Abs(dispatchDetail.RequestedQunatityInUnit);
                DDMD.DispatchedQuantityInUnit = Math.Abs(dispatchDetail.DispatchedQuantityInUnit);
                if (PreferedWeightMeasurment.ToUpperInvariant()  == "QN")
                {
                    DDMD.RequestedQuantityMT = Math.Abs(dispatchDetail.RequestedQuantityInMT)*10;
                    DDMD.DispatchedQuantityMT = Math.Abs(dispatchDetail.Dispatche
namespace ECmmerce.Data.Infrasctructure
    public class UnitOfWork : IUnitOfWork
    {
        private ecommerceContext dataContext;
        IDatabaseFactory dbFactory;
        public UnitOfWork(IDatabaseFactory dbFactory)
        {
            this.dbFactory = dbFactory;
        }
        private IAddressRepository addressRepository;
        public IAddressRepository AddressRepository
        {
            get
            { return addressRepository = new AddressRepository(dbFactory); }
        }
        private ICategoryRepository categoryRepository;
        public ICategoryRepository CategoryRepository
        {
            get
            { return categoryRepository = new CategoryRepository(dbFactory); }
        }
        private ICommisionRepository commisionRepository;
        public ICommisionRepository CommisionRepository
        {
            get
            { return commisionRepository = new CommisionRepository(dbFactory); }
        }
        private ICreditCardRepository cre

        public ICreditCardRepository CreditCardRepository
        {
            get
            { return creditCardRepository = new CreditCardRepository(dbFactory); }
        }
        private IGouvernoratRepository gouvernoratRepository;
        public IGouvernoratRepository GouvernoratRepository
        {
            get
            { return gouvernoratRepository = new GouvernoratRepository(dbFactory); }
        }
        private IOrderItemRepository orderItemRepository;
        public IOrderItemRepository OrderItemRepository
        {
            get
            { return orderItemRepository = new OrderItemRepository(dbFactory); }
        }
        private IOrderRepository orderRepository;
        public IOrderRepository OrderRepository
        {
            get
            { return orderRepository = new OrderRepository(dbFactory); }
        }
        private IPictureRepository pictureRepository;
        public IPictureRepository PictureRepository
        {
            get
         

        }
        private IProductItemRepository productItemRepository;
        public IProductItemRepository ProductItemRepository
        {
            get
            { return productItemRepository = new ProductItemRepository(dbFactory); }
        }
        private IProductItemSupplierRepository productItemSupplierRepository;
        public IProductItemSupplierRepository ProductItemSupplierRepository
        {
            get
            { return productItemSupplierRepository = new ProductItemSupplierRepository(dbFactory); }
        }
        private IProductRepository productRepository;
        public IProductRepository ProductRepository
        {
            get
            { return productRepository = new ProductRepository(dbFactory); }
        }
        private IPromotionRepository promotionRepository;
        public IPromotionRepository PromotionRepository
        {
            get
            { return promotionRepository = new PromotionRepository(dbFactory); }
        }
     
namespace YacqPlugin
    partial class ReplWindow
    {
        internal static class Symbols
        {
            [YacqSymbol(DispatchTypes.Method, "clear")]
            public static Expression Clear(DispatchExpression e, SymbolTable s, Type t)
            {
                return YacqExpression.Dispatch(
                    s,
                    DispatchTypes.Method,
                    s.Resolve("*textbox*"),
                    "Clear"
                );
            }
            [YacqSymbol(DispatchTypes.Method, typeof(object), "printn")]
            public static Expression Write(DispatchExpression e, SymbolTable s, Type t)
            {
                return YacqExpression.Dispatch(
                    s,
                    DispatchTypes.Method,
                    s.Resolve("*textbox*"),
                    "AppendText",
                    YacqExpression.Dispatch(
                        s,
                        DispatchTypes.Method,
                        e.Left,
    
namespace EventManagementSystem.Data.UnitOfWork.Interfaces
    public interface IReportsDataUnit : IDataUnitOfWork
    {
        IActivitiesRepository ActivitiesRepository { get; }
        IActivityTypesRepository ActivityTypesRepository { get; }
        IEventTypesRepository EventTypesRepository { get; }
        IEnquiriesRepository EnquiriesRepository { get; }
        IEventsRepository EventsRepository { get; }
        IEventPaymentsRepository EventPaymentsRepository { get; }
        IProductVatRatesRepository ProductVatRatesRepository { get; }
        IProductGroupsRepository ProductGroupsRepository { get; }
        IProductDepartmentsRepository ProductDepartmentsRepository { get; }
        IEventBookedProductsRepository EventBookedProductsRepository { get; }
        ITillsRepository TillsRepository { get; }
        IFinaliseKeysRepository FinaliseKeysRepository { get; }
        ITillProductsRepository TillProductsRepository { get; }
        IClerksRepository ClerksRepository { get;
﻿namespace client
    public class PacketProcessInfo
    {
        private PacketProcess _isProcess;
        private WorldPacket _packet;
        public PacketProcessInfo(WorldPacket packet)
        {
            this._packet = packet;
            this._isProcess = PacketProcess.PACKETPROCESS_NULL;
        }
        public bool IsProcessed()
        {
            return (this._isProcess == PacketProcess.PACKETPROCESS_PROCESS);
        }
        public bool IsSend()
        {
            return (this._isProcess != PacketProcess.PACKETPROCESS_NULL);
        }
        public void Process()
        {
            this._isProcess = PacketProcess.PACKETPROCESS_PROCESS;
        }
        public void Reset()
        {
            this._isProcess = PacketProcess.PACKETPROCESS_NULL;
        }
        public void Send()
        {
            this._isProcess = PacketProcess.PACKETPROCESS_SEND;
        }
        public WorldPacket Packet
        {
            get
            {
                return
namespace NWiretap
    internal static class InstrumentTracker
    {
        public static IList<TrackedInstrument> Instruments = new List<TrackedInstrument>();
        public static object SyncRoot = new object();
        public static void TrackInstrument(IInstrument instrument)
        {
            lock(SyncRoot)
            {
                Instruments.Add(new TrackedInstrument(instrument));
            }
            
        }
        public static void RemoveInstrument(IInstrument instrument)
        {
            lock(SyncRoot)
            {
                var trackedInstrument = Instruments.Single(a => a.Instrument == instrument);
                Instruments.Remove(trackedInstrument);
            }
        }
    }
    internal class TrackedInstrument
    {
        private static int _instrumentId;
        public IInstrument Instrument { get; private set; }
        public int InstrumentID { get; private set; }
        public TrackedInstrument(IInstrument instrument)
        {
namespace ChunkingFile
    public struct Chunk
    {
        public readonly Int32 Size;
        public readonly Int32 Id;
        public Chunk(Int32 size, Int32 id)
        {
            Size = size;
            Id = id;
        }
        public Chunk Next()
        {
            return new Chunk(Size, Id + 1);
        }
    }
    public static class ChunkReader
    {
        public static IEnumerable<Result> FromTextReader(TextReader reader,
                                                         ILineActionBuilder builder,
                                                         Int32 chunkSize)
        {
            return Repeat<Result>.Sequence(_ =>
                                           {
                                               var chunk = _ == null
                                                               ? new Chunk(chunkSize, 1)
                                                               : _.Chunk.Next();
                                               var 

                                               return Process(reader, action, chunk);
                                           })
                                 .Until(_ => _ is End);
        }
        private static Result Process(TextReader reader,
                                      ILineAction action,
                                      Chunk chunk)
        {
            String line;
            var i = 0;
            while ((line = reader.ReadLine()) != null && ++i < chunk.Size)
                action.Execute(line);
            action.Dispose();
            return line == null || reader.Peek() == -1
                       ? new End(chunk, i)
                       : (Result)new Continue(chunk, i);
        }
        public abstract class Result
        {
            private readonly Int32 _count;
            private readonly Chunk _chunk;
            protected Result(Chunk chunk, Int32 count)
            {
                _count = count;
                _chunk = chunk;
   
namespace BusinessLogic
    public class DataManager
    {
        public DataManager(
            ICustomerRepository customerRepository,
            IOrderRepository orderRepository, 
            IProductRepository productRepository,
            IProductsCustomersRepository productsCustomersRepository,
            CustomMembershipProvider provider)
        {
            _customerRepository = customerRepository;
            _orderRepository = orderRepository;
            _productRepository = productRepository;
            _productsCustomersRepository = productsCustomersRepository;
            _provider = provider;
        }
        public ICustomerRepository Customers { get { return _customerRepository; } }
        public IOrderRepository Orders { get { return _orderRepository; } }
        public IProductRepository Products { get { return _productRepository; } }
        public IProductsCustomersRepository ProductsCustomers { get { return _productsCustomersRepository; } }
        publi
namespace Curan.Common.FormalizedData.File.Riff.Avi
	public class RiffChunkListAvi_ : RiffChunkList
	{
		public const string TYPE = "AVI ";
		public static readonly Dictionary<string,Type> chunkTypeDictionary;
		public static readonly Dictionary<string,Type> bodyTypeDictionary;
		public readonly RiffChunkListMovi moviBodyList;
		public readonly RiffChunkListHdrl hdrlBodyList;
		static RiffChunkListAvi_()
		{
			chunkTypeDictionary = new Dictionary<string, Type>();
			chunkTypeDictionary.Add( RiffChunkListHdrl.TYPE, typeof( RiffChunkListHdrl ) );
			chunkTypeDictionary.Add( RiffChunkListStrl.TYPE, typeof( RiffChunkListStrl ) );
			chunkTypeDictionary.Add( RiffChunkListMovi.TYPE, typeof( RiffChunkListMovi ) );
			chunkTypeDictionary.Add( RiffChunkListInfo.TYPE, typeof( RiffChunkListInfo ) );
			bodyTypeDictionary = new Dictionary<string, Type>();
		}
		public RiffChunkListAvi_( string aId, UInt32 aSize, ByteArray aByteArray, RiffChunkList aParent )
			: base( chunkTypeDictionary, bodyTyp
namespace DataAccess.U8
    public class u8Dispatch :u8<Dispatch>
    {
        private Dispatch _dispatch = new Dispatch();
        private List<Dispatch> _dispatchs = new List<Dispatch>();
        public u8Dispatch() {
        }
        public override List<Dispatch> getList(string whereStr)
        {
            List<Dispatch> r = new List<Dispatch>();
            string cmd = "" + whereStr;
            r = Context.Sql("").QueryMany<Dispatch>();
            return r;
        }
        public override Dispatch getSingle(string code)
        {
            u8DispatchMain u8dm = new u8DispatchMain();
            u8DispatchDetail u8dd = new u8DispatchDetail();
            _dispatch.Main = u8dm.getSingle(code);
            _dispatch.Details = u8dd.getList(new VouchDetail() { Mid = _dispatch.Main.Mid });
            _dispatch.Main.Je = 0;
            if (_dispatch.Details != null && _dispatch.Details.Count > 0)
                foreach (var dd in _dispatch.Details)
                {
       

                }
            return _dispatch;
        }
        public override List<Dispatch> getList(Dispatch searchKey)
        {
            u8DispatchMain u8dm = new u8DispatchMain();
            u8DispatchDetail u8dd = new u8DispatchDetail();
            _dispatchs = new List<Dispatch>();
            if (searchKey != null) {
                if (searchKey.Main != null)
                {
                    var dms = u8dm.getList(searchKey.Main);
                    foreach (var dm in dms)
                    {
                        if (!_dispatchs.Exists(e => e.Main.vouchCode == dm.vouchCode))
                        {
                            _dispatchs.Add(getSingle(dm.vouchCode));
                        }
                    }
                }
                if (searchKey.Details != null)
                {
                    List<VouchMain> dms;
                    foreach (var kd in searchKey.Details)
                    { dms = u8dm.getList(new VouchMain() { Mid =
/*
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
namespace stab.query {
	public interface FunctionT<TResult>           { TResult invoke(); }
	public interface FunctionBoolean              { bool invoke(); }
	public interface FunctionInt                  { int invoke(); }
	public interface FunctionLong 

	public interface FunctionFloat                { float invoke(); }
	public interface FunctionDouble               { double invoke(); }
	public interface FunctionTBoolean<TArgument>  { bool invoke(TArgument argument); }
	public interface FunctionIntBoolean           { bool invoke(int argument); }
	public interface FunctionLongBoolean          { bool invoke(long argument); }
	public interface FunctionFloatBoolean         { bool invoke(float argument); }
	public interface FunctionDoubleBoolean        { bool invoke(double argument); }
	public interface FunctionTInt<TArgument>      { int invoke(TArgument argument); }
	public interface FunctionBooleanInt           { int invoke(bool argument); }
	public interface FunctionByteInt              { int invoke(byte argument); }
	public interface FunctionIntByte              { byte invoke(int argument); }
	public interface FunctionCharInt              { int invoke(char argument); }
	public interface FunctionIntChar              { char invoke(int ar

	public interface FunctionShortInt             { int invoke(short argument); }
	public interface FunctionIntShort             { short invoke(int argument); }
	public interface FunctionIntInt               { int invoke(int argument); }
	public interface FunctionIntT<TResult>        { TResult invoke(int argument); }
	public interface FunctionTLong<TArgument>     { long invoke(TArgument argument); }
	public interface FunctionIntLong              { long invoke(int argument); }
	public interface FunctionLongInt              { int invoke(long argument); }
	public interface FunctionLongLong             { long invoke(long argument); }
	public interface FunctionLongT<TResult>       { TResult invoke(long argument); }
	public interface FunctionTFloat<TArgument>    { float invoke(TArgument argument); }
	public interface FunctionIntFloat             { float invoke(int argument); }
	public interface FunctionLongFloat            { float invoke(long argument); }
	public interface FunctionFloatFloat  
namespace ProcessManager.DAO
    public class ProcessProcessDAO:IProcessDao<ProcessProcessModel>
    {
        public ProcessProcessModel selectByIdOrder(int pid,int order)
        {
            {
                Process process = selectProcessbyIdorder(pid, order,db);
                ProcessProcessModel processmodel = processToProcessModel(process);
                return processmodel;
            }
        }
        public List<ProcessProcessModel> selectById(int pid)
        {
                var selectstring = from p in db.Process where p.pid == pid select p;
                List<Process> processs = selectstring.ToList();
                List<ProcessProcessModel> processmodels = new List<ProcessProcessModel>();
                processs.ForEach(process =>
                {
                    ProcessProcessModel processmodel = processToProcessModel(process);
                    processmodels.Add(processmodel);
                });
                return processmodels;
            }
 

        public int update(ProcessProcessModel processmodel)
        {
            {
                Process process = selectProcessbyIdorder(processmodel.Pid, processmodel.Order,db);
                processModelToProcess(processmodel, process);
                int i = db.SaveChanges();
                return i;
            }
        }
        public int updatelist(List<ProcessProcessModel> processlist)
        {
            {
                
                processlist.ForEach(processmodel =>
                {
                    Process process = selectProcessbyIdorder(processmodel.Pid, processmodel.Order, db);
                    processModelToProcess(processmodel, process);
                });
                int i= db.SaveChanges();
                return i;
            }
        }
        
        public int insert(ProcessProcessModel processmodel)
        {
            {
                Process process = processModelToProcess(processmodel);
                db.Process.Add(proces

                int i= db.SaveChanges();
                return i;
            }
        }
        public int insertList(List<ProcessProcessModel> processmodellist)
        {
            {
                processmodellist.ForEach(processmodel =>
                {
                    Process process = processModelToProcess(processmodel);
                    db.Process.Add(process);
                });
                int i= db.SaveChanges();
                return i;
            }
        }
        private ProcessProcessModel processToProcessModel(Process process)
        {
            ProcessProcessModel processmodel = new ProcessProcessModel();
            processmodel.Pid = (int)process.pid;
            processmodel.Bid = (int)process.bid;
            processmodel.Order = (int)process.steps;
            processmodel.Handler = process.hanlder;
            processmodel.Nexthandler = process.nexthanlder;
            processmodel.Lasthandler = process.lasthanlder;
            processmod
namespace Employees.DAL.Repositories
    public interface IEmployeeUnitOfWork
    {
        UserGroupRepository UserGroupRepository { get; }
        UserRepository UserRepository { get; }
        PermissionKeyRepository PermissionKeyRepository { get; }
        EmployeeRepository EmployeeRepository { get; }
    }
    public class EmployeeUnitOfWork : IEmployeeUnitOfWork
    {
        private readonly EmployeeRepository _employeeRepository;
        private readonly UserGroupRepository _userGroupRepository;
        private readonly UserRepository _userRepository;
        private readonly PermissionKeyRepository _permissionKeyRepository;
        public EmployeeUnitOfWork(EmployeeRepository employeeRepository,
            UserGroupRepository userGroupRepository,
            UserRepository userRepository,
            PermissionKeyRepository permissionKeyRepository)
        {
            _employeeRepository = employeeRepository;
            _userGroupRepository = userGroupRepository;
        
namespace DRMFSS.BLL.Services
    public class DispatchDetailService : IDispatchDetailService
    {
        private readonly IUnitOfWork _unitOfWork;
        public DispatchDetailService(IUnitOfWork unitOfWork)
        {
            this._unitOfWork = unitOfWork;
        }
        #region Default Service Implementation
        public bool AddDispatchDetail(DispatchDetail dispatchDetail)
        {
            _unitOfWork.DispatchDetailRepository.Add(dispatchDetail);
            _unitOfWork.Save();
            return true;
        }
        public bool EditDispatchDetail(DispatchDetail dispatchDetail)
        {
            _unitOfWork.DispatchDetailRepository.Edit(dispatchDetail);
            _unitOfWork.Save();
            return true;
        }
        public bool DeleteDispatchDetail(DispatchDetail dispatchDetail)
        {
            if (dispatchDetail == null) return false;
            _unitOfWork.DispatchDetailRepository.Delete(dispatchDetail);
            _unitOfWork.Save();
    

        }
        public bool DeleteById(int id)
        {
            var entity = _unitOfWork.DispatchDetailRepository.FindById(id);
            if (entity == null) return false;
            _unitOfWork.DispatchDetailRepository.Delete(entity);
            _unitOfWork.Save();
            return true;
        }
        public List<DispatchDetail> GetAllDispatchDetail()
        {
            return _unitOfWork.DispatchDetailRepository.GetAll();
        }
        public DispatchDetail FindById(int id)
        {
            return _unitOfWork.DispatchDetailRepository.FindById(id);
        }
        public List<DispatchDetail> FindBy(Expression<Func<DispatchDetail, bool>> predicate)
        {
            return _unitOfWork.DispatchDetailRepository.FindBy(predicate);
        }
        #endregion
        public List<BLL.DispatchDetail> GetDispatchDetail(int partitionID, Guid dispatchId)
        {
            return _unitOfWork.DispatchDetailRepository.FindBy(t => t.DispatchID == dispatchId)

        }
        public List<DispatchDetail> GetDispatchDetail(Guid dispatchId)
        {
            return _unitOfWork.DispatchDetailRepository.FindBy(t => t.DispatchID == dispatchId);
        }
        public List<DispatchDetailModelDto> ByDispatchIDetached(Guid dispatchId, string PreferedWeightMeasurment)
        {
            List<DispatchDetailModelDto> dispatchDetais = new List<DispatchDetailModelDto>();
            var query = _unitOfWork.DispatchDetailRepository.FindBy(t => t.DispatchID == dispatchId);
            ;
            foreach (var dispatchDetail in query)
            {
                var DDMD = new DispatchDetailModelDto();
                DDMD.DispatchID = dispatchDetail.DispatchID;
                DDMD.DispatchDetailID = dispatchDetail.DispatchDetailID;
                DDMD.CommodityName = dispatchDetail.Commodity.Name;
                DDMD.UnitName = dispatchDetail.Unit.Name;
                DDMD.RequestedQuantityInUnit = Math.Abs(dispatchDetail.RequestedQunati
namespace ESurvey.DAL.Concrate
    public class RepositoryHolder : IRepositoryHolder
    {
        protected ESurveyEntities _context;
        protected IAnsweredQuestionsOptionsRepository _answeredQuestionsOptionsRepository;
        protected IAnsweredQuestionsRepository _answeredQuestionsRepository;
        protected IAnswerRepository _answerRepository;
        protected IQuestionRepository _questionRepository;
        protected ISurveyRepository _surveyRepository;
        protected ISurveySessionRepository _surveySessionRepository;
        protected IUserRepository _userRepository;
        protected IVoterRepository _voterRepository;
        protected ITokenRepository _tokenRepository;
        
        
        
        public RepositoryHolder()
        {
            _context = new ESurveyEntities();
        }
        public void Dispose()
        {
            _context.Dispose();
        }
        public IAnsweredQuestionsOptionsRepository AnsweredQuestionsOptionsRepository
       

            get
            {
                if(_answeredQuestionsOptionsRepository == null)
                    _answeredQuestionsOptionsRepository = new AnsweredQuestionsOptionsRepository(_context);
                return _answeredQuestionsOptionsRepository;
            }
        }
        public IAnsweredQuestionsRepository AnsweredQuestionsRepository
        {
            get
            {
                if(_answeredQuestionsRepository == null)
                    _answeredQuestionsOptionsRepository = new AnsweredQuestionsOptionsRepository(_context);
                return _answeredQuestionsRepository;
            }
        }
        public IAnswerRepository AnswerRepository
        {
            get
            {
                if(_answerRepository == null)
                    _answerRepository = new AnswerRepository(_context);
                return _answerRepository;
            }
        }
        public IQuestionRepository QuestionRepository
        {
            get
     

                if(_questionRepository == null)
                    _questionRepository = new QuestionRepository(_context);
                return _questionRepository;
            }
        }
        public ISurveyRepository SurveyRepository
        {
            get
            {
                if(_surveyRepository == null)
                    _surveyRepository = new SurveyRepository(_context);
                return _surveyRepository;
            }
        }
        public ISurveySessionRepository SurveySessionRepository
        {
            get
            {
                if(_surveySessionRepository == null)
                    _surveySessionRepository = new SurveySessionRepository(_context);
                return _surveySessionRepository;
            }
        }
        public IUserRepository UserRepository
        {
            get
            {
                if(_userRepository == null)
                    _userRepository = new UserRepository(_context);
                ret
namespace fluidedotnet
  public delegate void MyCallbackDelegate(SceneParam param);
  public partial class FormParam : Form
  {
    MyCallbackDelegate callback;
    Instrument instrument= new Instrument();
    public FormParam()
    {
      InitializeComponent();
    }
    public void InitParam(string path,MyCallbackDelegate c)
    {
      callback = c;
      var files = from file in Directory.GetFiles(path)
                  orderby file where file.EndsWith(".geo")
                  select file;
      foreach (var file in files)
      {
        FileList.Items.Add(Path.GetFileNameWithoutExtension(file));
      }
      XTrack.Value = 1;
      instrument.zoom = true;
      instrument.zoomx = XTrack.Value;
      instrument.changeinstrument = true;
      SetParams(true);
    }
    private void FormParam_Load(object sender, EventArgs e)
    {
    }
    public void SetParams(bool reinit)
    {
      SceneParam param = new SceneParam();
      param.reinit = reinit;
      if(FileList.SelectedI

        param.file = FileList.SelectedItem.ToString();
      else
            param.file = "circle";
      param.instrument = instrument;
      callback(param);
    }
    private void FileList_SelectedIndexChanged(object sender, EventArgs e)
    {
      instrument = new Instrument();
      SetParams(true);
    }
    private void XTrack_Scroll(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.zoom = true;
      instrument.zoomx = XTrack.Value;
      instrument.changeinstrument = true;
      SetParams(false);
    }
    private void ButDrop_Click(object sender, EventArgs e)
    {
      instrument = new  Instrument();
      instrument.changeinstrument = true;
      instrument.drop = true;
      SetParams(false);
    }
    private void butPipe_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.pipe = true;
      SetParams(false);
    }
    private void butObstacle_Clic

    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.setter = true;
      SetParams(false);
    }
    private void butDelate_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.remover = true;
      SetParams(false);
    }
    private void butForce_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.forceup = true;
      SetParams(false);
    }
    private void butForceDown_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.forcedown = true;
      SetParams(false);
    }
    private void butPush_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.push = true;
      SetParams(false);
    }
    private void 
namespace Assets.Scripts.AccessLayer.Worlds
    public class World
    {
        public static WorldPosition At(Vector3 v)
        {
            return new WorldPosition(v);
        }
        
        public static WorldPosition At(float x, float y, float z)
        {
            return new WorldPosition(new Vector3(x, y, z));
        }
    }
    public class WorldPosition
    {
        private readonly Vector3I _v;
        public WorldPosition(Vector3 v)
        {
            _v = v;
        }
        public void SetVoxel(VoxelMaterial material)
        {
            var chunkData = GetChunkData() ?? CreateChunk();
            chunkData.SetVoxel(_v.x % Chunk.ChunkSize, _v.y % Chunk.ChunkSize, _v.z % Chunk.ChunkSize, material);
        }
        public void SetVoxel(string type)
        {
            SetVoxel(MaterialRegistry.Instance.GetMaterialFromName(type));
        }
        public VoxelMaterial GetMaterial()
        {
            var chunkData = GetChunkData();
            return
namespace Microsoft.AspNet.Razor.Generator.Compiler
    public class CodeTreeBuilder
    {
        private readonly Stack<ChunkBlock> _blockChain;
        private Chunk _lastChunk;
        public CodeTreeBuilder()
        {
            CodeTree = new CodeTree();
            _blockChain = new Stack<ChunkBlock>();
        }
        public CodeTree CodeTree { get; private set; }
        public void AddChunk(Chunk chunk, SyntaxTreeNode association, bool topLevel = false)
        {
            _lastChunk = chunk;
            chunk.Start = association.Start;
            chunk.Association = association;
            if (_blockChain.Count == 0 || topLevel == true)
            {
                CodeTree.Chunks.Add(chunk);
            }
            else
            {
                _blockChain.Peek().Children.Add(chunk);
            }
        }
        public void AddLiteralChunk(string literal, SyntaxTreeNode association)
        {
            if (_lastChunk is LiteralChunk)
            {
     

            }
            else
            {
                AddChunk(new LiteralChunk
                {
                    Text = literal,
                }, association);
            }
        }
        public void AddExpressionChunk(string expression, SyntaxTreeNode association)
        {
            AddChunk(new ExpressionChunk
            {
                Code = expression
            }, association);
        }
        public void AddStatementChunk(string code, SyntaxTreeNode association)
        {
            AddChunk(new StatementChunk
            {
                Code = code,
            }, association);
        }
        {
            AddChunk(new UsingChunk
            {
            }, association, topLevel: true);
        }
        public void AddTypeMemberChunk(string code, SyntaxTreeNode association)
        {
            AddChunk(new TypeMemberChunk
            {
                Code = code,
            }, association, topLevel: true);
        }
        public void Ad

        {
            AddChunk(new LiteralCodeAttributeChunk
            {
                Code = code,
            }, association);
        }
        public void AddResolveUrlChunk(string url, SyntaxTreeNode association)
        {
            AddChunk(new ResolveUrlChunk
            {
                Url = url
            }, association);
        }
        public void AddSetLayoutChunk(string layout, SyntaxTreeNode association)
        {
            AddChunk(new SetLayoutChunk
            {
                Layout = layout
            }, association);
        }
        public void AddSetBaseTypeChunk(string typeName, SyntaxTreeNode association)
        {
            AddChunk(new SetBaseTypeChunk
            {
                TypeName = typeName.Trim()
            }, association, topLevel: true);
        }
        public void AddSessionStateChunk(string value, SyntaxTreeNode association)
        {
            AddChunk(new SessionStateChunk
            {
                Value = value
  
namespace Carlsberg.Foundation.Models.WebApi
    public static class WebApiEndPoints
    {
        public static readonly Dictionary<WebApi, WebApiSettings> Endpoints = new Dictionary<WebApi, WebApiSettings>
        {
            {
                WebApi.ProductList, new WebApiSettings
                {
                    Endpoint = "/carlsberg/api/webapi/getproductlisting"
                }
            },
            {
                WebApi.PromotionList, new WebApiSettings
                {
                    Endpoint = "/carlsberg/api/webapi/getpromotionlisting"
                }
            },
            {
                WebApi.PromotionProductList, new WebApiSettings
                {
                    Endpoint = "/carlsberg/api/webapi/getpromotionproductlisting"
                }
            },
                    {
                WebApi.FavouriteList, new WebApiSettings
                {
                    Endpoint = "/carlsberg/api/webapi/getfavorites"
                
namespace StoneCastle.Data.Repositories
    public class UnitOfWork : IUnitOfWork
    {
        private IDbFactory _dbFactory;
        private ISCDataContext _dbContext;
        private ICountryRepository _countryRepository;
        private ITimezoneRepository _timezoneRepository;
        private IProfileRepository _profileRepository;
        private IAccountRepository _accountRepository;
        private ITeacherRepository _teacherRepository;
        private IClassGroupRepository _classGroupRepository;
        private IClassRoomRepository _classRoomRepository;
        private IClassCourseRepository _courseRepository;
        private IDivisionRepository _divisionRepository;
        private IOrganizationRepository _organizationRepository;
        private ISemesterRepository _semesterRepository;
        private ISubjectGroupRepository _subjectGroupRepository;
        private ISubjectRepository _subjectRepository;
        private IBuildingRepository _buildingRepository;
        private IRo

        private ITeacherDivisionRepository _teacherDivisionRepository;
        private IClassTimetableRepository _classTimetableRepository;
        private ITimetableRepository _TimetableRepository;
        private ICourseSectionRepository _courseSectionRepository;
        private ISchedulingTableRepository _schedulingTableRepository;
        private ICourseRepository _courseSubjectRepository;
        private ITrainingProgramRepository _trainingProgramRepository;
        private IMessagingDataMappingRepository _messagingDataMappingRepository;
        private IMessagingMessageRepository _messagingMessageRepository;
        private IMessagingTemplateContentRepository _messagingTemplateContentRepository;
        private IMessagingTemplateRepository _messagingTemplateRepository;
        private IMessagingTypeRepository _messagingTypeRepository;
        public UnitOfWork()
        {
            this._dbFactory = new DbFactory();
            _dbContext = _dbFactory.Init();
        }
       

        {
            _dbContext = context;
        }
        public int SaveChanges()
        {
            return _dbContext.SaveChanges();
        }
        public ICountryRepository CountryRepository => _countryRepository ?? (_countryRepository = new CountryRepository(_dbContext));
        public ITimezoneRepository TimezoneRepository => _timezoneRepository ?? (_timezoneRepository = new TimezoneRepository(_dbContext));
        public IProfileRepository ProfileRepository => _profileRepository ?? (_profileRepository = new ProfileRepository(_dbContext));
        public IAccountRepository AccountRepository => _accountRepository ?? (_accountRepository = new AccountRepository(_dbContext));
        public ITeacherRepository TeacherRepository => _teacherRepository ?? (_teacherRepository = new TeacherRepository(_dbContext));
        public IClassGroupRepository ClassGroupRepository => _classGroupRepository ?? (_classGroupRepository = new ClassGroupRepository(_dbContext));
        public IC
namespace SmartQuant
	public class InstrumentList : IEnumerable<Instrument>, IEnumerable
	{
		private Dictionary<string, Instrument> instrumentBySymbol = new Dictionary<string, Instrument>();
		private IdArray<Instrument> instrumentById = new IdArray<Instrument>(10000);
		private List<Instrument> instruments = new List<Instrument>();
		public int Count
		{
			get
			{
				return this.instruments.Count;
			}
		}
		public Instrument this[string symbol]
		{
			get
			{
				return this.Get(symbol);
			}
		}
		public bool Contains(string symbol)
		{
			return this.instrumentBySymbol.ContainsKey(symbol);
		}
		public bool Contains(Instrument instrument)
		{
			return this.instrumentBySymbol.ContainsKey(instrument.Symbol);
		}
		public bool Contains(int id)
		{
			return this.instrumentById[id] != null;
		}
		public void Add(Instrument instrument)
		{
			if (this.instrumentById[instrument.Id] == null)
			{
				this.instruments.Add(instrument);
				this.instrumentBySymbol[instrument.Symbol] = 

				this.instrumentById[instrument.Id] = instrument;
				return;
			}
			Console.WriteLine(string.Concat(new object[]
			{
				"InstrumentList::Add Instrument ",
				instrument.Symbol,
				" with Id = ",
				instrument.Id,
				" is already in the list"
			}));
		}
		public void Remove(Instrument instrument)
		{
			this.instruments.Remove(instrument);
			this.instrumentBySymbol.Remove(instrument.Symbol);
			this.instrumentById.Remove(instrument.Id);
		}
		public Instrument Get(string symbol)
		{
			Instrument result;
			this.instrumentBySymbol.TryGetValue(symbol, out result);
			return result;
		}
		public Instrument GetByIndex(int index)
		{
			return this.instruments[index];
		}
		public Instrument GetById(int id)
		{
			return this.instrumentById[id];
		}
		public void Clear()
		{
			this.instrumentBySymbol.Clear();
			this.instrumentById.Clear();
			this.instruments.Clear();
		}
		public override string ToString()
		{
			string text = "";
			foreach (Instrument current in this.inst
namespace Core.TransactionServer.Agent.BLL.AccountBusiness
    internal sealed class InstrumentManager
    {
        private BusinessRecordDictionary<Guid,AccountClass.Instrument> _instruments;
        private Account _owner;
        private static readonly ILog Logger = LogManager.GetLogger(typeof(InstrumentManager));
        internal InstrumentManager(Account owner)
        {
            _owner = owner;
            _instruments = new BusinessRecordDictionary<Guid, AccountClass.Instrument>("Instruments", owner);
        }
        internal IEnumerable<AccountClass.Instrument> Instruments
        {
            get
            {
                return _instruments.GetValues();
            }
        }
        internal int Count
        {
            get { return _instruments.Count; }
        }
        internal void Add(AccountClass.Instrument instrument)
        {
            if (!_instruments.ContainsKey(instrument.Id))
            {
                _instruments.AddItem(instrument, Opera

            }
        }
        internal bool Exists(Guid instrumentId)
        {
            return _instruments.ContainsKey(instrumentId);
        }
        internal AccountClass.Instrument Get(Guid instrumentId)
        {
            AccountClass.Instrument result;
            _instruments.TryGetValue(instrumentId, out result);
            return result;
        }
        internal decimal GetResetBalanceGreatThanTradeDay(Guid currencyId, DateTime tradeDay)
        {
            decimal resetBalance = 0m;
            if (_owner.IsMultiCurrency)
            {
                foreach (var eachInstrument in _instruments.GetValues())
                {
                    if (eachInstrument.CurrencyId == currencyId)
                    {
                        resetBalance += this.GetInstrumentResetBalanceGreateThanTradeDay(eachInstrument, tradeDay);
                    }
                }
            }
            else
            {
                foreach (var eachInstrument in _instr

                {
                    resetBalance += this.GetInstrumentResetBalanceGreateThanTradeDay(eachInstrument, tradeDay);
                }
            }
            return resetBalance;
        }
        private decimal GetInstrumentResetBalanceGreateThanTradeDay(AccountClass.Instrument instrument, DateTime tradeDay)
        {
            var resetItems = instrument.ResetItems;
            if (resetItems == null || resetItems.Count() == 0) return 0m;
            decimal result = 0m;
            foreach (var eachResetItem in resetItems)
            {
                if (eachResetItem.TradeDay > tradeDay)
                {
                    result += eachResetItem.ResetBalance;
                }
            }
            return result;
        }
        internal DateTime? GetLastResetDay(Guid instrumentId)
        {
            AccountClass.Instrument instrument;
            if (_instruments.TryGetValue(instrumentId, out instrument))
            {
                return instr
namespace MFDExtractor.Configuration
	internal interface IInstrumentFormSettingsWriter
	{
		void Write(string instrumentName, IInstrumentFormSettings instrumentFormSettings);
	}
	internal class InstrumentFormSettingsWriter : IInstrumentFormSettingsWriter
	{
		private readonly ISettingWriter _settingWriter;
		public InstrumentFormSettingsWriter(ISettingWriter settingWriter = null)
		{
			_settingWriter = settingWriter ?? new SettingWriter();
		}
		public void Write(string instrumentName, IInstrumentFormSettings instrumentFormSettings)
		{
			_settingWriter.WriteSetting(value:instrumentFormSettings.Enabled, settingName: String.Format("Enable{0}Output", instrumentName));
			_settingWriter.WriteSetting(value:instrumentFormSettings.OutputDisplay, settingName: String.Format("{0}_OutputDisplay", instrumentName));
			_settingWriter.WriteSetting(value:instrumentFormSettings.StretchToFit, settingName: String.Format("{0}_StretchToFit", instrumentName));
            _settingWriter.WriteSetting(val
namespace SportLife.Core.Generic {
    public class UnitOfWork : IUnitOfWork {
        private readonly SportLifeEntities _dbEntities = new SportLifeEntities();
        private bool _disposed;
        private IAbonementOrderRepository _abonementOrderRepository;
        private IAbonementRepository _abonementRepository;
        private IClientRepository _clientRepository;
        private ICoachRepository _coachRepository;
        private IDaysInWeekRepository _daysInWeekRepository;
        private IImageRepository _imageRepository;
        private IFileTypeRepository _fileTypeRepository;
        private IHallRepository _hallRepository;
        private IPriceRepository _priceRepository;
        private ISheduleRepository _sheduleRepository;
        private ISportGroupRepository _sportGroupRepository;
        private ISportCategoryRepository _categoryRepository;
        private ISportRepository _sportRepository;
        private IUserRepository _userRepository;
        private IVisitingRep

        public IAbonementOrderRepository AbonementOrderRepository { get; }
        public IAbonementRepository AbonementRepository { get; }
        public IClientRepository ClientRepository
            => _clientRepository ?? (_clientRepository = new ClientRepository(_dbEntities));
        public ICoachRepository CoachRepository
            => _coachRepository ?? (_coachRepository = new CoachRepository(_dbEntities));
        public IDaysInWeekRepository DaysInWeekRepository
            => _daysInWeekRepository ?? (_daysInWeekRepository = new DayInWeekRepository(_dbEntities));
        public IImageRepository ImageRepository
            => _imageRepository ?? (_imageRepository = new ImageRepository(_dbEntities));
        public IFileTypeRepository FileTypeRepository
            => _fileTypeRepository ?? (_fileTypeRepository = new FileTypeRepository(_dbEntities));
        public IHallRepository HallRepository
            => _hallRepository ?? (_hallRepository = new HallRepository(_dbEnti

        public IPriceRepository PriceRepository { get; }
        public ISheduleRepository SheduleRepository
            => _sheduleRepository ?? (_sheduleRepository = new SheduleRepository(_dbEntities));
        public ISportCategoryRepository SportCategoryRepository
            => _categoryRepository ?? (_categoryRepository = new SportCategoryRepository(_dbEntities));
        public ISportGroupRepository SportGroupRepository
            => _sportGroupRepository ?? (_sportGroupRepository = new SportGroupRepository(_dbEntities));
        public ISportRepository SportRepository
            => _sportRepository ?? (_sportRepository = new SportRepository(_dbEntities));
        public IUserRepository UserRepository
            => _userRepository ?? (_userRepository = new UserRepository(_dbEntities));
        public IVisitingRepository VisitingRepository { get; }
        public void Dispose () {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        public void 
namespace SVE_Model.API_entidades
    public class ApiServicio:ApiUsuario
    {
        private int _idServicioAPI;
        public int IdServicioAPI
        {
            get { return _idServicioAPI; }
            set { _idServicioAPI = value; }
        }
        private string _NameServicioAPI;
        public string NameServicioAPI
        {
            get { return _NameServicioAPI; }
            set { _NameServicioAPI = value; }
        }
        private string _TipoServicioAPI;
        public string TipoServicioAPI
        {
            get { return _TipoServicioAPI; }
            set { _TipoServicioAPI = value; }
        }
        private string _descripcionServicioAPI;
        public string DescripcionServicioAPI
        {
            get { return _descripcionServicioAPI; }
            set { _descripcionServicioAPI = value; }
        }
         
        
        private int _EstadoServicioAPI;
        public int EstadoServicioAPI
        {
            get { return _EstadoServicio

            set { _EstadoServicioAPI = value; }
        }
        private DateTime _FechaInscripcionAPI;
        public DateTime FechaInscripcionAPI
        {
            get { return _FechaInscripcionAPI; }
            set { _FechaInscripcionAPI = value; }
        }
        private DateTime _FechFinAPI;
        public DateTime FechFinAPI
        {
            get { return _FechFinAPI; }
            set { _FechFinAPI = value; }
        }
        public ApiServicio() { }
        public ApiServicio(int idApi, string nombreAPi,string tipoApi,string descripcionApi, int estadoAPi,DateTime fechaCreacion, DateTime fechaInactivacion)  {
            this.IdServicioAPI = idApi;
            this.NameServicioAPI = nombreAPi;
            this.TipoServicioAPI = tipoApi;
            this.DescripcionServicioAPI = descripcionApi;
            this.EstadoServicioAPI = estadoAPi;
            this.FechaInscripcionAPI = fechaCreacion;
            this.FechFinAPI = fechaInactivacion;
            
        }

namespace Pattern.Node
    public class InvokeNodeList : InvokeNode
    {
        protected List<InvokeNode> m_ChildNodes;
        public virtual InvokeNode this[int index]
        {
            get { return m_ChildNodes[index]; }
        }
        public override int ChildCount
        {
            get { return m_ChildNodes.Count; }
        }
        public InvokeNodeList()
        {
            m_ChildNodes = new List<InvokeNode>(0);
            m_Name = string.Empty;
        }
        protected override void DetachChild(InvokeNode childNode)
        {
            var index = m_ChildNodes.LastIndexOf(childNode);
            if (index > -1)
            {
                m_ChildNodes.RemoveAt(index);
            }
        }
        protected override void AttachChild(InvokeNode childNode)
        {
            m_ChildNodes.Add(childNode);
        }
        public override IEnumerator<InvokeNode> GetEnumerator()
        {
            return m_ChildNodes.GetEnumerator();
        }
     

        {
            for (var i = ChildCount - 1; i >= 0; --i)
            {
                m_ChildNodes[i].ParentNode = null;
            }
        }
        public override InvokeNode Find(string name)
        {
            if (name == null)
            {
                return null;
            }
            string[] names = name.Split('/');
            return FindNode(names, 0);
        }
        public override InvokeNode FindNode(string[] names, int layerIndex)
        {
            for (var i = 0; i < m_ChildNodes.Count; ++i)
            {
                if (m_ChildNodes[i].Name != names[layerIndex])
                    continue;
                if (layerIndex == names.Length - 1)
                {
                    return m_ChildNodes[i];
                }
                var targetNode = m_ChildNodes[i].FindNode(names, layerIndex + 1);
                if (targetNode != null)
                {
                    return targetNode;
                }
            }
        

        }
        public virtual InvokeNode GetChild(int index)
        {
            if (index < 0 || index >= m_ChildNodes.Count)
            {
                return null;
            }
            return m_ChildNodes[index];
        }
        public virtual int GetSiblingIndex()
        {
            if (mParentNode is InvokeNodeList)
            {
                var invokeNodeList = mParentNode as InvokeNodeList;
                return invokeNodeList.m_ChildNodes.IndexOf(this);
            }
            return -1;
        }
        public override bool IsChildOf(InvokeNode parent)
        {
            InvokeNode tempNode = this;
            while (tempNode != null)
            {
                if (tempNode == parent)
                {
                    return true;
                }
                tempNode = tempNode.ParentNode;
            }
            return false;
        }
        public virtual bool SetAsFirstSibling()
        {
            if (mParentNode is InvokeNo
namespace SopraProject.Models.ObjectApi
    public class ObjectApiProvider
    {
        #region Static
        private static ObjectApiProvider _instance;
        public static ObjectApiProvider Instance
        {
            get 
            {
                if (_instance == null)
                    _instance = new ObjectApiProvider();
                return _instance;
            }
            private set
            { 
                _instance = new ObjectApiProvider();
            }
        }
        #endregion
        #region Properties
        public IAuthApi AuthApi { get; private set; }
        public IBookingsApi BookingsApi { get; private set; }
        public ISitesApi SitesApi { get; private set; }
        public IUserProfileAPI UserProfileApi { get; private set; }
        #endregion
        private ObjectApiProvider()
        {
            BookingsApi = new BookingsApiTestImplementation();
            AuthApi = new AuthApiTestImplementation();
            UserProfileAp
/* start App.cs */
namespace io.newgrounds.results.App {
	public class checkSession : SessionResult 
	{
		public override void dispatchMe(string component)
		{
			ngio_core.dispatchEvent<checkSession>(component, this);
		}
	}
	public class endSession : ResultModel 
	{
		public override void dispatchMe(string component)
		{
			ngio_core.dispatchEvent<endSession>(component, this);
		}
	}
	public class getCurrentVersion : ResultModel 
	{
		public bool client_deprecated { get; set; }
		public string current_version { get; set; }
		public override void dispatchMe(string component)
		{
			ngio_core.dispatchEvent<getCurrentVersion>(component, this);
		}
	}
	public class getHostLicense : ResultModel 
	{
		public bool host_approved { get; set; }
		public override void dispatchMe(string component)
		{
			ngio_core.dispatchEvent<getHostLicense>(component, this);
		}
	}
	public class logView : ResultModel 
	{
		public override void dispatchMe(string component)
		{
			ngio_core.dispatchEvent<logVie
namespace CarReservation.Core.IRepository.Base
    public interface IUnitOfWork
    {
        ApplicationDbContext DBContext { get; }
        IRequestInfo RequestInfo { get; }
        IColorRepository ColorRepository { get; }
        IRideStatusRepository RideStatusRepository { get; }
        ICountryRepository CountryRepository { get; }
        IStateRepository StateRepository { get; }
        ICityRepository CityRepository { get; }
        IVehicleMakerRepository VehicleMakerRepository { get; }
        IVehicleModelRepository VehicleModelRepository { get; }
        IVehicleBodyTypeRepository VehicleBodyTypeRepository { get; }
        IVehicleFeatureRepository VehicleFeatureRepository { get; }
        IVehicleTransmissionRepository VehicleTransmissionRepository { get; }
        IVehicleAssemblyRepository VehicleAssemblyRepository { get; }
        IVehicleVehicleFeatureRepository VehicleVehicleFeatureRepository { get; }
        IVehicleRepository VehicleRepository { get; }
        ITra

        IDistanceUnitRepository DistanceUnitRepository { get; }
        IDriverStatusRepository DriverStatusRepository { get; }
        ICreditCardRepository CreditCardRepository { get; }
        ICurrencyRepository CurrencyRepository { get; }
        ICurrencyLogRepository CurrencyLogRepository { get; }
        IAccountRepository AccountRepository { get; }
        IAccountLogRepository AccountLogRepository { get; }
        IFavouriteLocationRepository FavouriteLocationRepository { get; }
        ILocationLagLonRepository LocationLagLonRepository { get; }
        IFareRepository FareRepository { get; }
        IPackageRepository PackageRepository { get; }
        IPackageTravelUnitRepository PackageTravelUnitRepository { get; }
        IPackageVehicleAssemblyRepository PackageVehicleAssemblyRepository { get; }
        IPackageVehicleBodyTypeRepository PackageVehicleBodyTypeRepository { get; }
        IPackageVehicleFeatureRepository PackageVehicleFeatureRepository { get; }
        IPa
public class World : MonoBehaviour {
    TerrainGen terrainGen;
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public GameObject chunkPrefab;
    public string worldName = "world";
    void Awake()
    {
        terrainGen = new TerrainGen(this);
    }
    public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(x, y, z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
        newChunkObject.transform.SetParent(this.gameObject.transform);
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        newChunk = terrainGen.ChunkGen(newChunk);
        newChunk.SetBlocksUnmodified();
        Serialization.Load(newChunk);
    }
    public void DestroyChunk(

    {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
        {
            Serialization.SaveChunk(chunk);
            Object.Destroy(chunk.gameObject);
            chunks.Remove(new WorldPos(x, y, z));
        }
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / multiple) * Chunk.chunkSize;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Block GetBlock(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null)
        {
            Block block = containerChunk.GetBlock(
                x - containerChunk.pos.x,
                y - containerChu

                z - containerChunk.pos.z);
            return block;
        }
        else
        {
            return new BlockAir();
        }
    }
    public bool SetBlock(int x, int y, int z, Block block)
    {
        Chunk chunk = GetChunk(x, y, z);
        if (chunk != null)
        {
            chunk.SetBlock(x - chunk.pos.x, y - chunk.pos.y, z - chunk.pos.z, block);
            chunk.update = true;
            UpdateIfEqual(x - chunk.pos.x, 0, new WorldPos(x - 1, y, z));
            UpdateIfEqual(x - chunk.pos.x, Chunk.chunkSize - 1, new WorldPos(x + 1, y, z));
            UpdateIfEqual(y - chunk.pos.y, 0, new WorldPos(x, y - 1, z));
            UpdateIfEqual(y - chunk.pos.y, Chunk.chunkSize - 1, new WorldPos(x, y + 1, z));
            UpdateIfEqual(z - chunk.pos.z, 0, new WorldPos(x, y, z - 1));
            UpdateIfEqual(z - chunk.pos.z, Chunk.chunkSize - 1, new WorldPos(x, y, z + 1));
            return true;
        }
        return false;
    }
    void UpdateIfEqual(
namespace Survivalist {
	/* The ChunkCache should deal with what chunks to keep in memory and saving of
	 * unloaded chunks */
	public class ChunkCache {
		ChunkSource source;
		ChunkGenerator generator;
		Hashtable cache = new Hashtable();
		int lastChunkX, lastChunkY;
		ChunkData lastChunk;
		public ChunkCache(ChunkSource source, ChunkGenerator generator) {
			this.source = source;
			this.generator = generator;
		}
		public ChunkData Get(int x, int y) {
			if (lastChunk != null && lastChunkX == x && lastChunkY == y)
				return lastChunk;
			ulong hashKey = BuildKey(x, y);
			ChunkData chunk = cache[hashKey] as ChunkData;
			if (chunk == null) {
				Console.WriteLine("[ChunkCache] Loading {0}, {1}", x, y);
				chunk = source.Load(x, y);
				if (chunk == null)
					chunk = generator.GenerateNewChunk(x, y);
				cache[hashKey] = chunk;
			}
			lastChunkX = x;
			lastChunkY = y;
			lastChunk = chunk;
			return chunk;
		}
		public void Save(int x, int y) {
			var key = BuildKey(x, y);
			
namespace PlayGen.SUGAR.Core.UnitTests
    public abstract class ControllerLocator
    {
        private static AccountController _accountController;
        private static AccountSourceController _accountSourceController;
		private static ActorClaimController _actorClaimController;
		private static ActorRoleController _actorRoleController;
        private static ClaimController _claimController;
        private static EvaluationController _evaluationController;
        private static GameController _gameController;
        private static EvaluationDataController _evaluationDataController;
        private static GroupController _groupController;
        private static GroupMemberController _groupMemberController;
        private static LeaderboardController _leaderboardController;
        private static ResourceController _resourceController;
        private static RewardController _rewardController;
        private static RoleController _roleController;
        private static RoleClai

        private static UserController _userController;
        private static UserFriendController _userFriendController;
        private static MatchController _matchController;
        private static ActorController _actorController;
        private static GameDataController _gameDataController;
        public static AccountController AccountController
            => _accountController ?? (_accountController = new AccountController(DbControllerLocator.AccountController, AccountSourceController, UserController, ActorRoleController));
        public static AccountSourceController AccountSourceController
            => _accountSourceController ?? (_accountSourceController = new AccountSourceController(DbControllerLocator.AccountSourceController));
		public static ActorClaimController ActorClaimController
			=> _actorClaimController ?? (_actorClaimController = new ActorClaimController(DbControllerLocator.ActorClaimController, ActorRoleController, RoleClaimController, GroupMemberControll

		public static ActorRoleController ActorRoleController
            => _actorRoleController ?? (_actorRoleController = new ActorRoleController(DbControllerLocator.ActorRoleController, DbControllerLocator.RoleController));
        public static ClaimController ClaimController
            => _claimController ?? (_claimController = new ClaimController(DbControllerLocator.ClaimController, DbControllerLocator.RoleController, DbControllerLocator.RoleClaimController));
        public static EvaluationController EvaluationController
            => _evaluationController ?? (_evaluationController= new EvaluationController(DbControllerLocator.EvaluationController, GroupMemberController, UserFriendController, ActorController, RewardController, DbControllerLocator.ContextFactory));
        public static GameController GameController
            => _gameController ?? (_gameController = new GameController(DbControllerLocator.GameController, ActorClaimController, ActorRoleController));
        
     
namespace RiskAnalysisTool.MobileApp.ViewModels
    public abstract class InstrumentDetailViewModel<T> : FunctionViewModel<T>, IModelViewModel<T>
        where T : Instrument, new()
    {
        private bool _includeMarketQuote;
        private T _instrument;
        private string _symbol;
        protected InstrumentDetailViewModel()
        {
            _includeMarketQuote = true;
            _instrument = new T();
            SaveCommand = new AsyncCommand(Save);
        }
        public bool IncludeMarketQuote
        {
            get { return _includeMarketQuote; }
            set { SetProperty(ref _includeMarketQuote, value); }
        }
        public T Instrument
        {
            get { return _instrument; }
            set
            {
                SetProperty(ref _instrument, value);
                LoadModel(_instrument);
            }
        }
        public ICommand SaveCommand { get; private set; }
        public string Symbol
        {
            get { retu
namespace Core.TransactionServer.Agent.BLL.AccountBusiness
    internal sealed class InstrumentManager
    {
        private BusinessRecordDictionary<Guid,AccountClass.Instrument> _instruments;
        private Account _owner;
        private static readonly ILog Logger = LogManager.GetLogger(typeof(InstrumentManager));
        internal InstrumentManager(Account owner)
        {
            _owner = owner;
            _instruments = new BusinessRecordDictionary<Guid, AccountClass.Instrument>("Instruments", owner);
        }
        internal IEnumerable<AccountClass.Instrument> Instruments
        {
            get
            {
                return _instruments.GetValues();
            }
        }
        internal int Count
        {
            get { return _instruments.Count; }
        }
        internal void Add(AccountClass.Instrument instrument)
        {
            if (!_instruments.ContainsKey(instrument.Id))
            {
                _instruments.AddItem(instrument, Opera

            }
        }
        internal void ClearResetItems()
        {
            foreach (var eachInstrument in _instruments.GetValues())
            {
                eachInstrument.ClearResetItems();
            }
        }
        internal bool Exists(Guid instrumentId)
        {
            return _instruments.ContainsKey(instrumentId);
        }
        internal AccountClass.Instrument Get(Guid instrumentId)
        {
            AccountClass.Instrument result;
            _instruments.TryGetValue(instrumentId, out result);
            return result;
        }
        internal decimal GetResetBalanceGreatThanTradeDay(Guid currencyId, DateTime tradeDay)
        {
            decimal resetBalance = 0m;
            if (_owner.IsMultiCurrency)
            {
                foreach (var eachInstrument in _instruments.GetValues())
                {
                    if (eachInstrument.CurrencyId == currencyId)
                    {
                        resetBalance += this.Ge

                    }
                }
            }
            else
            {
                foreach (var eachInstrument in _instruments.GetValues())
                {
                    resetBalance += this.GetInstrumentResetBalanceGreateThanTradeDay(eachInstrument, tradeDay);
                }
            }
            return resetBalance;
        }
        private decimal GetInstrumentResetBalanceGreateThanTradeDay(AccountClass.Instrument instrument, DateTime tradeDay)
        {
            var resetItems = instrument.ResetItems;
            if (resetItems == null || resetItems.Count() == 0) return 0m;
            decimal result = 0m;
            foreach (var eachResetItem in resetItems)
            {
                if (eachResetItem.TradeDay > tradeDay)
                {
                    result += eachResetItem.ResetBalance;
                }
            }
            return result;
        }
        internal DateTime? GetLastResetDay(Guid instrumentId)
        {
    
namespace MTB
    public class DataProcessorManager
    {
        public PersistanceWorker persistanceWorker { get; private set; }
        public GeneratorWorker generatorWorker { get; private set; }
        public RenderWorker renderWorker { get; private set; }
        private Queue<PriorityChunk> _priorityCaches;
        private Queue<WaitRenderChunkJob> _waitRenderChunkJobs;
        private Queue<Chunk> _waitRemoveChunks;
        private Queue<NetChunkData> _waitResponseNetChunkDatas;
        private Queue<NetChunkData> _waitNetChunkRemoveDatas;
        private Queue<MeshData> _meshDataQueue;
        public int MaxMeshDataNum = 5;
        public World World { get; set; }
        public DataProcessorManager(World world)
        {
            World = world;
            InitMap();
            InitQueue();
            WorldPersistanceManager.Instance.Init();
        }
        public void StartHandler()
        {
            persistanceWorker.Start();
            generatorWorker.Start();

            renderWorker.Start();
        }
        public void StopHandler()
        {
            persistanceWorker.Stop();
            generatorWorker.Stop();
            renderWorker.Stop();
        }
        public void UpdateChunkPriority(WorldPos curInChunkPos)
        {
            persistanceWorker.UpdateLoadChunkPriority(curInChunkPos);
            generatorWorker.UpdateGeneratorChunkPriority(curInChunkPos);
        }
        public void UpdateNetChunkPriority(WorldPos curInChunkPos)
        {
            persistanceWorker.UpdateNetLoadChunkPriority(curInChunkPos);
            generatorWorker.UpdateNetGeneratorChunkPriority(curInChunkPos);
        }
        public void EnqueueLoadChunk(Chunk chunk, WorldPos curInChunkPos)
        {
            persistanceWorker.EnLoadQueue(chunk, curInChunkPos);
        }
        public PriorityChunk GetPriorityChunk(Chunk chunk)
        {
            lock (_priorityCaches)
            {
                if (_priorityCaches.Count > 0)
       

                    PriorityChunk c = _priorityCaches.Dequeue();
                    c.chunk = chunk;
                    return c;
                }
                return new PriorityChunk(chunk);
            }
        }
        public void SetPriorityChunk(PriorityChunk c)
        {
            lock (_priorityCaches)
            {
                c.chunk = null;
                c.Priority = 0;
                _priorityCaches.Enqueue(c);
            }
        }
        public double GetPriority(WorldPos chunkPos, WorldPos curInChunkPos)
        {
            double priority = Math.Sqrt(Math.Pow((chunkPos.x - curInChunkPos.x) / Chunk.chunkWidth, 2) +
                Math.Pow((chunkPos.z - curInChunkPos.z) / Chunk.chunkDepth, 2));
            return priority;
        }
        public void EnqueueSaveChunk(Chunk chunk)
        {
            persistanceWorker.EnSaveQueue(chunk);
        }
        public void EnqueueRefreshChunk(RefreshChunkArea chunk)
        {
            persistanceWo
namespace HitPoint6.Unity.StratosSylphs.GameUnitControllers
	[Serializable]
	public class PlayerController
	{
		[SerializeField]
		private PlayerMoveController _MoveController;
		[SerializeField]
		private PlayerStateController _StateController;
		[SerializeField]
		private PlayerFiringController _FiringController;
		[SerializeField]
		private PlayerBombController _BombController;
		[SerializeField]
		private PlayerColliderController _ColliderController;
		[SerializeField]
		private PlayerAnimationController _AnimationController;
		[SerializeField]
		private PlayerLifeController _LifeController;
		public PlayerMoveController MoveController
		{
			get { return _MoveController; }
		}
		public PlayerStateController StateController
		{
			get
			{ return _StateController; }
		}
		public PlayerFiringController FiringController
		{
			get { return _FiringController; }
		}
		public PlayerBombController BombController
		{
			get { return _BombController; }
		}
		public PlayerLifeController Lif
namespace FreeQuant.Trading
	[StrategyComponent("{664274F3-FDE1-46da-A84F-556E4A0EB170}", ComponentType.CrossEntry, Description = "", Name = "Default_CrossEntry")]
	public class CrossEntry : StrategyMultiComponent
	{
		public const string GUID = "{664274F3-FDE1-46da-A84F-556E4A0EB170}";
		public CrossEntry() : base()
		{
		}
		public virtual SingleOrder EmitSignal(Signal signal)
		{
			return this.Strategy.BgvpSPpUAD(signal);
		}
		public virtual SingleOrder LongEntry(Instrument instrument, string text)
		{
			if (!this.Strategy.IsInstrumentActive(instrument))
				return null;
			else
				return this.Strategy.BgvpSPpUAD(new Signal(DateTime.Now, ComponentType.CrossEntry, SignalType.Market, SignalSide.Buy, instrument, text));
		}
		public virtual SingleOrder LongEntry(Instrument instrument)
		{
			return this.LongEntry(instrument, this.Strategy.Name);
		}
		public virtual SingleOrder ShortEntry(Instrument instrument, string text)
		{
			if (!this.Strategy.IsInstrumentActive(instrument))


			else
				return this.Strategy.BgvpSPpUAD(new Signal(Clock.Now, ComponentType.CrossEntry, SignalType.Market, SignalSide.SellShort, instrument, text));
		}
		public virtual SingleOrder ShortEntry(Instrument instrument)
		{
			return this.ShortEntry(instrument, this.Strategy.Name);
		}
		public virtual SingleOrder LongEntry(Instrument instrument, double price, string text)
		{
			if (!this.Strategy.IsInstrumentActive(instrument))
				return (SingleOrder)null;
			return this.Strategy.BgvpSPpUAD(new Signal(Clock.Now, ComponentType.CrossEntry, SignalType.Market, SignalSide.Buy, instrument, text)
			{
				StrategyFill = true,
				StrategyPrice = price
			});
		}
		public virtual SingleOrder LongEntry(Instrument instrument, double price)
		{
			return this.LongEntry(instrument, price, this.Strategy.Name);
		}
		public virtual SingleOrder ShortEntry(Instrument instrument, double price, string text)
		{
			if (!this.Strategy.IsInstrumentActive(instrument))
				return (SingleOrder)null;
			re

			{
				StrategyFill = true,
				StrategyPrice = price
			});
		}
		public virtual SingleOrder ShortEntry(Instrument instrument, double price)
		{
			return this.ShortEntry(instrument, price, this.Strategy.Name);
		}
		public virtual SingleOrder LongEntry(Instrument instrument, FillOnBarMode mode, string text)
		{
			if (!this.Strategy.IsInstrumentActive(instrument))
				return (SingleOrder)null;
			return this.Strategy.BgvpSPpUAD(new Signal(Clock.Now, ComponentType.CrossEntry, SignalType.Market, SignalSide.Buy, instrument, text)
			{
				Fuwj5CvMiW = true,
				R2djQy947W = mode
			});
		}
		public virtual SingleOrder LongEntry(Instrument instrument, FillOnBarMode mode)
		{
			return this.LongEntry(instrument, mode, this.Strategy.Name);
		}
		public virtual SingleOrder ShortEntry(Instrument instrument, FillOnBarMode mode, string text)
		{
			if (!this.Strategy.IsInstrumentActive(instrument))
				return (SingleOrder)null;
			return this.Strategy.BgvpSPpUAD(new Signal(Clock.Now, Compon
public class ChunkLocation : Location {
    public ChunkLocation(World world, float x, float y, float z) : base(world, x, y, z) {
        setX(x * Chunk.chunkSize);
        setZ(z * Chunk.chunkSize);
    }
    public ChunkLocation(Location location) : base(location) {
        float x = location.getX();
        float z = location.getZ();
        setX(x * Chunk.chunkSize);
        setZ(z * Chunk.chunkSize);
    }
    public static ChunkLocation asChunkLocation(Location location) {
        World world = location.getWorld();
        float x = location.getX();
        float z = location.getZ();
        x = (x - (x % 16)) / 16f;
        z = (z - (z % 16)) / 16f;
        return new ChunkLocation(world, x, 0, z);
    }
    public static ChunkLocation operator +(ChunkLocation chunkLocation1, ChunkLocation chunkLocation2) {
        Location location1 = chunkLocation1;
        Location location2 = chunkLocation2;
        return ChunkLocation.asChunkLocation(location1 + location2);
    }
    publi
namespace MultiMethods
	[Flags]
	public enum DispatchStatus
	{
		Success = 1,
		NoMatch = 2,
		AmbiguousMatch = 4,
		DynamicInvoke = 8
	}
	public struct DispatchResult
	{
		private DispatchStatus _status;
		internal DispatchResult(DispatchStatus status)
			: this()
		{
			_status = status;
		}
		public object ReturnValue { get; internal set; }
		public bool Success
		{
			get
			{
				return (_status & DispatchStatus.Success) == DispatchStatus.Success;
			}
		}
		public bool AmbiguousMatch
		{
			get
			{
				return (_status & DispatchStatus.AmbiguousMatch) == DispatchStatus.AmbiguousMatch;
			}
		}
		public bool NoMatch
		{
			get
			{
				return (_status & DispatchStatus.NoMatch) == DispatchStatus.NoMatch;
			}
		}
		public bool IsDynamicInvoke
		{
			get
			{
				return (_status & DispatchStatus.DynamicInvoke) == DispatchStatus.DynamicInvoke;
			}
			internal set
			{
				_status |= DispatchStatus.DynamicInvoke;
			}
		}
		public DispatchResult<R> Typed<R>()
		{
			DispatchResult<R>
namespace Generate.Content
    class ChunkLoader : IDisposable
    {
        internal static int ChunkCountSide = 10;
        internal static long MovedX = 0, MovedZ = 0;
        private int ChunkCountMaxKey;
        private int ChunkCount;
        private static Chunk[,] Chunks;
        internal Chunk Mid
        {
            get
            {
                return Chunks[ChunkCountSide, ChunkCountSide];
            }
        }
        internal ChunkLoader()
        {
            ChunkCountMaxKey = 2 * ChunkCountSide;
            ChunkCount = ChunkCountMaxKey + 1;
            Chunks = new Chunk[ChunkCount, ChunkCount];
            for (int X = 0; X < ChunkCount; X++)
            {
                for (int Z = 0; Z < ChunkCount; Z++)
                {
                    Chunks[X, Z] = new Chunk(X + MovedX - ChunkCountSide, Z + MovedZ - ChunkCountSide);
                }
            }
        }
        internal void RenderVisible()
        {
            for (int X = 0; X < ChunkCount

            {
                for (int Z = 0; Z < ChunkCount; Z++)
                {
                    Chunks[X, Z].Render(X - ChunkCountSide, Z - ChunkCountSide);
                }
            }
        }
        internal void UpX()
        {
            MovedX++;
            Parallel.For(0, ChunkCount, Z =>
            {
                Chunks[0, Z].Dispose();
                for (int X = 0; X < ChunkCountMaxKey; X++)
                {
                    Chunks[X, Z] = Chunks[X + 1, Z];
                }
                Chunks[ChunkCount - 1, Z] = new Chunk(ChunkCountSide + MovedX, Z + MovedZ - ChunkCountSide);
            });
        }
        internal void DownX()
        {
            MovedX--;
            Parallel.For(0, ChunkCount, Z =>
            {
                Chunks[ChunkCountMaxKey, Z].Dispose();
                for (int X = ChunkCount - 1; X > 0; X--)
                {
                    Chunks[X, Z] = Chunks[X - 1, Z];
                }
                Chunks[0, Z

            });
        }
        internal void UpZ()
        {
            MovedZ++;
            Parallel.For(0, ChunkCount, X =>
            {
                Chunks[X, 0].Dispose();
                for (int Z = 0; Z < ChunkCountMaxKey; Z++)
                {
                    Chunks[X, Z] = Chunks[X, Z + 1];
                }
                Chunks[X, ChunkCount - 1] = new Chunk(X + MovedX - ChunkCountSide, ChunkCountSide + MovedZ);
            });
        }
        internal void DownZ()
        {
            MovedZ--;
            Parallel.For(0, ChunkCount, X =>
            {
                Chunks[X, ChunkCountMaxKey].Dispose();
                for (int Z = ChunkCountMaxKey; Z > 0; Z--)
                {
                    Chunks[X, Z] = Chunks[X, Z - 1];
                }
                Chunks[X, 0] = new Chunk(X + MovedX - ChunkCountSide, MovedZ - ChunkCountSide);
            });
        }
        public void Dispose()
        {
            foreach (var Chunk in Chunks)
   
namespace Chiffrage.Mvc.Views
    public class UserControlView : WithValidationUserControl, IView
    {
        #region IView Members
        public virtual void SetParent(IWin32Window parent)
        {
            Parent = parent as Control;
            Dock = DockStyle.Fill;
        }
        public virtual void ShowView()
        {
            if(this.Parent == null)
            {
                throw new NoParentViewException();
            }
            else
            {
                InvokeIfRequired(Show);   
            }            
        }
        public virtual void HideView()
        {
            InvokeIfRequired(Hide);
        }
        #endregion
        public void InvokeIfRequired(Action action)
        {
            if (this.InvokeRequired)
            {
                BeginInvoke(action);
            }
            else
            {
                action();   
            }            
        }
        public T InvokeIfRequired<T>(Func<T> func)
        {
   
namespace Profit
    public class RepositoryFactory
    {
        Hashtable m_listService = new Hashtable();
        static volatile RepositoryFactory m_instance;
        public const string BANK_REPOSITORY = "BankRepository";
        public const string CURRENCY_REPOSITORY = "CurrencyRepository";
        public const string DIVISION_REPOSITORY = "DivisionRepository";
        public const string EMPLOYEE_REPOSITORY = "EmployeeRepository";
        public const string TOP_REPOSITORY = "TOPRepository";
        public const string UNIT_REPOSITORY = "UnitRepository";
        public const string CUSTOMER_CATEGORY_REPOSITORY = "CustomerCategoryRepository";
        public const string SUPPLIER_CATEGORY_REPOSITORY = "SupplierCategoryRepository";
        public const string PRICE_CATEGORY_REPOSITORY = "PriceCategoryRepository";
        public const string TAX_REPOSITORY = "TaxRepository";
        public const string PART_GROUP_REPOSITORY = "PartGroupRepository";
        public const string WAREH

        public const string PART_CATEGORY_REPOSITORY = "PartCategoryRepository";
        public const string DOC_TYPE_REPOSITORY = "DocTypeRepository";
        public const string EXCHANGE_RATE_REPOSITORY = "ExchangeRateRepository";
        public const string CUSTOMER_REPOSITORY = "CustomerRepository";
        public const string SUPPLIER_REPOSITORY = "SupplierRepository";
        public const string YEAR_REPOSITORY = "YearRepository";
        public const string PART_REPOSITORY = "PartRepository";
        public const string STOCKTAKING_REPOSITORY = "StockTakingRepository";
        public const string USER_REPOSITORY = "UserRepository";
        public const string GENERAL_SETUP_REPOSITORY = "GeneralSetupRepository";
        public const string PURCHASEORDER_REPOSITORY = "PurchaseOrderRepository";
        public const string PERIOD_REPOSITORY = "PeriodRepository";
        public const string USER_SETTING_REPOSITORY = "UserSettingRepository";
        public const string GOODRECEIVENOT

        public const string PURCHASE_RETURN_REPOSITORY = "PurchaseReturnRepository";
        public const string SUPPLIERINVOICE_REPOSITORY = "SupplierInvoiceRepository";
        public const string SUPPLIERINVOICE_JOURNAL_REPOSITORY = "SupplierInvoiceJournalRepository";
        public const string SUPPLIER_OUTSTANDING_INVOICE_REPOSITORY = "SupplierOutStandingInvoiceRepository";
        public const string PAYMENT_REPOSITORY = "PaymentRepository";
        public const string APDEBITNOTE_REPOSITORY = "APDebitNoteRepository";
        public const string PROCESS_TRANSACTION_REPOSITORY = "ProcessTransactionRepository";
        public const string SALES_ORDER_REPOSITORY = "SalesOrderRepository";
        public const string DELIVERY_ORDER_REPOSITORY = "DeliveryOrderRepository";
        public const string SALES_RETURN_REPOSITORY = "SalesReturnRepository";
        public const string CUSTOMER_OUTSTANDING_INVOICE_REPOSITORY = "CustomerOutStandingInvoiceRepository";
        public const string
public class ChunkMaker : MonoBehaviour {
    public Transform ChunkPrefab;
    public float SquareSize = 1.0f;
    public int ChunkWidth = 50;
    public int ChunkHeight = 50;
    public List<Transform> Activators;
    public float ActivationDistance;
    [HideInInspector]
    public List<MapGenerator> Chunks;
    void Start()
    {
    }
    void Update()
    {
        ActivateChunks();
    }
    void ActivateChunks()
    {
        var relevantActivators = Activators.Where(
                                    x=>
                                    checkActivatorInActivationRange(x)
                                ).ToList();
    }
    private bool checkActivatorInActivationRange(Transform activator)
    {
        var chunkRelativeX = (activator.transform.position.x % (ChunkWidth * SquareSize)) - (ChunkWidth * SquareSize / 2);
        var chunkRelativeY = (activator.transform.position.x % (ChunkWidth * SquareSize)) - (ChunkWidth * SquareSize / 2);
        if (chunkRelativeX > ((Chunk

            chunkRelativeX < ((ChunkWidth * SquareSize) / 2f) + ActivationDistance ||
            chunkRelativeY > ((ChunkHeight * SquareSize) / 2f) - ActivationDistance ||
            chunkRelativeY < ((ChunkHeight * SquareSize) / 2f) + ActivationDistance)
            return true;
        else
            return false;
    }
    private List<Vector2> getRelavantChunks(Transform activator)
    {
        var relavantChunks = new List<MapGenerator>();
        var CheckableAbsolutePositions = new List<Vector2>();
        var chunkRelativeX = ((activator.transform.position.x - transform.position.x) % (ChunkWidth * SquareSize)) - (ChunkWidth * SquareSize / 2f);
        var chunkRelativeY = ((activator.transform.position.x - transform.position.y) % (ChunkHeight * SquareSize)) - (ChunkHeight * SquareSize / 2f);
        var currChunkPosX = activator.transform.position.x - chunkRelativeX;
        var currChunkPosY = activator.transform.position.y - chunkRelativeY;
        CheckableAbsolutePosi

        bool right = false;
        bool left = false;
        bool bottom = false;
        bool top = false;
        if (chunkRelativeX > ((ChunkWidth * SquareSize) / 2f) - ActivationDistance) {
            CheckableAbsolutePositions.Add(new Vector2(currChunkPosX + (ChunkWidth * SquareSize), currChunkPosY));
            right = true;
        }
        if (chunkRelativeX < ActivationDistance)
        {
            CheckableAbsolutePositions.Add(new Vector2(currChunkPosX - (ChunkWidth * SquareSize), currChunkPosY));
            left = true;
        }
        if (chunkRelativeY > ((ChunkHeight * SquareSize) / 2f) - ActivationDistance)
        {
            CheckableAbsolutePositions.Add(new Vector2(currChunkPosX, currChunkPosY + (ChunkHeight * SquareSize)));
            bottom = true;
        }
        if (chunkRelativeY < ActivationDistance)
        {
            CheckableAbsolutePositions.Add(new Vector2(currChunkPosX, currChunkPosY - (ChunkHeight * SquareSize) ));
            top = t
﻿namespace FootballBetting.Data.UnitsOfWork
    public class GenericUnitOfWork : IDisposable
    {
        private readonly FootballBettingContext context = new FootballBettingContext();
        private GenericRepository<Bet> betsRepository;
        private GenericRepository<BetGame> betsGamesRepository;
        private GenericRepository<Color> colorsRepository;
        private GenericRepository<Competition> competitionsRepository;
        private GenericRepository<CompetitionType> competitionTypesRepository;
        private GenericRepository<Continent> continentsRepository;
        private GenericRepository<Country> countriesRepository;
        private GenericRepository<Game> gamesRepository;
        private GenericRepository<Player> playersRepository;
        private GenericRepository<Position> positionsRepository;
        private GenericRepository<ResultPrediction> resultPredictionsRepository;
        private GenericRepository<Round> roundsRepository;
        private GenericReposito

        private GenericRepository<Town> townsRepository;
        private GenericRepository<User> usersRepository;
        private bool isDisposed = false;
        public GenericRepository<Bet> BetsRepository
        {
            get
            {
                if (this.betsRepository == default(GenericRepository<Bet>))
                {
                    this.betsRepository = new GenericRepository<Bet>(this.context);
                }
                return this.betsRepository;
            }
        }
        public GenericRepository<BetGame> BetsGamesRepository
        {
            get
            {
                if (this.betsGamesRepository == default(GenericRepository<BetGame>))
                {
                    this.betsGamesRepository = new GenericRepository<BetGame>(this.context);
                }
                return this.betsGamesRepository;
            }
        }
        public GenericRepository<Color> ColorsRepository
        {
            get
            {
 

                {
                    this.colorsRepository = new GenericRepository<Color>(this.context);
                }
                return this.colorsRepository;
            }
        }
        public GenericRepository<Competition> CompetitionsRepository
        {
            get
            {
                if (this.competitionsRepository == default(GenericRepository<Competition>))
                {
                    this.competitionsRepository = new GenericRepository<Competition>(this.context);
                }
                return this.competitionsRepository;
            }
        }
        public GenericRepository<CompetitionType> CompetitionTypesRepository
        {
            get
            {
                if (this.competitionTypesRepository == default(GenericRepository<CompetitionType>))
                {
                    this.competitionTypesRepository = new GenericRepository<CompetitionType>(this.context);
                }
                return this.com
namespace fluidedotnet
  public delegate void MyCallbackDelegate(SceneParam param);
  public partial class FormParam : Form
  {
    MyCallbackDelegate callback;
    Instrument instrument= new Instrument();
    public FormParam()
    {
      InitializeComponent();
    }
    public void InitParam(string path,MyCallbackDelegate c)
    {
      callback = c;
      var files = from file in Directory.GetFiles(path)
                  orderby file where file.EndsWith(".geo")
                  select file;
      foreach (var file in files)
      {
        FileList.Items.Add(Path.GetFileNameWithoutExtension(file));
      }
      XTrack.Value = 900;
      instrument.zoom = true;
      instrument.zoomx = XTrack.Value;
      instrument.changeinstrument = true;
      SetParams(true);
    }
    private void FormParam_Load(object sender, EventArgs e)
    {
    }
    public void SetParams(bool reinit)
    {
      SceneParam param = new SceneParam();
      param.reinit = reinit;
      if(FileList.Selecte

        param.file = FileList.SelectedItem.ToString();
      else
      param.file = "free2";
      param.instrument = instrument;
      callback(param);
    }
    private void FileList_SelectedIndexChanged(object sender, EventArgs e)
    {
      instrument = new Instrument();
      SetParams(true);
    }
    private void XTrack_Scroll(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.zoom = true;
      instrument.zoomx = XTrack.Value;
      instrument.changeinstrument = true;
      SetParams(false);
    }
    private void ButDrop_Click(object sender, EventArgs e)
    {
      instrument = new  Instrument();
      instrument.changeinstrument = true;
      instrument.drop = true;
      SetParams(false);
    }
    private void butPipe_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.pipe = true;
      SetParams(false);
    }
    private void butObstacle_Click(objec

    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.setter = true;
      SetParams(false);
    }
    private void butDelate_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.remover = true;
      SetParams(false);
    }
    private void butForce_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.forceup = true;
      SetParams(false);
    }
    private void butForceDown_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.forcedown = true;
      SetParams(false);
    }
    private void butPush_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.push = true;
      SetParams(false);
    }
    private void 
namespace NAudio.FileFormats.SoundFont
	internal class InstrumentBuilder : StructureBuilder
	{
		private Instrument lastInstrument;
		public override int Length
		{
			get { return 22; }
		}
		public Instrument[] Instruments
		{
			get { return (Instrument[]) data.ToArray(typeof (Instrument)); }
		}
		public override object Read(BinaryReader br)
		{
			var i = new Instrument();
			string s = Encoding.ASCII.GetString(br.ReadBytes(20));
			if (s.IndexOf('\0') >= 0)
			{
				s = s.Substring(0, s.IndexOf('\0'));
			}
			i.Name = s;
			i.startInstrumentZoneIndex = br.ReadUInt16();
			if (lastInstrument != null)
			{
				lastInstrument.endInstrumentZoneIndex = (ushort) (i.startInstrumentZoneIndex - 1);
			}
			data.Add(i);
			lastInstrument = i;
			return i;
		}
		public override void Write(BinaryWriter bw, object o)
		{
			var i = (Instrument) o;
		}
		public void LoadZones(Zone[] zones)
		{
			for (int instrument = 0; instrument < data.Count - 1; instrument++)
			{
				var i = (Instrument)
namespace Ensage.SDK.Handlers
    public class InvokeHandler
    {
        private static InvokeHandler instance;
        public static InvokeHandler Default
        {
            get
            {
                if (instance == null)
                {
                    instance = new InvokeHandler();
                }
                return instance;
            }
        }
        public virtual bool Invoke(Action callback)
        {
            callback.Invoke();
            return true;
        }
        public override string ToString()
        {
            return "Handler";
        }
    }
    public class InvokeHandler<TEventArgs>
    {
        private static InvokeHandler<TEventArgs> instance;
        public static InvokeHandler<TEventArgs> Default
        {
            get
            {
                if (instance == null)
                {
                    instance = new InvokeHandler<TEventArgs>();
                }
                return instance;
            }
    
namespace EventManagementSystem.Data.UnitOfWork
    public class EventDataUnit : EntitiesUnitOfWork, IEventDataUnit
    {
        public EventDataUnit()
            : base(new EmsEntities())
        {
            RegisterRepository<Event, EventsRepository>();
            RegisterRepository<Corresponcence, CorresponcencesRepository>();
            RegisterRepository<EventUpdate, EventUpdatesRepository>();
            RegisterRepository<Room, RoomsRepository>();
            RegisterRepository<Golf, GolfsRepository>();
            RegisterRepository<EventRoom, EventRoomsRepository>();
            RegisterRepository<EventGolf, EventGolfsRepository>();
            RegisterRepository<EventCatering, EventCateringsRepository>();
            RegisterRepository<ContactTitle, ContactTitlesRepository>();
            RegisterRepository<Contact, ContactsRepository>();
            RegisterRepository<EventStatus, EventStatusesRepository>();
            RegisterRepository<EventType, EventTypesRepositor

            RegisterRepository<EventContact, EventContactsRepository>();
            RegisterRepository<EventCharge, EventChargesRepository>();
            RegisterRepository<EventBookedProduct, EventBookedProductsRepository>();
            RegisterRepository<EventInvoice, EventInvoicesRepository>();
            RegisterRepository<EventNote, EventNotesRepository>();
            RegisterRepository<EventPayment, EventPaymentsRepository>();
            RegisterRepository<Report, ReportsRepository>();
            RegisterRepository<Product, ProductsRepository>();
            RegisterRepository<Invoice, InvoicesRepository>();
            RegisterRepository<MailTemplate, MailTemplatesRepository>();
            RegisterRepository<CorresponcenceType, CorresponcenceTypesRepository>();
            RegisterRepository<Document, DocumentsRepository>();
            RegisterRepository<GolfHole, GolfHolesRepository>();
            RegisterRepository<User, UsersRepository>();
            RegisterRepos

            RegisterRepository<PaymentMethod, PaymentMethodsRepository>();
            RegisterRepository<CalendarNote, CalendarNotesRepository>();
            RegisterRepository<CCContactsCorrespondence, CCContactsCorrespondenceRepository>();
            RegisterRepository<CorrespondenceDocument, CorrespondenceDocumentsRepository>();
            RegisterRepository<EventReminder, EventRemindersRepository>();
            RegisterRepository<FollowUpStatus, FollowUpStatusesRepository>();
            RegisterRepository<EmailHeader, EmailHeadersRepository>();
        }
        public ICalendarNotesRepository CalendarNotesRepository
        {
            get { return (ICalendarNotesRepository)GetRepository<CalendarNote>(); }
        }
        public IPaymentMethodsRepository PaymentMethodsRepository
        {
            get { return (IPaymentMethodsRepository)GetRepository<PaymentMethod>(); }
        }
        public IEventNoteTypesRepository EventNoteTypesRepository
        {
            
namespace KCVDB.TestClient
	class Program
	{
		static void Main(string[] args)
		{
			var sendCount = 100;
			var agentId = "疣痔つらい";
			var statusCode = 200;
			var requestBody = "api%5Fverno=1";
			var responseBody = "body";
			var httpDateHeaderValue = DateTime.UtcNow.ToString("r");
				Send(client, rquestUri, statusCode, requestBody, responseBody, httpDateHeaderValue, sendCount);
			}
			Console.ReadKey();
		}
		static void Send(
			IKCVDBClient client,
			Uri requestUri,
			int statusCode,
			string requestBody,
			string responseBody,
			string httpDateHeaderValue,
			int sendCount)
		{
			var trackingIds = new ConcurrentQueue<Guid>();
			var doneAll = false;
			var allDataSentSuccessfully = true;
			client.FatalError += (_, e) => {
				Console.WriteLine("Fatal Error: {0}, {1}", e.Message, e.Exception);
				allDataSentSuccessfully = false;
				doneAll = true;
			};
			client.SendingError += (_, e) => {
				Console.WriteLine("Sending Error: {0}, {1}", e.Message, e.Exception);
			};

			client.InternalError += (_, e) => {
				Console.WriteLine("Internal Error: {0}, {1}", e.Message, e.Exception);
			};
			client.ApiDataSent += (_, e) => {
				foreach (var trackingId in e.TrackingIds) {
					Console.WriteLine($"Sending data suceceded ({trackingId})");
					Console.WriteLine(e.SentApiData);
					bool succeeded = false;
					Guid nextTrackingId;
					do {
						succeeded = trackingIds.TryDequeue(out nextTrackingId);
					}
					while (!succeeded);
					if (trackingId != nextTrackingId) {
						allDataSentSuccessfully = false;
						Console.WriteLine("Invalid tracking ID. (Expected: {0}, Actual: {1})", nextTrackingId, trackingId);
					}
				}
				doneAll = trackingIds.Count == 0;
			};
			Console.WriteLine("Sending data...");
			var rand = new Random();
			for (int i = 0; i < 20; i++) {
				var timeToWait = rand.Next(5000);
				if (timeToWait > 3000) {
					Task.Delay(timeToWait).Wait();
				}
				var trackingId = client.SendRequestDataAsync(requestUri, statusCode, re
namespace YunDa.JC.MMI.Common.Extensions
   public static class ControlExtension
    {
       public static void InvokeIfNeed(this Control control, Delegate methed, params object[] objs)
       {
           if (control.InvokeRequired)
           {
               control.Invoke(methed, objs);
               
           }
           else
           {
               methed.DynamicInvoke(objs);
           }
       }
       private static readonly Action<Control> InvalidateAction = t => t.Invalidate();
       public static void InvokeInvalidate(this Control control)
       {
           if (control.InvokeRequired)
           {
               control.Invoke(InvalidateAction, control);
           }
           else
           {
               InvalidateAction.DynamicInvoke(control);
           }
       }
       private static readonly Action<Control, bool> VisibleAction = (t, b) => t.Visible = b;
       public static void InvokeVisible(this Control control, bool visible)
       {
           if 

           {
               control.Invoke(VisibleAction,control, visible);
           }
           else
           {
               VisibleAction.DynamicInvoke(control, visible);
           }
       }
       private static readonly Action<Control> ShowAction = (t) => t.Show();
       public static void InvokeShow(this Control control)
       {
           if (control.InvokeRequired)
           {
               control.Invoke(ShowAction, control);
           }
           else
           {
               ShowAction.DynamicInvoke(control);
           }
       }
       private static readonly Action<Control> HideAction = (t) => t.Hide();
       public static void InvokeHide(this Control control)
       {
           if (control.InvokeRequired)
           {
               control.Invoke(HideAction, control);
           }
           else
           {
               HideAction.DynamicInvoke(control);
           }
       }
       private static readonly Action<Control, Control> RemoveChildActi
namespace Spacebrick
    public class VoxelMapQuery
    {
        public VoxelMap Map { get; private set; }
        public VoxelChunk LastChunk { get; private set; }
        public bool InBatchMode { get; set; }
        private void GetNextChunk(int x, int y, int z, bool createIfMissing)
        {
            int chunkX = x;
            int chunkY = y;
            int chunkZ = z;
            bool shouldGet = false;
            VoxelChunk.ConvertWorldToChunk(ref chunkX, ref chunkY, ref chunkZ);
            if (LastChunk != null)
            {
                Vector3i lastChunkPosition = LastChunk.ChunkPosition;
                if (chunkX != lastChunkPosition.x || chunkY != lastChunkPosition.y || chunkZ != lastChunkPosition.z)
                    shouldGet = true;
            }
            else
                shouldGet = true;
            if (shouldGet)
            {
                if (createIfMissing)
                    LastChunk = Map.GetOrCreateChunk(chunkX, chunkY, chunkZ);
      

                    LastChunk = Map.GetChunk(chunkX, chunkY, chunkZ);
            }
        }
        public Voxel GetVoxel(int x, int y, int z)
        {
            GetNextChunk(x, y, z, false);
            if (LastChunk != null)
            {
                VoxelChunk.ConvertWorldToLocal(ref x, ref y, ref z);
                return LastChunk.GetVoxel(x, y, z);
            }
            return new Voxel();
        }
        public void SetVoxelInExistingChunk(int x, int y, int z, Voxel voxel)
        {
            GetNextChunk(x, y, z, false);
            if (LastChunk != null)
            {
                VoxelChunk.ConvertWorldToLocal(ref x, ref y, ref z);
                LastChunk.SetVoxel(x, y, z, voxel, !InBatchMode);
            }
        }
        public void SetVoxel(int x, int y, int z, Voxel voxel)
        {
            GetNextChunk(x, y, z, true);
            if (LastChunk != null)
            {
                VoxelChunk.ConvertWorldToLocal(ref x, ref y, ref z);
      

            }
        }
    }
    public class VoxelChunkCreatedEvent
    {
        public VoxelChunk Chunk { get; private set; }
        public VoxelChunkCreatedEvent(VoxelChunk chunk) { Chunk = chunk; }
    }
    public class VoxelMap
    {
        public const ulong OffsetToPositive = 1000000;
        public const ulong MaxSize = OffsetToPositive*2;
        private static Dictionary<ulong, VoxelChunk> _voxelMap = new Dictionary<ulong, VoxelChunk>();
        public EventHub Events { get; private set; }
        private EventCallbackList _chunkCreatedList;
        private static ulong ConvertChunkPositionToKey(int chunkX, int chunkY, int chunkZ)
        {
            ulong x = (ulong)chunkX + OffsetToPositive;
            ulong y = (ulong)chunkY + OffsetToPositive;
            ulong z = (ulong)chunkZ + OffsetToPositive;
            return z*MaxSize*MaxSize + y*MaxSize + x;
        }
        public VoxelChunk GetChunk(int chunkX, int chunkY, int chunkZ)
        {
            ulong key 
namespace SharpCMS.Service.IoC
    public static class ServiceFactory
    {
        public static ContentService CreateContentService()
        {
            IUnitOfWork uow = new EFUnitOfWork();
            IArticleRepository articleRepository = new ArticleRepository(uow);
            ISiteNodeRepository siteNodeRepository = new SiteNodeRepository(uow);
            INewsRepository newsRepository = new NewsRepository(uow);
            ICompanyRepository companyRepository = new CompanyRepository(uow);
            IIdeaRepository ideaRepository = new IdeaRepository(uow);
            ICommentRepository commentRepository = new CommentRepository(uow);
            IVacancyRepository vacancyRepository = new VacancyRepository(uow);
            IAnnouncementRepository announcementRepository = new AnnouncementRepository(uow);
            
            return new ContentService(articleRepository, siteNodeRepository, newsRepository, companyRepository, ideaRepository,
                 commentReposit
namespace MTB
    [RequireComponent(typeof(WorldRenderer))]
    public class World : MonoBehaviour
    {
        private static World _world;
        public static World world { get { return _world; } }
        private Queue<Chunk> _cacheChunks;
        public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>(200, new WorldPosComparer());
        public GameObject chunkPrefab;
        public bool editorMode;
        private WorldGenerator _worldGenerator;
        public WorldGenerator WorldGenerator { get { return _worldGenerator; } }
        private IWorldLoader _worldLoader;
        public IWorldLoader WorlderLoader { get { return _worldLoader; } }
		public bool FirstGeneted{get;private set;}
        public static int MaxHeight = Chunk.chunkHeight;
        public static int MinHeight = 0;
        public Vector3 generatorPos { get; set; }
        public NetType netType { get; set; }
        public static void Generate(string path, Vector3 pos, NetType netType)
     

            GameObject worldObject = GameObject.Instantiate(Resources.Load(path) as GameObject);
            _world = worldObject.GetComponent<World>();
            _world.generatorPos = pos;
            _world.netType = netType;
        }
        public void Awake()
        {
            _worldGenerator = new WorldGenerator(this);
            MTBPathFinder.Instance.Init(this);
        }
        public void Start()
        {
            ChangeLoader(netType);
            int extendChunkWidth = WorldConfig.Instance.extendChunkWidth;
            InitCacheChunks((extendChunkWidth * 2 + 1) * (extendChunkWidth * 2 + 1) - extendChunkWidth * extendChunkWidth);
			EventManager.RegisterEvent(EventMacro.GENERATE_FIRST_WORLD_FINISH, OnFirstWorldGenerated);
			FirstGeneted = false;
			_worldLoader.LoadFirst(generatorPos, extendChunkWidth > 7 ? 7 : extendChunkWidth);
            _worldLoader.Start();
            _worldGenerator.StartWorldGenerator();
        }
		private void OnFirstWorldGenerated(

		{
			EventManager.UnRegisterEvent(EventMacro.GENERATE_FIRST_WORLD_FINISH, OnFirstWorldGenerated);
			FirstGeneted = true;
		}
        public void ChangeLoader(NetType netType)
        {
            if (_worldLoader != null)
            {
                _worldLoader.Stop();
                _worldLoader.Dispose();
            }
            if (editorMode)
            {
                _worldLoader = new EditorWorldLoader(this);
            }
            else
            {
                if (netType == NetType.Single)
                {
                    _worldLoader = new SingleWorldLoader(this);
                }
                else
                {
                    _worldLoader = new NetWorldLoader(this);
                }
            }
        }
        public void saveAll()
        {
            _worldLoader.SaveAll();
        }
        void Update()
        {
            _worldLoader.Update();
        }
        public float showSplashTimeout = 1.0F;
        private static
namespace ProcessUsage.Services
    public class ProcessWatcher
    {
        readonly int _checkInterval;
        Timer _timer;
        Process _previousProcess;
        Process _currentProcess;
        public ProcessWatcher(int checkInterval, Action<Process,Process> onWorkingProcessChanchged):
            this(checkInterval)
        {
            if (onWorkingProcessChanchged == null)
            {
                throw new ArgumentNullException("onWorkingProcessChanchged");
            }
            WorkingProcessChanged += new WorkingProcessChangedHandler(onWorkingProcessChanchged);
        }
        public ProcessWatcher(int checkInterval)
        {
            this._checkInterval = checkInterval;
            _timer = new Timer(_checkInterval);
            _timer.Elapsed+=OnTimerElapsed;
        }
        void OnTimerElapsed(object sender, ElapsedEventArgs e)
        {
            var newProcess = ProcessHelper.GetCurrentUserWorkingProcess();
            if (_currentProcess == nul
namespace AssemblyCSharp
    public class ChunkManager
    {
        private Hashtable chunkCollection = new Hashtable();
        public Queue<Chunk2> requiresGOgeneration = new Queue<Chunk2>();
                private System.Object thisLock = new System.Object();
        public GameObject worldGO;
        public World world;
        public ChunkRenderer renderer;
        public ChunkManager(World world)
        {
            this.world = world;
            this.renderer = new ChunkRenderer(this, world);
        }
        public bool LoadChunkWithinDist(int startChunkX, int startChunkZ, int blockDist, int maxLoad)
        {
            int currentLoad = 0;
            int chunkx = startChunkX >> 4;
            int chunkz = startChunkZ >> 4;
            int chunkdist = blockDist >> 4;
            int minX = chunkx - chunkdist;
            int minZ = chunkz - chunkdist;
            int maxX = chunkx + chunkdist;
            int maxZ = chunkz + chunkdist;
            for (int x = minX; x 

            {
                for (int z = minZ; z < maxZ; z++)
                {
                    Chunk2 chunk = GetChunk(x, z);
                    if (chunk == null) 
                    {
                        LoadChunk(x, z, true);
                        currentLoad ++;
                        if (currentLoad >= maxLoad) return true;
                    }
                    
                }
            }
            return false;
        }
        public void LoadChunk(int x, int z, bool useQueue) 
        {
            System.DateTime genStart = System.DateTime.Now;
            Chunk2 chunk = new Chunk2(this, x, z);
            chunkCollection.Add(x + ":" + z, chunk);
            chunk.pendingStatus = 1;
            Chunk2 n = GetChunk(chunk.xPosition, chunk.zPosition + 1);
            Chunk2 ne = GetChunk(chunk.xPosition + 1, chunk.zPosition + 1);
            Chunk2 e = GetChunk(chunk.xPosition + 1, chunk.zPosition);
            Chunk2 se = GetChunk(chunk.xPosition + 1

            Chunk2 s = GetChunk(chunk.xPosition, chunk.zPosition - 1);
            Chunk2 sw = GetChunk(chunk.xPosition - 1, chunk.zPosition - 1);
            Chunk2 w = GetChunk(chunk.xPosition - 1, chunk.zPosition);
            Chunk2 nw = GetChunk(chunk.xPosition - 1, chunk.zPosition + 1);
            if (n != null)
            {
                chunk.ChunkNorth = n;
                n.ChunkSouth = chunk;
            }
            if (ne != null)
            {
                chunk.ChunkNorthEast = ne;
                ne.ChunkSouthWest = chunk;
            }
            if (e != null)
            {
                chunk.ChunkEast = e;
                e.ChunkWest = chunk;
            }
            if (se != null)
            {
                chunk.ChunkSouthEast = se;
                se.ChunkNorthWest = chunk;
            }
            if (s != null)
            {
                chunk.ChunkSouth = s;
                s.ChunkNorth = chunk;
            }
            if (sw != null)
  
namespace Plants_vs_Crackers
    class Resource
    {
        public string processName { get; private set; }
        public int processId { get; private set; }
        private Resource(string processName, int processId)
        {
            this.processName = processName;
            this.processId = processId;
        }
        private static IEnumerable<Process> getTargetProcess(ref string targetProcessName)
        {
            if (targetProcessName.IndexOf(".exe") != -1)
                targetProcessName = targetProcessName.Substring(0, targetProcessName.IndexOf(".exe"));
            IEnumerable<Process> targetProcess = Process.GetProcessesByName(targetProcessName).AsEnumerable();
            if ( ( targetProcess.Count() >= 1 ) && ( targetProcess.First().Id != -1 ) )
            {
                return targetProcess;
            }
            return null;
        }
        public Resource getProcessResource(string targetProcessName)
        {
            if (targetProcessName =
public class World : MonoBehaviour {
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public GameObject chunkPrefab;
    public void InitData ()
    {
        for (int x = -2; x <= 1; x++)
        {
            for (int y = 0; y <= 1; y++)
            {
                for (int z = -2; z <= 1; z++)
                {
                    CreateChunk(x * 16, y * 16, z * 16);
                }
            }
        }
    }
    public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(chunkPrefab, new Vector3(x, y, z), Quaternion.Euler(Vector3.zero)) as GameObject;
        newChunkObject.transform.parent = transform;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        for (int xi = 0; xi < 16; xi++)
        {
            for (int yi = 0; yi <

            {
                for (int zi = 0; zi < 16; zi++)
                {
                    SetBlock(x + xi, y + yi, z + zi, new BlockAir());
                }
            }
        }
    }
    public void UpdateChucks()
    {
        float[,] mapHeight = References.Refs.mapGenerator.GenerateNoiseMap();
        for (int x = -32; x < 32; x++)
        {
            for (int z = -32; z < 32; z++)
            {
                for (int y = 0; y < 32; y++)
                {
                    int Height = Mathf.RoundToInt(mapHeight[x + 32, z + 32] * 32);
                    if(Height >= 6 && Height <= 13)
                    {
                        SetBlock(x, Height, z, new BlockStone());
                    }
                    else if (Height > 13)
                    {
                        SetBlock(x, Height, z, new BlockSnow());
                    }
                    else
                    {
                        SetBlock(x, Height, z, new BlockGrass());
        

                    if (y < Height)
                    {
                        if (y > 7 && y <= 13)
                        {
                            SetBlock(x, y, z, new BlockStone());
                        }
                        else if (y > 13)
                        {
                            SetBlock(x, y, z, new BlockSnow());
                        }
                        else
                        {
                            SetBlock(x, y, z, new BlockStone());
                        }
                    }
                }
            }
        }
        for (int xi = -2; xi <= 1; xi++)
        {
            for (int zi = -2; zi <= 1; zi++)
            {
                Chunk containerChunk = GetChunk(xi * 16, 0, zi * 16);
                if (containerChunk != null)
                {
                    containerChunk.update = true;
                }
            }
        }
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos p
namespace com.bp.remoteservices.wmi.process {
    public class ProcessLocal : IProcessObject {
        
        #region "fields"
        ConnectionOptions options;
        ManagementScope connectionScope;
        #endregion
        #region "constructors"
        public ProcessLocal() {
            options = ProcessConnection.ProcessConnectionOptions();
            connectionScope = ProcessConnection.ConnectionScope(
                                     Environment.MachineName, options);
        }
        #endregion
        
        #region "polymorphic methods"
        public ArrayList RunningProcesses() {
            ArrayList alProcesses = new ArrayList();
            alProcesses = ProcessMethod.RunningProcesses(connectionScope);
            return alProcesses;
        }
        public ArrayList ProcessProperties(string processName) {
            ArrayList alProperties = new ArrayList();
            alProperties = ProcessMethod.ProcessProperties(connectionScope,
                     

            return alProperties;
        }
        public string CreateProcess(string processPath, string processName, string arguments) {
            return ProcessMethod.StartProcess(Environment.MachineName, processPath + processName + " " + arguments);
        }
        public string CreateCMDProcess(string processPath, string processName, string arguments) {
            return ProcessMethod.StartProcess(Environment.MachineName, processPath + processName + " " + arguments);
        }
        public void TerminateProcess(string processName) {
            ProcessMethod.KillProcess(connectionScope, processName);
        }
        public void SetPriority(string processName, ProcessPriority.priority priority) {
            ProcessMethod.ChangePriority(connectionScope, processName, priority);
        }
        public string GetProcessOwner(string processName) {
            return ProcessMethod.ProcessOwner(connectionScope, processName);
        }
        public string GetProcessOwnerSID(
namespace JustGiving.Api.Sdk
    public class JustGivingClient : JustGivingClientBase
    {
        public JustGivingClient(string apiKey)
            : base(
                new ClientConfiguration(apiKey), new HttpClientWrapper(), null, null, null, null, null, null, null, null,
                null, null, null)
        {
        }
        public JustGivingClient(ClientConfiguration clientConfiguration)
            : base(
                clientConfiguration, new HttpClientWrapper(), null, null, null, null, null, null, null, null, null, null, null
                )
        {
        }
        public JustGivingClient(ClientConfiguration clientConfiguration, IHttpClient httpClient)
            : base(clientConfiguration, httpClient, null, null, null, null, null, null, null, null, null, null, null)
        {
        }
        public JustGivingClient(ClientConfiguration clientConfiguration, IHttpClient httpClient, IAccountApi accountApi,
                                IDonationApi donati
namespace CraftsmanKata.InstrumentProcessorKata
    public class InstrumentProcessor : IDisposable
    {
        private readonly ITaskDispatcher taskDispatcher;
        private readonly IInstrument instrument;
        public InstrumentProcessor(ITaskDispatcher taskDispatcher, IInstrument instrument)
        {
            this.taskDispatcher = taskDispatcher;
            this.instrument = instrument;
            instrument.Error += InstrumentOnError;
            instrument.Finished += InstrumentOnFinished;
        }
        
        public void Process()
        {
            string task = taskDispatcher.GetTask();
            instrument.Execute(task);
        }
        private void InstrumentOnFinished(object sender, EventArgs taskEventArgs)
        {
             taskDispatcher.FinishedTask(((TaskEventArgs)taskEventArgs).Task);
        }
        private void InstrumentOnError(object sender, EventArgs taskEventArgs)
        {
        }
        public void Dispose()
        {
         
namespace Wags.DataAccess
    public class PlayerRepository : GenericDataRepository<Player>, IPlayerRepository
    {
    }
    public class CourseRepository : GenericDataRepository<Course>, ICourseRepository
    {
    }
    public class MemberRepository : GenericDataRepository<Member>, IMemberRepository
    {
    }
    public class CourseDataRepository : GenericDataRepository<CourseData>, ICourseDataRepository
    {
    }
    public class EventRepository : GenericDataRepository<Event>, IEventRepository
    {
    }
    public class TrophyRepository : GenericDataRepository<Trophy>, ITrophyRepository
    {
    }
    public class BookingRepository : GenericDataRepository<Booking>, IBookingRepository
    {
    }
    public class GuestRepository : GenericDataRepository<Guest>, IGuestRepository
    {
    }
    public class HistoryRepository : GenericDataRepository<History>, IHistoryRepository
    {
    }
    public class TransactionRepository : GenericDataRepository<Transaction>, ITransaction
namespace UurFac.Models.Repo
    public class UnitOfWork : IUnitOfWork
    {
        private UurFacContext context;
        private IDepartementKlantRepository departementKlantRepository;
        private IDepartementRepository departementRepository;
        private IFactuurRepository factuurRepository;
        private IGebruikerKlantRepository gebruikerKlantRepository;
        private IGebruikerRepository gebruikerRepository;
        private IKlantRepository klantRepository;
        private TariefRepository tariefRepository;
        private IUurRegistratieRepository uurRegistratieRepository;
        private IGebruikerDepartementRepository gebruikerDepartementRepository;
        private IUurRegistratieDetailRepository uurRegistratieDetailRepository;
        private IdentityManager identityManager;
        public UnitOfWork()
        {
            context = new UurFacContext();
        }
        public IdentityManager IdentityManager
        {
            get
            {
              

                {
                    identityManager = new IdentityManager(context);
                }
                return identityManager;
            }
        }
        public IDepartementKlantRepository DepartementKlantRepository
        {
            get
            {
                if (departementKlantRepository == null)
                {
                    departementKlantRepository = new DepartementKlantRepository(context);
                }
                return departementKlantRepository;
            }
        }
        public IDepartementRepository DepartementRepository
        {
            get
            {
                if (departementRepository == null)
                {
                    departementRepository = new DepartementRepository(context);
                }
                return departementRepository;
            }
        }
        public IFactuurRepository FactuurRepository
        {
            get
            {
                if (factuurReposito

                {
                    factuurRepository = new FactuurRepository(context);
                }
                return factuurRepository;
            }
        }
        public IGebruikerKlantRepository GebruikerKlantRepository
        {
            get
            {
                if (gebruikerKlantRepository == null)
                {
                    gebruikerKlantRepository = new GebruikerKlantRepository(context);
                }
                return gebruikerKlantRepository;
            }
        }
        public IGebruikerRepository GebruikerRepository
        {
            get
            {
                if (gebruikerRepository == null)
                {
                    gebruikerRepository = new GebruikerRepository(context);
                }
                return gebruikerRepository;
            }
        }
        public IKlantRepository KlantRepository
        {
            get
            {
                if (klantRepository == null)
            
namespace DataAccess.Repositories.Impl
    public class QuestionRepository : Repository<Question>, IQuestionRepository
    {
        public QuestionRepository(IMySqlRepositoryContext repositoryContext)
            : base(repositoryContext)
        {
        }
    }
    public class QuestionItemRepository : Repository<QuestionItem>, IQuestionItemRepository
    {
        public QuestionItemRepository(IMySqlRepositoryContext repositoryContext)
            : base(repositoryContext)
        {
        }
    }
    public class QuestionSelectRepository : Repository<QuestionSelect>, IQuestionSelectRepository
    {
        public QuestionSelectRepository(IMySqlRepositoryContext repositoryContext)
            : base(repositoryContext)
        {
        }
    }
    public class QuestionSelectUserRepository : Repository<QuestionSelectUser>, IQuestionSelectUserRepository
    {
        public QuestionSelectUserRepository(IMySqlRepositoryContext repositoryContext)
            : base(repositoryContext)
namespace Sisgim.Controllers
    public class MusicalInstrumentController : Controller
    {
        private SISGIMEntities dbSisgim = new SISGIMEntities();
        [Authorize]
        public ActionResult Index(String nombreInstrumento)
        {
            var instrumento = from s in dbSisgim.INSTRUMENTOMUSICAL select s;
            if (!string.IsNullOrEmpty(nombreInstrumento))
            {
                instrumento = instrumento.Where(a => a.NOMBRE.Contains(nombreInstrumento));
            }
            return View(instrumento);
        }
        public ActionResult Create()
        {
            return View();
        }
        [HttpPost]
        public ActionResult Create(INSTRUMENTOMUSICAL instrument)
        {
            try
            {
                if (ModelState.IsValid)
                {
                    var a = instrument;
                    a.NOMBREPROFESOR = User.Identity.Name;
                    dbSisgim.INSTRUMENTOMUSICAL.Add(a);
                    dbSisgi

                    dbSisgim.Dispose();
                    return RedirectToAction("Index");
                }
                return View(instrument);
            }
            catch
            {
                return View(instrument);
            }
        }
        public ActionResult Edit(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            var instrument = dbSisgim.INSTRUMENTOMUSICAL.Find(id);
            if (instrument == null)
            {
                return HttpNotFound();
            }
            return View(instrument);
        }
        [HttpPost]
        public ActionResult Edit(INSTRUMENTOMUSICAL instrument)
        {
            try
            {
                if (ModelState.IsValid)
                {
                    dbSisgim.Entry(instrument).State = EntityState.Modified;
                    dbSisgim.SaveChanges();
                    return Redir

                }
                return View(instrument);
            }
            catch
            {
                return View(instrument);
            }
        }
        public ActionResult Delete(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            var instrument = dbSisgim.INSTRUMENTOMUSICAL.Find(id);
            if (instrument == null)
            {
                return HttpNotFound();
            }
            return View(instrument);
        }
        [HttpPost]
        public ActionResult Delete(int id, INSTRUMENTOMUSICAL instrument)
        {
            try
            {
                if (ModelState.IsValid)
                {
                    instrument = dbSisgim.INSTRUMENTOMUSICAL.Find(id);
                    if (instrument == null)
                    {
                        return HttpNotFound();
                    }
                    dbSisgim.
namespace WebApplication2.Models
	public static class RepositoryHelper
	{
		public static IUnitOfWork GetUnitOfWork()
		{
			return new EFUnitOfWork();
		}		
		
		public static ClientRepository GetClientRepository()
		{
			var repository = new ClientRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static ClientRepository GetClientRepository(IUnitOfWork unitOfWork)
		{
			var repository = new ClientRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OccupationRepository GetOccupationRepository()
		{
			var repository = new OccupationRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OccupationRepository GetOccupationRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OccupationRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OrderRepository GetOrderRepository()
		{
			var repository = new Orde

			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OrderRepository GetOrderRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OrderRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OrderLineRepository GetOrderLineRepository()
		{
			var repository = new OrderLineRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OrderLineRepository GetOrderLineRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OrderLineRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static ProductRepository GetProductRepository()
		{
			var repository = new ProductRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static ProductRepository GetProductRepository(IUnitOfWork unitOfWork)
		{
			var repository = new ProductRepository();
			repository.UnitOfWork = unitOfWork;
			return repo
﻿namespace Frankfort.Threading.Internal
    public static class MainThreadDispatcher
    {
        private static SafeQueue<Action> _actions = new SafeQueue<Action>();
        private static List<DelayedQueueItem> _currentDelayed = new List<DelayedQueueItem>();
        private static List<DelayedQueueItem> _delayed = new List<DelayedQueueItem>();
        public static int currentFrame = 0;
        private static SafeQueue<DispatchAction> dispatchActions = new SafeQueue<DispatchAction>();
        private static bool helperCreated;
        private static void CreateHelperGameObject()
        {
            GameObject target = new GameObject("MainThreadDispatchHelper");
            target.AddComponent<MainThreadDispatchHelper>().hideFlags = target.hideFlags = HideFlags.HideInInspector | HideFlags.HideInHierarchy;
            UnityEngine.Object.DontDestroyOnLoad(target);
            helperCreated = true;
        }
        public static void DispatchActionsIfPresent()
        {
            i

            {
                DispatchAction action = dispatchActions.Dequeue();
                if (!action.Executed)
                {
                    action.ExecuteDispatch();
                }
            }
        }
        public static void DispatchToMainThread(CallBack dispatchCall, bool waitForExecution = false, bool safeMode = true)
        {
            if (MainThreadWatchdog.CheckIfMainThread())
            {
                if (dispatchCall != null)
                {
                    dispatchCall();
                }
            }
            else
            {
                ThreadDispatchAction<object> t = new ThreadDispatchAction<object>();
                dispatchActions.Enqueue(t);
                t.Init(dispatchCall, waitForExecution, safeMode);
            }
        }
        public static void DispatchToMainThread<T>(CallBackArg<T> dispatchCall, T dispatchArgument, bool waitForExecution = false, bool safeMode = true)
        {
            if (MainThreadWat

            {
                if (dispatchCall != null)
                {
                    dispatchCall(dispatchArgument);
                }
            }
            else
            {
                ThreadDispatchAction<T> t = new ThreadDispatchAction<T>();
                dispatchActions.Enqueue(t);
                t.Init(dispatchCall, dispatchArgument, waitForExecution, safeMode);
            }
        }
        public static object DispatchToMainThreadReturn(CallBackReturn dispatchCall, bool safeMode = true)
        {
            if (MainThreadWatchdog.CheckIfMainThread())
            {
                if (dispatchCall != null)
                {
                    return dispatchCall();
                }
            }
            else
            {
                ThreadDispatchAction<object> t = new ThreadDispatchAction<object>();
                dispatchActions.Enqueue(t);
                t.Init(dispatchCall, safeMode);
                return t.dispatchExecutionResult;
   
namespace VetTrainer.Controllers.Apis
    public class InstrumentModifyController : ApiController
    {
        VetAppDBContext _context = new VetAppDBContext();
        protected override void Dispose(bool disposing)
        {
            _context.Dispose();
        }
        public IHttpActionResult PostInstrumentModify(InstrumentDto instrument)
        {
            string msg = "";
            if (instrument == null)
            {
                msg = "参数错误";
            }
            var instrumentToUpdate = _context.Instruments.Find(instrument.Id);
            instrumentToUpdate.Name = instrument.Name;
            instrumentToUpdate.Description = instrument.Description;
            instrumentToUpdate.ModelUrl = instrument.ModelUrl;
            try
            {
                _context.Entry(instrumentToUpdate).State = EntityState.Modified;
                _context.SaveChanges();
                msg = "修改成功";
            }
            catch (RetryLimitExceededException)
        
namespace ProcessManager
    public class ProcessManager : ReceiveActor
    {
        private readonly Dictionary<string, IActorRef> _processes = new Dictionary<string, IActorRef>();
        protected IActorRef ProcessOf(string processId)
        {
            if (_processes.ContainsKey(processId))
            {
                return _processes[processId];
            }
            return null;
        }
        protected void StartProcess(string processId, IActorRef process)
        {
            if (!_processes.ContainsKey(processId))
            {
                _processes.Add(processId, process);
                Self.Tell(new ProcessStarted(processId, process));
            }    
        }
        protected void StopProcess(string processId)
        {
            if (_processes.ContainsKey(processId))
            {
                var process = _processes[processId];
                _processes.Remove(processId);
                Self.Tell(new ProcessStopped(processId, process));
 
namespace Spark.Compiler.ChunkVisitors
    public abstract class AbstractChunkVisitor : IChunkVisitor
    {
        private readonly Stack<RenderPartialChunk> _renderPartialStack = new Stack<RenderPartialChunk>();
        public RenderPartialChunk OuterPartial
        {
            get { return _renderPartialStack.Any() ? _renderPartialStack.Peek() : null; }
        }
        public void Accept(IList<Chunk> chunks)
        {
            if (chunks == null) throw new ArgumentNullException("chunks");
            foreach (var chunk in chunks)
                Accept(chunk);
        }
        public void Accept(Chunk chunk)
        {
            if (chunk == null) throw new ArgumentNullException("chunk");
            if (chunk is SendLiteralChunk)
            {
                Visit((SendLiteralChunk)chunk);
            }
            else if (chunk is LocalVariableChunk)
            {
                Visit((LocalVariableChunk)chunk);
            }
            else if (chunk is SendExpressio

            {
                Visit((SendExpressionChunk)chunk);
            }
            else if (chunk is ForEachChunk)
            {
                Visit((ForEachChunk)chunk);
            }
            else if (chunk is ScopeChunk)
            {
                Visit((ScopeChunk)chunk);
            }
            else if (chunk is GlobalVariableChunk)
            {
                Visit((GlobalVariableChunk)chunk);
            }
            else if (chunk is AssignVariableChunk)
            {
                Visit((AssignVariableChunk)chunk);
            }
            else if (chunk is ContentChunk)
            {
                Visit((ContentChunk)chunk);
            }
            else if (chunk is ContentSetChunk)
            {
                Visit((ContentSetChunk)chunk);
            }
            else if (chunk is UseContentChunk)
            {
                Visit((UseContentChunk)chunk);
            }
            else if (chunk is RenderPartialChunk)
            {
        

            }
            else if (chunk is RenderSectionChunk)
            {
                Visit((RenderSectionChunk)chunk);
            }
            else if (chunk is ViewDataChunk)
            {
                Visit((ViewDataChunk)chunk);
            }
            else if (chunk is ViewDataModelChunk)
            {
                Visit((ViewDataModelChunk)chunk);
            }
            else if (chunk is UseNamespaceChunk)
            {
                Visit((UseNamespaceChunk)chunk);
            }
            else if (chunk is ConditionalChunk)
            {
                Visit((ConditionalChunk)chunk);
            }
            else if (chunk is ExtensionChunk)
            {
                Visit((ExtensionChunk)chunk);
            }
            else if (chunk is CodeStatementChunk)
            {
                Visit((CodeStatementChunk)chunk);
            }
            else if (chunk is MacroChunk)
            {
                Visit((MacroChunk)chunk);
            }
 
namespace EventManagementSystem.Data.UnitOfWork.Interfaces
    public interface ICrmDataUnit : IDataUnitOfWork
    {
        ICampaignTypesRepository CampaignTypesRepository { get; }
        ICampaignsRepository CampaignsRepository { get; }
        IFollowUpStatusesRepository FollowUpStatusesRepository { get; }
        IEnquiriesRepository EnquiriesRepository { get; }
        IFollowUpsRepository FollowUpsRepository { get; }
        IActivitiesRepository ActivitiesRepository { get; }
        IEnquiryUpdatesRepository EnquiryUpdatesRepository { get; }
        IEventStatusesRepository EventStatusesRepository { get; }
        IEventTypesRepository EventTypesRepository { get; }
        IEventNoteTypesRepository EventNoteTypesRepository { get; }
        IEventNotesRepository EventNotesRepository { get; }
        ICorresponcencesRepository CorresponcencesRepository { get; }
        ICorrespondenceDocumentsRepository CorrespondenceDocumentsRepository { get; }
        ICCContactsCorrespondence
namespace MotoTrak.DataLogic
    public class MotoTrakCatalog : StormContext
    {
        public MotoTrakCatalog()
            : base("MotoTrak")
        {
        }
        public AttachmentRepository Attachments
        {
            get { return GetRepository<AttachmentRepository>(); }
        }
        public ClaimHistoryRepository ClaimHistory
        {
            get { return GetRepository<ClaimHistoryRepository>(); }
        }
        public ClaimLabourRepository ClaimLabour
        {
            get { return GetRepository<ClaimLabourRepository>(); }
        }
        public ClaimMiscellaneousRepository ClaimMiscellaneous
        {
            get { return GetRepository<ClaimMiscellaneousRepository>(); }
        }
        public ClaimPartRepository ClaimParts
        {
            get { return GetRepository<ClaimPartRepository>(); }
        }
        public ClaimQueueRepository ClaimQueues
        {
            get { return GetRepository<ClaimQueueRepository>(); }
        }
  

        {
            get { return GetRepository<ClaimRepository>(); }
        }
        public ClaimStatusRepository ClaimStatuses
        {
            get { return GetRepository<ClaimStatusRepository>(); }
        }
        public ClaimTypeRepository ClaimTypes
        {
            get { return GetRepository<ClaimTypeRepository>(); }
        }
        public ConditionRepository Conditions
        {
            get { return GetRepository<ConditionRepository>(); }
        }
        public CustomerRepository Customers
        {
            get { return GetRepository<CustomerRepository>(); }
        }
        public CustomerConcernRepository CustomerConcerns
        {
            get { return GetRepository<CustomerConcernRepository>(); }
        }
        public DealerRepository Dealers
        {
            get { return GetRepository<DealerRepository>(); }
        }
        public GenderRepository Genders
        {
            get { return GetRepository<GenderRepository>(); }
       

        public LabourRepository Labour
        {
            get { return GetRepository<LabourRepository>(); }
        }
        public LanguageRepository Languages
        {
            get { return GetRepository<LanguageRepository>(); }
        }
        public MiscellaneousRepository Miscellaneous
        {
            get { return GetRepository<MiscellaneousRepository>(); }
        }
        public ModelRepository Models
        {
            get { return GetRepository<ModelRepository>(); }
        }
        public PartRepository Parts
        {
            get { return GetRepository<PartRepository>(); }
        }
        public PartDiscountRepository PartDiscounts
        {
            get { return GetRepository<PartDiscountRepository>(); }
        }
        public PartPriceRepository PartPrices
        {
            get { return GetRepository<PartPriceRepository>(); }
        }
        public PartTypeRepository PartTypes
        {
            get { return GetRepository<PartTypeR
namespace BorgCivil.Repositories
    public interface IUnitOfWork
    {
        AppIdentityDbContext DbEntities { get; }
        AnonymousFieldRepository AnonymousFieldRepository { get; }
        AttachmentsRepository AttachmentsRepository { get; }
        BookingRepository BookingRepository { get; }
        BookingFleetsRepository BookingFleetsRepository { get; }
        BookingSiteGatesRepository BookingSiteGatesRepository { get; }
        BookingSiteSupervisorRepository BookingSiteSupervisorRepository { get; }
        CustomerRepository CustomerRepository { get; }
        CountryRepository CountryRepository { get; }
        DriversRepository DriversRepository { get; }
        DriverWhiteCardRepository DriverWhiteCardRepository { get; }
        DriverInductionCardRepository DriverInductionCardRepository { get; }
        DriverVocCardRepository DriverVocCardRepository { get; }
        DocketRepository DocketRepository { get; }
        DocumentRepository DocumentRepository { get; }
   

        EmployeeRepository EmployeeRepository { get; }
        EmploymentCategoryRepository EmploymentCategoryRepository { get; }
        EmailRepository EmailRepository { get; }
        FleetRepository FleetRepository { get; }
        FleetHistoryRepository FleetHistoryRepository { get; }
        FleetTypesRepository FleetTypesRepository { get; }
        FleetsRegistrationRepository FleetsRegistrationRepository { get; }
        GatesRepository GatesRepository { get; }
        GateContactPersonRepository GateContactPersonRepository { get; }
        LicenseClassRepository LicenseClassRepository { get; }
        LoadDocketRepository LoadDocketRepository { get; }
        SitesRepository SitesRepository { get; }
        SupervisorRepository SupervisorRepository { get; }
        StatusLookupRepository StatusLookupRepository { get; }
        SubcontractorRepository SubcontractorRepository { get; }
        StateRepository StateRepository { get; }
        WorkTypesRepository WorkTypesReposito
namespace VIPER.Migrations
    
    public partial class IdentityKey : DbMigration
    {
        public override void Up()
        {
            DropForeignKey("dbo.JobProcess", new[] { "ProcessTime_ProcessTimeID", "ProcessTime_ProcessID", "ProcessTime_RepairTypeID", "ProcessTime_SizeID" }, "dbo.ProcessTime");
            DropPrimaryKey("dbo.ProcessTime");
            AlterColumn("dbo.ProcessTime", "ProcessTimeID", c => c.Int(nullable: false, identity: true));
            AddPrimaryKey("dbo.ProcessTime", new[] { "ProcessTimeID", "ProcessID", "RepairTypeID", "SizeID" });
            AddForeignKey("dbo.JobProcess", new[] { "ProcessTime_ProcessTimeID", "ProcessTime_ProcessID", "ProcessTime_RepairTypeID", "ProcessTime_SizeID" }, "dbo.ProcessTime", new[] { "ProcessTimeID", "ProcessID", "RepairTypeID", "SizeID" });
        }
        
        public override void Down()
        {
            DropForeignKey("dbo.JobProcess", new[] { "ProcessTime_ProcessTimeID", "ProcessTime_ProcessID", "Proces
namespace Pelco.AgentHosting
    public class ProcessMonitor
    {
        private readonly Action _onProcessExit;
        private bool _fired;
        public ProcessMonitor(Action onProcessExit)
        {
            if (onProcessExit == null) throw new ArgumentNullException("onProcessExit");
            _onProcessExit = onProcessExit;
        }
        public void Start(int processId)
        {
            Start(Process.GetProcessById(processId));
        }
        public void Start(Process process)
        {
            if (process == null)
            {
                FireOnce();
                return;
            }
            process.Exited += (sender, args) => FireOnce();
            process.EnableRaisingEvents = true;
            if (process.HasExited) FireOnce();
        }
        private void FireOnce()
        {
            lock (this)
            {
                if (_fired) return;
                _fired = true;
            }
            _onProcessExit();
        }
    
namespace FreeQuant.Instruments
	public class InstrumentManager
	{
		private static Hashtable instrumentLists;
		public static InstrumentList Instruments { get; private set; }
		public static IInstrumentServer Server { get; set; }
		
        public static event InstrumentEventHandler InstrumentAdded;
		public static event InstrumentEventHandler InstrumentRemoved;
		static InstrumentManager()
		{
			InstrumentManager.Server = new InstrumentDbServer();
            Type connectionType = null;
			string connectionString = String.Empty;
			switch (Framework.Storage.ServerType)
			{
                case DbServerType.MYSQL:
                    connectionType = Type.GetType("MySqlConnection");
                    connectionString = string.Format("Server={0};Database={1};Uid={2};Pwd={3}", "localhost", "freequant", "freequant", "freequant");
                    break;
                case DbServerType.SQLITE:
                    connectionType = Type.GetType("SQLiteConnection");
                

                    break;
                default:
                    throw new NotSupportedException("This db is not support yet.");
			}
            InstrumentManager.Server = null;
            InstrumentManager.Server = new InstrumentFileServer();
			InstrumentManager.Server.Open(connectionType, connectionString);
            InstrumentManager.Instruments = InstrumentManager.Server.Load();
            InstrumentManager.instrumentLists = new Hashtable();
		}
		public static void Init()
		{
		}
		public static void Remove(Instrument instrument)
		{
			InstrumentManager.Server.Remove(instrument);
			InstrumentManager.Instruments.Remove(instrument);
			if (InstrumentManager.InstrumentRemoved == null)
				return;
			InstrumentManager.InstrumentRemoved(new InstrumentEventArgs(instrument));
		}
		public static void Remove(string symbol)
		{
			var instrument = InstrumentManager.Instruments[symbol];
			if (instrument == null)
				return;
			InstrumentManager.Remove(instrument);
		}
		pub
public class Score : MonoBehaviour
	public static Score scoreInstance;
	public GameObject prefabInst;
	public AudioClip[] clips;
	public bool[] inst0;
	public bool[] inst1;
	public bool[] inst2;
	public bool[] inst3;
	public static int instrumentCount;
	private GameObject[] instruments;
	private SequencerInstrument[] instrumentScripts;
	private int instrumentsCount;
	void Awake()
	{
		scoreInstance = this;
		instrumentsCount = clips.Length;
		instruments = new GameObject[instrumentsCount];
		instrumentScripts = new SequencerInstrument[instrumentsCount];
		for (int i = 0; i < instrumentsCount; i++)
		{
			instruments [i] = Instantiate (prefabInst);
			instruments [i].name = "" + i;
			instruments [i].transform.parent = this.transform;
			instrumentScripts [i] = instruments [i].GetComponent<SequencerInstrument> ();
			instrumentScripts [i].audioClip = clips [i];
			switch(i)
			{
			case 0: 
				instrumentScripts [i].score = inst0;
				break;
			case 1: 
				instrumentScripts [i].score =
namespace MRDC.Tests.MarketDataTests.FollowingErrorsShouldBeCaught {
    [TestFixture]
    public class ForInstrument {
        private MarketData marketData;
        [SetUp]
        public void Init() {
            var instrument = Builder<Instrument>.CreateNew()
                                                .With(x => x.InstrumentId = 1)
                                                .Build();
            marketData = Builder<MarketData>.CreateNew()
                                            .With(x => x.Instrument = instrument)
                                            .Build();
            marketData.SelfValidate()
                      .Result
                      .Should()
                      .BeTrue("Everything is ok according to types and rules");
        }
        [Test]
        public void InstrumentMissing() {
            marketData.Instrument = null;
            var validation = marketData.SelfValidate();
            validation.Result
                      .Should(

                      .BeFalse("Instrument was set to null");
            validation.ErrorMessage
                      .Should()
                      .Be("Instrument is null. ");
        }
        [Test]
        public void InstrumentIsEmpty() {
            marketData.Instrument = new Instrument();
            var validation = marketData.SelfValidate();
            validation.Result
                      .Should()
                      .BeFalse("Instrument is not initialized");
            validation.ErrorMessage
                      .Should()
                      .Be("Instrument is not initizlized, because InstrumentId should be positive number. Name for the instrument was not provided. ");
        }
        [Test]
        [TestCase("")]
        [TestCase("   ")]
        [TestCase("\t")]
        [TestCase("\r\n")]
        [TestCase(null)]
        public void NameIsMissed(string instrumentName) {
            marketData.Instrument.Name = instrumentName;
            var validation =
namespace MTB
    public class WorldGenerator
    {
        private World _world;
        private DataProcessorManager _manager;
        public DataProcessorManager DataProcessorManager { get { return _manager; } }
        public WorldGenerator(World world)
        {
            _world = world;
            _manager = new DataProcessorManager(_world);
        }
        public void StartWorldGenerator()
        {
            _manager.StartHandler();
        }
        public void Dispose()
        {
            _manager.StopHandler();
            WorldPersistanceManager.Instance.Dispose();
        }
        public bool HasSingleDataGenerateFinish()
        {
            return _manager.generatorWorker.hasSingleDataGenerated();
        }
        public void GenerateChunk(int x, int y, int z, WorldPos curInChunkPos)
        {
            WorldPos pos = new WorldPos(x, y, z);
            if (_world.chunks.ContainsKey(pos)) return;
            Chunk newChunk = _world.CreateNewChunk(pos);
    

            GenerateChunk(newChunk, curInChunkPos);
        }
        public void GenerateChunk(Chunk chunk, WorldPos curInChunkPos)
        {
            _world.chunks.Add(chunk.worldPos, chunk);
            _manager.generatorWorker.AddSingleGenerateChunk();
            _manager.EnqueueLoadChunk(chunk, curInChunkPos);
        }
        public void RefreshChunk(RefreshChunkArea chunk)
        {
            _manager.EnqueueRefreshChunk(chunk);
        }
        public void GenerateNetChunk(NetChunkData data, WorldPos curInChunkPos)
        {
            WorldPos pos = data.worldPos;
            Chunk newChunk = _world.GetChunk(pos.x, pos.y, pos.z);
            if (newChunk != null)
            {
                NetChunk netChunk = new NetChunk(data);
                netChunk.chunk = newChunk;
                netChunk.curPlayerInChunkPos = curInChunkPos;
                _manager.EnqueueNetChunk(netChunk);
            }
        }
        public void UpdatePopulationFromServer(NetChunkDat

        {
            WorldPos pos = data.worldPos;
            Chunk curChunk = _world.GetChunk(pos.x, pos.y, pos.z);
            if (curChunk != null)
            {
                NetChunk netChunk = new NetChunk(data);
                netChunk.chunk = curChunk;
                netChunk.curPlayerInChunkPos = curInChunkPos;
                _manager.EnqueueUpdatePopulation(netChunk);
            }
        }
        public void UpdateAreaFromServer(RefreshChunkArea area)
        {
            _manager.EnqueueNetUpdateArea(area);
        }
        public void GenerateFromServer(int x, int y, int z)
        {
            WorldPos pos = new WorldPos(x, y, z);
            if (_world.chunks.ContainsKey(pos)) return;
            Chunk newChunk = _world.CreateNewChunk(pos);
            if (newChunk == null) return;
            _world.chunks.Add(newChunk.worldPos, newChunk);
            RequestChunkPackage package = PackageFactory.GetPackage(PackageType.ResquestChunk) as RequestChunkPackage;

public class GraphPortChunkEncoder : GraphPortDelegate
    public delegate void ChunkPacked(BufferChunk chunk);
    public event ChunkPacked ChunkPackedEvent;
    IntPtr fDeviceContext;
    public GraphPortChunkEncoder()
    {
        fDeviceContext = IntPtr.Zero;
    }
    public IntPtr DeviceContext
    {
        get
        {
            return fDeviceContext;
        }
    }
    void PackCommand(BufferChunk aCommand)
    {
        if (ChunkPackedEvent != null)
            ChunkPackedEvent(aCommand);
    }
    void PackCommand(EMR aCommand)
    {
        BinaryFormatter fFormatter = new BinaryFormatter();
        MemoryStream fMemoryStream = new MemoryStream(2048);
        fMemoryStream.Seek(0, SeekOrigin.Begin);
        fFormatter.Serialize(fMemoryStream, aCommand);
        byte[] sendBytes = fMemoryStream.GetBuffer();
        BufferChunk chunk = new BufferChunk(sendBytes);
    }
    void Pack(BufferChunk aChunk, int x, int y)
    {
        aChunk += x;
        aChunk += y;
    }
 

    {
        aChunk += left;
        aChunk += top;
        aChunk += right;
        aChunk += bottom;
    }
    void Pack(BufferChunk chunk, Point[] points)
    {
        chunk += points.Length;
        for (int i = 0; i < points.Length; i++)
        {
            Pack(chunk, points[i].x, points[i].y);
        }
    }
    void Pack(BufferChunk chunk, Guid uniqueID)
    {
        chunk += uniqueID.ToByteArray();
    }
    void Pack(BufferChunk chunk, XFORM aTrans)
    {
    }
    void Pack(BufferChunk chunk, TRIVERTEX[] vertices)
    {
        int nVertices = vertices.Length;
        chunk += nVertices;
        for (int i = 0; i < nVertices; i++)
        {
            chunk += vertices[i].x;
            chunk += vertices[i].y;
            chunk += vertices[i].Alpha;
            chunk += vertices[i].Blue;
            chunk += vertices[i].Green;
            chunk += vertices[i].Red;
        }
    }
    void Pack(BufferChunk chunk, GRADIENT_RECT[] gRect)
    {
        int nRects = gRect

        chunk += nRects;
        for (int i = 0; i < nRects; i++)
        {
            chunk += gRect[i].UpperLeft;
            chunk += gRect[i].LowerRight;
        }
    }
    public override void SetTextColor(uint colorref)
    {
        BufferChunk chunk = new BufferChunk(128);
        chunk += GDI32.EMR_SETTEXTCOLOR;
        chunk += colorref;
        PackCommand(chunk);
    }
    public override void MoveTo(int x, int y)
    {
        BufferChunk chunk = new BufferChunk(128);
        chunk += GDI32.EMR_MOVETOEX;
        chunk += x;
        chunk += y;
        PackCommand(chunk);
    }
    public override void LineTo(int x, int y)
    {
        BufferChunk chunk = new BufferChunk(128);
        chunk += GDI32.EMR_LINETO;
        chunk += x;
        chunk += y;
        PackCommand(chunk);
    }
    public override void SaveState()
    {
        BufferChunk chunk = new BufferChunk(128);
        chunk += GDI32.EMR_SAVEDC;
        PackCommand(chunk);
    }
    public override void Re
namespace mtm.Articles.Repository
    public class IArticleRepository
    {
        private ArticleRepository _articleRepository;
        public ArticleRepository article
        {
            get
            {
                if (_articleRepository == null)
                    _articleRepository = new ArticleRepository();
                return _articleRepository;
            }
        }
        private CategoryRepository _categoryRepository;
        public CategoryRepository category
        {
            get
            {
                if (_categoryRepository == null)
                    _categoryRepository = new CategoryRepository();
                return _categoryRepository;
            }
        }
        private CommentRepository _commentRepository;
        public CommentRepository comment
        {
            get
            {
                if (_commentRepository == null)
                    _commentRepository = new CommentRepository();
                return _commentRepo
namespace SlackCleanup.SlackApiImplementation
    public class SlackApi : ISlackApi
    {
        public IChannelsApi Channels { get; set; }
        public IChatApi Chat { get; set; }
        public IFilesApi Files { get; set; }
        public IGroupsApi Groups { get; set; }
        public IImApi Im { get; set; }
        public IReactionsApi Reactions { get; set; }
        public ISearchApi Search { get; set; }
        public ITeamApi Team { get; set; }
        public IUsersApi Users { get; set; }
        public IRtmApi Rtm { get; set; }
        public IApiApi Api { get; set; }
        public IAuthApi Auth { get; set; }
        public IEmojiApi Emoji { get; set; }
        public IStarsApi Stars { get; set; }
        public IOauthApi Oauth { get; set; }
        private SlackApi() { }
        public static ISlackApi Create(string apiKey)
        {
            return Create(new RestSharpRequestHandler(apiKey));
        }
        private static ISlackApi Create(IRequestHandler requestHandl

        {
            if (requestHandler == null)
                throw new ArgumentNullException("requestHandler");
            var slackApi = new SlackApi()
            {
                Api = new ApiApi(requestHandler),
                Auth = new AuthApi(requestHandler),
                Channels = new ChannelsApi(requestHandler),
                Chat = new ChatApi(requestHandler),
                Emoji = new EmojiApi(requestHandler),
                Files = new FilesApi(requestHandler),
                Groups = new GroupsApi(requestHandler),
                Im = new ImApi(requestHandler),
                Oauth = new OauthApi(requestHandler),
                Reactions = new ReactionsApi(requestHandler),
                Rtm = new RtmApi(requestHandler),
                Search = new SearchApi(requestHandler),
                Stars = new StarsApi(requestHandler),
                Team = new TeamApi(requestHandler),
                Users = new UsersApi(requestHandler)
            };
    
namespace BioInfo.App.Library.Common.Helpers
    public static class InvocationHelper
    {
        public static T ExecuteWithExceptionHandling<T>(this Func<T> codeToInvoke, string exceptionString = "", Func<T> codeToInvokeOnFail = null)
        {
            try
            {
                return codeToInvoke.Invoke();
            }
            catch (Exception e)
            {
                if (codeToInvokeOnFail != null)
                {
                    return codeToInvokeOnFail.Invoke();
                }
                throw;
            }
        }
        public static void ExecuteWithExceptionHandling(this Action codeToInvoke, string exceptionString = "", Action codeToInvokeOnFail = null)
        {
            try
            {
                codeToInvoke.Invoke();
            }
            catch (Exception e)
            {
                if (codeToInvokeOnFail != null)
                {
                    codeToInvokeOnFail.Invoke();
                }
           

            }
        }
        public static void WithClient<T>(this T proxy, Action<T> codeToExecute)
        {
            codeToExecute.Invoke(proxy);
            var disposableClient = proxy as IDisposable;
            if (disposableClient != null)
            {
                disposableClient.Dispose();
            }
        }
        public static void ExecuteWithIgnoreException(this Action codeToInvoke, Action codeToInvokeOnFail = null)
        {
            try
            {
                codeToInvoke.Invoke();
            }
            catch (Exception e)
            {
                if (codeToInvokeOnFail != null)
                {
                    codeToInvokeOnFail.Invoke();
                }
            }
        }
        public static T ExecuteWithIgnoreException<T>(this Func<T> codeToInvoke, Func<T> codeToInvokeOnFail = null)
        {
            try
            {
                return codeToInvoke.Invoke();
            }
            catch (Exception e)
     
namespace Whisper.ChunkGenerator
	public partial class StreamChunk
	{
		public StreamChunk ()
		{
			Chunks = new List<byte[]> ();
		}
		public static ChunkHash GenerateChunk (string path, Repo repo)
		{
			StreamChunk message = new StreamChunk ();
				BinaryReader br = new BinaryReader (stream);
				message.Size = (ulong)stream.Length;
				while (true) {
					byte[] data = br.ReadBytes (4096);
					if (data.Length == 0)
						break;
					Chunk c = new Chunk (data);
					ChunkHash ch = repo.WriteChunk (c);
					message.Chunks.Add (ch.bytes);
				}
			}
			byte[] messageBytes = StreamChunk.SerializeToBytes (message);
			Chunk messageChunk = new Chunk (messageBytes);
			ChunkHash messageHash = repo.WriteChunk (messageChunk);
			return messageHash;
		}
		public static void Extract (Repo store, ChunkHash fileHash, string targetPath)
		{
			Chunk chunk = store.ReadChunk (fileHash);
			StreamChunk streamChunk = StreamChunk.Deserialize<StreamChunk> (chunk.Data);
				foreach (byte[] hashBytes 
namespace BeatsByDre
    class InstrumentCan
    {
        private InstrumentType _instrument;
        public InstrumentType Instrument
        {
            get { return _instrument; }
            set
            {
                _instrument = value;
                SetModelFromInstrument(_instrument);
            }
        }
        public InstrumentCan()
        {
            Clear();
        }
        public void Preview()
        {
            if (HasInstrument())
            {
                DrumMachine.GetInstance().Play(Instrument, 500, 100);
            }
        }
        public bool HasInstrument()
        {
            return !Instrument.Equals(InstrumentType.None);
        }
        public void Clear()
        {
            Instrument = InstrumentType.None;
        }
        private void SetModelFromInstrument(InstrumentType instrument)
        {
            switch (instrument)
            {
                case InstrumentType.None:
                    break;
           
namespace LiteDispatch.Web.BusinessAdapters
  public class TrackingAdapter : BaseAdapter
  {
    public TrackingResponseDto CreateTrackingNotification(TrackingNotificationDto dto)
    {
      return ExecuteCommand(locator => CreateTrackingNotificationImpl(locator, dto));
    }
    private TrackingResponseDto CreateTrackingNotificationImpl(IRepositoryLocator locator, TrackingNotificationDto dto)
    {
      var response = new TrackingResponseDto
        {
          Accepted = false,
          NotificationId = dto.Id,
          DispatchNoteId = 0,
          Error = string.Empty
        };
      var dispatchNote =
        locator.FindAll<DispatchNote>()
               .FirstOrDefault(d => d.TruckReg.Equals(dto.TruckRegistration, StringComparison.InvariantCultureIgnoreCase));
      if (dispatchNote == null)
      {
        response.Error = "DispatchNote was not found with Truck Registration: " + dto.TruckRegistration;
        return response;
      }
      
      response.DispatchNoteId = 

      response = dispatchNote.CreateTrackingNotification(locator, dto, response);
      if (response.Accepted)
      {
        var dispatchEvent = Mapper.Map<DispatchEventBase>(dispatchNote);
        CreateDispatchEvent(dispatchEvent);
      }
      return response;
    }
    public List<DispatchNoteDto> GetActiveDispatchNotes()
    {
      return ExecuteCommand(GetActiveDispatchNotesImpl);
    }
    private List<DispatchNoteDto> GetActiveDispatchNotesImpl(IRepositoryLocator locator)
    {
      var results = locator.FindAll<DispatchNote>()
                    .Where(
                      d =>
                      d.DispatchNoteStatus.Equals(DispatchNote.New) ||
                      d.DispatchNoteStatus.Equals(DispatchNote.InTransit)).ToList();
      return Mapper.Map<List<DispatchNoteDto>>(results);
    }
    private void CreateDispatchEvent(DispatchEventBase dispatchEvent)
    {
      {
        client.Headers[HttpRequestHeader.ContentType] = "application/json";
        client.Hea
public class World : MonoBehaviour {
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public GameObject chunkPrefab;
    public string worldName = "world";
    /*public int newChunkX;
    public int newChunkY;
    public int newChunkZ;
    public bool genChunk;
    void Start()
    {
        int sizeX = 8;
        int sizeZ = 8;
        for (int x = -sizeX; x < sizeX; x++)
        {
            for (int y = -1; y < 3; y++)
            {
                for (int z = -sizeZ; z < sizeZ; z++)
                {
                    CreateChunk(x * 16, y * 16, z * 16);
                }
            }
        }
    }
    void Update()
    {
        if (genChunk)
        {
            genChunk = false;
            WorldPos chunkPos = new WorldPos(newChunkX, newChunkY, newChunkZ);
            Chunk chunk = null;
            if (chunks.TryGetValue(chunkPos, out chunk))
            {
                DestroyChunk(chunkPos.x, chunkPos.y, chunkPos.z);
           

            else
            {
                CreateChunk(chunkPos.x, chunkPos.y, chunkPos.z);
            }
        }
    }*/
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / multiple) * Chunk.chunkSize;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Block GetBlock(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null)
        {
            Block block = containerChunk.GetBlock(
                x - containerChunk.pos.x,
                y - containerChunk.pos.y,
                z - containerChunk.pos.z);
            return block;
        }
        else
        {
            return new Blo

        }
    }
    public void SetBlock(int x, int y, int z, Block block)
    {
        Chunk chunk = GetChunk(x, y, z);
        if (chunk != null)
        {
            chunk.SetBlock(x - chunk.pos.x, y - chunk.pos.y, z - chunk.pos.z, block);
            UpdateIfEqual(x - chunk.pos.x, 0, new WorldPos(x - 1, y, z));
            UpdateIfEqual(x - chunk.pos.x, Chunk.chunkSize - 1, new WorldPos(x + 1, y, z));
            UpdateIfEqual(y - chunk.pos.y, 0, new WorldPos(x, y - 1, z));
            UpdateIfEqual(y - chunk.pos.y, Chunk.chunkSize - 1, new WorldPos(x, y + 1, z));
            UpdateIfEqual(z - chunk.pos.z, 0, new WorldPos(x, y, z - 1));
            UpdateIfEqual(z - chunk.pos.z, Chunk.chunkSize - 1, new WorldPos(x, y, z + 1));
            chunk.UpdateChunk();
        }
    }
    public void DestroyChunk(int x, int y, int z)
    {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
        {
            Serialization.SaveChunk(chunk);
   
﻿#region Copyright
#endregion
namespace Welt.Core.Forge
    public class World : IWorld
    {
        public string Name { get; }
        public long Seed { get; }
        public int Size { get; }
        public int Height { get; }
        public IForgeGenerator Generator { get; }
        public IWorldSystem System { get; }
        public int SystemIndex { get; }
        protected readonly ChunkManager Manager;
        protected int MaxX => Size*Chunk.Width;
        protected int MaxZ => Size*Chunk.Depth;
        public World(string name, IForgeGenerator gen)
        {
            Name = name;
            var random = new FastMath.LongRandom();
            Seed = random.Next(int.MaxValue)*name.GetHashCode();
            Size = 32;
            Height = 256;
            Generator = gen;
            Manager = new ChunkManager(this);
            System = null;
            SystemIndex = 0;
        }
        public World(string name, long seed, IForgeGenerator gen)
        {
            Name

            Seed = seed;
            Size = 32;
            Generator = gen;
            Manager = new ChunkManager(this);
            System = null;
            SystemIndex = 0;
        }
        public Chunk CreateChunk(uint x, uint z)
        {
            var chunk = new Chunk(this, x, z);
            Generator.GenerateChunk(this, chunk);
            _SetChunk(x, z, chunk, ChunkChangedEventArgs.ChunkChangedAction.Created);
            return chunk;
        }
        public Chunk CreateChunkInMemory(uint x, uint z)
        {
            var chunk = new Chunk(this, x, z);
            Generator.GenerateChunk(this, chunk);
            ChunkChanged?.Invoke(this, new ChunkChangedEventArgs(x, z, ChunkChangedEventArgs.ChunkChangedAction.Created));
            return chunk;
        }
        public Chunk CreateChunkWithoutGeneration(uint x, uint z)
        {
            var chunk = new Chunk(this, x, z);
            _SetChunk(x, z, chunk, ChunkChangedEventArgs.ChunkChangedAction.Created);


        }
        public Chunk CreateChunkInMemoryWithoutGeneration(uint x, uint z)
        {
            var chunk = new Chunk(this, x, z);
            return chunk;
        }
        public virtual IChunk GetChunk(uint x, uint z)
        {
            var chunk = Manager.GetChunk(x, z) ?? CreateChunk(x, z);
            return chunk;
        }
        public virtual void SetChunk(uint x, uint z, IChunk value)
        {
            _SetChunk(x, z, value, ChunkChangedEventArgs.ChunkChangedAction.Adjusted);
        }
        private void _SetChunk(uint x, uint z, IChunk value, ChunkChangedEventArgs.ChunkChangedAction action)
        {
            Manager.SetChunk(x, z, (Chunk) value);
            ChunkChanged?.Invoke(this, new ChunkChangedEventArgs(x, z, action));
        }
        public virtual void RemoveChunk(uint x, uint z)
        {
            Manager.RemoveChunk(x, z);
            ChunkChanged?.Invoke(this, new ChunkChangedEventArgs(x, z, ChunkChangedEventArgs.ChunkChangedAction
namespace Dalworth.Server.MainForm.DispatchConfirm
    public enum DispatchConfirmResultEnum
    {
        Yes,
        NoContinueDispatch,
        NoCancelDispatch
    }
    public class DispatchConfirmController : Controller<DispatchConfirmModel, DispatchConfirmView>
    {
        #region DispatchConfirmResult
        private DispatchConfirmResultEnum m_dispatchConfirmResult;
        public DispatchConfirmResultEnum DispatchConfirmResult
        {
            get { return m_dispatchConfirmResult; }
        }
        #endregion
        #region OnModelInitialize
        protected override void OnModelInitialize(object[] data)
        {
            Model.Visit = (Visit)data[0];
            Model.DispatchTime = (DateTime)data[1];
            base.OnModelInitialize(data);
        }
        #endregion
        #region OnInitialize
        protected override void OnInitialize()
        {
            View.m_btnYes.Click += OnYesClick;
            View.m_btnNoContinueDispatch.Click += OnNoCont

            View.m_btnNoCancelDispatch.Click += OnNoCancelDispatchClick;
            
        }
        #endregion
        #region OnViewLoad
        protected override void OnViewLoad()
        {
            View.m_lblReasons.Text = Model.GetConfirmationReasons();
        }
        #endregion
        #region OnYesClick
        private void OnYesClick(object sender, EventArgs e)
        {
            m_dispatchConfirmResult = DispatchConfirmResultEnum.Yes;
            View.Destroy();
        }
        #endregion
        #region OnNoContinueDispatchClick
        private void OnNoContinueDispatchClick(object sender, EventArgs e)
        {
            m_dispatchConfirmResult = DispatchConfirmResultEnum.NoContinueDispatch;
            View.Destroy();
        }
        #endregion
        #region OnNoCancelDispatchClick
        private void OnNoCancelDispatchClick(object sender, EventArgs e)
        {
            m_dispatchConfirmResult = DispatchConfirmResultEnum.NoCancelDispatch;
        
namespace MCFire.Common.Coordinates
    public struct ChunkPositionDimension : IEquatable<ChunkPositionDimension>
    {
        readonly int _dimension;
        readonly int _chunkX;
        readonly int _chunkZ;
        public ChunkPositionDimension(int chunkX, int chunkZ, int dimension)
        {
            _dimension = dimension;
            _chunkX = chunkX;
            _chunkZ = chunkZ;
        }
        public ChunkPositionDimension(ChunkPosition position, int dimension)
        {
            _dimension = dimension;
            _chunkX = position.ChunkX;
            _chunkZ = position.ChunkZ;
        }
        public static implicit operator ChunkPosition(ChunkPositionDimension value)
        {
            return new ChunkPosition(value.ChunkX, value.ChunkZ);
        }
        public static bool operator ==(ChunkPositionDimension left, ChunkPositionDimension right)
        {
            return left.ChunkX == right.ChunkX && left.ChunkZ == right.ChunkZ && left.Dimension == right.

        }
        public static bool operator !=(ChunkPositionDimension left, ChunkPositionDimension right)
        {
            return left.ChunkX != right.ChunkX || left.ChunkZ != right.ChunkZ || left.Dimension != right.Dimension;
        }
        public bool Equals(ChunkPositionDimension other)
        {
            return _chunkX == other._chunkX && _chunkZ == other._chunkZ && _dimension == other._dimension;
        }
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            return obj is ChunkPositionDimension && Equals((ChunkPositionDimension)obj);
        }
        public override int GetHashCode()
        {
            unchecked
            {
                int hashCode = _dimension;
                hashCode = (hashCode * 397) ^ _chunkX;
                hashCode = (hashCode * 397) ^ _chunkZ;
                return hashCode;
            }
        }
        public override string ToString()
        {
      
namespace Frankfort.Threading.Internal
    public class ThreadDispatchAction
    {
        public bool executed = false;
        public object dispatchExecutionResult = null;
        private ThreadDispatchDelegate          dispatchCallClean;
        private ThreadDispatchDelegateArg       dispatchCallArg;
        private ThreadDispatchDelegateArgReturn dispatchCallArgReturn;
        private ThreadDispatchDelegateReturn    dispatchCallReturn;
        
        private object dispatchArgParam;
        private bool safeMode;
        
        public ThreadDispatchAction()
        {
        }
        #region 4 DIFFERENT OVERLOADS
        public void Init(ThreadDispatchDelegate dispatchCall, bool waitForExecution, bool safeMode)
        {
            this.safeMode = safeMode;
            this.dispatchCallClean = dispatchCall;
            ValidateExecutionOnInit(waitForExecution);
        }
        public void Init(ThreadDispatchDelegateArg dispatchCall, object dispatchArgumentParameter, bool 

        {
            this.safeMode = safeMode;
            this.dispatchCallArg = dispatchCall;
            this.dispatchArgParam = dispatchArgumentParameter;
            ValidateExecutionOnInit(waitForExecution);
        }
        public void Init(ThreadDispatchDelegateArgReturn dispatchCall, object dispatchArgumentParameter, bool safeMode)
        {
            this.safeMode = safeMode;
            this.dispatchCallArgReturn = dispatchCall;
            this.dispatchArgParam = dispatchArgumentParameter;
        }
        public void Init(ThreadDispatchDelegateReturn dispatchCall, bool safeMode)
        {
            this.safeMode = safeMode;
            this.dispatchCallReturn = dispatchCall;
        } 
        #endregion
			
        private void ValidateExecutionOnInit(bool waitForExecution)
        {
            if (waitForExecution)
            {
                if (!MainThreadWatchdog.CheckIfMainThread())
                {
                    while (!executed)
                  

                }
                else
                {
                    ExecuteDispatch();
                }
            }
        }
        public void ExecuteDispatch()
        {
            if (safeMode)
            {
                try
                {
                    if (dispatchCallClean != null)
                    {
                        dispatchCallClean();
                    }
                    else if (dispatchCallArg != null)
                    {
                        dispatchCallArg(dispatchArgParam);
                    }
                    else if (dispatchCallArgReturn != null)
                    {
                        dispatchExecutionResult = dispatchCallArgReturn(dispatchArgParam);
                    }
                    else if (dispatchCallReturn != null)
                    {
                        dispatchExecutionResult = dispatchCallReturn();
                    }
                }
                catch (Exception e)
                
namespace Tauron.Application.RadioStreamer.Contracts.Data
    [Serializable]
    public sealed class ImportExportSettings
    {
        public bool ProcessRadios { get; private set; }
        public bool ProcessSettings { get; private set; }
        public bool ProcessPlugIns { get; private set; }
        public bool ProcessScripts { get; private set; }
        public ImportExportSettings(bool processRadios, bool processSettings, bool processPlugIns, bool processScripts)
        {
            ProcessRadios = processRadios;
            ProcessSettings = processSettings;
            ProcessPlugIns = processPlugIns;
            ProcessScripts = processScripts;
        }
        [NotNull]
        public ImportExportSettings Merge([NotNull] ImportExportSettings settings)
        {
            ProcessPlugIns = ProcessPlugIns && settings.ProcessPlugIns;
            ProcessRadios = ProcessRadios && settings.ProcessRadios;
            ProcessScripts = ProcessScripts && settings.ProcessScripts;

namespace ViveController
    public class ControllerObject
    {
        private GameObject _controller;
        private HapticController _hapticController;
        private GrabController _grabController;
        public GameObject controller
        {
            get { return _controller; }
            set
            {
                _controller = value;
                _hapticController = _controller.GetComponent<HapticController>();
                _grabController = _controller.GetComponent<GrabController>();
            }
        }
        public HapticController hapticController
        {
            get { return _hapticController; }
        }
        public GrabController grabController
        {       
            get { return _grabController; }
        }
        public SteamVR_Controller.Device device
        {
            get 
            {
                SteamVR_TrackedObject sto = _controller.GetComponent<SteamVR_TrackedObject>();
                return SteamVR_Controller.
namespace CarcassonneCraft
    public class Area
    {
        public int areaid { get; private set; }
        public string areaname { get; private set; }
        public int userid { get; private set; }
        public string username { get; private set; }
        public int rating { get; private set; }
        public bool rated { get; private set; }
        public List<UserInfo> editusers { get; private set; }
        Chunk[,] chunks = new Chunk[Env.XChunkN, Env.ZChunkN];
        public Area(AreaInfo info)
        {
            areaid = info.areaid;
            areaname = info.areaname;
            userid = info.userid;
            username = info.username;
            rating = info.rating;
            rated = info.rated;
            editusers = info.editusers;
            /*for (int x = 0; x < Env.XChunkN; x++)
            {
                for (int z = 0; z < Env.ZChunkN; z++)
                {
                    chunks[x, z] = new Chunk();
                }
            }*/
       

        public void UpdateAreaInfo(AreaInfo info)
        {
            areaid = info.areaid;
            areaname = info.areaname;
            userid = info.userid;
            username = info.username;
            rating = info.rating;
            rated = info.rated;
            editusers = info.editusers;
        }
        public bool IsChunkLoaded(XZNum loadChunkPos)
        {
            XZNum loadChunkNum = Env.GetChunkNum(loadChunkPos);
            return chunks[loadChunkNum.xnum, loadChunkNum.znum] != null;
        }
        public void LoadDefaultChunk(XZNum loadChunkPos)
        {
            XZNum loadChunkNum = Env.GetChunkNum(loadChunkPos);
            chunks[loadChunkNum.xnum, loadChunkNum.znum] = new Chunk();
        }
        public void LoadChunk(Chunk chunk)
        {
            if(chunks[chunk.xchunknum, chunk.zchunknum] == null)
            {
                chunks[chunk.xchunknum, chunk.zchunknum] = new Chunk();
                chunks[chunk.xchunknum, chunk.zchun

            }
            else
            {
                chunks[chunk.xchunknum, chunk.zchunknum].diffs.Clear();
                chunks[chunk.xchunknum, chunk.zchunknum].diffs.AddRange(chunk.diffs);
            }            
        }
        public bool IsPrefabLoaded(XZNum loadChunkPos)
        {
            XZNum loadChunkNum = Env.GetChunkNum(loadChunkPos);
            return chunks[loadChunkNum.xnum, loadChunkNum.znum].IsPrefabLoaded();
        }
        public void LoadPrefab(XZNum loadChunkPos)
        {
            XZNum loadChunkNum = Env.GetChunkNum(loadChunkPos);
            chunks[loadChunkNum.xnum, loadChunkNum.znum].CreatePrefab(loadChunkPos);
        }
        public void UnLoadPrefab(XZNum unloadChunkPos)
        {
            XZNum loadChunkNum = Env.GetChunkNum(unloadChunkPos);
            if (chunks[loadChunkNum.xnum, loadChunkNum.znum] != null)
            {
                chunks[loadChunkNum.xnum, loadChunkNum.znum].DestroyPrefab(/*unloadChunkPos*/);
        
public struct ChunkCoord
	public int coordX;
	public int coordY;
public class ChunkLoader : MonoBehaviour {
	public const int viewDistance = 800;
	public int visibleChunks;
	public Transform player;
	public MapGenerator generator;
	public Material materail;
	protected Vector2 playerPos;
	protected IHeightmapGenerator mapGenerator;
	Dictionary<ChunkCoord, Chunk> chunks = new Dictionary<ChunkCoord, Chunk>();
	protected float h_sqrt_3 = Mathf.Sqrt(3.0f) * 0.5f;
	void Start () {
		mapGenerator = generator.createGenerator();
		visibleChunks = viewDistance / Chunk.size + 1; /* sometimes when the player is near an edge an extra chunk is loaded */
	}
	void Update () {
		playerPos = new Vector2(player.position.x, player.position.z);
		List<ChunkCoord> removeKeys = new List<ChunkCoord>();
		foreach (KeyValuePair<ChunkCoord, Chunk> chunk in chunks)
		{
			Vector2 center = chunk.Value.getCenter();
			if (distanceChunkToPlayer(center) > viewDistance)
			{
				chunk.Value.visible(0, false, false, fa

				removeKeys.Add(chunk.Key);
				Destroy(chunk.Value.getObject());
			}
		}
		foreach(ChunkCoord key in removeKeys)
		{
			chunks.Remove(key);
		}
		ChunkCoord playerChunk = getChunkCoord(playerPos);
		float f_centerX = ((float)playerChunk.coordX) * Chunk.size;
		float f_centerY = ((float)playerChunk.coordY) * Chunk.size * h_sqrt_3;
		for (int x = -visibleChunks; x <= visibleChunks; x++)
		{
			for (int y = -visibleChunks; y <= visibleChunks; y++)
			{
				
				Vector2 chunkCenter = new Vector2(f_centerX + (x * Chunk.size - 0), f_centerY + y * Chunk.size * h_sqrt_3);
				
				loadChunk(chunkCenter);
			}
		}
	}
	/**
	 * Render the chunk at the position chunkCenter.
	 */
	protected void loadChunk(Vector2 chunkCenter)
	{
		Chunk chunk;
		int details = getDetails(chunkCenter);
		ChunkCoord chunkCoord = getChunkCoord(chunkCenter);
		
		if (details == 0)
		{
			return;
		}
		if (!chunks.TryGetValue(chunkCoord, out chunk))
		{
			chunk = new Chunk(chunkCenter, mapGenerator, materail);
			

		}
		bool lowResTop = getDetails(new Vector2(chunkCenter.x, chunkCenter.y + Chunk.size * h_sqrt_3)) > details;
		bool lowResBottom = getDetails(new Vector2(chunkCenter.x, chunkCenter.y - Chunk.size * h_sqrt_3)) > details;
		bool lowResLeft = getDetails(new Vector2(chunkCenter.x - Chunk.size, chunkCenter.y)) > details;
		bool lowResRight = getDetails(new Vector2(chunkCenter.x + Chunk.size, chunkCenter.y)) > details;
		chunk.visible(details, lowResTop, lowResRight, lowResBottom, lowResLeft);
	}
	/**
	 * Get the distance from this chunk to the player.
	 */
	protected float distanceChunkToPlayer(Vector2 chunkCenter)
	{
		float diffX = 0.5f * Chunk.size;
		float closestX = (chunkCenter.x + diffX < playerPos.x) ? chunkCenter.x + diffX :
			(chunkCenter.x - diffX > playerPos.x) ? chunkCenter.x - diffX : playerPos.x;
		float diffY = 0.5f * Chunk.size * h_sqrt_3;
		float closestY = (chunkCenter.y + diffY < playerPos.y) ? chunkCenter.y + diffY :
			(chunkCenter.y - diffY > playerPos.y) ? chunk
namespace InvokeCount
    public class ManagerInvoke
    {
        private bool firstSet;
        private int countInvokeMethod;
        private int countInvokeMethodInInterval;
        private long symInvokeMethodInInterval;
        private StatisticStructure statisticStructure;
        private Task taskInternal;
        private Task taskExternal;
        private CancellationTokenSource cancelTokenSource;
        private CancellationToken cancellationToken;
        public ManagerInvoke(TimeSpan timeInvoke, TimeSpan interval)
        {
            TimeInvoke = timeInvoke;
            Interval = interval;
            statisticStructure = new StatisticStructure();
            firstSet = true;
        }
        public void Invoke()
        {
            Interlocked.Increment(ref countInvokeMethod);
        }
        public void Start()
        {
            countInvokeMethod = 0;
            cancelTokenSource = new CancellationTokenSource();
            cancellationToken = cancelTokenSour

            taskInternal = Task.Factory.StartNew(TimeInvokeDispatcher);
            taskExternal = Task.Factory.StartNew(IntervalDispatcher);
        }
        public void Stop()
        {
            cancelTokenSource.Cancel();
            firstSet = false;
            countInvokeMethod = 0;
            countInvokeMethodInInterval = 0;
            symInvokeMethodInInterval = 0;
        }
        private async void TimeInvokeDispatcher()
        {
            try { await Task.Delay(TimeInvoke, cancellationToken); }
            catch (TaskCanceledException e) { return; }
            ProccessInvoke();
            TimeInvokeDispatcher();
        }
        private async void IntervalDispatcher()
        {
            try { await Task.Delay(Interval, cancellationToken); }
            catch (TaskCanceledException e) { return; }
            InvokeCountedValue();
            IntervalDispatcher();
        }
        private void ProccessInvoke()
        {
            lock (statisticStructure)
 

                StatisticProcces(countInvokeMethod);
                OnCountInvoke(countInvokeMethod);
                countInvokeMethod = 0;
            }
        }
        private void InvokeCountedValue()
        {
            lock (statisticStructure)
            {
                ProccesMiddleValue();
                OnStatistic(statisticStructure);
                statisticStructure.MiddleCountInvoke = 0;
                statisticStructure.MinCountInvoke = 0;
                statisticStructure.MaxCountInvoke = 0;
                symInvokeMethodInInterval = 0;
                countInvokeMethodInInterval = 0;
            }
            firstSet = true;
        }
        private void ProccesMiddleValue()
        {
            if (countInvokeMethodInInterval != 0)
                statisticStructure.MiddleCountInvoke = ((double)symInvokeMethodInInterval /
                                                        countInvokeMethodInInterval);
        }
        private void StatisticProcc
namespace LimsProject.BusinessLayer
	public class CRecep_sample_dispatch: BusinessObjectBase
	{
		#region InnerClass
		public enum CRecep_sample_dispatchFields
		{
			Idrecep_sample,
			Dispatch_person,
			Dispatch_mail,
			Dispatch_curier,
			Dispatch_transport,
			Dispatch_fax,
			Dispatch_otro,
			Usernew,
			Datenew,
			Useredit,
			Dateedit,
			Status
		}
		#endregion
		#region Data Members
			long _idrecep_sample;
			short? _dispatch_person;
			short? _dispatch_mail;
			short? _dispatch_curier;
			short? _dispatch_transport;
			short? _dispatch_fax;
			short? _dispatch_otro;
			string _usernew;
			DateTime? _datenew;
			string _useredit;
			DateTime? _dateedit;
			bool? _status;
		#endregion
		#region Properties
		public long  Idrecep_sample
		{
			 get { return _idrecep_sample; }
			 set
			 {
				 if (_idrecep_sample != value)
				 {
					_idrecep_sample = value;
					 PropertyHasChanged("Idrecep_sample");
				 }
			 }
		}
		public short?  Dispatch_person
		{
			 get { return _

			 set
			 {
				 if (_dispatch_person != value)
				 {
					_dispatch_person = value;
					 PropertyHasChanged("Dispatch_person");
				 }
			 }
		}
		public short?  Dispatch_mail
		{
			 get { return _dispatch_mail; }
			 set
			 {
				 if (_dispatch_mail != value)
				 {
					_dispatch_mail = value;
					 PropertyHasChanged("Dispatch_mail");
				 }
			 }
		}
		public short?  Dispatch_curier
		{
			 get { return _dispatch_curier; }
			 set
			 {
				 if (_dispatch_curier != value)
				 {
					_dispatch_curier = value;
					 PropertyHasChanged("Dispatch_curier");
				 }
			 }
		}
		public short?  Dispatch_transport
		{
			 get { return _dispatch_transport; }
			 set
			 {
				 if (_dispatch_transport != value)
				 {
					_dispatch_transport = value;
					 PropertyHasChanged("Dispatch_transport");
				 }
			 }
		}
		public short?  Dispatch_fax
		{
			 get { return _dispatch_fax; }
			 set
			 {
				 if (_dispatch_fax != value)
				 {
					_dispatch_fax = value;
					 PropertyHasChang

				 }
			 }
		}
		public short?  Dispatch_otro
		{
			 get { return _dispatch_otro; }
			 set
			 {
				 if (_dispatch_otro != value)
				 {
					_dispatch_otro = value;
					 PropertyHasChanged("Dispatch_otro");
				 }
			 }
		}
		public string  Usernew
		{
			 get { return _usernew; }
			 set
			 {
				 if (_usernew != value)
				 {
					_usernew = value;
					 PropertyHasChanged("Usernew");
				 }
			 }
		}
		public DateTime?  Datenew
		{
			 get { return _datenew; }
			 set
			 {
				 if (_datenew != value)
				 {
					_datenew = value;
					 PropertyHasChanged("Datenew");
				 }
			 }
		}
		public string  Useredit
		{
			 get { return _useredit; }
			 set
			 {
				 if (_useredit != value)
				 {
					_useredit = value;
					 PropertyHasChanged("Useredit");
				 }
			 }
		}
		public DateTime?  Dateedit
		{
			 get { return _dateedit; }
			 set
			 {
				 if (_dateedit != value)
				 {
					_dateedit = value;
					 PropertyHasChanged("Dateedit");
				 }
			 }
		}
		public bool?  
namespace SystemController.InstrumentBLL
    internal delegate void DayCloseQuotationReceivedHandle(Guid instrumentId, DateTime tradeDay);
    internal sealed class InstrumentManager
    {
        private static readonly ILog Logger = LogManager.GetLogger(typeof(InstrumentManager));
        internal static readonly InstrumentManager Default = new InstrumentManager();
        private Dictionary<Guid, Instrument> _instrumentDict = new Dictionary<Guid, Instrument>();
        private object _mutex = new object();
        static InstrumentManager() { }
        private InstrumentManager() { }
        internal int Count
        {
            get
            {
                lock (_mutex)
                {
                    return _instrumentDict.Count;
                }
            }
        }
        internal DateTime? GetInstrumentTradeDay(Guid instrumentId)
        {
            lock (_mutex)
            {
                try
                {
                    return _instrumentDict[

                }
                catch (System.Collections.Generic.KeyNotFoundException ex)
                {
                    Logger.ErrorFormat("instrumentId = {0}, error = {1}", instrumentId, ex);
                    throw;
                }
            }
        }
        internal void DayCloseQuotationReceivedEventHandle(Guid instrumentId, DateTime tradeDay)
        {
            lock (_mutex)
            {
                Instrument instrument;
                if (!_instrumentDict.TryGetValue(instrumentId, out instrument))
                {
                    Logger.InfoFormat("DayCloseQuotationReceived instrument not exists. instrumentId = {0}, tradeDay = {1}", instrumentId, tradeDay);
                    return;
                }
                Logger.InfoFormat("DayCloseQuotationReceivedEventHandle instrumentId = {0}, instrument.TradeDay = {1}, tradeDay = {2}", instrumentId, instrument.TradeDay, tradeDay);
                instrument.DayCloseQuotationReceived = true;
   

        }
        internal bool IsAllInstrumentsReceivedDayCloseQuotation(DateTime tradeDay)
        {
            lock (_mutex)
            {
                foreach (var eachInstrument in _instrumentDict.Values)
                {
                    if (!IsInstrumentReceivedDayCloseQuotation(eachInstrument, tradeDay))
                    {
                        Logger.InfoFormat("IsInstrumentReceivedDayCloseQuotation instrumentId = {0}, instrument.TradeDay = {1}, instrument.ReceivedDayCloseQuotation = {2}, tradeDay = {3}", eachInstrument.Id,
                            eachInstrument.TradeDay, eachInstrument.DayCloseQuotationReceived, tradeDay);
                        return false;
                    }
                }
                return true;
            }
        }
        private bool IsInstrumentReceivedDayCloseQuotation(Instrument instrument, DateTime tradeDay)
        {
            return (instrument.TradeDay == tradeDay.AddDays(1) && instrument.DayCloseQuotationRecei
namespace NewTake.view
   
    class SolidBoundsChunkRenderer : ChunkRenderer
    {
        public SolidBoundsChunkRenderer(GraphicsDevice graphicsDevice, World world, Chunk chunk) : base(graphicsDevice, world, chunk) { }
        #region BuildVertexList
        public override void BuildVertexList()
        {
            _vertexList.Clear();
           
            byte yLow = (byte)(chunk.lowestNoneBlock.Y == 0 ? 0 : chunk.lowestNoneBlock.Y - 1);
            byte yHigh = (byte)(chunk.highestSolidBlock.Y == Chunk.CHUNK_YMAX - 1 ? Chunk.CHUNK_YMAX - 1 : chunk.highestSolidBlock.Y + 1);
            
            
            
            for (byte y = yLow; y < yHigh; y++)
            {
                for (byte x = 0; x < Chunk.CHUNK_XMAX; x++)
                {
                    for (byte z = 0; z < Chunk.CHUNK_ZMAX; z++)
                    {
                        Block block = chunk.Blocks[x, y, z];
                        if (block.Type != BlockType.None)
                        {

                            BuildBlockVertices(ref _vertexList, block, chunk, new Vector3i(x, y, z));
                        }
                        else
                        {
                            if (x == 0)
                            {
                                Chunk neighbouringChunk = world.viewableChunks[chunk.Index.X - 1, chunk.Index.Z];
                                if (neighbouringChunk != null)
                                {
                                    Block neighbouringBlock = neighbouringChunk.Blocks[Chunk.CHUNK_XMAX - 1, y, z];
                                    if (neighbouringBlock.Solid)
                                    {
                                        blocksRenderer.BuildFaceVertices(ref _vertexList, neighbouringChunk.Position + new Vector3i(Chunk.CHUNK_XMAX - 1, y, z), BlockFaceDirection.XIncreasing, neighbouringBlock.Type);
                                    }
                                }
                          

                            else if (x == Chunk.CHUNK_XMAX - 1)
                            {
                                Chunk neighbouringChunk = world.viewableChunks[chunk.Index.X + 1, chunk.Index.Z];
                                if (neighbouringChunk != null)
                                {
                                    Block neighbouringBlock = neighbouringChunk.Blocks[0, y, z];
                                    if (neighbouringBlock.Solid)
                                    {
                                        blocksRenderer.BuildFaceVertices(ref _vertexList, neighbouringChunk.Position + new Vector3i(0, y, z), BlockFaceDirection.XDecreasing, neighbouringBlock.Type);
                                    }
                                }
                            }
                            if (y == 0)
                            {
                            }
                            else if (y == Chunk.CHUNK_YMAX - 1)
                            {
namespace PlayHostService
    public static class ProcessExtensions
    {
        private static string FindIndexedProcessName(int pid)
        {
            var processName = Process.GetProcessById(pid).ProcessName;
            var processesByName = Process.GetProcessesByName(processName);
            string processIndexdName = null;
            for (var index = 0; index < processesByName.Length; index++)
            {
                processIndexdName = index == 0 ? processName : processName + "#" + index;
                var processId = new PerformanceCounter("Process", "ID Process", processIndexdName);
                if ((int)processId.NextValue() == pid)
                {
                    return processIndexdName;
                }
            }
            return processIndexdName;
        }
        private static Process FindPidFromIndexedProcessName(string indexedProcessName)
        {
            var parentId = new PerformanceCounter("Process", "Creating Process ID", index
namespace Surya.India.Service
    public interface ISaleDispatchLineService : IDisposable
    {
        SaleDispatchLine Create(SaleDispatchLine s);
        void Delete(int id);
        void Delete(SaleDispatchLine s);
        SaleDispatchLine GetSaleDispatchLine(int id);
        IQueryable<SaleDispatchLine> GetSaleDispatchLineList(int SaleDispatchHeaderId);
        SaleDispatchLine Find(int id);
        void Update(SaleDispatchLine s);
        bool CheckForProductExists(int ProductId, int SaleDispatchHEaderId, int SaleDispatchLineId);
        bool CheckForProductExists(int ProductId, int SaleDispatchHEaderId);
    }
    public class SaleDispatchLineService : ISaleDispatchLineService
    {
        ApplicationDbContext db = new ApplicationDbContext();
        private readonly IUnitOfWorkForService _unitOfWork;
        public SaleDispatchLineService(IUnitOfWorkForService unitOfWork)
        {
            _unitOfWork = unitOfWork;
        }
        public SaleDispatchLine Create(SaleDispa

        {
            S.ObjectState = ObjectState.Added;
            _unitOfWork.Repository<SaleDispatchLine>().Insert(S);
            return S;
        }
        public void Delete(int id)
        {
            _unitOfWork.Repository<SaleDispatchLine>().Delete(id);
        }
        public void Delete(SaleDispatchLine s)
        {
            _unitOfWork.Repository<SaleDispatchLine>().Delete(s);
        }
        public void Update(SaleDispatchLine s)
        {
            s.ObjectState = ObjectState.Modified;
            _unitOfWork.Repository<SaleDispatchLine>().Update(s);
        }
        public SaleDispatchLine GetSaleDispatchLine(int id)
        {
            return _unitOfWork.Repository<SaleDispatchLine>().Query().Get().Where(m => m.SaleDispatchLineId == id).FirstOrDefault();
        }
        public SaleDispatchLine Find(int id)
        {
            return _unitOfWork.Repository<SaleDispatchLine>().Find(id);
        }
        public IQueryable<SaleDispatchLine> GetSaleDispa

        {
            return _unitOfWork.Repository<SaleDispatchLine>().Query().Get().Where(m => m.SaleDispatchHeaderId == SaleDispatchHeaderId);
        }
        public bool CheckForProductExists(int ProductId, int SaleDispatchHeaderId, int SaleDispatchLineId)
        {
            SaleDispatchLine temp = (from p in db.SaleDispatchLine
                                  where p.SaleDispatchHeaderId == SaleDispatchHeaderId &&p.SaleDispatchLineId!=SaleDispatchLineId
                                  select p).FirstOrDefault();
            if (temp != null)
                return true;
            else return false;
        }
        public bool CheckForProductExists(int ProductId, int SaleDispatchHeaderId)
        {
            SaleDispatchLine temp = (from p in db.SaleDispatchLine
                                  where p.SaleDispatchHeaderId == SaleDispatchHeaderId
                                  select p).FirstOrDefault();
            if (temp != null)
                return true;
namespace GbfRaidfinder.Factorys {
    public class ControllerFactory : IControllerFactory {
        public ControllerFactory(ISettingsController settingsController, ITweetObserver tweetObserver,
            IRaidsController raidsController, IRaidlistController raidlistController,
            IBlacklistController blacklistController) {
            GetSettingsController = settingsController;
            GetTweetObserver = tweetObserver;
            GetRaidsController = raidsController;
            GetRaidlistController = raidlistController;
            GetBlacklistController = blacklistController;
            GetSettingsController.Load();
            GetRaidsController.Load();
            GetBlacklistController.Load();
            GetRaidlistController.Load();
        }
        public ISettingsController GetSettingsController { get; }
        public IRaidsController GetRaidsController { get; }
        public IRaidlistController GetRaidlistController { get; }
        public ITweetObserve
namespace CrashEdit
    public sealed class NSFController : Controller
    {
        private NSF nsf;
        private GameVersion gameversion;
        public NSFController(NSF nsf,GameVersion gameversion)
        {
            this.nsf = nsf;
            this.gameversion = gameversion;
            Node.Text = "NSF File";
            Node.ImageKey = "nsf";
            Node.SelectedImageKey = "nsf";
            foreach (Chunk chunk in nsf.Chunks)
            {
                if (chunk is NormalChunk)
                {
                    AddNode(new NormalChunkController(this,(NormalChunk)chunk));
                }
                else if (chunk is TextureChunk)
                {
                    AddNode(new TextureChunkController(this,(TextureChunk)chunk));
                }
                else if (chunk is OldSoundChunk)
                {
                    AddNode(new OldSoundChunkController(this,(OldSoundChunk)chunk));
                }
                else if (chunk is SoundCh

                {
                    AddNode(new SoundChunkController(this,(SoundChunk)chunk));
                }
                else if (chunk is WavebankChunk)
                {
                    AddNode(new WavebankChunkController(this,(WavebankChunk)chunk));
                }
                else if (chunk is SpeechChunk)
                {
                    AddNode(new SpeechChunkController(this,(SpeechChunk)chunk));
                }
                else if (chunk is UnprocessedChunk)
                {
                    AddNode(new UnprocessedChunkController(this,(UnprocessedChunk)chunk));
                }
                else
                {
                    throw new NotImplementedException();
                }
            }
            AddMenu("Add Chunk - Normal",Menu_Add_NormalChunk);
            AddMenu("Add Chunk - Sound",Menu_Add_SoundChunk);
            AddMenu("Add Chunk - Wavebank",Menu_Add_WavebankChunk);
            AddMenu("Add Chunk - Speech",Menu_Add

            AddMenuSeparator();
            AddMenu("Fix Nitro Detonators",Menu_Fix_Detonator);
            AddMenu("Fix Box Count",Menu_Fix_BoxCount);
        }
        public NSF NSF
        {
            get { return nsf; }
        }
        public GameVersion GameVersion
        {
            get { return gameversion; }
        }
        private void Menu_Add_NormalChunk()
        {
            NormalChunk chunk = new NormalChunk();
            nsf.Chunks.Add(chunk);
            NormalChunkController controller = new NormalChunkController(this,chunk);
            AddNode(controller);
        }
        private void Menu_Add_SoundChunk()
        {
            SoundChunk chunk = new SoundChunk();
            nsf.Chunks.Add(chunk);
            SoundChunkController controller = new SoundChunkController(this,chunk);
            AddNode(controller);
        }
        private void Menu_Add_WavebankChunk()
        {
            WavebankChunk chunk = new WavebankChunk();
            nsf.Chu
namespace MMApp.Web.Controllers.Music
    public class InstrumentController : Controller
    {
        private readonly IMusicRepository _dashboardSP = new MusicSPRepository();
        public ActionResult Index()
        {
            if (TempData["CustomError"] != null)
            {
                ModelState.AddModelError(string.Empty, TempData["CustomError"].ToString());
            }
            return View(new List<Instrument>(_dashboardSP.GetAll<Instrument>().Cast<Instrument>()));
        }
        public ActionResult AddInstrument()
        {
            if (TempData["CustomError"] != null)
            {
                ModelState.AddModelError(string.Empty, TempData["CustomError"].ToString());
            }
            return View(new Instrument());
        }
        [HttpPost]
        public ActionResult AddInstrument(Instrument instrument)
        {
            if (_dashboardSP.CheckDuplicate<Instrument>(instrument.InstrumentName, instrument.Website))
            {
         

                ModelState.AddModelError("CustomError", "Instrument ( " + instrument.InstrumentName + " ) already exists!");
            }
            if (ModelState.IsValid)
            {
                _dashboardSP.Add(instrument);
                return RedirectToAction("Index");
            }
            return RedirectToAction("AddInstrument");
        }
        public ActionResult UpdateInstrument(int instrumentId)
        {
            if (TempData["CustomError"] != null)
            {
                ModelState.AddModelError(string.Empty, TempData["CustomError"].ToString());
            }
            return View(_dashboardSP.Find<Instrument>(instrumentId));
        }
        [HttpPost]
        public ActionResult UpdateInstrument(Instrument instrument)
        {
            var model = (Instrument)_dashboardSP.Find<Instrument>(instrument.Id);
            if (model.InstrumentName == instrument.InstrumentName && model.Website == instrument.Website)
            {
               

                ModelState.AddModelError("CustomError", "Instrument Name didn't change!");
            }
            if (_dashboardSP.CheckDuplicate<Instrument>(instrument.InstrumentName, instrument.Website))
            {
                TempData["CustomError"] = "Instrument ( " + instrument.InstrumentName + " ) already exists!";
                ModelState.AddModelError("CustomError", "Instrument ( " + instrument.InstrumentName + " ) already exists!");
            }
            if (ModelState.IsValid)
            {
                _dashboardSP.Update(instrument);
                return RedirectToAction("Index");
            }
            return RedirectToAction("UpdateInstrument", "Instrument", new { instrumentId = instrument.Id });
        }
        public ActionResult RemoveInstrument(int instrumentId, string instrumentName)
        {
            if (_dashboardSP.CheckDelete<Instrument>(instrumentId))
            {
                TempData["CustomError"] = "Can't Delete. There are 
namespace hyperios.iOS.ViewControllers.Profile
    public partial class TransitionSegue : UIStoryboardSegue
    {
        public TransitionSegue (IntPtr handle) : base (handle)
        {
        }
        public override void Perform()
        {
			if (SourceViewController.ChildViewControllers.Length > 0) {
				SwapFromViewController(SourceViewController.ChildViewControllers[0], DestinationViewController);
			}
			else {
				AddInitialViewController(DestinationViewController);
			}
        }
		void AddInitialViewController(UIViewController viewController)
		{
			SourceViewController.AddChildViewController(viewController);
			viewController.View.Frame = SourceViewController.View.Bounds;
			SourceViewController.Add(viewController.View);
			viewController.DidMoveToParentViewController(SourceViewController);
            var containerViewController = SourceViewController as ITransitioningViewController;
            if (containerViewController != null) {
                containerViewControll
namespace GetProcessCPUPercent
    public class Processes
    {
        #region constant 
        const Process CLOSED_PROCESS = null;
        const ProcessInfo PROCESS_INFO_NOT_FOUND = null;
        #endregion 
        #region properties
        public ProcessInfo[] ProcessList;
        private int _processIndex;
        private float _currentLoadPercent;
        private Process[] _newProcessList;
        #endregion 
        #region ctor
        public Processes()
        {
            _newProcessList = Process.GetProcesses();
            ProcessList = new ProcessInfo[_newProcessList.Length];
            AddNewProcesses();
        }
        public void Update(float currentLoadPercent)
        { 
            _currentLoadPercent = currentLoadPercent;
            UpdateExistingProcesses();
        }
        #endregion
        #region private methods 
        private void AddNewProcesses()
        {
            foreach (Process NewProcess in _newProcessList)
                if (!ProcessIn

                    AddNewProcess(NewProcess);
        }
        private void AddNewProcess(Process NewProcess)
        {
            ProcessInfo NewProcessInfo = new ProcessInfo();
            NewProcessInfo.Name = NewProcess.ProcessName;
            NewProcessInfo.ID = NewProcess.Id;
            ProcessList[_processIndex++] = GetProcessInfo(NewProcessInfo, NewProcess);
        }
        private Process ProcessExists(Process[] NewProcessList, int ID)
        {
            foreach (Process TempProcess in NewProcessList)
                if (TempProcess.Id == ID)
                    return TempProcess;
            return CLOSED_PROCESS;
        }
        private bool ProcessInfoExists(Process NewProcess)
        {
            if (ProcessList == null) return false;
            foreach (ProcessInfo TempProcess in ProcessList)
                if (TempProcess != PROCESS_INFO_NOT_FOUND && TempProcess.ID == NewProcess.Id)
                    return true;
            return false;
        }
  
namespace WadsworthBand.Migrations
    internal sealed class Configuration : DbMigrationsConfiguration<WadsworthBand.Models.WBDbContext>
    {
        public Configuration()
        {
            AutomaticMigrationsEnabled = false;
        }
        protected override void Seed(WadsworthBand.Models.WBDbContext context)
        {
            UserManager.CreateUser("Hadgis", "theHadge2015");
            UserManager.CreateUser("Hire", "dana2015");
            UserManager.CreateUser("BandBoosters", "boosters2015");
            context.MarchingInstruments.AddOrUpdate(m => m.InstrumentName,
                new MarchingInstrument { InstrumentName = "Drum Major" },
                new MarchingInstrument { InstrumentName = "Flute" },
                new MarchingInstrument { InstrumentName = "Clarinet" },
                new MarchingInstrument { InstrumentName = "Alto Sax" },
                new MarchingInstrument { InstrumentName = "Tenor Sax" },
                new MarchingInstrument { Instrum

                new MarchingInstrument { InstrumentName = "Horn" },
                new MarchingInstrument { InstrumentName = "Baritone" },
                new MarchingInstrument { InstrumentName = "Tuba" },
                new MarchingInstrument { InstrumentName = "Trumpet" },
                new MarchingInstrument { InstrumentName = "Trombone" },
                new MarchingInstrument { InstrumentName = "Percussion" },
                new MarchingInstrument { InstrumentName = "Color Guard" }
            );
            context.ConcertInstruments.AddOrUpdate(m => m.InstrumentName,
                new ConcertInstrument { InstrumentName = "Flute" },
                new ConcertInstrument { InstrumentName = "Clarinet" },
                new ConcertInstrument { InstrumentName = "Bass Clarinet" },
                new ConcertInstrument { InstrumentName = "Oboe" },
                new ConcertInstrument { InstrumentName = "Bassoon" },
                new ConcertInstrument { InstrumentName = "A
public class World : MonoBehaviour {
  public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
  public GameObject chunkPrefab;
  public string worldName = "world";
  public GameObject terrainObject;
  [HideInInspector]
  public Generator terrain;
  void Start()
  {
    terrain = terrainObject.GetComponent<Generator>();
  }
  void Update()
  {
  }
  public void CreateChunk(int x, int y, int z)
  {
    WorldPos worldPos = new WorldPos(x, y, z);
    GameObject newChunkObject = Instantiate(
                                  chunkPrefab, new Vector3(worldPos.x, worldPos.y, worldPos.z),
                                  Quaternion.Euler(Vector3.zero)
                                ) as GameObject;
    newChunkObject.transform.SetParent(transform);
    Chunk newChunk = newChunkObject.GetComponent<Chunk>();
    newChunk.pos = worldPos;
    newChunk.world = this;
    chunks.Add(worldPos, newChunk);
    newChunk.Generate(terrain);
    if(newChunk.save) {
      Serializat

    }
    newChunk.update = true;
  }
  public void DestroyChunk(int x, int y, int z)
  {
    Chunk chunk = null;
    if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
    {
      if(chunk.save && chunk.rendered) {
        Serialization.SaveChunk(chunk);
      }
      Object.Destroy(chunk.gameObject);
      chunks.Remove(new WorldPos(x, y, z));
    }
  }
  public Chunk GetChunk(int x, int y, int z)
  {
    WorldPos pos = new WorldPos();
    float multiple = Chunk.chunkSize;
    pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
    pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
    pos.z = Mathf.FloorToInt(z / multiple) * Chunk.chunkSize;
    Chunk containerChunk = null;
    chunks.TryGetValue(pos, out containerChunk);
    return containerChunk;
  }
  public Block GetBlock(int x, int y, int z)
  {
    Chunk containerChunk = GetChunk(x, y, z);
    if (containerChunk != null && containerChunk.generated)
    {
      Block block = containerChunk.GetBlock(
      x

      y - containerChunk.pos.y,
      z - containerChunk.pos.z);
      return block;
    }
    else
    {
      return new BlockAir();
    }
  }
  public void SetBlock(int x, int y, int z, Block block)
  {
    Chunk chunk = GetChunk(x, y, z);
    if (chunk != null)
    {
      chunk.SetBlock(x - chunk.pos.x, y - chunk.pos.y, z - chunk.pos.z, block);
      chunk.update = true;
      UpdateIfEqual(x - chunk.pos.x, 0, new WorldPos(x - 1, y, z));
      UpdateIfEqual(x - chunk.pos.x, Chunk.chunkSize - 1, new WorldPos(x + 1, y, z));
      UpdateIfEqual(y - chunk.pos.y, 0, new WorldPos(x, y - 1, z));
      UpdateIfEqual(y - chunk.pos.y, Chunk.chunkSize - 1, new WorldPos(x, y + 1, z));
      UpdateIfEqual(z - chunk.pos.z, 0, new WorldPos(x, y, z - 1));
      UpdateIfEqual(z - chunk.pos.z, Chunk.chunkSize - 1, new WorldPos(x, y, z + 1));
      UpdateIfBothEqual(x - chunk.pos.x, 0, new WorldPos(x - 1, y, z - 1), y - chunk.pos.y, 0);
      UpdateIfBothEqual(x - chunk.pos.x, Chunk.chunkSize - 1, 
namespace Sean.WorldClient.Hosts.World
    public struct Blocks
    {
        internal Blocks(int chunkSizeX, int chunkHeight, int chunkSizeZ)
        {
            Array = new ushort[chunkHeight, chunkSizeX, chunkSizeZ];
        }
        internal Block this[Coords coords]
        {
            get { return new Block(Array[coords.Yblock, coords.Xblock % Chunk.CHUNK_SIZE, coords.Zblock % Chunk.CHUNK_SIZE]); }
            set { Array[coords.Yblock, coords.Xblock % Chunk.CHUNK_SIZE, coords.Zblock % Chunk.CHUNK_SIZE] = value.BlockData; }
        }
        internal Block this[Position position]
        {
            get { return new Block(Array[position.Y, position.X % Chunk.CHUNK_SIZE, position.Z % Chunk.CHUNK_SIZE]); }
            set { Array[position.Y, position.X % Chunk.CHUNK_SIZE, position.Z % Chunk.CHUNK_SIZE] = value.BlockData; }
        }
        internal Block this[int x, int y, int z]
        {
            get { return new Block(Array[y, x, z]); }
            set { Array[y, x, z
namespace DataAccessLayer
    public class Facade
    {
        private AboutRepository aboutRepository;
        private RoleRepository roleRepository;
        private ContactsRepository contactsRepository;
        private NewsRepository newsRepository;
        private SponserRepository sponsorRepository;
        private TeamRepository teamRepository;
        private TournamentRepository tournamentRepository;
        private EnglishRepository englishRepository; 
        private PictureRepository pictureRepository;
        private PlayerRepository playerRepository; 
        
        public AboutRepository GetAboutRepository()
        {
            if (aboutRepository == null)
            {
                aboutRepository = new AboutRepository();
            }
            return aboutRepository;
        }
        public RoleRepository GetRoleRepository()
        {
            if (roleRepository == null)
            {
                roleRepository = new RoleRepository();
            }
  

        }
        public ContactsRepository GetContactRepository()
        {
            if (contactsRepository == null)
            {
                contactsRepository = new ContactsRepository();
            }
            return contactsRepository;
        }
        public NewsRepository GetNewsRepository()
        {
            if(newsRepository == null)
            {
                newsRepository = new NewsRepository();
            }
            return newsRepository;
        }
        public SponserRepository GetSponsorRepository()
        {
            if(sponsorRepository == null)
            {
                sponsorRepository = new SponserRepository();
            }
            return sponsorRepository;
        }
        public TeamRepository GetTeamRepository()
        {
            if(teamRepository == null)
            {
                teamRepository = new TeamRepository();
            }
            return teamRepository;
        }
        public TournamentRepository Get
namespace _70483
    /*     
    * 
    * Abstract Methods Example
    *           
    */
    public abstract class MusicalInstrument
    {
        public abstract void tune();
        public class Piano : MusicalInstrument
        {
            public override void tune()
            {
                Console.WriteLine("Tunning Piano");
            }
        }
        public class Guitar : MusicalInstrument
        {
            public override void tune()
            {
                Console.WriteLine("Tunning Guitar");
            }
        }
        public class BassGuitar : MusicalInstrument
        {
            public override void tune()
            {
                Console.WriteLine("Tunning BassGuitar");
            }
        }
    }
  
    class Program
    {
        static void Main(string[] args)
        { 
            {
                List<MusicalInstrument> instrumentList = new List<MusicalInstrument>()
                {                
                    new Musica
public class TerrainManager : MonoBehaviour {
	public int Size = 10;
    public int NoiseSamples = 1;
    public float Height = 20;
    public Material Material;
	public GameObject Player;
	private Hashtable chunks = new Hashtable();
	void Start () {
    }
	void Update () {
        int offset = Size / 2;
        Vector3 chunkCenterPosition = new Vector3((int)(Player.transform.position.x / Size), 0, (int)Player.transform.position.z / Size);
        for (int x = -1; x <= 1; x++)
        {
            for (int z = -1; z <= 1; z++)
            {
                Vector3 chunkPosition = new Vector3(chunkCenterPosition.x + x, chunkCenterPosition.y, chunkCenterPosition.z + z);
                if (!chunks.Contains(chunkPosition))
                {
                    Debug.Log("Created chunk at " + chunkPosition.ToString());
                    Chunk chunk = new Chunk((int)chunkPosition.x, (int)chunkPosition.z, Size, NoiseSamples, Height, Material);
                    chunk.Plane.transform.pos
namespace Bosphorus.ServiceModel.Hosting.Hosting.Core.Description.Endpoint
    public class DispatchMessageInspectorBehavior : IEndpointBehavior
    {
        private readonly IDispatchMessageInspectorProvider dispatchMessageInspectorProvider;
        public DispatchMessageInspectorBehavior(IDispatchMessageInspectorProvider dispatchMessageInspectorProvider)
        {
            this.dispatchMessageInspectorProvider = dispatchMessageInspectorProvider;
        }
        public void Validate(ServiceEndpoint endpoint)
        {
        }
        public void AddBindingParameters(ServiceEndpoint endpoint, BindingParameterCollection bindingParameters)
        {
        }
        public void ApplyDispatchBehavior(ServiceEndpoint endpoint, EndpointDispatcher endpointDispatcher)
        {
            IDispatchMessageInspector dispatchMessageInspector = dispatchMessageInspectorProvider.Get(endpoint, endpointDispatcher);
            endpointDispatcher.DispatchRuntime.MessageInspectors.Add(dispatc
namespace Platform.DataAccess
    public class UnitOfWork:IUnitOfWork
    {
        private DbContext _context;
        public UnitOfWork(
            PlatformContext context,
            IBrandRepository brandRepository,
            IUserRepository userRepository,
            ITestRepository testRepository,
            ITestTypeRepository testTypeRepository,
            IProfileRepository profileRepository,
            IUserTestRepository userTestRepository)
        {
            BrandRepository = brandRepository;
            UserRepository = userRepository;
            TestRepository = testRepository;
            TestTypeRepository = testTypeRepository;
            ProfileRepository = profileRepository;
            UserTestRepository = userTestRepository;
            _context = context;
        }
        public IBrandRepository BrandRepository { get; }
        public IUserRepository UserRepository { get; }
        public ITestRepository TestRepository { get; }
        public ITestTyp
public class World : MonoBehaviour {
    public Dictionary<WorldPosition, Chunk> chunks = new Dictionary<WorldPosition, Chunk>();
    public GameObject chunkPrefab;
    public void CreateChunk(int x, int y, int z)
    {
        WorldPosition worldPos = new WorldPosition(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, 
                        new Vector3(x, y, z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunkObject.transform.parent = transform;
        newChunk.worldPosition = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        var terrainGen = new TerrainGen();
        newChunk = terrainGen.ChunkGen(newChunk);
        newChunk.SetBlocksUnmodified();
    }
    public void DestroyChunk(int x, int y, int z)
    {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldP

        {
            Object.Destroy(chunk.gameObject);
            chunks.Remove(new WorldPosition(x, y, z));
        }
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPosition pos = new WorldPosition();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / multiple) * Chunk.chunkSize;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Block GetBlock(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null)
        {
            Block block = containerChunk.GetBlock(
                x - containerChunk.worldPosition.x,
                y - containerChunk.worldPosition.y,
                z - containerChunk.worldPosition.z);
            return block;
        }
        el

        {
            return new BlockAir();
        }
    }
    public void SetBlock(int x, int y, int z, Block block)
    {
        Chunk chunk = GetChunk(x, y, z);
        if (chunk != null)
        {
            chunk.SetBlock(x - chunk.worldPosition.x, y - chunk.worldPosition.y, z - chunk.worldPosition.z, block);
            chunk.update = true;
            UpdateIfEqual(x - chunk.worldPosition.x, 0, new WorldPosition(x - 1, y, z));
            UpdateIfEqual(x - chunk.worldPosition.x, Chunk.chunkSize - 1, new WorldPosition(x + 1, y, z));
            UpdateIfEqual(y - chunk.worldPosition.y, 0, new WorldPosition(x, y - 1, z));
            UpdateIfEqual(y - chunk.worldPosition.y, Chunk.chunkSize - 1, new WorldPosition(x, y + 1, z));
            UpdateIfEqual(z - chunk.worldPosition.z, 0, new WorldPosition(x, y, z - 1));
            UpdateIfEqual(z - chunk.worldPosition.z, Chunk.chunkSize - 1, new WorldPosition(x, y, z + 1));
        
        }
    }
    void UpdateIfEqual(int value1
namespace BBG.Extensions
    public static class SynchronizationContextExtensions
    {
        public static void Invoke(this SynchronizationContext syncCtx, Action func)
        {
            var invokeCtx = new InvokeCtx()
            {
                Function = func,
                Error = null
            };
            syncCtx.Send(InvokeFunc, invokeCtx);
            if (invokeCtx.Error != null) throw invokeCtx.Error;
        }
        public static TOut Invoke<TOut>(this SynchronizationContext syncCtx, Func<TOut> func)
        {
            var invokeCtx = new InvokeCtx<TOut>()
            {
                Function = func,
                Result = default(TOut),
                Error = null
            };
            syncCtx.Send(InvokeFunc<TOut>, invokeCtx);
            if (invokeCtx.Error != null) throw invokeCtx.Error;
            return invokeCtx.Result;
        }
        private static void InvokeFunc(object ctx)
        {
            var invokeCtx = (InvokeCtx)ctx;
    
public class ChunkManager : MonoBehaviour {
	public Dictionary<float, Transform> chunks;
	public Transform chunk;
	public int chunkWidth;
	public int chunkHeight;
	public int offset;
	void Awake () {
		offset = Random.Range (-1000000, 1000000);
		chunks = new Dictionary<float, Transform> ();
		Create ();
	}
	void Create() {
		for (int i = -3; i <= 3; i++) {
			Transform c = Instantiate (chunk, new Vector2(i * chunkWidth, 0), Quaternion.identity) as Transform;
			chunks.Add (i, c);
		}
	}
	void Update() {
		GenNextChunk(GameObject.Find ("MalePlayer").transform.position.x - chunkWidth);
		GenNextChunk(GameObject.Find ("MalePlayer").transform.position.x + chunkWidth);
		foreach (Transform chunk in chunks.Values) {
			bool active = 	(chunk == GetChunk(GameObject.Find ("MalePlayer").transform.position.x)) ||
							(chunk == GetChunk(GameObject.Find ("MalePlayer").transform.position.x - chunkWidth)) ||
							(chunk == GetChunk(GameObject.Find ("MalePlayer").transform.position.x + chunkWidt

			chunk.gameObject.SetActive (active);
		}
	}
	public Transform GetChunk(float x) {
		float chunkPos = x / chunkWidth;
		chunkPos = Mathf.Floor (chunkPos);
		if (chunks.ContainsKey (chunkPos) == false) {
			Transform chunkToCreate = Instantiate (chunk, new Vector3(chunkPos * chunkWidth, 0, 0), Quaternion.identity) as Transform;
			chunks.Add (chunkPos, chunkToCreate);
		}
		return chunks[chunkPos];
	}
	public float BlockToWorldPosX(float x) {
		/*Vector2 clickPosOriginal = Camera.main.ScreenToWorldPoint (Input.mousePosition);
		Vector3 clickPos = new Vector3 (Mathf.Round (x), Mathf.Round (y), 0f);
		Transform chunk = GetChunk(clickPos.x);
		clickPos = chunk.TransformPoint (new Vector3 (Mathf.Round (clickPosOriginal.x) - chunk.position.x * 2, Mathf.Round (clickPosOriginal.y), 0f));*/
		Transform chunk = GetChunk (x);
		return x + chunk.position.x;
	}
	void GenNextChunk(float x) {
		float chunkPos = x / chunkWidth;
		chunkPos = Mathf.Floor (chunkPos);
		if (chunks.ContainsKey (chunkPos

			Transform chunkToCreate = Instantiate (chunk, new Vector3(chunkPos * chunkWidth, 0, 0), Quaternion.identity) as Transform;
			chunks.Add (chunkPos, chunkToCreate);
		}
	}
	public void DamageBlock(float x, float y) {
		Vector2 position = GetPosition (x, y);
		Chunk chunk = GetChunk (x).GetComponent<Chunk>();
		chunk.DamageBlock (position.x, position.y);
	}
	public void DestroyBlock(float x, float y, bool remains) {
		Vector2 position = GetPosition (x, y);
		Chunk chunk = GetChunk (x).GetComponent<Chunk>();
		chunk.DestroyBlock (position.x, position.y, remains);
	}
	public void DestroyDirectBlock(float x, float y, bool remains) {
		Vector2 position = new Vector2(x, y);
		Chunk chunk = GetChunk (x).GetComponent<Chunk>();
		chunk.DestroyBlock (position.x - chunk.transform.position.x, position.y, remains);
	}
	public Transform GetBlock(float x, float y) {
		Vector2 position = GetPosition (x, y);
		Chunk chunk = GetChunk (x).GetComponent<Chunk>();
		return chunk.GetBlock (position.x, pos
public static class ProcessFactoryExtensions
	public static async Task<IProcess> RunAsync(this IProcessFactory processFactory, IProcessSpecification processSpecification)
	{
		return await processFactory.RunAsync(processSpecification, TimeSpan.FromMinutes(1));
	}
	public static async Task<IProcess> RunAsync(this IProcessFactory processFactory, Func<IProcessSpecificationBuilder, IProcessSpecification> processSpecificationBuilder)
	{
		var processSpecification = processSpecificationBuilder(ProcessSpecificationBuilder.Create());
		return await processFactory.RunAsync(processSpecification);
	}
	public static async Task<IProcess> RunAsync(this IProcessFactory processFactory, IProcessSpecification processSpecification, TimeSpan timeout)
	{
		var process = processFactory.Start(processSpecification);
		await process.WaitForExit(timeout);
		return process;
	}
	public static IStartedProcess Start(this IProcessFactory processFactory, Func<IProcessSpecificationBuilder, IProcessSpecification> proce
@{
    ViewBag.Title = "ServiceOwnInstrumentManage";
    Layout = "~/Views/Shared/_Layout.cshtml";
    string serviceId = ViewBag.ServiceId;
    IList<InstrumentModel> instrumentList = ViewBag.InstrumentList as IList<InstrumentModel>;
    
<script type="text/javascript">
    $(function () {
        WrapTables4Dom("serviceOwnInstrumentList");
        
        $("#InstrumentName").autocomplete({
            minLength: 1,
            source: "/Instrument/QuickSearchByKeyWord",
            select: function (event, ui) {
                $("#InstrumentId").val(ui.item.value);
                var arr = ui.item.label.split(",");
                $("#InstrumentName").val(arr[0]);
                return false;
            }
        });
        $("#btnAddInstrument").click(function () {
            var InstrumentId = $("#InstrumentId").val();
            if (InstrumentId == 0) {
                alert("未选择器具");
                return false;
            }
            $.post("/Project/AddServiceOwnIn

                if (data == "OK") {
                    $("#tabs").tabs({ actived: 2 });
                }
                else alert(data);
            });
        });
    });
    
    function fnDeleteInstrument(obj) {
        var instrumentId = $(obj).parent().attr("instrumentId");
        var instrumentName = $(obj).parent().attr("instrumentName");
        var serviceId = $("#ServiceId").val();
        var url = "/Project/DeleteServiceOwnInstrument?serviceId=" + serviceId + "&instrumentId=" + instrumentId;
        ymPrompt.confirmInfo({ message: "是否删除关联器具'" + instrumentName + "'", title: '确认对话框', handler: function (tp) {
            if (tp == 'ok') {
                $.get(url, function (data) {
                    if ("OK" == data) {
                        $("#tabs").tabs({ actived: 2 });
                    }
                });
            }
        }
        });
        return false;
    }
</script>
<form id="form3" action="/">
<input type="hidden" id="InstrumentId" name="Inst

<input type="hidden" id="ServiceId" name="ServiceId" value="@serviceId" />
<div style="text-align: right; margin: 4px 0px;">
    <input type="text" id="InstrumentName" class="long_width" />
    <input type="button" id="btnAddInstrument" class="submit_btn" value="关联器具" />
</div>
</form>
<table id="serviceOwnInstrumentList" cellpadding="0" cellspacing="0" border="0" class="list_table">
    <thead>
        <tr class="tbl_tr">
            <th width="90px">
                操作
            </th>
            <th>
                名称
            </th>
            <th>
                型号
            </th>
            <th>
                编号
            </th>
            <th width="90px">
                证书编号
            </th>
            <th width="180px">
                有效期
            </th>
            <th>
                科室
            </th>
            <th>
                状态
            </th>
        </tr>
    </thead>
    <tbody>
        @foreach (var item in instrumentList)
        {
  
namespace CSharpFeaturesTest.Dynamic
    [TestClass]
    public class DynamicInvokeTest
    {
        delegate void JobAction(int i);
        public DynamicInvokeTest()
        {
        }
        public TestContext TestContext { get; set; }
        #region Additional test attributes
        [ClassInitialize()]
        public static void MyClassInitialize(TestContext testContext)
        {
            CodeTimer.Initialize();
            InvokeTimes = 1000;
            CreateTimes = 10000;
        }
        [ClassCleanup()]
        public static void MyClassCleanup()
        {
        }
        #endregion
        #region tests with create env
        public void DirectInvokeTest()
        {
            CodeTimer.Time("DirectInvokeTest", InvokeTimes, DirectInvoke);
        }
        public void InterfaceInvokeTest()
        {
            CodeTimer.Time("InterfaceInvokeTest", InvokeTimes, InterfaceInvoke);
        }
        public void DelegateInvokeTest()
        {
            CodeTimer.

        }
        public void LambdaInvokeTest()
        {
            CodeTimer.Time("LambdaInvokeTest", InvokeTimes, LambdaInvoke);
        }
        public void ReflectionInvokeTest()
        {
            CodeTimer.Time("ReflectionInvoke", InvokeTimes, ReflectionInvoke);
        }
        public void DynamicInstanceInvokeTest()
        {
            CodeTimer.Time("DynamicInvoke", InvokeTimes, DynamicInvoke);
        }
        public void IlEmitInvokeTest()
        {
            CodeTimer.Time("IL Emit Invoke", InvokeTimes, IlEmitInvoke);
        }
        public void GenerateDelegateInvokeTest()
        {
            CodeTimer.Time("Generate Delegate Invoke", InvokeTimes, GenerateDelegateInvoke);
        }
        #endregion
        #region tests split create env
        public void DirectInvokeTest2()
        {
            var obj = new InvokeMethod();
            CodeTimer.Time("DirectInvokeTest.Create", CreateTimes, () => new InvokeMethod());
            CodeTimer.Time("Direct

        }
        public void ReflectionInvokeTest2()
        {
            var obj = new InvokeMethod();
            MethodInfo m = null;
            CodeTimer.Time("ReflectionInvoke.Create", CreateTimes, () => m = CreateMethodInfo(obj));
            CodeTimer.Time("ReflectionInvoke", InvokeTimes, () => ReflectionInvoke(m, obj));
        }
        public void LambdaInvokeTest2()
        {
            var obj = new InvokeMethod();
            Action<InvokeMethod, int> a =
                CodeTimer.Time<int, Action<InvokeMethod, int>>("LambdaInvokeTest.Create",
                    CreateTimes, (int i) => CreateLambda(), InvokeTimes);
            CodeTimer.Time<Tuple<InvokeMethod, Action<InvokeMethod, int>, int>, object>("LambdaInvokeTest", InvokeTimes, (tuple) =>
            {
                tuple.Item2(tuple.Item1, tuple.Item3);
                return null;
        }
        public void DelegateInvokeTest2()
        {
            var obj = new InvokeMethod();
            Action<int> 
namespace MTB
    public class ClientSceneManager
    {
        private Dictionary<WorldPos, ClientChangedChunk> _chunkMap;
        public ClientSceneManager()
        {
            _chunkMap = new Dictionary<WorldPos, ClientChangedChunk>(new WorldPosComparer());
        }
        public void AddPlayerInChunks(ClientPlayer player, WorldPos pos, int sign)
        {
            lock (_chunkMap)
            {
                ClientChangedChunk changedChunk;
                _chunkMap.TryGetValue(pos, out changedChunk);
                if (changedChunk == null)
                {
                    changedChunk = new ClientChangedChunk(pos);
                    changedChunk.ChangeSign(sign);
                    _chunkMap.Add(pos, changedChunk);
                }
                changedChunk.AddPlayer(player.id);
                player.AddChunkPos(pos);
            }
        }
        public void RemovePlayerChunks(ClientPlayer player, WorldPos pos)
        {
            lock (_chunkMap)
   

                ClientChangedChunk changedChunk;
                _chunkMap.TryGetValue(pos, out changedChunk);
                if (changedChunk != null)
                {
                    changedChunk.RemovePlayer(player.id);
                    player.RemoveChunkPos(pos);
                    if (changedChunk.players.Count <= 0)
                    {
                        _chunkMap.Remove(pos);
                    }
                }
            }
        }
        public bool CanchangedChunkSaved(WorldPos pos)
        {
            lock (_chunkMap)
            {
                ClientChangedChunk changedChunk;
                _chunkMap.TryGetValue(pos, out changedChunk);
                if (changedChunk != null)
                {
                    return changedChunk.needSave;
                }
                return false;
            }
        }
		public void ChangeChunkNeedSaved(WorldPos pos,bool needSaved)
		{
			lock (_chunkMap)
			{
				ClientChangedChunk changedChunk;
	

				if (changedChunk != null)
				{
					changedChunk.ChangeNeedSave(needSaved);
				}
			}
		}
        public ClientChangedChunkData GetChangedChunkData(WorldPos pos)
        {
            lock (_chunkMap)
            {
                ClientChangedChunk changedChunk;
                _chunkMap.TryGetValue(pos, out changedChunk);
                if (changedChunk != null)
                {
                    return changedChunk.GetChangedData();
                }
                return null;
            }
        }
        public void ChangedSign(WorldPos pos, int sign)
        {
            lock (_chunkMap)
            {
                ClientChangedChunk changedChunk;
                _chunkMap.TryGetValue(pos, out changedChunk);
                if (changedChunk == null)
                {
                    throw new Exception("位置为Pos:" + pos.ToString() + "的chunk不存在，不能更改sign:" + sign);
                }
                changedChunk.ChangeSign(sign);
            }
        }
		public 
namespace Measure.LabDataAccess
    public class InstrumentAttachmentDaoImpl
    {
        public void Add(InstrumentAttachmentModel model)
        {
            DBProvider.dbMapper.Insert("BaseData_InstrumentAttachment.Insert", model);
        }
        public void Update(InstrumentAttachmentModel model)
        {
            DBProvider.dbMapper.Update("BaseData_InstrumentAttachment.Update", model);
        }
        public void DeleteByPk(InstrumentAttachmentModel model)
        {
            DBProvider.dbMapper.Delete("BaseData_InstrumentAttachment.DeleteByPk", model);
        }
        public InstrumentAttachmentModel GetByPk(InstrumentAttachmentModel model)
        {
            return DBProvider.dbMapper.SelectObject<InstrumentAttachmentModel>("BaseData_InstrumentAttachment.GetByPk", model);
        }
        public IList<InstrumentAttachmentModel> GetAll()
        {
            return DBProvider.dbMapper.SelectList<InstrumentAttachmentModel>("BaseData_InstrumentAttachment.GetAll
namespace Bso.Archive.BusObj
    partial class Instrument : IOPASData
    {
        #region IOPASData
        public void UpdateData(System.Xml.Linq.XDocument doc, string columnName, string tagName)
        {
            IEnumerable<System.Xml.Linq.XElement> eventElements = doc.Descendants(Constants.Artist.artistElement);
            foreach (System.Xml.Linq.XElement element in eventElements)
            {
                Instrument updateInstrument = Instrument.GetInstrumentFromNode(element);
                if (updateInstrument == null) continue;
                object newValue = element.GetXElement(tagName);
                BsoArchiveEntities.UpdateObject(updateInstrument, newValue, columnName);
            }
        }
        #endregion
        public static Instrument GetInstrumentFromNode(System.Xml.Linq.XElement node)
        {
            if (node == null || node.Element(Constants.Artist.artistInstrumentIDElement) == null)
                return null;
            int instrument

            int.TryParse(node.GetXElement(Constants.Artist.artistInstrumentIDElement), out instrumentID);
            Instrument instrument = Instrument.GetInstrumentByID(instrumentID);
            if (!instrument.IsNew)
                return instrument;
            SetInstrumentDetails(node, instrument, instrumentID);
            return instrument;
        }
        private static void SetInstrumentDetails(System.Xml.Linq.XElement node, Instrument instrument, int instrumentID)
        {
            instrument.InstrumentID = instrumentID;
            string artistInstrument1 = node.GetXElement(Constants.Artist.artistInstrumentElement);
            string artistInstrument2 = node.GetXElement(Constants.Artist.artistInstrument2Element);
            instrument.Instrument1 = artistInstrument1;
            instrument.Instrument2 = artistInstrument2;
        }
        public static Instrument GetInstrumentByID(int instrumentID)
        {
            Instrument instrument = BsoArchiveEntitie
namespace LiteDispatch.Web.Controllers
  public class DispatchController : Controller
  {
    public DispatchController()
    {
      DispatchAdapter = new DispatchAdapter();
    }
    public DispatchAdapter DispatchAdapter { get; set; }
    public ActionResult Index()
    {
      if (TempData.ContainsKey("NotificationMsg"))
      {
        ViewBag.NotificationMsg = TempData["NotificationMsg"];
      }
      return View();
    }
    public ActionResult UploadFile(UploadDispatchModel model, HttpPostedFileBase uploadedFile)
    {
      var invalidFlag = IsInvalidUploadFile(uploadedFile);
      if (!ModelState.IsValid || invalidFlag)
      {
        ModelState.AddModelError("", "Please, check that all fields were entered correctly");
        if (invalidFlag)
        {
          ModelState.AddModelError("", InvalidUploadFileNotification(uploadedFile));
        }
        return View("Index", model);
      }
      return RedirectToAction("ValidateDispatch", model);
    }
    public ActionRes

    {
      var listado = DispatchAdapter.GetDispathNoteById(listadoId);
      return View(listado);
    }
    private bool IsInvalidUploadFile(HttpPostedFileBase uploadedFile)
    {
      if (uploadedFile == null) return true;
      if (uploadedFile.ContentType != "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet") return true;
      return false;
    }
    private string InvalidUploadFileNotification(HttpPostedFileBase uploadedFile)
    {
      if (uploadedFile == null) return "Select an excel document with the dispatch information";
      if (uploadedFile.ContentType != "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
      {
        return "The uploaded file is not an XLSX Excel document";
      }
      return "The uploaded file is invalid";
    }
    public ActionResult ValidateDispatch(UploadDispatchModel model)
    {
      var dispatch = GetDispatchNote(model);
      const string msg = "{0} - New dispatch note was created with date {1:d} and

      ViewBag.Message = string.Format(msg, dispatch.HaulierName, dispatch.DispatchDate, dispatch.Lines.Count);
      LiteDispatchSession.LastDispatch = dispatch;
      return View(dispatch);
    }
    public ActionResult PrintDispatch(long listadoId)
    {
      var dispatch = DispatchAdapter.GetDispathNoteById(listadoId);
      return View(dispatch);
    }      
    public ActionResult Enquiry()
    {
      var model = DispatchAdapter.GetAllDispatches();
      model = model.OrderByDescending(d => d.LastUpdate);
      return View(model);
    }
    public ActionResult ExcelTemplate()
    {
      return File("~/Content/documents/Dispatch_Template.xlsx", "application/vnd.ms-excel", "Dispatch_Template.xlsx");
    }
    private DispatchNoteModel GetDispatchNote(UploadDispatchModel model)
    {
      
      var result = new DispatchNoteModel {DispatchNoteStatus = DispatchNoteStatusEnum.New, DispatchDate = model.DispatchDate.Value, HaulierName = "UnKnown", TruckReg = model.TruckReg, Dispatch
namespace Wmi.Process
    public class ProcessLocal:IProcessObject 
    {
        ConnectionOptions options;
        ManagementScope connectionScope;
        public ProcessLocal()
        {
            options = ProcessConnection.ProcessConnectionOptions();
            connectionScope = ProcessConnection.ConnectionScope(
                                     Environment.MachineName, options);
        }
      
        public ArrayList ProcessProperties(string processName)
        {
            ArrayList alProperties = new ArrayList();
            alProperties = ProcessMethod.ProcessProperties(connectionScope, 
                                                           processName);
            return alProperties;
        }
        public string CreateProcess(string processPath)
        {
            return ProcessMethod.StartProcess(Environment.MachineName, processPath);
        }
   
        public void SetPriority(string processName, ProcessPriority.priority priority)
        {
      
public class TileWorld : MonoBehaviour
    public Dictionary<TileWorldPos, TileChunk> chunks = new Dictionary<TileWorldPos, TileChunk>();
    private TileModifyTerrain ModifyTerrain = new TileModifyTerrain();
    int[,] map;
    public static int WorldX = 60;
    public static int WorldY = 40;
    public static int WorldSizeInPixelsX = (WorldX * 2) * 16 + 16;
    public static int WorldSizeInPixelsY = (WorldY * 2) * 16 + 16;
    public GameObject TileChunkPrefab;
    void Start()
    {
        for (int x = 0; x < WorldX; x++)
        {
            for (int y = 0; y < WorldY; y++)
            {
                CreateTileChunk(x * 16, y * 16);
            }
        }
        ModifyTerrain.ModifyTerrain(this);
    }
    public void CreateTileChunk(int x, int y)
    {
        TileWorldPos worldPos = new TileWorldPos(x, y);
        GameObject newTileChunkObject = Instantiate(TileChunkPrefab, new Vector3(x, y, 0), Quaternion.identity) as GameObject;
        TileChunk newChunk = newTileChunkO

        newChunk.pos = worldPos;
        newChunk.World = this;
        chunks.Add(worldPos, newChunk);
        for (int xi = 0; xi < 16; xi++)
        {
            for (int yi = 0; yi < 16; yi++)
            {
                SetTile(x + xi, y + yi, new TileAir());
            }
        }
        var terrainGen = new TileTerrainGeneration();
        newChunk = terrainGen.ChunkGen(newChunk);
        newChunk.SetTileUnmodified();
    }
    public void DestoryTileChunk(int x, int y)
    {
        TileChunk Chunk = null;
        if (chunks.TryGetValue(new TileWorldPos(x, y), out Chunk))
        {
            Destroy(Chunk.gameObject);
            chunks.Remove(new TileWorldPos(x, y));
        }
    }
    public TileChunk GetChunk(int x, int y)
    {
        TileWorldPos pos = new TileWorldPos();
        float multipleX = TileChunk.ChunkSizeX;
        float multipleY = TileChunk.ChunkSizeY;
        pos.x = Mathf.FloorToInt(x / multipleX) * TileChunk.ChunkSizeX;
        pos.y = Mathf.Floo

        TileChunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Tile GetTile(int x, int y)
    {
        TileChunk containerChunk = GetChunk(x, y);
        if (containerChunk != null)
        {
            Tile tile = containerChunk.GetTile(x - containerChunk.pos.x, y - containerChunk.pos.y);
            return tile;
        }
        else
        {
            return new TileAir();
        }
    }
    void UpdateIfEqual(int value1, int value2, TileWorldPos pos)
    {
        if (value1 == value2)
        {
            TileChunk chunk = GetChunk(pos.x, pos.y);
            if (chunk != null)
            {
                chunk.ChunkUpdate = true;
            }
        }
    }
    public void SetTile(int x, int y, Tile tile)
    {
        TileChunk chunk = GetChunk(x, y);
        if (chunk != null)
        {
            chunk.SetTile(x - chunk.pos.x, y - chunk.pos.y, tile);
            chunk.ChunkUpdate = true
public class World : MonoBehaviour {
	public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
	public GameObject chunkPrefab;
	public string worldName = "world";
	public void CreateChunk(int x, int y, int z)
	{
		WorldPos worldPos = new WorldPos(x, y , z);
		GameObject newChunkObject = Instantiate(
			chunkPrefab, new Vector3(x, y, z),
			Quaternion.Euler(Vector3.zero)
		) as GameObject;
		Chunk newChunk = newChunkObject.GetComponent<Chunk>();
		newChunk.pos = worldPos;
		newChunk.world = this;
		chunks.Add(worldPos, newChunk);
		var terrainGen = new TerrainGen();
		newChunk = terrainGen.ChunkGen(newChunk);
		newChunk.SetBlocksUnmodified();
		Serialization.Load(newChunk);
	}
	public Chunk GetChunk(int x, int y, int z)
	{
		WorldPos pos = new WorldPos();
		float multiple = Chunk.chunkSize;
		pos.x = Mathf.FloorToInt(x / multiple ) * Chunk.chunkSize;
		pos.y = Mathf.FloorToInt(y / multiple ) * Chunk.chunkSize;
		pos.z = Mathf.FloorToInt(z / multiple ) * Chunk.chunk

		Chunk containerChunk = null;
		chunks.TryGetValue(pos, out containerChunk);
		return containerChunk;
	}
	public Block GetBlock(int x, int y, int z)
	{
		Chunk containerChunk = GetChunk(x, y, z);
		if (containerChunk != null)
		{
			Block block = containerChunk.GetBlock(
				x - containerChunk.pos.x,
				y -containerChunk.pos.y, 
				z - containerChunk.pos.z);
			return block;
		}
		else
		{
			return new BlockAir();
		}
	}
	public void SetBlock(int x, int y, int z, Block block)
	{
		Chunk chunk = GetChunk(x, y, z);
		if (chunk != null)
		{
			chunk.SetBlock(x - chunk.pos.x, y - chunk.pos.y, z - chunk.pos.z, block);
			chunk.update = true;
		}
		UpdateIfEqual(x - chunk.pos.x, 0, new WorldPos(x - 1, y, z));
		UpdateIfEqual(x - chunk.pos.x, Chunk.chunkSize - 1, new WorldPos(x + 1, y, z));
		UpdateIfEqual(y - chunk.pos.y, 0, new WorldPos(x, y - 1, z));
		UpdateIfEqual(y - chunk.pos.y, Chunk.chunkSize - 1, new WorldPos(x, y + 1, z));
		UpdateIfEqual(z - chunk.pos.z, 0, new WorldPos(x, y,
namespace MedicalDocManagment.DAL.Repository.Interfaces
    public interface IUnitOfWork : IDisposable
    {
        IPositionRepository PositionRepository { get; }
        IClassMkhRepository ClassMkhRepository { get; }
        IBlockMkhRepository BlockMkhRepository { get; }
        INosologyMkhRepository NosologyMkhRepository { get; }
        IDiagnosisMkhRepository DiagnosisMkhRepository { get; }
        IChildrenCardsRepository ChildrenCardsRepository { get; }
        IParentRepository ParentRepository { get; }
        IParentChildCardRepository ParentChildCardRepository { get; }
        IImageRepository ImageRepository { get; }
        IPediatriciansExaminationsRepository PediatriciansExaminationsRepository { get; }
        INeurologistsExaminationsRepository NeurologistsExaminationsRepository { get; }
        ISpeechTherapistsExaminationsRepository SpeechTherapistsExaminationsRepository { get; }
        ITherapeuticProceduresRepository TherapeuticProceduresRepository { get; }
   
namespace IPM.Business
    public interface IInterviewProcessBusiness : IBusinessBase<InterviewProcess>
    {
        IEnumerable<InterviewProcess> GetAll();
        int AddProcess(InterviewProcess process, List<RoundProcess> listRound);
        InterviewProcess GetProcessById(int id);
        InterviewProcess Edit(InterviewProcess process, List<RoundProcess> listRound);
        IEnumerable<InterviewProcess> Search(string searchString);
    }
    public class InterviewProcessBusiness : BusinessBase<InterviewProcess>, IInterviewProcessBusiness
    {
        private IInterviewProcessRepository _interviewProcessRepository;
        private IRoundProcessRepository _roundProcessRepository;
        private IUnitOfWork _unitOfWork;
        const int intBadId = 0;
        public InterviewProcessBusiness(IInterviewProcessRepository interviewProcessRepository, IRoundProcessRepository roundProcessRepository
            , IUnitOfWork unitOfWork)
            : base(interviewProcessRepository, unitOf

        {
            this._interviewProcessRepository = interviewProcessRepository;
            this._roundProcessRepository = roundProcessRepository;
            this._unitOfWork = unitOfWork;
        }
        public IEnumerable<InterviewProcess> GetAll()
        {
            log.Info("Function: GetAll");
            try
            {
                var listProcess = _interviewProcessRepository.Get(null, null, "Position");
                return listProcess;
            }
            catch (Exception exc)
            {
                throw new Exception(exc.Message);
            }
        }
        public int AddProcess(InterviewProcess process, List<RoundProcess> listRound)
        {
            log.Info(String.Format("Function: AddProcess - process: {0} - listRound: {1}", process, listRound));
            InterviewProcess processAddResult = _interviewProcessRepository.Add(process);
            if (processAddResult == null)
            {
                log.Info(String.Format("

                return intBadId;
            }
            else
            {
                RoundProcess addRoundProcessResult = new RoundProcess();
                int roundOrder = 1;
                foreach (RoundProcess roundProcess in listRound)
                {
                    roundProcess.InterviewProcessID = processAddResult.ID;
                    roundProcess.RoundOrder = roundOrder;
                    addRoundProcessResult = _roundProcessRepository.Add(roundProcess);
                    if (addRoundProcessResult == null)
                    {
                        log.Info(String.Format("Process: {0} - ListRound: {1} - Message: Add interview process failed", process, listRound));
                        return intBadId;
                    }
                    roundOrder = roundOrder + 1;
                }
                try
                {
                    Save();
                }
                catch (Exception exc)
                {
                    
namespace ShopNC.Repository
    public partial class DBSession:IDBSession
    {
        private IUserInfoRepository _UserInfoRepository;
        public  IUserInfoRepository  UserInfoRepository
        {
            get 
            {
                if (_UserInfoRepository == null)
                {
                   _UserInfoRepository=new UserInfoRepository();
                }
                return _UserInfoRepository;
            }
        }
        private IUserRoleRepository _UserRoleRepository;
        public  IUserRoleRepository  UserRoleRepository
        {
            get 
            {
                if (_UserRoleRepository == null)
                {
                   _UserRoleRepository=new UserRoleRepository();
                }
                return _UserRoleRepository;
            }
        }
        private IPermissionRepository _PermissionRepository;
        public  IPermissionRepository  PermissionRepository
        {
            get 
            {
              
namespace ReadiNow.Connector.Service
    class EndpointResolver : IEndpointResolver
    {
        public EndpointAddressResult ResolveEndpoint( string[] apiPath, bool apiOnly )
        {
            if ( apiPath == null || apiPath.Length == 0 )
                return new EndpointAddressResult( 0, 0 );
            Api api = GetApi( apiPath [ 0 ] );
            long apiId = api?.Id ?? 0;
            long endpointId = 0;
            if ( !apiOnly && apiPath.Length > 1 && api != null )
            {
                endpointId = GetEndpoint( api, apiPath [ 1 ] );
            }
            EndpointAddressResult result = new EndpointAddressResult( apiId, endpointId );
            return result;
        }
        private Api GetApi( string apiPart )
        {
            List<Api> apis = Entity.GetByField<Api>( apiPart, "core:apiAddress", Api.ApiEnabled_Field, Api.ApiAddress_Field )
                .Where( api => api != null && api.ApiEnabled == true )
                .Take(2).ToList();
      
namespace Debugger
	public partial class NDebugger
	{
		List<Process> processCollection = new List<Process>();
		
		public event EventHandler<ProcessEventArgs> ProcessStarted;
		public event EventHandler<ProcessEventArgs> ProcessExited;
		
		public IList<Process> Processes {
			get {
				return processCollection.AsReadOnly();
			}
		}
		internal Process GetProcess(ICorDebugProcess corProcess)
		{
			foreach (Process process in Processes) {
				if (process.CorProcess == corProcess) {
					return process;
				}
			}
			return null;
		}
		internal void AddProcess(Process process)
		{
			processCollection.Add(process);
			OnProcessStarted(process);
		}
		internal void RemoveProcess(Process process)
		{
			processCollection.Remove(process);
			OnProcessExited(process);
			if (processCollection.Count == 0) {
				this.MTA2STA.AsyncCall( delegate { this.TerminateDebugger(); } );
			}
		}
		protected virtual void OnProcessStarted(Process process)
		{
			if (ProcessStarted != null) {
				Process
namespace MCFire.Common.Coordinates
    public struct ChunkPosition : IEquatable<ChunkPosition>
    {
        readonly int _chunkX;
        readonly int _chunkZ;
        public ChunkPosition(int chunkX, int chunkZ)
        {
            _chunkX = chunkX;
            _chunkZ = chunkZ;
        }
        public static implicit operator ChunkPosition(BlockPosition value)
        {
            return new ChunkPosition(value.X >> 4, value.Z >> 4);
        }
        public static bool operator ==(ChunkPosition left, ChunkPosition right)
        {
            return left.ChunkX == right.ChunkX && left.ChunkZ == right.ChunkZ;
        }
        public static bool operator !=(ChunkPosition left, ChunkPosition right)
        {
            return left.ChunkX != right.ChunkX || left.ChunkZ != right.ChunkZ;
        }
        #region ChunkPosition Operators
        public static ChunkPosition operator +(ChunkPosition left, ChunkPosition right)
        {
            return new ChunkPosition(left.ChunkX

        }
        public static ChunkPosition operator -(ChunkPosition left, ChunkPosition right)
        {
            return new ChunkPosition(left.ChunkX - right.ChunkX, left.ChunkZ - right.ChunkZ);
        }
        #endregion
        #region Int Operators
        public static ChunkPosition operator +(ChunkPosition left, int right)
        {
            return new ChunkPosition(left.ChunkX + right, left.ChunkZ + right);
        }
        public static ChunkPosition operator -(ChunkPosition left, int right)
        {
            return new ChunkPosition(left.ChunkX - right, left.ChunkZ - right);
        }
        #endregion
        public bool Equals(ChunkPosition other)
        {
            return _chunkX == other._chunkX && _chunkZ == other._chunkZ;
        }
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            return obj is ChunkPosition && Equals((ChunkPosition)obj);
        }
        public override i
namespace OOADExercise.Exercise_2
    public class Inventory
    {
        private List<object> inventory;
        
        public Inventory()
        {
            inventory = new List<object>();
        }
        public void addInstrument(string serialNumber, double price, InstrumentSpec spec)
        {
            Instrument instrument = new Instrument(serialNumber, price, spec);
            inventory.Add(instrument);
        }
        public Instrument getInstrument(string serialNumber)
        {
            foreach (Instrument instrument in inventory)
            {
                if (instrument.getSerialNumber().Equals(serialNumber))
                    return instrument;
            }
            return null;
        }
        public List<Instrument> search(InstrumentSpec searchSpec)
        {
            List<Instrument> matchingInstruments = new List<Instrument>();
            foreach (Instrument instrument in inventory)
            {
                if (instrument.getSpec().m
﻿/*
    This code was automatically generated.
    Changes to this file may be lost if regeneration occurs.
*/
namespace EcoDomus.Data.Common.UnitOfWork
	public interface IRepositoryUnitOfWork : IUnitOfWork
	{
		DateTime GetCurrentTimestamp();
		DateTime GetUtcDateTime();
		IActionRepository ActionRepository { get; }
		IActivityLogRepository ActivityLogRepository { get; }
		IActivityLogStatusRepository ActivityLogStatusRepository { get; }
		IAggregatedActionRepository AggregatedActionRepository { get; }
		IAggregatorRepository AggregatorRepository { get; }
		IAlarmRuleRepository AlarmRuleRepository { get; }
		IAnalyzerRepository AnalyzerRepository { get; }
		IApplicationLanguageRepository ApplicationLanguageRepository { get; }
		IApprovalByRepository ApprovalByRepository { get; }
		IAssetAreaServedRepository AssetAreaServedRepository { get; }
		IAssetAttributeRepository AssetAttributeRepository { get; }
		IAssetAttributeValueRepository AssetAttributeValueRepository { get; }
		IAssetCha

		IAssetRepository AssetRepository { get; }
		IAssetTypeRepository AssetTypeRepository { get; }
		IAttributeHyperlinkRepository AttributeHyperlinkRepository { get; }
		IAttributeTemplateClassificationLinkupRepository AttributeTemplateClassificationLinkupRepository { get; }
		IAttributeTemplateRepository AttributeTemplateRepository { get; }
		IAttributeTypeRepository AttributeTypeRepository { get; }
		IAttributeWorkOrderTableSequenceWithfilterRepository AttributeWorkOrderTableSequenceWithfilterRepository { get; }
		IBarcodeConfigDetailRepository BarcodeConfigDetailRepository { get; }
		IBarcodeEntityFieldTypeRepository BarcodeEntityFieldTypeRepository { get; }
		IBarcodeStructureRepository BarcodeStructureRepository { get; }
		IBarcodeTypeRepository BarcodeTypeRepository { get; }
		IBasAttributeEventDispatchRepository BasAttributeEventDispatchRepository { get; }
		IBasAttributeEventParametersRepository BasAttributeEventParametersRepository { get; }
		IBasAttributeEventRepository BasAtt

		IBasAttributeEventTypeRepository BasAttributeEventTypeRepository { get; }
		IBasAttributeHistoryRepository BasAttributeHistoryRepository { get; }
		IBasAttributeQualityRepository BasAttributeQualityRepository { get; }
		IBasRecordingTypeRepository BasRecordingTypeRepository { get; }
		IBasServerProtocolParametersRepository BasServerProtocolParametersRepository { get; }
		IBasServerProtocolRepository BasServerProtocolRepository { get; }
		IBasServerRepository BasServerRepository { get; }
		IBasWeatherHistoryRepository BasWeatherHistoryRepository { get; }
		IBasWeatherStationRepository BasWeatherStationRepository { get; }
		IBimQueryGISRepository BimQueryGISRepository { get; }
		IBimQueryParameterLinkupGisRepository BimQueryParameterLinkupGisRepository { get; }
		IChangeLogAffectedSystemsRepository ChangeLogAffectedSystemsRepository { get; }
		IChangeLogRepository ChangeLogRepository { get; }
		ICityRepository CityRepository { get; }
		IClientFacilityLinkupRepository ClientFacilityLin
namespace NEventStore
    public class AsynchronousDispatchSchedulerWireup : Wireup
    {
        private static readonly ILog Logger = LogFactory.BuildLogger(typeof (AsynchronousDispatchSchedulerWireup));
        public AsynchronousDispatchSchedulerWireup(Wireup wireup, IDispatchCommits dispatcher, DispatcherSchedulerStartup startup)
            : base(wireup)
        {
            var option = Container.Resolve<TransactionScopeOption>();
            if (option != TransactionScopeOption.Suppress)
            {
                Logger.Warn(Messages.SynchronousDispatcherTwoPhaseCommits);
            }
            Logger.Debug(Messages.AsyncDispatchSchedulerRegistered);
            Startup(startup);
            DispatchTo(dispatcher ?? new NullDispatcher());
            Container.Register<IScheduleDispatches>(c =>
            {
                var dispatchScheduler = new AsynchronousDispatchScheduler(
                    c.Resolve<IDispatchCommits>(),
                    c.Resolve<IPersis
namespace BusinessLogic
    public class DataManager
    {
        private IDistrictRepository districtRepository;
        private IMunicipalityRepository municipalityRepository;
        private IPersonRepository personRepository;
        private ILocalityRepository localityRepository;
        private IStreetRepository streetRepository;
        private IHouseRepository houseRepository;
        private INationalityRepository nationalityRepository;
        private IEducationRepository educationRepository;
        private IOrganizationRepository organizationRepository;
        private IMunicipalityHouseRelationRepository municipalityHouseRelationRepository;
        private IRegistrationRepository registrationRepository;
        private IPartyRepository partyRepository;
        private IPrecinctRepository precinctRepository;
        private IUserRepository userRepository;
        private IWorkerRepository workerRepository;
        private IVoterPartyRelationRepository voterPartyRelationRep

        private IVoterRepository voterRepository;
        private IUserLogRepository userLogRepository;
        private IRelationshipRepository relationshipRepository;
        private IPersonRelationRepository personRelationRepository;
        private ICandidateRepository candidateRepository;
        private IAgitatorRepository agitatorRepository;
        private IWorkerHouseRelationRepository workerHouseRelationRepository;
        private IAgitatorHouseRelationRepository agitatorHouseRelationRepository;
        private IAgitatorPrecinctRelationRepository agitatorPrecinctRelationRepository;
        private ICandidatePrecinctRelationRepository candidatePrecinctRelationRepository;
        private ICandidateMunicipalityRelationRepository candidateMunicipalityRelationRepository;
        private ITempPersonRepository tempPersonRepository;
        private IGEORepository geoRepository;
        private IPartyMemberRepository partyMemberRepository;
        private IPartySupporterRepository par

        public DataManager(IDistrictRepository districtRepository,
            ILocalityRepository localityRepository,
            IStreetRepository streetRepository,
            IHouseRepository houseRepository,
            IMunicipalityRepository municipalityRepository,
            IPersonRepository personRepository,
            INationalityRepository nationalityRepository,
            IEducationRepository educationRepository,
            IOrganizationRepository organizationRepository,
            IMunicipalityHouseRelationRepository municipalityHouseRelationRepository,
            IRegistrationRepository registrationRepository,
            IPartyRepository partyRepository,
            IPrecinctRepository precinctRepository,
            IUserRepository userRepository,
            IWorkerRepository workerRepository,
            IVoterPartyRelationRepository voterPartyRelationRepository,
            IVoterRepository voterRepository,
            IUserLogRepository userLogRepository,
  
namespace Exchange.Core.Dao
    public interface IInstrumentRepository
    {
        List<InstrumentHistory> FindInstrumentHistoriesBy(Guid instrumentId, DateTime startDate, DateTime endDate, ScopeKind scope);
        List<InstrumentHistory> FindInstrumentHistoriesBy(DateTime startDate, DateTime endDate, ScopeKind scope);
    }
    public class InstrumentRepository : IInstrumentRepository
    {
        private IGenericDAO<Instrument> _instrumetnDAO;
        private IGenericDAO<InstrumentHistory> _instrumetnHistoryDAO;
        public InstrumentRepository()
        {
        }
        public InstrumentRepository(IGenericDAO<Instrument> instrumetnDAO, IGenericDAO<InstrumentHistory> instrumetnHistoryDAO)
        {
            _instrumetnDAO = instrumetnDAO;
            _instrumetnHistoryDAO = instrumetnHistoryDAO;
        }
        public List<InstrumentHistory> FindInstrumentHistoriesBy(Guid instrumentId, DateTime startDate, DateTime endDate, ScopeKind scope)
        {           
        

                return (List<InstrumentHistory>) session
                        .CreateCriteria(typeof(InstrumentHistory))
                        .CreateAlias("Instrument",  "Instrument")                        
                        .Add(Restrictions.Between("DateStamp", startDate, endDate))
                        .Add(Restrictions.Eq("Scope", scope))
                        .Add(Restrictions.Eq("Instrument.Id", instrumentId))
                        .List<InstrumentHistory>();
            }
        }
        public List<InstrumentHistory> FindInstrumentHistoriesBy(DateTime startDate, DateTime endDate, ScopeKind scope)
        {
            {
                return (List<InstrumentHistory>)session
                        .CreateCriteria(typeof(InstrumentHistory))
                        .Add(Restrictions.Between("DateStamp", startDate, endDate))
                        .Add(Restrictions.Eq("Scope", scope))
                        .SetFetchMode("Instrument", FetchMode.Eager)
    
public class Galaxy : MonoBehaviour
	public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
	public GameObject chunkPrefab;
	public string worldName = "world";
	public void CreateChunk(int x, int y, int z)
	{
		WorldPos worldPos = new WorldPos(x, y, z);
		
		GameObject newChunkObject = Instantiate(chunkPrefab, new Vector3(x, y, z), Quaternion.Euler(Vector3.zero)) as GameObject;
		Chunk newChunk = newChunkObject.GetComponent<Chunk>();
		
		newChunk.pos = worldPos;
		newChunk.world = this;
		
		chunks.Add(worldPos, newChunk);
		
		
		newChunk.SetBlockUnmodified();
		
		Serialization.Load(newChunk);
	}
	public void DestroyChunk(int x, int y, int z)
	{
		Chunk chunk = null;
		if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
		{
			Serialization.SaveChunk(chunk);
			Object.Destroy(chunk.gameObject);
			chunks.Remove(new WorldPos(x, y, z));
		}
	}
	public Chunk GetChunk(int x, int y, int z) 
	{
		WorldPos pos = new WorldPos();
		float multiple = Chunk.CHUNK_S

		pos.x = Mathf.FloorToInt(x / multiple) * Chunk.CHUNK_SIZE;
		pos.y = Mathf.FloorToInt(y / multiple) * Chunk.CHUNK_SIZE;
		pos.z = Mathf.FloorToInt(z / multiple) * Chunk.CHUNK_SIZE;
		
		Chunk containerChunk = null;
		
		chunks.TryGetValue(pos, out containerChunk);
		
		return containerChunk;
	}
	public Block GetBlock(int x, int y, int z)
	{
		Chunk containerChunk = GetChunk(x, y, z);
		
		if (containerChunk != null)
		{
			Block block = containerChunk.GetBlock(x - containerChunk.pos.x,
			                                      y - containerChunk.pos.y,
			                                      z - containerChunk.pos.z);
			return block;
		}
		else
		{
			return new BlockAir();
		}
	}
	public void SetBlock(int x, int y, int z, Block block)
	{
		Chunk chunk = GetChunk(x, y, z);
		
		if (chunk != null)
		{
			chunk.SetBlock(x - chunk.pos.x, y - chunk.pos.y, z - chunk.pos.z, block);
			chunk.update = true;
			
			UpdateIfEqual(x - chunk.pos.x, 0, new WorldPos(x - 1, y, z));
			UpdateIfEqu
namespace _01_DataAccessLayer
    public class UnitOfWork
    {
        TaskManagementContext _context;
        public UnitOfWork()
        {
            _context = new TaskManagementContext();
        }
        CustomerRepository _customerRepository;
        public CustomerRepository CustomerRepository
        {
            get
            {
                if (_customerRepository == null)
                {
                    _customerRepository = new CustomerRepository(_context);
                }
                return _customerRepository;
            }
        }
        CustomerRequestRepository _customerRequestRepository;
        public CustomerRequestRepository CustomerRequestRepository
        {
            get
            {
                if (_customerRequestRepository == null)
                {
                    _customerRequestRepository = new CustomerRequestRepository(_context);
                }
                return _customerRequestRepository;
            }
        }


        public EmployeeRepository EmployeeRepository
        {
            get
            {
                if (_employeeRepository == null)
                {
                    _employeeRepository = new EmployeeRepository(_context);
                }
                return _employeeRepository;
            }
        }
        EmployeeTypeRepository _employeeTypeRepository;
        public EmployeeTypeRepository EmployeeTypeRepository
        {
            get
            {
                if (_employeeTypeRepository == null)
                {
                    _employeeTypeRepository = new EmployeeTypeRepository(_context);
                }
                return _employeeTypeRepository;
            }
        }
        ProjectRepository _projectRepository;
        public ProjectRepository ProjectRepository
        {
            get
            {
                if (_projectRepository == null)
                {
                    _projectRepository = new ProjectRepository(_context)

                }
                return _projectRepository;
            }
        }
        StatusRepository _statusRepository;
        public StatusRepository StatusRepository
        {
            get
            {
                if (_statusRepository == null)
                {
                    _statusRepository = new StatusRepository(_context);
                }
                return _statusRepository;
            }
        }
        TasksRepository _tasksRepository;
        public TasksRepository TasksRepository
        {
            get
            {
                if (_tasksRepository == null)
                {
                    _tasksRepository = new TasksRepository(_context);
                }
                return _tasksRepository;
            }
        }
        ProjectEmployeesRepository _projectEmployeesRepository;
        public ProjectEmployeesRepository ProjectEmployeesRepository
        {
            get
            {
                if (_projectEmployeesRepo
namespace nsCore.Areas.Products.Controllers
    public class DispatchController : BaseProductsController
    {
        [FunctionFilter("Products", "~/Accounts")]
        public virtual ActionResult Index()
        {
            Dictionary<string, string> startperiod = Periods.GetAllPeriods();
            ViewBag.dcStartPeriod = startperiod;
            ViewBag.dcCampaniaHasta = startperiod;
            return View();
        }
        [OutputCache(CacheProfile = "PagedGridData")]
        public virtual ActionResult Get(bool? status, int page, int pageSize, string orderBy, string description, string periodStart, string periodEnd, string sku, 
            string orderByDirection)
        {
            try
            {
                if (orderByDirection == "Descending")
                {
                    orderByDirection = "desc";
                }
                else
                {
                    orderByDirection = "asc";
                }
                var dispatchs = P

                {
                    PageSize = pageSize,
                    PageIndex = page,
                    OrderBy = orderBy,
                    Order = orderByDirection,
                    Description = description,
                    PeriodStart = periodStart,
                    PeriodEnd = periodEnd,
                    SKU = sku
                });
                if (!dispatchs.Any())
                {
                    return Json(new { result = true, totalPages = 0, page = String.Format("<tr><td colspan=\"6\">{0}</td></tr>", Translation.GetTerm("ThereAreNoDispatchs", "There are no dispatcs")) });
                }
                var builder = new StringBuilder();
                foreach (var dispatch in dispatchs)
                {
                     string controllerName = (dispatch.Description); 
                     string editUrl = string.Format("~/Products/{0}/Edit?dispatchID={1}", "Dispatch", dispatch.DispatchID);
                    builder.Append("<tr

                        .AppendCheckBoxCell(value: dispatch.DispatchID.ToString())
                        .AppendLinkCell(editUrl, dispatch.Description)
                        .AppendCell(dispatch.PeriodStart.ToString())
                        .AppendCell(dispatch.PeriodEnd.ToString())
                        .AppendCell(dispatch.DateStart.HasValue ? dispatch.DateStart.Value.ToString("g", CoreContext.CurrentCultureInfo) : string.Empty)
                        .AppendCell(dispatch.DateEnd.HasValue ? dispatch.DateEnd.Value.ToString("g", CoreContext.CurrentCultureInfo) : string.Empty)
                        .AppendCell(dispatch.Situacion.ToString())
                        .AppendCell(dispatch.ListName.ToString())
                        .Append("</tr>");
                }
                return Json(new { result = true, totalPages = dispatchs.TotalPages, page = dispatchs.TotalCount == 0 ? "<tr><td colspan=\"7\">There are no Dispatch</td></tr>" : builder.ToString() });
              
namespace KiraNet.GutsMvc.Implement
    public class ControllerFactoryProvider: IControllerFactoryProvider
    {
        private readonly ControllerCollection _controllerCollection;
        private readonly IControllerFactory _controllerFactory;
        private static ControllerCache _cache = new ControllerCache();
        public ControllerFactoryProvider(IControllerProvider controllerProvider, IControllerFactory controllerFactory =null)
        {
            if (controllerProvider == null)
                throw new ArgumentNullException(nameof(controllerProvider));
            _controllerCollection = controllerProvider.GetControllerCollection();
        }
        public Func<ControllerContext, Controller> CreateControllerFactory(ControllerDescriptor descriptor)
        {
            if (descriptor == null)
                throw new ArgumentNullException(nameof(descriptor));
            if (!_cache.TryGetController(descriptor.ControllerName, out var controllerTypeInfo))
            {
 

                        .Where(type =>
                        {
                            if (type.IsDefined(typeof(RouteControllerAttribute), true))
                            {
                                var routeController = type.GetCustomAttribute<RouteControllerAttribute>().RouteController;
                                if (String.Equals(routeController.ToLower().Replace("controller", ""), descriptor.ControllerName, StringComparison.OrdinalIgnoreCase))
                                {
                                    return true;
                                }
                            }
                            if (String.Equals(type.Name.ToLower().Replace("controller",""), descriptor.ControllerName, StringComparison.OrdinalIgnoreCase))
                            {
                                return true;
                            }
                            return false;
                        }).FirstOrDefault();
                if (controllerT

                {                  
                    throw new InvalidOperationException($"无法找到指定的控制器：{descriptor.ControllerName}");
                }
                else
                {
                    _cache.TryAddOrUpdateController(descriptor.ControllerName, controllerTypeInfo);
                }
            }
            descriptor.ControllerType = controllerTypeInfo;
            return context =>
            {
                if (context == null)
                    throw new ArgumentNullException(nameof(context));
                context.ControllerInfo = controllerTypeInfo;
                context.ControllerDescriptor = descriptor;
                var controller = _controllerFactory.CreateController(context);
                controller.RouteEntity = context.RouteEntity;
                return controller;
            };
        }
        public Action<ControllerContext, Controller> CreateControllerReleaser(ControllerDescriptor descriptor)
        {
            if (descr
﻿namespace Serpent.Common.MessageBus.MessageHandlerChain.Decorators.Filter
    internal class FilterDecorator<TMessageType> : MessageHandlerChainDecorator<TMessageType>
    {
        private readonly Func<TMessageType, CancellationToken, Task> handlerFunc;
        private readonly Func<TMessageType, CancellationToken, Task<bool>> beforeInvoke;
        private readonly Func<TMessageType, CancellationToken, Task> afterInvoke;
        public FilterDecorator(Func<TMessageType, CancellationToken, Task> handlerFunc, Func<TMessageType, CancellationToken, Task<bool>> beforeInvoke = null, Func<TMessageType, CancellationToken, Task> afterInvoke = null)
        {
            this.handlerFunc = handlerFunc;
            this.beforeInvoke = beforeInvoke;
            this.afterInvoke = afterInvoke;
        }
        public override async Task HandleMessageAsync(TMessageType message, CancellationToken token)
        {
            bool invoke = false;
            if (this.beforeInvoke != null)
        
namespace Kondor.Data.EF
    public class EFUnitOfWork : IUnitOfWork
    {
        private readonly IDbContext _context;
        private IRepository<Notification> _notificationRepository;
        private IRepository<Language> _languageRepository;
        private IRepository<Medium> _mediumRepository;
        private IRepository<CardState> _cardStateRepository;
        private IRepository<Deck> _deckRepository;
        private IRepository<SubDeck> _subDeckRepository;
        private ICardRepository _cardRepository;
        private IExampleRepository _exampleRepository;
        private IExampleViewRepository _exampleViewRepository;
        private IResponseRepository _responseRepository;
        private ISettingRepository _settingRepository;
        private IUpdateRepository _updateRepository;
        private IUserRepository _userRepository;
        public EFUnitOfWork(IDbContext context)
        {
            _context = context;
        }
        public IRepository<Notification> Notific

        public IRepository<Language> LanguageRepository => _languageRepository ?? (_languageRepository = new EFRepository<Language>(_context));
        public IRepository<Medium> MediumRepository => _mediumRepository ?? (_mediumRepository = new EFRepository<Medium>(_context));
        public IRepository<CardState> CardStateRepository => _cardStateRepository ?? (_cardStateRepository = new EFRepository<CardState>(_context));
        public IRepository<Deck> DeckRepository => _deckRepository ?? (_deckRepository = new EFRepository<Deck>(_context));
        public IRepository<SubDeck> SubDeckRepository => _subDeckRepository ?? (_subDeckRepository = new EFRepository<SubDeck>(_context));
        public ICardRepository CardRepository => _cardRepository ?? (_cardRepository = new EFCardRepository(_context));
        public IExampleRepository ExampleRepository => _exampleRepository ?? (_exampleRepository = new EFExampleRepository(_context));
        public IExampleViewRepository ExampleViewRepos

        public IResponseRepository ResponseRepository => _responseRepository ?? (_responseRepository = new EFResponseRepository(_context));
        public ISettingRepository SettingRepository => _settingRepository ?? (_settingRepository = new EFSettingRepository(_context));
        public IUpdateRepository UpdateRepository => _updateRepository ?? (_updateRepository = new EFUpdateRepository(_context));
        public IUserRepository UserRepository => _userRepository ?? (_userRepository = new EFUserRepository(_context));
        public void Save()
        {
            _context.SaveChanges();
        }
        protected virtual void Dispose(bool disposing)
        {
            if (!this._disposed)
            {
                if (disposing)
                {
                    _context.Dispose();
                }
            }
            this._disposed = true;
        }
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
       
namespace Rental.Repository
    public class UnitOfWork
    {
        private RentalEntities _edm = null;
        private SliderRepository _sliderRepository = null;
        private RoomRepository _roomRepository = null;
        private AreaRepository _areaRepository = null;
        private ServiceRepository _serviceRepository = null;
        private FoodRepository _foodRepository = null;
        private PreferenceRepository _preferenceRepository = null;
        private AboutRepository _aboutRepository = null;
        public UnitOfWork()
        {
            _edm = new RentalEntities();
        }
        public AboutRepository AboutRepository
        {
        }
        public PreferenceRepository PreferenceRepository
        {
            get
            {
                if (_preferenceRepository == null)
                {
                    _preferenceRepository = new PreferenceRepository(_edm);
                }
                return _preferenceRepository;
            }
        }

        public ServiceRepository ServiceRepository
        {
            get
            {
                if (_serviceRepository == null)
                {
                    _serviceRepository = new ServiceRepository(_edm);
                }
                return _serviceRepository;
            }
        }
        public FoodRepository FoodRepository
        {
            get
            {
                if (_foodRepository == null)
                {
                    _foodRepository = new FoodRepository(_edm);
                }
                return _foodRepository;
            }
        }
        public RoomRepository RoomRepository
        {
            get
            {
                if (_roomRepository == null)
                {
                    _roomRepository = new RoomRepository(_edm);
                }
                return _roomRepository;
            }
        }
        public AreaRepository AreaRepository
        {
            get
            {
              
namespace com.espertech.esper.multithread.dispatchmodel
    public class UpdateDispatchViewNonConcurrentModel : UpdateDispatchViewModel, Dispatchable
    {
        private DispatchService dispatchService;
        private DispatchListener dispatchListener;
    
        internal class ThreadLocalData
        {
            public bool IsDispatchWaiting;
            public LinkedList<int[]> Received;
            internal ThreadLocalData()
            {
                IsDispatchWaiting = false;
                Received = new LinkedList<int[]>();
            }
        }
        private readonly IThreadLocal<ThreadLocalData> threadLocalData =
            ThreadLocalManager.Create<ThreadLocalData>(() => new ThreadLocalData());
    
        private ThreadLocalData LocalData
        {
            get { return threadLocalData.GetOrCreate(); }
        }
        public UpdateDispatchViewNonConcurrentModel(DispatchService dispatchService, DispatchListener dispatchListener)
        {
            thi
namespace RentalModel.Repository.Generic.UnitofWork
    public partial interface IGenericUnitofWork :IDisposable
    {
      IGenericRepository<Agent> AgentRepository {get;}
     IGenericRepository<AgentAcceptedApplication> AgentAcceptedApplicationRepository {get;}
     IGenericRepository<AgentAcceptedPostedProject> AgentAcceptedPostedProjectRepository {get;}
     IGenericRepository<AgentPendingApplication> AgentPendingApplicationRepository {get;}
     IGenericRepository<AgentPendingPostedProject> AgentPendingPostedProjectRepository {get;}
     IGenericRepository<AgentProject> AgentProjectRepository {get;}
     IGenericRepository<AgentRejectedApplication> AgentRejectedApplicationRepository {get;}
     IGenericRepository<AgentRejectedPostedProject> AgentRejectedPostedProjectRepository {get;}
     IGenericRepository<aspnet_Applications> AspnetApplicationsRepository {get;}
     IGenericRepository<aspnet_Membership> AspnetMembershipRepository {get;}
     IGenericRepository<aspnet_Paths> As

     IGenericRepository<aspnet_PersonalizationAllUsers> AspnetPersonalizationAllUsersRepository {get;}
     IGenericRepository<aspnet_PersonalizationPerUser> AspnetPersonalizationPerUserRepository {get;}
     IGenericRepository<aspnet_Profile> AspnetProfileRepository {get;}
     IGenericRepository<aspnet_Roles> AspnetRolesRepository {get;}
     IGenericRepository<aspnet_SchemaVersions> AspnetSchemaVersionsRepository {get;}
     IGenericRepository<aspnet_Users> AspnetUsersRepository {get;}
     IGenericRepository<aspnet_WebEvent_Events> AspnetWebEventEventsRepository {get;}
     IGenericRepository<Basement> BasementRepository {get;}
     IGenericRepository<Bathroom> BathroomRepository {get;}
     IGenericRepository<Bed> BedRepository {get;}
     IGenericRepository<Cooling> CoolingRepository {get;}
     IGenericRepository<Currency> CurrencyRepository {get;}
     IGenericRepository<Floor> FloorRepository {get;}
     IGenericRepository<FloorCovering> FloorCoveringRepository {get;}
     IG

     IGenericRepository<Garage> GarageRepository {get;}
     IGenericRepository<GeneratedRentalContract> GeneratedRentalContractRepository {get;}
     IGenericRepository<Heating> HeatingRepository {get;}
     IGenericRepository<MaintenanceCompany> MaintenanceCompanyRepository {get;}
     IGenericRepository<MaintenanceCompanyLookUp> MaintenanceCompanyLookUpRepository {get;}
     IGenericRepository<MaintenanceCompanySpecialization> MaintenanceCompanySpecializationRepository {get;}
     IGenericRepository<MaintenanceCrew> MaintenanceCrewRepository {get;}
     IGenericRepository<MaintenanceCustomService> MaintenanceCustomServiceRepository {get;}
     IGenericRepository<MaintenanceExterior> MaintenanceExteriorRepository {get;}
     IGenericRepository<MaintenanceInterior> MaintenanceInteriorRepository {get;}
     IGenericRepository<MaintenanceNewConstruction> MaintenanceNewConstructionRepository {get;}
     IGenericRepository<MaintenanceOrder> MaintenanceOrderRepository {get;}
     IGeneric
namespace Nvsg.WinService.Processes
    public class BgjAdapter : ICloudProcess
    {
        private readonly ICloudProcess _bgjProcess;
        public BgjAdapter(ICloudProcess bgjProcess)
        {
            _bgjProcess = bgjProcess;
        }
        public void Process() => _bgjProcess.Process();
        public void Run() =>_bgjProcess.Run();
        public string Route => _bgjProcess.Route;
    }
    public class CompareResultAdapter : ICloudProcess
    {
        private readonly ICloudProcess _compareResultProcess;
        public CompareResultAdapter(ICloudProcess compareResultProcess)
        {
            _compareResultProcess = compareResultProcess;
        }
        public void Run() => _compareResultProcess.Run();
        public void Process() => _compareResultProcess.Process();
        public string Route => _compareResultProcess.Route;
    }
    public class DumpAdapter : ICloudProcess
    {
        private readonly ICloudProcess _dumpProcess;
        public DumpAdapter(

        {
            _dumpProcess = dumpProcess;
        }
        public void Run() => _dumpProcess.Run();
        public void Process() => _dumpProcess.Process();
        public string Route => _dumpProcess.Route;
    }
    public class EditOpenAdapter : ICloudProcess
    {
        private readonly ICloudProcess _editOpenProcess;
        public EditOpenAdapter(ICloudProcess editOpenProcess)
        {
            _editOpenProcess = editOpenProcess;
        }
        public void Run() => _editOpenProcess.Run();
        public void Process() => _editOpenProcess.Process();
        public string Route => _editOpenProcess.Route;
    }
    public class ExceptionAdapter : ICloudProcess
    {
        private readonly ICloudProcess _exceptionProcess;
        public ExceptionAdapter(ICloudProcess exceptionProcess)
        {
            _exceptionProcess = exceptionProcess;
        }
        public void Run() => _exceptionProcess.Run();
        public void Process() => _exceptionProcess.Proces

        public string Route => _exceptionProcess.Route;
    }
    public class HardwareAdapter : ICloudProcess
    {
        private readonly ICloudProcess _hardwareProcess;
        public HardwareAdapter(ICloudProcess hardwareProcess)
        {
            _hardwareProcess = hardwareProcess;
        }
        public void Run() => _hardwareProcess.Run();
        public void Process() => _hardwareProcess.Process();
        public string Route => _hardwareProcess.Route;
    }
    public class HourAverageAdapter : ICloudProcess
    {
        private readonly ICloudProcess _hourAverageProcess;
        public HourAverageAdapter(ICloudProcess hourAverageProcess)
        {
            _hourAverageProcess = hourAverageProcess;
        }
        public void Run() => _hourAverageProcess.Run();
        public void Process() => _hourAverageProcess.Process();
        public string Route => _hourAverageProcess.Route;
    }
    public class LockAdapter : ICloudProcess
    {
        private readonly 
namespace BlogEngine.Core.Work
    public class UnitOfWork : IUnitOfWork, IDisposable
    {
        private readonly BlogContext _context = new BlogContext();
        private BlogRepository _blogRepository;
        private CategoryRepository _categoryRepository;
        private UserRepository _userRepository;
        private CommentRepository _commentRepository;
        private VoteRepository _voteRepository;
        private TagRepository _tagRepository;
        private MessageRepository _messageRepository;
        private bool _disposed = false;
        public IBlogRepository BlogRepository
        {
            get
            {
                if (this._blogRepository == null)
                {
                    this._blogRepository = new BlogRepository(_context);
                }
                return _blogRepository;
            }
        }
        public ICategoryRepository CategoryRepository
        {
            get
            {
                if (this._categoryRepository

                {
                    this._categoryRepository = new CategoryRepository(_context);
                }
                return _categoryRepository;
            }
        }
        public ICommentRepository CommentRepository
        {
            get
            {
                if (this._commentRepository == null)
                {
                    this._commentRepository = new CommentRepository(_context);
                }
                return _commentRepository;
            }
        }
        public IUserRepository UserRepository
        {
            get
            {
                if (this._userRepository == null)
                {
                    this._userRepository = new UserRepository(_context);
                }
                return _userRepository;
            }
        }
        public IVoteRepository VoteRepository
        {
            get
            {
                if (this._voteRepository == null)
                {
                    this

                }
                return _voteRepository;
            }
        }
        public ITagRepository TagRepository
        {
            get 
            {
                if (this._tagRepository == null)
                {
                    this._tagRepository = new TagRepository(_context);
                }
                return _tagRepository;
            }
        }
        public IMessageRepository MessageRepository
        {
            get
            {
                if (this._messageRepository == null)
                {
                    this._messageRepository = new MessageRepository(_context);
                }
                return _messageRepository;
            }
        }
        public void Save()
        {
            _context.SaveChanges();
        }
        protected virtual void Dispose(bool disposing)
        {
            if (!this._disposed)
            {
                if (disposing)
                {
                    _context.Dispose();
  
namespace Sample.Github
    public class GithubAPI
    {
        public string authString { get; set; }
        
        public UserAPI user { get; set; }
        public RepoAPI GetRepo(string owner, string name)
        {
            var api = GithubAPIFactory.Create<RepoAPI>(authString);
            api.owner = owner;
            api.name = name;
            return api;
        }
        public GistAPI GetGist(string id)
        {
            var api = GithubAPIFactory.Create<GistAPI>(authString);
            api.id = id;
            return api;
        }
    }
    
    public static class GithubAPIFactory
    {
        public static GithubAPI Create(string username, string password)
        {
            var api = new GithubAPI();
            api.authString = "Basic " + Convert.ToBase64String(
                Encoding.UTF8.GetBytes($"{username}:{password}"));
            api.user = Create<UserAPI>(api.authString);
            return api;
        }
        internal static T Create<T>
namespace NScumm.Scumm.Audio.IMuse
    enum InstrumentType
    {
        None = 0,
        Program = 1,
        AdLib = 2,
        Roland = 3,
        PcSpk = 4,
        MacSfx = 5
    }
    class Instrument
    {
        InstrumentType _type;
        IInstrumentInternal _instrument;
        static bool _native_mt32;
        public static void NativeMT32(bool native)
        {
            _native_mt32 = native;
        }
        public static readonly byte[] _gmRhythmMap =
            {
                0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
                0,  0,  0,  0,  0,  0,  0,  0, 36, 37, 38, 39, 40, 41, 66, 47,
                65, 48, 56
            };
        public void Clear()
        {
            _instrument = null;
            _type = InstrumentType.None;
        }
        public void CopyTo(Instrument dest)
        {
            if (_instrument != null)
                _instrument.CopyTo(dest);
            else
                dest.Clear();
       

        public void Program(byte program, bool mt32)
        {
            Clear();
            if (program > 127)
                return;
            _type = InstrumentType.Program;
            _instrument = new InstrumentProgram(program, mt32);
        }
        public void Adlib(byte[] instrument)
        {
            Clear();
            if (instrument == null)
                return;
            _type = InstrumentType.AdLib;
            _instrument = new InstrumentAdLib(instrument);
        }
        public void Roland(byte[] instrument)
        {
            throw new NotImplementedException();
        }
        public void PcSpk(byte[] instrument)
        {
            Clear();
            if (instrument == null)
                return;
            _type = InstrumentType.PcSpk;
            _instrument = new InstrumentPcSpk(instrument);
        }
        public void MacSfx(byte program)
        {
            throw new NotImplementedException();
        }
        public Instrume

        public bool IsValid { get { return (_instrument != null && _instrument.IsValid); } }
        public void SaveOrLoad(Serializer s)
        {
            if (!s.IsLoading)
            {
                s.Writer.WriteByte((byte)_type);
                if (_instrument != null)
                    _instrument.SaveOrLoad(s);
            }
            else
            {
                Clear();
                _type = (InstrumentType)s.Reader.ReadByte();
                switch (_type)
                {
                    case InstrumentType.None:
                        break;
                    case InstrumentType.Program:
                        _instrument = new InstrumentProgram(s);
                        break;
                    case InstrumentType.AdLib:
                        _instrument = new InstrumentAdLib(s.Reader.BaseStream);
                        break;
                    case InstrumentType.PcSpk:
                        _instrument = new InstrumentPcSpk(s.Read
namespace SEMining.StockData.DataServices.Trades.Finam
    class FinamTradesDownloader : ITradesDownloader
    {
        public void Download(Instrument instrument)
        {
            new WebClient().DownloadFile(Url(instrument), instrument.DataProvider + "\\" + instrument.Path +"\\"+ instrument.FileName + ".txt");
        }
        private string Url(Instrument instrument)
        {
            StringBuilder urlBuilder = new StringBuilder();
            urlBuilder
                .Append("export.finam.ru")
                .Append("/")
                .Append(instrument.FileName)
                .Append(".txt?")
                .Append("market=").Append(instrument.MarketId).Append("&")
                .Append("em=").Append(instrument.Id).Append("&")
                .Append("code=").Append(instrument.Code).Append("&")
                .Append("df=").Append(instrument.From.Day).Append("&")
                .Append("mf=").Append(instrument.From.Month - 1).Append("&")
                .App

                .Append("from=").Append(instrument.From.ToShortDateString()).Append("&")
                .Append("dt=").Append(instrument.To.Day).Append("&")
                .Append("mt=").Append(instrument.To.Month - 1).Append("&")
                .Append("yt=").Append(instrument.To.Year).Append("&")
                .Append("to=").Append(instrument.To.ToShortDateString()).Append("&")
                .Append("p=").Append(1).Append("&")
                .Append("f=")
                .Append(instrument.FileName)
                .Append("&")
                .Append("e=").Append(".txt").Append("&")
                .Append("cn=").Append(instrument.Name).Append("&")
                .Append("dtf=").Append(1).Append("&")
                .Append("tmf=").Append(1).Append("&")
                .Append("MSOR=").Append(1).Append("&")
                .Append("mstime=").Append("on").Append("&")
                .Append("mstimever=").Append(1).Append("&")
                .Append("sep=").Append(1).Append
public class ChunkLib
    public static bool ChunkExists(World world, Chunk detectionChunk, int x, int y, int z)
    {
        if (detectionChunk.numID.x + x < world.chunkNumber.x &&
            detectionChunk.numID.x + x >= 0 &&
            detectionChunk.numID.y + y < world.chunkNumber.y &&
            detectionChunk.numID.y + y >= 0 &&
            detectionChunk.numID.z + z < world.chunkNumber.z &&
            detectionChunk.numID.z + z >= 0)
            return true;
        else
            return false;
    }
    public static bool ChunkExists(World world, IntVector3 numID)
    {
        if (numID.x < world.chunkNumber.x &&
            numID.x >= 0 &&
            numID.y < world.chunkNumber.y &&
            numID.y >= 0 &&
            numID.z < world.chunkNumber.z &&
            numID.z >= 0)
            return true;
        else
            return false;
    }
    public static void Reset(World world, Chunk detectionChunk, Voxel detectionVoxel)
    {
        int xSign, ySign, zSi

        if (detectionVoxel.numID.x < world.chunkSize.x / 2)
            xSign = -1;
        else
            xSign = 1;
        if (detectionVoxel.numID.y < world.chunkSize.y / 2)
            ySign = -1;
        else
            ySign = 1;
        if (detectionVoxel.numID.z < world.chunkSize.z / 2)
            zSign = -1;
        else
            zSign = 1;
        world.chunksToReset.Add(new IntVector3(detectionChunk.numID.x, detectionChunk.numID.y, detectionChunk.numID.z));
        if (ChunkLib.ChunkExists(world, detectionChunk, xSign, 0, 0))
            world.chunksToReset.Add(new IntVector3(detectionChunk.numID.x + xSign, detectionChunk.numID.y, detectionChunk.numID.z));
        if (ChunkLib.ChunkExists(world, detectionChunk, 0, ySign, 0))
            world.chunksToReset.Add(new IntVector3(detectionChunk.numID.x, detectionChunk.numID.y + ySign, detectionChunk.numID.z));
        if (ChunkLib.ChunkExists(world, detectionChunk, 0, 0, zSign))
            world.chunksToReset.Add(new In
namespace HBoop.Business.Layer
    public class BusinessLayer : IBusinessLayer, IDisposable
    {
        public IManager<Address> AddressRepository { get; }
        public IManager<Beneficiary> BeneficiaryRepository { get; }
        public IManager<Affiliate> AffiliateRepository { get; }
        public IManager<BookingDetail> BookingDetailRepository { get; }
        public IManager<Booking> BookingRepository { get; }
        public IManager<Comment> CommentRepository { get; }
        public IManager<CreditCard> CreditCardRepository { get; }
        public IManager<Currency> CurrencyRepository { get; }
        public IManager<Discount> DiscountRepository { get; }
        public IManager<Language> LanguageRepository { get; }
        public IManager<Media> MediaRepository { get; }
        public IManager<Message> MessageRepository { get; }
        public IManager<Notification> NotificationRepository { get; }
        public IManager<OrderDetail> OrderDetailRepository { get; }
        publ

        public IManager<Person> PersonRepository { get; }
        public IManager<Price> PriceRepository { get; }
        public IManager<ProductCategory> ProductCategoryRepository { get; }
        public IManager<Product> ProductRepository { get; }
        public IManager<Role> RoleRepository { get; }
        public IManager<ShipMethod> ShipMethodRepository { get; }
        public IManager<Store> StoreRepository { get; }
        public IManager<User> UserRepository { get; }
        public IManager<Vat> VatRepository { get; }
        public BusinessLayer(
            IManager<Address> addressRepository,
            IManager<Beneficiary> beneficiaryRepository,
            IManager<Affiliate> affiliateRepository,
            IManager<Comment> commentRepository,
            IManager<Comment> CommentRepository,
            IManager<CreditCard> creditCardRepository,
            IManager<Currency> currencyRepository,
            IManager<Discount> discountRepository,
            IManager<La

            IManager<Media> mediaRepository,
            IManager<Message> messageRepository,
            IManager<Notification> notificationRepository,
            IManager<Order> OrderRepository,
            IManager<OrderDetail> orderDetailRepository,
            IManager<Person> personRepository,
            IManager<Booking> bookingRepository,
            IManager<BookingDetail> bookingDetailRepository,
            IManager<Product> productRepository,
            IManager<ProductCategory> productCategoryRepository,
            IManager<Role> roleRepository,
            IManager<ShipMethod> shipMethodRepository,
            IManager<Store> storeRepository,
            IManager<User> userRepository,
            IManager<Vat> vatRepository
            )
        {
            this.AddressRepository = addressRepository;
            this.BeneficiaryRepository = beneficiaryRepository;
            this.AffiliateRepository = affiliateRepository;
            this.CommentRepository = commen
namespace Galssoft.VKontakteWM.Components.MVC
    public class DefaultControllerProvider : IControllerProvider
    {
        private Dictionary<string, Controller> controllerCache;
        private Dictionary<Type, Controller> typeMap;
        public DefaultControllerProvider()
        {
            controllerCache = new Dictionary<string, Controller>();
            typeMap = new Dictionary<Type, Controller>();
        }
        #region IControllerProvider Members
        public Controller GetController(string name)
        {
            Controller controller = null;
            if (!controllerCache.TryGetValue(name, out controller))
            {
                throw new ArgumentException("Controller is not registered.");
            }
            return controller;
        }
        public Controller GetController<T>()
        {
            Controller controller = null;
            if (!typeMap.TryGetValue(typeof(T), out controller))
            {
                throw new ArgumentEx

            }
            return controller;
        }
        public Controller GetController(Type type)
        {
            Controller controller = null;
            if (!typeMap.TryGetValue(type, out controller))
            {
                throw new ArgumentException("Controller is not registered.");
            }
            return controller;
        }
        public Controller GetController<T>(IView view)
        {
            Controller controller = null;
            if (!typeMap.TryGetValue(typeof(T), out controller))
            {
                controller = this.CreateController(typeof(T));
                controller.View = view;
            }
            return controller;
        }
        public void RegisterController(Controller controller)
        {
            if (!controllerCache.ContainsKey(controller.Name))
            {
                controllerCache.Add(controller.Name, controller);
                typeMap.Add(controller.GetType(), controller);
            
﻿namespace Sean.World
	public struct ChunkCoords
	{
		public ChunkCoords(int x, int z)
		{
			X = x;
			Z = z;
			WorldCoordsX = X * Chunk.CHUNK_SIZE;
			WorldCoordsZ = Z * Chunk.CHUNK_SIZE;
		}
		public ChunkCoords(ref Coords coords)
		{
			X = coords.Xblock / Chunk.CHUNK_SIZE;
			Z = coords.Zblock / Chunk.CHUNK_SIZE;
			WorldCoordsX = X * Chunk.CHUNK_SIZE;
			WorldCoordsZ = Z * Chunk.CHUNK_SIZE;
		}
		public readonly int X;
		public readonly int Z;
		public int WorldCoordsX;
		public int WorldCoordsZ;
		public static bool operator ==(ChunkCoords c1, ChunkCoords c2)
		{
			return c1.X == c2.X && c1.Z == c2.Z;
		}
		public static bool operator !=(ChunkCoords c1, ChunkCoords c2)
		{
			return c1.X != c2.X || c1.Z != c2.Z;
		}
		public override bool Equals(object obj)
		{
			return X == ((ChunkCoords)obj).X && Z == ((ChunkCoords)obj).Z;
		}
		public override int GetHashCode()
		{
			return base.GetHashCode();
		}
		public override string ToString()
		{
			return string.Format("({0},{1})"
namespace XmlCrud
    class Program
    {
        static void Main(string[] args)
        {
            var band = new Band()
            {
                Name = "Pink Floyd",
                Vocalist = new Leader()
                {
                    Name = "Roger Waters"
                },
                Musicians = new List<Musician>()
                {
                    new Musician()
                    {
                        Name = "Sid Barret",
                        Instrument = new Instrument()
                        {
                            Name = "Electic-Guitar",
                            Type = InstrumentType.keyboard
                        }
                    },
                    new Musician()
                    {
                        Name = "Nick Mayson",
                        Instrument = new Instrument()
                        {
                            Name = "Drums",
                            Type = InstrumentType.drum
            

                    },
                    new Musician()
                    {
                        Name = "Richard Wright",
                        Instrument = new Instrument()
                        {
                            Name = "Electic-Piano",
                            Type = InstrumentType.keyboard
                        }
                    },
                }
            };
            XmlWorker worker = new XmlWorker();
            worker.Create(band);
            worker.Delete(new Musician()
            {
                Name = "Sid Barret",
                Instrument = new Instrument()
                {
                    Name = "Electic-Guitar",
                    Type = InstrumentType.keyboard
                }
            },
                band);
            worker.Update(new Musician()
            {
                Name = "David Gilmour",
                Instrument = new Instrument()
                {
                    Name = "Electic-Guitar",
    
namespace BeeGame.Terrain.LandGeneration
    public class World : MonoBehaviour
    {
        #region Data
        public Dictionary<ChunkWorldPos, Chunk> chunks = new Dictionary<ChunkWorldPos, Chunk>();
        public GameObject chunkPrefab;
        public bool chunkHasMadeCollisionMesh = false;
        #endregion
        #region Creation and Destruction
        #region Chunk
        public void CreateChunk(int x, int y, int z)
        {
            ChunkWorldPos pos = new ChunkWorldPos(x, y, z);
            GameObject newChunk = Instantiate(chunkPrefab, new Vector3(x, y, z), Quaternion.identity);
            
            Chunk chunk = newChunk.GetComponent<Chunk>();
            chunk.chunkWorldPos = pos;
            chunk.world = this;
            chunks.Add(pos, chunk);
            chunk = new TerrainGeneration().ChunkGen(chunk);
            
            Serialization.Serialization.LoadChunk(chunk);
            chunks.TryGetValue(new ChunkWorldPos(x, y - 16, z), out chunk);
        

                chunk.update = true;
            chunks.TryGetValue(new ChunkWorldPos(x, y, z - 16), out chunk);
            if (chunk != null)
                chunk.update = true;
            chunks.TryGetValue(new ChunkWorldPos(x - 16, y, z), out chunk);
            if (chunk != null)
                chunk.update = true;
            chunks.TryGetValue(new ChunkWorldPos(x, y + 16, z), out chunk);
            if (chunk != null)
                chunk.update = true;
            chunks.TryGetValue(new ChunkWorldPos(x, y, z + 16), out chunk);
            if (chunk != null)
                chunk.update = true;
            chunks.TryGetValue(new ChunkWorldPos(x + 16, y, z), out chunk);
            if (chunk != null)
                chunk.update = true;
        }
        public void DestroyChunk(int x, int y, int z)
        {
            if (chunks.TryGetValue(new ChunkWorldPos(x, y, z), out Chunk chunk))
            {
                Serialization.Serialization.SaveChunk(chunk);
           

                chunks.Remove(new ChunkWorldPos(x, y, z));
            }
        }
        #endregion
        #region Block
        public void SetBlock(int x, int y, int z, Block block, bool saveChunk = false)
        {
            Chunk chunk = GetChunk(x, y, z);
            if(chunk != null && chunk.blocks[x - chunk.chunkWorldPos.x, y - chunk.chunkWorldPos.y, z - chunk.chunkWorldPos.z].breakable)
            {
                chunk.SetBlock(x - chunk.chunkWorldPos.x, y - chunk.chunkWorldPos.y, z - chunk.chunkWorldPos.z, block);
                chunk.update = true;
                
                UpdateIfEqual(x - chunk.chunkWorldPos.x, 0, new ChunkWorldPos(x - 1, y, z));
                UpdateIfEqual(x - chunk.chunkWorldPos.x, Chunk.chunkSize - 1, new ChunkWorldPos(x + 1, y, z));
                UpdateIfEqual(y - chunk.chunkWorldPos.y, 0, new ChunkWorldPos(x, y - 1, z));
                UpdateIfEqual(y - chunk.chunkWorldPos.y, Chunk.chunkSize - 1, new ChunkWorldPos(x, y + 1, z));

namespace SisOpe.Data.Repository.Repositories
    public class UnitOfWork : IUnitOfWork
    {
        #region propriedades
        private IAcessoRepository _acessoRepository;
        private IAcessoUsuarioRepository _acessoUsuarioRepository;
        private IArquivosOrdemServicoRepository _arquivosOrdemServicoRepository;
        private IContato_PJRepository _contato_PJRepository;
        private ICotacaoRepository _cotacaoRepository;
        private IDepartamentoRepository _departamentoRepository;
        private IEmailRepository _emailRepository;
        private IEnderecoRepository _enderecoRepository;
        private IEntradaProdutoNFRepository _entradaProdutoNFRepository;
        private IEntradaProdutoRepository _entradaProdutoRepository;
        private IEquipeOrdemServicoRepository _equipeOrdemServicoRepository;
        private IFinalidadeRepository _finalidadeRepository;
        private IFormaPagamentoRepository _formaPagamentoRepository;
        private IFornecedorCotacaoRepo

        private IFuncionarioRepository _funcionarioRepository;
        private IHistoricoOrdemServicoRepository _historicoOrdemServicoRepository;
        private IHistoricoStatusCotacaoRepository _historicoStatusCotacaoRepository;
        private IItemEntradaEstoqueRepository _itemEntradaEstoqueRepository;
        private IItemEstoqueRepository _itemEstoqueRepository;
        private IItemPedidoCompraCotacaoRepository _itemPedidoCompraCotacaoRepository;
        private IItemPedidoCompraRepository _itemPedidoCompraRepository;
        private IItemProdutoNotaFiscalRepository _itemProdutoNotaFiscalRepository;
        private IItemReservaVendaProdutoRepository _itemReservaVendaProdutoRepository;
        private IItemRetornoCotacaoRepository _itemRetornoCotacaoRepository;
        private IItemSolicitacaoCompraCotacaoRepository _itemSolicitacaoCompraCotacaoRepository;
        private IItemSolicitacaoCompraRepository _itemSolicitacaoCompraRepository;
        private IItemTransferenciaEstoque

        private IItemVendaEstoqueRepository _itemVendaEstoqueRepository;
        private IMarcaProdutoRepository _marcaProdutoRepository;
        private INotaFiscalRepository _notaFiscalRepository;
        private IOrdemServicoRepository _ordemServicoRepository;
        private IPagamentoOrdemServicoRepository _pagamentoOrdemServicoRepository;
        private IPagamentoPedidoCompraRepository _pagamentoPedidoCompraRepository;
        private IPagamentoRetornoCotacaoRepository _pagamentoRetornoCotacaoRepository;
        private IPedidoCompraRepository _pedidoCompraRepository;
        private IPessoaFisicaRepository _pessoaFisicaRepository;
        private IPessoaJuridicaRepository _pessoaJuridicaRepository;
        private IPessoaRepository _pessoaRepository;
        private IProdutoCotacaoRepository _produtoCotacaoRepository;
        private IProdutoRepository _produtoRepository;
        private IProfissaoFuncionarioRepository _profissaoFuncionarioRepository;
        private IProfissa
﻿namespace Cinema.Data.Infrastructure
    public class EFUnitOfWork : IUnitOfWork
    {
        public EFUnitOfWork() : this(new CinemaContext()) { }
        public EFUnitOfWork(CinemaContext context) 
        {
            Context = context;
        }
        public CinemaContext Context { get; private set; }
        
        #region IDisposable && Dispose(bool)
        public void Dispose()
        {
            Dispose(true);
        }
        private bool _disposed;
        private void Dispose(bool disposing)
        {
            if (Context != null && !_disposed && disposing)
            {
                Context.Dispose();
            }
            _disposed = true;
        }
        #endregion
        #region IUnitOfWork members EFGenericRepository<T>
        private EFGenericRepository<Booking> _bookingRepository;
        private EFGenericRepository<Hall> _hallRepository;
        private EFGenericRepository<LoginToken> _loginTokenRepository;
        private EFGenericRepositor

        private EFGenericRepository<Movie> _movieRepository;
        private EFGenericRepository<ScreeningInfo> _screeningInfoRepository;
        private EFGenericRepository<Screening> _screeningRepository;
        private EFGenericRepository<Seat> _seatRepository;
        private EFGenericRepository<Ticket> _ticketRepository;
        private EFGenericRepository<TicketType> _ticketTypeRepository;
        private EFGenericRepository<User> _userRepository;
        public IGenericRepository<Booking> BookingRepository
        {
            get
            {
                _bookingRepository = _bookingRepository ?? new EFGenericRepository<Booking>(Context);
                return _bookingRepository;
            }
        }
        public IGenericRepository<Hall> HallRepository
        {
            get
            {
                _hallRepository = _hallRepository ?? new EFGenericRepository<Hall>(Context);
                return _hallRepository;
            }
        }
        public IGe

        {
            get
            {
                _loginTokenRepository = _loginTokenRepository ?? new EFGenericRepository<LoginToken>(Context);
                return _loginTokenRepository;
            }
        }
        public IGenericRepository<MovieInfo> MovieInfoRepository
        {
            get
            {
                _movieInfoRepository = _movieInfoRepository ?? new EFGenericRepository<MovieInfo>(Context);
                return _movieInfoRepository;
            }
        }
        public IGenericRepository<Movie> MovieRepository
        {
            get
            {
                _movieRepository = _movieRepository ?? new EFGenericRepository<Movie>(Context);
                return _movieRepository;
            }
        }
        public IGenericRepository<ScreeningInfo> ScreeningInfoRepository
        {
            get
            {
                _screeningInfoRepository = _screeningInfoRepository ?? new EFGenericRepository<ScreeningInfo>(Context);
     
public class AIScript : ICommand
    public void Think(IPlayerApi api)
    {
        if (!api.GetEnemySighted())
        {
            if ((api.GetHealth() < 100) && (api.GetNumberofVisibleMedkits() > 0))
            {
                api.GetNearestMedkit();
            }
            else
            {
                if ((api.GetAmmo() < 3) && (api.GetNumberOfVisibleBazookas() > 0))
                {
                    api.GetNearestBazooka();
                }
                else
                {
                    api.MoveToRandomLocation();
                }
            }
        }
        else
        {
            if ((api.GetHealth() < 40) && (api.GetNumberofVisibleMedkits() > 0))
            {
                api.GetNearestMedkit();
            }
            else
            {
                if (api.GetAmmo() == 0)
                {
                    api.Stop();
                    api.ShootBullet(api.GetEnemyPosition());
                }
                else
          
public abstract class TerrainMeshGenerator
    #region Constants
    public const int DefaultBlockDepth = 2;
    #endregion
    #region Constructor
    public TerrainMeshGenerator()
    {
        this.BlockDepth = DefaultBlockDepth;
        this.MaterialLookup = new MaterialLookup();
    }
    #endregion
    #region Properties
    public int BlockDepth { get; set; }
    protected MaterialLookup MaterialLookup { get; set; }
    #endregion
    #region Public Methods
    public virtual void UpdateChunkMesh(Terrain terrain, Vector2I chunkIndex)
    {
        Chunk chunk = terrain.Blocks[chunkIndex];
        if ((chunk.Usage & ChunkUsage.Rendering) == 0)
        {
            throw new ApplicationException(string.Format("The chunk {0} does not support rendering.", chunkIndex));
        }
        Chunk chunkUp, chunkRight, chunkDown, chunkLeft;
        terrain.Blocks.TryGetChunk(new Vector2I(chunkIndex.X, chunkIndex.Y + 1), out chunkUp);
        terrain.Blocks.TryGetChunk(new Vector2I(chunkI

        terrain.Blocks.TryGetChunk(new Vector2I(chunkIndex.X, chunkIndex.Y - 1), out chunkDown);
        terrain.Blocks.TryGetChunk(new Vector2I(chunkIndex.X - 1, chunkIndex.Y), out chunkLeft);
        for (int x = 0; x < Chunk.SizeX; x++)
        {
            for (int y = 0; y < Chunk.SizeY; y++)
            {
                this.UpdateBlockMesh(terrain, x, y, chunk, chunkIndex, chunkUp, chunkRight, chunkDown, chunkLeft);
            }
        }
    }
    public void UpdateBlock(Terrain terrain, Vector2I position, bool updateNeighbours)
    {
        Vector2I chunkIndex = TerrainBlocks.GetChunkIndex(position.X, position.Y);
        Chunk chunk = terrain.Blocks[chunkIndex];
        if ((chunk.Usage & ChunkUsage.Rendering) == 0)
        {
            throw new ApplicationException(string.Format("The chunk {0} does not support rendering.", chunkIndex));
        }
        Vector2I chunkIndexUp = new Vector2I(chunkIndex.X, chunkIndex.Y + 1);
        Vector2I chunkIndexRight = new Vector

        Vector2I chunkIndexDown = new Vector2I(chunkIndex.X, chunkIndex.Y - 1);
        Vector2I chunkIndexLeft = new Vector2I(chunkIndex.X - 1, chunkIndex.Y);
        Chunk chunkUp, chunkRight, chunkDown, chunkLeft;
        terrain.Blocks.TryGetChunk(chunkIndexUp, out chunkUp);
        terrain.Blocks.TryGetChunk(chunkIndexRight, out chunkRight);
        terrain.Blocks.TryGetChunk(chunkIndexDown, out chunkDown);
        terrain.Blocks.TryGetChunk(chunkIndexLeft, out chunkLeft);
        int chunkX = position.X & Chunk.MaskX;
        int chunkY = position.Y & Chunk.MaskY;
        this.UpdateBlockMesh(terrain, chunkX, chunkY, chunk, chunkIndex, chunkUp, chunkRight, chunkDown, chunkLeft);
        if (updateNeighbours)
        {
            if (chunkY != Chunk.SizeY - 1)
            {
                this.UpdateBlockMesh(
                    terrain, chunkX, chunkY + 1, chunk, chunkIndex, chunkUp, chunkRight, chunkDown, chunkLeft);
            }
            else if (chunkUp != null)
      
﻿#region copyright
#endregion
namespace Flux
    public class Dispatcher
    {
        protected Dictionary<DispatchToken, Action<IPayload>> callbackRegistry = new Dictionary<DispatchToken, Action<IPayload>>();
        protected IPayload currentPayload = null;
        protected List<DispatchToken> isPending = new List<DispatchToken>();
        protected List<DispatchToken> isHandled = new List<DispatchToken>();
        public bool IsDispatching { get; protected set; }
        public string Version
        {
            get
            {
                return System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString();
            }
        }
        public DispatchToken Register(Action<IPayload> callback)
        {
            DispatchToken dispatchToken = new DispatchToken();
            callbackRegistry.Add(dispatchToken, callback);
            return dispatchToken;
        }
        public void Deregister(DispatchToken dispatchToken)
        {
            if (!Ha

                throw new DispatcherExceptions.InvalidCallbackException();
            callbackRegistry.Remove(dispatchToken);
        }
        public bool HasRegistered(DispatchToken dispatchToken)
        {
            return dispatchToken != null && callbackRegistry.ContainsKey(dispatchToken);
        }
        public void Dispatch(IPayload payload)
        {
            if (IsDispatching)
                throw new DispatcherExceptions.AlreadyDispatchingException();
            startDispatching(payload);
            try
            {
                foreach (KeyValuePair<DispatchToken, Action<IPayload>> callback in callbackRegistry)
                {
                    if (isPending.Contains(callback.Key))
                        continue;
                    invokeCallback(callback.Key);
                }
            }
            finally
            {
                stopDispatching();
            }
        }
        public void Dispatch(string action, object data)
        {
  

        }
        public void Dispatch(string action)
        {
            Dispatch(new Payload(action, null));
        }
        protected void startDispatching(IPayload payload) {
            isPending = new List<DispatchToken>();
            isHandled = new List<DispatchToken>();
            currentPayload = payload;
            IsDispatching = true;
        }
        protected void stopDispatching()
        {
            currentPayload = null;
            IsDispatching = false;
        }
        public void WaitFor(List<DispatchToken> dispatchTokenList)
        {
            if (!IsDispatching)
                throw new DispatcherExceptions.NotDispatchingException();
            dispatchTokenList.ForEach((DispatchToken dispatchToken) =>
            {
                if (isPending.Contains(dispatchToken) || isHandled.Contains(dispatchToken))
                    throw new DispatcherExceptions.CircularDependecyException();
                if (!callbackRegistry.ContainsKey(dispatchTo
namespace MusicfyApi.Controllers
    public class InstrumentsController : ApiController
    {
        private readonly IInstrumentService _instrumentService;
        public InstrumentsController(IInstrumentService instrumentService)
        {
            _instrumentService = instrumentService;
        }
        [HttpGet]
        [CustomAuthorize]
        public IEnumerable<InstrumentModel> Get()
        {
            return _instrumentService.GetAll();
        }
        [HttpGet]
        [CustomAuthorize]
        public InstrumentModel Get([FromUri] string id)
        {
            return _instrumentService.GetById(id);
        }
        [HttpPost]
        [CustomAuthorize(true)]
        public void Post([FromBody] InstrumentModel instrumentModel)
        {
            _instrumentService.Add(instrumentModel);
        }
        [HttpPut]
        [CustomAuthorize(true)]
        public void Put([FromUri] string id, [FromBody] InstrumentModel instrumentModel)
        {
            _instrum
namespace Frankfort.Threading.Internal
    public class ThreadDispatchAction
    {
        public bool executed = false;
        public object dispatchExecutionResult = null;
        private ThreadDispatchDelegate          dispatchCallClean;
        private ThreadDispatchDelegateArg       dispatchCallArg;
        private ThreadDispatchDelegateArgReturn dispatchCallArgReturn;
        private ThreadDispatchDelegateReturn    dispatchCallReturn;
        
        private object dispatchArgParam;
        private bool safeMode;
        
        public ThreadDispatchAction()
        {
        }
        #region 4 DIFFERENT OVERLOADS
        public void Init(ThreadDispatchDelegate dispatchCall, bool waitForExecution, bool safeMode)
        {
            this.safeMode = safeMode;
            this.dispatchCallClean = dispatchCall;
            ValidateExecutionOnInit(waitForExecution);
        }
        public void Init(ThreadDispatchDelegateArg dispatchCall, object dispatchArgumentParameter, bool 

        {
            this.safeMode = safeMode;
            this.dispatchCallArg = dispatchCall;
            this.dispatchArgParam = dispatchArgumentParameter;
            ValidateExecutionOnInit(waitForExecution);
        }
        public void Init(ThreadDispatchDelegateArgReturn dispatchCall, object dispatchArgumentParameter, bool safeMode)
        {
            this.safeMode = safeMode;
            this.dispatchCallArgReturn = dispatchCall;
            this.dispatchArgParam = dispatchArgumentParameter;
        }
        public void Init(ThreadDispatchDelegateReturn dispatchCall, bool safeMode)
        {
            this.safeMode = safeMode;
            this.dispatchCallReturn = dispatchCall;
        } 
        #endregion
			
        private void ValidateExecutionOnInit(bool waitForExecution)
        {
            if (waitForExecution)
            {
                if (!MainThreadWatchdog.CheckIfMainThread())
                {
                    while (!executed && Loom.CheckUnityA

                        Thread.Sleep(5);
                }
                else
                {
                    ExecuteDispatch();
                }
            }
        }
        public void ExecuteDispatch()
        {
            if (safeMode)
            {
                try
                {
                    if (dispatchCallClean != null)
                    {
                        dispatchCallClean();
                    }
                    else if (dispatchCallArg != null)
                    {
                        dispatchCallArg(dispatchArgParam);
                    }
                    else if (dispatchCallArgReturn != null)
                    {
                        dispatchExecutionResult = dispatchCallArgReturn(dispatchArgParam);
                    }
                    else if (dispatchCallReturn != null)
                    {
                        dispatchExecutionResult = dispatchCallReturn();
                    }
                }
           
namespace Bussiness
    public class DispatchData
    {
        DBDispatch dbDispatch = new DBDispatch();
        public DataSet GetAllOrdersDetails()
        {
            return dbDispatch.GetAllOrdersDetails();
        }
        public DataSet GetDispatchSearch(Dispatch dispatch)
        {
            return dbDispatch.GetDispatchSearch(dispatch);
        }
        public DataSet GetDispatchByAgentID(Dispatch dispatch)
        {
            return dbDispatch.GetDispatchByAgentID(dispatch);
        }
        public DataSet CashierGetDetails(Dispatch dispatch)
        {
            return dbDispatch.CashierGetDetails(dispatch);
        }
        public DataSet GetDetailsForSettlement(Dispatch dispatch)
        {
            return dbDispatch.GetDetailsForSettlement(dispatch);
        }
        public DataSet GetStockFromDispatch(Dispatch dispatch)
        {
            return dbDispatch.GetStockFromDispatch(dispatch);
        }
        
        public DataSet GenerateDispatchSummary(i

        {
            return dbDispatch.GenerateDispatchSummary(id);
        }
        public DataSet GetDispatchLists(Dispatch disp)
        {
            return dbDispatch.GetDispatchLists(disp);
        }
        public DataSet GetDispatchListsUser(Dispatch disp)
        {
            return dbDispatch.GetDispatchListsUser(disp);
        }
        public DataSet getStock(int id)
        {
            return dbDispatch.getStock(id);
        }
        public DataSet getDetailsbyDDid(int id)
        {
            return dbDispatch.getDetailsbyDDid(id);
        }
        public DataSet CashierGetDetailsId(int id)
        {
            return dbDispatch.CashierGetDetailsId(id);
        }
        
        public DataSet GetDispatchByID(int id)
        {
            return dbDispatch.GetDispatchByID(id);
        }
        
        public int AddDispatchInfo(Dispatch dispatch)
        {
            DBDispatch dbdispatch = new DBDispatch();
            int Result = 0;
            try
      

                Result = dbdispatch.AddDispatchInfo(dispatch);
                return Result;
            }
            catch (Exception)
            {
                throw;
            }
        }
        public int UpdateDispatch(Dispatch dispatch)
        {
            DBDispatch dbdispatch = new DBDispatch();
            int Result = 0;
            try
            {
                Result = dbdispatch.UpdateDispatch(dispatch);
                return Result;
            }
            catch (Exception)
            {
                throw;
            }
        }
        public int updateReturnItems(Dispatch dispatch)
        {
            DBDispatch dbdispatch = new DBDispatch();
            int Result = 0;
            try
            {
                Result = dbdispatch.updateReturnItems(dispatch);
                return Result;
            }
            catch (Exception)
            {
                throw;
            }
        }
        public int CashierUpdate(Dispatch dispat
namespace StockSimulationMVC.Models
    public class Transaction:IComparable<Transaction>
    {
        BuyModel BuyInstrument;
        SellModel SellInstrument;
        TransactionResultModel BuySellResult;
        public BuyModel BuyDetail { get { return BuyInstrument; } }
        public SellModel SellDetail { get { return SellInstrument; } }
        public TransactionResultModel Result { get { return BuySellResult; } }
        public void Buy(string Number , string Name , Decimal Price , DateTime datetime , int share=1)
        {
            if (BuyInstrument == null)
            {
                BuyInstrument = new BuyModel();
                BuyInstrument.Name = Name;
                BuyInstrument.Nubmer = Number;
                BuyInstrument.Price = Price;
                BuyInstrument.Share = share;
                BuyInstrument.Date = datetime;
            }              
            else
                throw new Exception("Buy Instrument has object. Please check logic" + Nu

            if (SellInstrument != null)
                CalculateResult();
        }
        public int CompareTo(Transaction other)
        {
            if (other == null)
                return 1;
            else
                return this.BuyDetail.Date.CompareTo(other.BuyDetail.Date);
        }
        public void Sell(string Number, string Name, Decimal Price, DateTime datetime, int share = 1)
        {
            if(SellInstrument==null)
            {
                SellInstrument = new SellModel();
                SellInstrument.Name = Name;
                SellInstrument.Nubmer = Number;
                SellInstrument.Price = Price;
                SellInstrument.Share = share;
                SellInstrument.Date = datetime;
            }
            else
                throw new Exception("Sell Instrument has object. Please check logic" + Number + ":" + datetime);
            if (BuyInstrument != null)
                CalculateResult();
        }
        void CalculateR
namespace HelloNintaco
    class Program
    {
        private readonly RemoteAPI api = ApiSource.API;
        public void launch()
        {
            api.addFrameListener(renderFinished);
            api.addStatusListener(statusChanged);
            api.addActivateListener(apiEnabled);
            api.addDeactivateListener(apiDisabled);
            api.addStopListener(dispose);
            api.run();
        }
        private void apiEnabled()
        {
            Console.WriteLine("API enabled");
        }
        private void apiDisabled()
        {
            Console.WriteLine("API disabled");
        }
        private void dispose()
        {
            Console.WriteLine("API stopped");
        }
        private void statusChanged(String message)
        {
            Console.WriteLine("Status message: {0}", message);
        }
        private void renderFinished()
        {
            ApiSource.API.writeGamepad(0, GamepadButtons.Left, true);
            if(DateTime.Now.Sec
namespace L2dotNET.Repositories
    public class UnitOfWork : IUnitOfWork
    {
        public UnitOfWork() { }
        public UnitOfWork(IPlayerRepository playerRepository, IAccountRepository accountRepository, IServerRepository serverRepository, ICheckRepository checkRepository, IItemRepository itemRepository)
        {
            _playerRepository = playerRepository;
            _accountRepository = accountRepository;
            _serverRepository = serverRepository;
            _checkRepository = checkRepository;
            _itemRepository = itemRepository;
        }
        public void Commit() { }
        public void Dispose() { }
        #region REPOSITORIES
        private IPlayerRepository _playerRepository;
        public IPlayerRepository PlayerRepository => _playerRepository ?? (_playerRepository = new PlayerRepository());
        private IAccountRepository _accountRepository;
        public IAccountRepository AccountRepository => _accountRepository ?? (_accountRepository
namespace OpenQuant.API
	class DefaultCurrencyConverter : CurrencyConverter
	{
		public override double Convert(double amount, FreeQuant.Instruments.Currency fromCurrency, FreeQuant.Instruments.Currency toCurrency)
		{
			if (fromCurrency == toCurrency)
				return amount;
			Instrument instrument1 = InstrumentManager.Instruments[fromCurrency.Code + "_" + toCurrency.Code];
			if (instrument1 != null)
				return amount * this.GetAmount(instrument1, amount);
			Instrument instrument2 = InstrumentManager.Instruments[toCurrency.Code + "_" + fromCurrency.Code];
			if (instrument2 == null)
				return amount;
			else
				return amount / this.GetAmount(instrument2, amount);
		}
		private double GetAmount(Instrument instrument, double amount)
		{
			if (instrument.Quote.DateTime != DateTime.MinValue)
				return (instrument.Quote.Ask + instrument.Quote.Bid) / 2.0;
			if (instrument.Trade.DateTime != DateTime.MinValue && instrument.Trade.DateTime >= instrument.Bar.DateTime)
				return instrument.T
namespace Repertoar.Pages.RepertoarPages
    public partial class InstrumentCRUD : System.Web.UI.Page
    {
        #region Service-objekt
        private Service _service;
        private Service Service
        {
            get { return _service ?? (_service = new Service()); }
        }
        #endregion
        protected void Page_Load(object sender, EventArgs e)
        {
            SuccessMessageLiteral.Text = Page.GetTempData("SuccessMessage") as string;
            SuccessMessagePanel.Visible = !String.IsNullOrWhiteSpace(SuccessMessageLiteral.Text);
        }
        #region CREATE
        public void InstrumentFormView_InsertInstrument(Instrument instrument)
        {
            if (ModelState.IsValid)
            {
                try
                {
                    instrument.InstrumentID = Service.SaveInstrument(instrument);
                    Page.SetTempData("SuccessMessage", "Instrumentet: " + instrument.Namn + " har lagts till.");
                    Response

                    Context.ApplicationInstance.CompleteRequest();
                }
                catch (Exception ex)
                {
                    ModelState.AddModelError(string.Empty, ex.Message);
                }
            }
        }
        #endregion
        #region UPDATE
        public void InstrumentListView_UpdateInstrument(Instrument Instrument)
        {
            if (ModelState.IsValid)
            {
                try
                {
                    var instrument = Service.GetInstrumentByID(Instrument.InstrumentID);
                    if (instrument == null)
                    {
                        ModelState.AddModelError(String.Empty, String.Format("Instrumentet med id {0} hittades inte, så det gick tyvärr inte att uppdatera just nu.", Instrument.InstrumentID));
                        return;
                    }
                    if (TryUpdateModel(Instrument))
                    {
                        Service.SaveInstrument(Ins

                    }
                    Page.SetTempData("SuccessMessage", Strings.Action_Instrument_Updated);
                    Response.RedirectToRoute("CreateInstrument", false);
                    Context.ApplicationInstance.CompleteRequest();
                }
                catch (Exception)
                {
                    ModelState.AddModelError(String.Empty, Strings.Song_Updating_Error);
                }
            }
        }
        #endregion
        #region DELETE
        public void InstrumentListView_DeleteInstrument(Instrument instrument)
        {
            try
            {   
                Service.DeleteInstrument(instrument);
                Page.SetTempData("SuccessMessage", Strings.Action_Instrument_Deleted);
               
                Response.RedirectToRoute("CreateInstrument", false);
                Context.ApplicationInstance.CompleteRequest();
            }
            catch (Exception)
            {
                ModelState.AddMode
namespace Thermo.IAPI.Examples
    sealed public class InstrumentAPI
    {
        public InstrumentInfo InstrumentInfo = new InstrumentInfo();
        IFusionInstrumentAccessContainer _instAccessContainer;
        public IFusionInstrumentAccessContainer InstAccessContainer
        {
            get { return _instAccessContainer; }
            set { _instAccessContainer = value; }
        }
        IFusionInstrumentAccess _instAccess;
        public IFusionInstrumentAccess InstAccess
        {
            get { return _instAccess; }
            set { _instAccess = value; }
        }
        IFusionMsScanContainer _instMSScanContainer;
        public IFusionMsScanContainer InstMSScanContainer
        {
            get { return _instMSScanContainer; }
            set { _instMSScanContainer = value; }
        }
        IAcquisition _instAcq;
        public IAcquisition InstAcq
        {
            get { return _instAcq; }
            set { _instAcq = value; }
        }
        IControl _

        public InstrumentAPI()
        {
            _instAccessContainer = Factory<IFusionInstrumentAccessContainer>.Create();
        }
        public bool ServiceConnected { get { return _instAccessContainer.ServiceConnected; } }
        internal void StartOnlineAccess()
        {
            _instAccessContainer.StartOnlineAccess();
        }
        internal void CloseConnection()
        {
            _instAccessContainer.Dispose();
            DBHelper.Close();
        }
        internal void GetInstAccess(int p)
        {
            _instAccess = _instAccessContainer.Get(1);
            _instControl = _instAccess.Control;
            _instAcq = _instControl.Acquisition;
            InstrumentInfo.InstrumentId = _instAccess.InstrumentId.ToString();
            InstrumentInfo.InstrumentName = _instAccess.InstrumentName;
        }
        public bool InstrumentConnected { get { return _instAccess.Connected; } }
    }
    public class InstrumentInfo
    {
        public string In
public class GraphPortChunkEncoder : GraphPortDelegate
    public delegate void ChunkPacked(BufferChunk chunk);
    public event ChunkPacked ChunkPackedEvent;
    IntPtr fDeviceContext;
    public GraphPortChunkEncoder()
    {
        fDeviceContext = IntPtr.Zero;
    }
    public IntPtr DeviceContext
    {
        get
        {
            return fDeviceContext;
        }
    }
    void PackCommand(BufferChunk aCommand)
    {
        if (ChunkPackedEvent != null)
            ChunkPackedEvent(aCommand);
    }
    void PackCommand(EMR aCommand)
    {
        BinaryFormatter fFormatter = new BinaryFormatter();
        MemoryStream fMemoryStream = new MemoryStream(2048);
        fMemoryStream.Seek(0, SeekOrigin.Begin);
        fFormatter.Serialize(fMemoryStream, aCommand);
        byte[] sendBytes = fMemoryStream.GetBuffer();
        BufferChunk chunk = new BufferChunk(sendBytes);
    }
    void Pack(BufferChunk aChunk, int x, int y)
    {
        aChunk += x;
        aChunk += y;
    }
 

    {
        aChunk += left;
        aChunk += top;
        aChunk += right;
        aChunk += bottom;
    }
    void Pack(BufferChunk chunk, Point[] points)
    {
        chunk += points.Length;
        for (int i = 0; i < points.Length; i++)
        {
            Pack(chunk, points[i].x, points[i].y);
        }
    }
    void Pack(BufferChunk chunk, Guid uniqueID)
    {
        chunk += uniqueID.ToByteArray();
    }
    void Pack(BufferChunk chunk, XFORM aTrans)
    {
    }
    void Pack(BufferChunk chunk, TRIVERTEX[] vertices)
    {
        int nVertices = vertices.Length;
        chunk += nVertices;
        for (int i = 0; i < nVertices; i++)
        {
            chunk += vertices[i].x;
            chunk += vertices[i].y;
            chunk += vertices[i].Alpha;
            chunk += vertices[i].Blue;
            chunk += vertices[i].Green;
            chunk += vertices[i].Red;
        }
    }
    void Pack(BufferChunk chunk, GRADIENT_RECT[] gRect)
    {
        int nRects = gRect

        chunk += nRects;
        for (int i = 0; i < nRects; i++)
        {
            chunk += gRect[i].UpperLeft;
            chunk += gRect[i].LowerRight;
        }
    }
    public override void SetTextColor(uint colorref)
    {
        BufferChunk chunk = new BufferChunk(128);
        chunk += GDI32.EMR_SETTEXTCOLOR;
        chunk += colorref;
        PackCommand(chunk);
    }
    public override void MoveTo(int x, int y)
    {
        BufferChunk chunk = new BufferChunk(128);
        chunk += GDI32.EMR_MOVETOEX;
        chunk += x;
        chunk += y;
        PackCommand(chunk);
    }
    public override void LineTo(int x, int y)
    {
        BufferChunk chunk = new BufferChunk(128);
        chunk += GDI32.EMR_LINETO;
        chunk += x;
        chunk += y;
        PackCommand(chunk);
    }
    public override void SaveState()
    {
        BufferChunk chunk = new BufferChunk(128);
        chunk += GDI32.EMR_SAVEDC;
        PackCommand(chunk);
    }
    public override void Re
public class Location
    World_Location world;
    Chunk_Location chunk;
    int chunkTileWidth = Chunk.getTileWidth();
    [System.Serializable]
    public class MyException : System.Exception
    {
        public MyException() { }
        public MyException(string message) : base(message) { }
        public MyException(string message, System.Exception inner) : base(message, inner) { }
        protected MyException(
          System.Runtime.Serialization.SerializationInfo info,
          System.Runtime.Serialization.StreamingContext context) : base(info, context) { }
    }
    public Location(int x, int y)
    {
        world = new World_Location(x, y);
        chunk = new Chunk_Location();
        if (world.x >= 0)
        {
            chunk.i = Mathf.FloorToInt(world.x / chunkTileWidth);
            chunk.x = world.x - chunk.i * chunkTileWidth;
        }
        else
        {
            chunk.i = Mathf.CeilToInt((world.x + 1) / chunkTileWidth) - 1;
            chunk.x = (chunkTi

        }
        if (world.y >= 0)
        {
            chunk.j = Mathf.FloorToInt(world.y / chunkTileWidth);
            chunk.y = world.y - chunk.j * chunkTileWidth;
        }
        else
        {
            chunk.j = Mathf.CeilToInt((world.y + 1) / chunkTileWidth) - 1;
            chunk.y = (chunkTileWidth - 1) + (world.y + 1) - (chunk.j + 1) * chunkTileWidth;
        }
    }
    public Location(int i, int j, int x, int y)
    {
        
        world = new World_Location();
        chunk = new Chunk_Location(i, j, x, y);
        if (chunk.i >= 0)
        {
            world.x = chunk.i * chunkTileWidth + chunk.x;
        }
        else
        {
            world.x = ((chunk.i + 1) * chunkTileWidth) + (chunk.x - chunkTileWidth);
        }
        if (chunk.j >= 0)
        {
            world.y = chunk.j * chunkTileWidth + chunk.y;
        }
        else
        {
            world.y = ((chunk.j + 1) * chunkTileWidth) + (chunk.y - chunkTileWidth);
        }
    }
    public cl

    /* Each tile has a coordinate in world space, with origin (0,0) the player spawn location
     * and every newly generated tile position recorded in cartesian fashion. 
     * The origin will be in chunk (0,0) lower left corner tile; (0,0) in chunk coordinates. */
        public int x;
        public int y;
        public World_Location()
        {
            this.x = 0;
            this.y = 0;
        }
        public World_Location(int x, int y) 
        {
            this.x = x;
            this.y = y;
        }
    }
    public class Chunk_Location
    /* Tiles divided into chunks. Each chunk has a column and row (i,j) and each tile within are designated chunk coordinates (x,y)
     * with (0,0) being the lower left tile.
     * World origin (0,0) would be in Chunk (0,0) in the lower left corner tile (0,0). */
    {
        public int i;
        public int j;
        public int x;
        public int y;
        public Chunk_Location()
        {
            this.i = 0;
        
namespace LolBackdoor
    public class LolServer
    {
        public LolRegion Region
        {
            get { return _region; }
        }
        public ILolChampionApi ChampionApi
        {
            get { return (ILolChampionApi) _apis[LolApi.Champion]; }
        }
        public ILolGameApi GameApi
        {
            get { return (ILolGameApi) _apis[LolApi.Game]; }
        }
        public ILolLeagueApi LeagueApi
        {
            get { return (ILolLeagueApi)_apis[LolApi.League]; }
        }
        public ILolMatchApi MatchApi
        {
            get { return (ILolMatchApi)_apis[LolApi.Match]; }
        }
        public ILolMatchHistoryApi MatchHistoryApi
        {
            get { return (ILolMatchHistoryApi)_apis[LolApi.MatchHistory]; }
        }
        public ILolStaticDataApi StaticDataApi
        {
            get { return (ILolStaticDataApi)_apis[LolApi.StaticData]; }
        }
        public ILolStatsApi StatsApi
        {
            get { return (ILolStat
namespace MobileCenterApp
	internal static class EventHandlerExtensions
	{
		public static void InvokeOnMainThread<T>(this EventHandler<T> handler, object sender, T args) where T : EventArgs
		{
			Device.BeginInvokeOnMainThread(() => handler.Invoke(sender, args));
		}
		public static void InvokeOnMainThread(this EventHandler handler, object sender, EventArgs args)
		{
			Device.BeginInvokeOnMainThread(() => handler.Invoke(sender, args));
		}
		public static void InvokeOnMainThread<T>(this EventHandler<EventArgs<T>> handler, object sender, T args)
		{
			Device.BeginInvokeOnMainThread(() => handler.Invoke(sender, new EventArgs<T>(args)));
		}
		public static void InvokeOnMainThread(this EventHandler handler, object sender)
		{
			handler.InvokeOnMainThread(sender, EventArgs.Empty);
		}
		public static void InvokeOnMainThread(this Action action)
		{
			Device.BeginInvokeOnMainThread(action.Invoke);
		}
		public static void InvokeOnMainThread<T>(this Action<T> action, T t)
		{
			Device.
namespace DAL.Concrete
    public class UnitOfWork : IUnitOfWork
    {
        private EntityModel Context;
        private UserRepository userRepository;
        private RoleRepository roleRepository;
        private UserRoleRepository userRoleRepository;
        private TestRepository testRepository;
        private QuestionRepository questionRepository;
        private AnswerRepository answerRepository;
        private ResultRepository resultRepository;
        public UnitOfWork(EntityModel context)
        {
            Context = context;
        }
        public IRoleRepository RoleRepository
        {
            get
            {
                if (roleRepository == null)
                    roleRepository = new RoleRepository(Context);
                return roleRepository;
            }
        }
        public IUserRepository UserRepository
        {
            get
            {
                if (userRepository == null)
                    userRepository = new UserReposit

                return userRepository;
            }
        }
        public IUserRoleRepository UserRoleRepository
        {
            get
            {
                if (userRoleRepository == null)
                    userRoleRepository = new UserRoleRepository(Context);
                return userRoleRepository;
            }
        }
        public ITestRepository TestRepository
        {
            get
            {
                if (testRepository == null)
                    testRepository = new TestRepository(Context);
                return testRepository;
            }
        }
        public IQuestionRepository QuestionRepository
        {
            get
            {
                if (questionRepository == null)
                    questionRepository = new QuestionRepository(Context);
                return questionRepository;
            }
        }
        public IAnswerRepository AnswerRepository
        {
            get
            {
                if (a
namespace Vlc.DotNet.Core
    internal static class EventsHelper
    {
        public static void RaiseEvent<TSender, THandler>(VlcEventHandler<TSender, THandler> handler, TSender sender, VlcEventArgs<THandler> arg)
        {
            if (handler == null)
                return;
            foreach (VlcEventHandler<TSender, THandler> singleInvoke in handler.GetInvocationList())
            {
                var syncInvoke = singleInvoke.Target as ISynchronizeInvoke;
                if (syncInvoke == null)
                {
                    singleInvoke.DynamicInvoke(new object[] {sender, arg});
                    continue;
                }
                try
                {
                    if (syncInvoke.InvokeRequired)
                        syncInvoke.Invoke(singleInvoke, new object[] {sender, arg});
                    else
                        singleInvoke(sender, arg);
                }
                catch (ObjectDisposedException)
                {
          
[System.Serializable]
public class SerializedChunk {
	public int chunkSize; 
	public float chunkPositionX;
	public float chunkPositionY;
	public SerializedTile[,] tiles;
	public SerializedChunk (Chunk chunk) { 
		chunkSize = chunk.chunkSize;
		chunkPositionX = chunk.chunkPosition.x;
		chunkPositionY = chunk.chunkPosition.y; 
		tiles = new SerializedTile[chunkSize, chunkSize];
		for(int x = 0; x < chunk.chunkSize; x++ ) {
			
			for(int y = 0; y < chunk.chunkSize; y++ ) {
				if(chunk.tiles[x,y] != null) {
					tiles[x,y] = new SerializedTile(); 
					tiles[x,y].sand = chunk.tiles[x,y].sand;
					tiles[x,y].silt = chunk.tiles[x,y].silt;
					tiles[x,y].clay = chunk.tiles[x,y].clay;
				}
			}
		}
	}
	public SerializedChunk(int chunkSize, int chunkPositionX, int chunkPositionY, SerializedTile[,] tiles) {
		this.chunkSize = chunkSize;
		this.chunkPositionX = chunkPositionX;
		this.chunkPositionY = chunkPositionY;
		this.tiles = tiles;
	}
	public void WriteToChunk(Chunk chunk) {
		 
		chun
namespace PopNTouch2.ViewModel
    public class InstrumentVM : ViewModelBase
    {
        public InstrumentVM(Tuple<Instrument,Difficulty> instrument, PlayerVM playerVM)
        {
            this.Instrument = instrument.Item1;
            this.Difficulty = instrument.Item2;
            this.PlayerVM = playerVM;
        }
        private Instrument instrument;
        public Instrument Instrument
        {
            get { return this.instrument; }
            set
            {
                this.instrument = value;
                RaisePropertyChanged("Instrument");
            }
        }
        private Difficulty difficulty;
        public Difficulty Difficulty
        {
            get { return this.difficulty; }
            set
            {
                this.difficulty = value;
                RaisePropertyChanged("Difficulty");
            }
        }
        private PlayerVM playerVM;
        public PlayerVM PlayerVM {
            get { return this.playerVM; }
         
namespace MTB
	public class ObstacleDetector : MonoBehaviour {
		public bool inCollision;
		private List<Chunk> chunkList;
		void Start()
		{
			chunkList = new List<Chunk>();
			EventManager.RegisterEvent(EventMacro.CHUNK_RENDER_START,OnChunkRenderStart);
		}
		void OnDestroy()
		{
			EventManager.UnRegisterEvent(EventMacro.CHUNK_RENDER_START,OnChunkRenderStart);
		}
		private void OnChunkRenderStart(object[] param)
		{
			Chunk chunk = param[0] as Chunk;
			if(chunkList.Contains(chunk))
			{
				chunkList.Remove(chunk);
				UpdateIsCollision();
			}
		}
		private void UpdateIsCollision()
		{
			if(chunkList.Count > 0)
			{
				inCollision = true;
			}
			else
			{
				inCollision = false;
			}
		}
		void OnTriggerEnter(Collider col)
		{
			ChunkObj chunkObj = col.GetComponentInParent<ChunkObj>();
			if(chunkObj == null)return;
			if(!chunkList.Contains(chunkObj.chunk))
			{
				chunkList.Add(chunkObj.chunk);
				UpdateIsCollision();
			}
		}
		void OnTriggerExit (Collider col)
		{
		
﻿namespace LiteDispatch.Domain.Entities
  public class DispatchNote
    :EntityBase
  {
    public const string New = "New";
    public const string InTransit = "InTransit";
    public const string Received = "Received";
    protected DispatchNote()
    {
      DispatchLineSet = new HashSet<DispatchLine>();
    }
    public static DispatchNote Create(IRepositoryLocator locator, DispatchNoteModel model)
    {
      var haulier = locator.GetById<Haulier>(model.HaulierId);
      var instance = new DispatchNote
        {
          CreationDate = model.CreationDate,
          LastUpdate = model.CreationDate,
          DispatchDate = model.DispatchDate,
          DispatchNoteStatus = New,
          DispatchReference = model.DispatchReference,
          Haulier = haulier,
          TruckReg = model.TruckReg,
          User = model.User
        };
      locator.Save(instance);
      model.Lines.ForEach(l => instance.AddLine(locator, l));
      return instance;
    }
    public DispatchLine Add

    {
      var line = DispatchLine.Create(locator, dispatchLineModel);
      DispatchLineSet.Add(line);
      return line;
    }
    #region Persisted Properties
    public virtual Haulier Haulier { get; private set; }
    public DateTime DispatchDate { get; private set; }
    public string DispatchNoteStatus { get; private set; }
    public string TruckReg { get; private set; }
    public string DispatchReference { get; private set; }
    public DateTime CreationDate { get; private set; }
    public DateTime LastUpdate { get; private set; }
    public string User { get; private set; }
    public virtual TrackingNotification LastTrackingNotification { get; private set; }
    protected virtual ICollection<DispatchLine> DispatchLineSet { get; set; }
    #endregion
    #region Public Methods
    public IEnumerable<DispatchLine> DispatchLines()
    {
      return DispatchLineSet;
    }
    #endregion
    public class Mapping : EntityTypeConfiguration<DispatchNote>
    {
      public Mapp

      {
        HasMany(d => d.DispatchLineSet);
        HasOptional(d => d.LastTrackingNotification).WithMany();
      }
    }
    public TrackingResponseDto CreateTrackingNotification(IRepositoryLocator locator, TrackingNotificationDto dto, TrackingResponseDto response)
    {
      if (!(DispatchNoteStatus == New |
            DispatchNoteStatus == InTransit))
      {
        response.Error = "DispatchNote was found but its status was not new or in-transit, it was: " + DispatchNoteStatus;
        return response;
      }
      if (DispatchNoteStatus == New)
      {
        DispatchNoteStatus = InTransit;
      }
      LastUpdate = DateTime.Now;
      var trackingNotification = TrackingNotification.Create(locator, dto, this);
      LastTrackingNotification = trackingNotification;
      response.Accepted = true;
      return response;
    }    
    public string LastTrackingNotificationDescription()
    {
      var distance = LastTrackingNotification == null
                       ? "
namespace DAL.UnitOfWork
    public class UnitOfWork : IUnitOfWork
    {
        private readonly DBEntities _context = new DBEntities();
        private GenericRepository<Client> _userRepository;
        private GenericRepository<Order> _orderRepository;
        private GenericRepository<Product> _productRepository;
        private GenericRepository<Employee> _employeeRepository;
        private GenericRepository<Package> _packageRepository;
        private GenericRepository<Invoice> _invoiceRepository;
        private GenericRepository<Contains> _containsRepository;
        private GenericRepository<RecipeDrug> _recipeDrugRepository;
        private GenericRepository<Manager> _managerRepository;
        private GenericRepository<ManagerStatus> _managerStatusRepository;
        private GenericRepository<PackageStatus> _packageStatusRepository;
        private GenericRepository<OrderStatus> _orderStatusRepository;
        private GenericRepository<Position> _positionRepository;
       

        private GenericRepository<Shipping> _shippingRepository;
        public GenericRepository<Client> UserRepository
        {
            get { return _userRepository ?? (_userRepository = new GenericRepository<Client>(_context)); }
        }
        public GenericRepository<Order> OrderRepository
        {
            get { return _orderRepository ?? (_orderRepository = new GenericRepository<Order>(_context)); }
        }
        public GenericRepository<Product> ProductRepository
        {
            get { return _productRepository ?? (_productRepository = new GenericRepository<Product>(_context)); }
        }
        public GenericRepository<Employee> EmployeeRepository
        {
            get { return _employeeRepository ?? (_employeeRepository = new GenericRepository<Employee>(_context)); }
        }
        public GenericRepository<Package> PackageRepository
        {
            get { return _packageRepository ?? (_packageRepository = new GenericRepository<Package>(_con

        }
        public GenericRepository<Invoice> InvoiceRepository
        {
            get { return _invoiceRepository ?? (_invoiceRepository = new GenericRepository<Invoice>(_context)); }
        }
        public GenericRepository<Contains> ContainsRepository
        {
            get { return _containsRepository ?? (_containsRepository = new GenericRepository<Contains>(_context)); }
        }
        public GenericRepository<RecipeDrug> RecipeDrugRepository
        {
            get { return _recipeDrugRepository ?? (_recipeDrugRepository = new GenericRepository<RecipeDrug>(_context)); }
        }
        public GenericRepository<Manager> ManagerRepository
        {
            get { return _managerRepository ?? (_managerRepository = new GenericRepository<Manager>(_context)); }
        }
        public GenericRepository<ManagerStatus> ManagerStatusRepository
        {
            get { return _managerStatusRepository ?? (_managerStatusRepository = new GenericRepository<ManagerS
namespace Rimworld.model.entities
    public class Map
    {
        private Chunk[,] chunks { get; set; }
        public Map()
        {
        }
        public Room GetOutsideRoom(Position position)
        {
            return GetChunkAt(position).outsideRoom;
        }
        public Chunk GetChunkAt(Position position)
        {
            return GetChunkAt(position.x, position.y);
        }
        public Chunk GetChunkAt(float x, float y)
        {
            float cx = (int)(x / GameConsts.CHUNK_SIZE);
            float cy = (int)(y / GameConsts.CHUNK_SIZE);
            if (x < 0) cx = chunkWidth - 1 - (x / GameConsts.CHUNK_SIZE);
            if (y < 0) cy = chunkHeight - 1 - (y / GameConsts.CHUNK_SIZE);
            if (cx >= chunkWidth) cx = cx - chunkWidth;
            if (cy >= chunkHeight) cy = cy - chunkHeight;
            return chunks[(int)cx, (int)cy];
        }
        int chunkWidth = 0;
        int chunkHeight = 0;
        internal void SetupWorld(int width, int he
namespace Compacter
    public class ProcessList : Component
    {
        public delegate void ProcessEventHandler(Process Process);
        public event ProcessEventHandler ProcessStarted;
        public event ProcessEventHandler ProcessTerminated;
        private Dictionary<int, Process> ProcessesByID = new Dictionary<int, Process>();
        public ProcessList()
        {
        }
        private void AddProcess(_Process _Process)
        {
            Process Process = new Process(_Process);
            this.ProcessesByID.Add(Process.Id, Process);
            if (this.ProcessStarted != null)
            {
                this.ProcessStarted(Process);
            }
            Process.Exited += this.Process_Exited;
        }
        private void Process_Exited(Process Process)
        {
            this.RemoveProcess(Process);
        }
        private void RemoveProcess(Process Process)
        {
            if (!this.ProcessesByID.ContainsKey(Process.Id))
            {
         

            }
            if (this.ProcessTerminated != null)
            {
                this.ProcessTerminated(this.ProcessesByID[Process.Id]);
            }
            this.ProcessesByID.Remove(Process.Id);
        }
        public void Update()
        {
            _Process[] Processes = _Process.GetProcesses();
            foreach (_Process Proc in Processes)
            {
                if (this.ProcessesByID.ContainsKey(Proc.Id))
                {
                    continue;
                }
                this.AddProcess(Proc);
            }
            Dictionary<int, _Process> CurrentProcesses = new Dictionary<int, _Process>(Processes.ToDictionary(delegate(_Process Proc) { return Proc.Id; }));
            List<Process> TerminatedProcesses = new List<Process>();
            foreach (Process Proc in this.ProcessesByID.Values)
            {
                if (!CurrentProcesses.ContainsKey(Proc.Id) || !Proc.IsSameProcess (CurrentProcesses[Proc.Id]))
                {
 
﻿namespace DelegateOfMainExample.MethodInvokers
    public class MainMethodInvoker
    {
        #region MyImplementation
        /*  I could not find a way to resolve the ambiguous call when the method signatures were of Func<string[], int> and Action<string[]>
         *  So I had to better define their names as opposed to naming them all InvokeMethod()
         *  This is how I would implement it but below this is another option
         */
        public void InvokeActionMethod(Action methodToInvoke)
        {
            methodToInvoke();
        }
        public void InvokeActionMethod(Action<string[]> methodToInvoke, string[] args)
        {
            methodToInvoke(args);
        }
        public int InvokeFunctionMethod(Func<int> methodToInvoke)
        {
            return methodToInvoke();
        }
        public int InvokeFunctionMethod(Func<string[], int> methodToInvoke, string[] args)
        {
            return methodToInvoke(args);
        }
        #endregion
     
namespace ProcessManager.Helper
    public class TestHelper
    {
        public static List<ProcessProcessModel> processCreateProcess(int pid, int bid, List<string> liuchengren)
        {
            List<ProcessProcessModel> lprocess = new List<ProcessProcessModel>();
            int order = 0;
            foreach (string renyuan in liuchengren)
            {
                ProcessProcessModel process = new ProcessProcessModel();
                process.Pid = pid;
                process.Bid = bid;
                process.Order = order;
                if (process.Order == 0)
                {
                    process.Handler = "发起人";
                    process.Nexthandler = renyuan;
                    process.Lasthandler = ProcessState.BEGIN.ToString();
                    process.State = ProcessState.FINISH;
                }
                else if (liuchengren.IndexOf(renyuan) == liuchengren.Count - 1)
                {
                    process.Handler = renyuan;
       

                    process.Lasthandler = liuchengren[liuchengren.IndexOf(renyuan) - 1];
                    process.State = ProcessState.DEFINE;
                }
                else
                {
                    process.Handler = renyuan;
                    process.Nexthandler = liuchengren[liuchengren.IndexOf(renyuan) + 1];
                    process.Lasthandler = liuchengren[liuchengren.IndexOf(renyuan) - 1];
                    process.State = ProcessState.DEFINE;
                }
                lprocess.Add(process);
                order += 100;
            }
            return lprocess;
        }
        public static ProcessPredefineModel createPredefine(IList<ProcessPredefineModel> lprocess, int order = 0)
        {
            List<ProcessPredefineModel> listProcess = (List<ProcessPredefineModel>)lprocess;
            listProcess.Sort();
            ProcessPredefineModel predefine = new ProcessPredefineModel();
            predefine.Bid = listProcess[order].Bid
namespace StringCalculator
    [TestFixture]
    public class StringCalculatorTests
    {
        
        [Test]
        public void Calculate_EmptyString_Returns0()
        {
            Assert.AreEqual(0, Calculator.Calculate(string.Empty));
        }
        [Test]
        public void Calculate_InputNull_Returns0()
        {
            Assert.AreEqual(0, Calculator.Calculate(null));
        }
        [ExpectedException(typeof(ArgumentException))]
        [Test]
        public void Calculate_stringNotNumeric_ThrowsException()
        {
            Calculator.Calculate("blabl");
        }
        [Test]
        public void Calculate_ThreePlusFour_ReturnsSeven()
        {
            Assert.AreEqual(7, Calculator.Calculate("3+4"));
        }
        [Test]
        public void Calculate_4Times2_8()
        {
            Assert.AreEqual(8, Calculator.Calculate("4*2"));
        }
        [ExpectedException(typeof(ArgumentException))]
        [Test]
        public void Calculate_3Plus_Th

        {
             Calculator.Calculate("3+");
        }
        
        [ExpectedException(typeof(ArgumentException))]
        [Test]
        public void Calculate_3Times_ThrowsArgumentException()
        {
             Calculator.Calculate("3*");
        }
        
        [ExpectedException(typeof(ArgumentException))]
        [Test]
        public void Calculate_Times3_ThrowsArgumentException()
        {
             Calculator.Calculate("*3");
        }
        [Test]
        public void Calculate_77_7()
        {
            Assert.AreEqual(7, Calculator.Calculate("77"));
        }
        [Test]
        public void Calculate_3Plus4_7()
        {
            Assert.AreEqual(7, Calculator.Calculate("3plus4"));
        }
        [Test]
        public void Calculate_WithSpaces_ReturnsSameResult()
        {
            Assert.AreEqual(6, Calculator.Calculate("3 + 3"));
        }
        [Test]
        public void Calculate_8Divide2_Returns4()
        {
            Assert.AreEqua

        }
        [Test]
        public void Calculate_3Divide2_Returns1()
        {
            Assert.AreEqual(1, Calculator.Calculate("3/2"));
        }
        [Test]
        [ExpectedException(typeof(DivideByZeroException))]
        public void Calculate_DivideBy0_ThrowsException()
        {
            Calculator.Calculate("1/0");
        }
        [Test]
        public void Calculate_7Modulus2_Returns1()
        {
            Assert.AreEqual(1, Calculator.Calculate("7%2"));
        }
        [Test]
        public void Calculate_minus3plus2_Returns1()
        {
            Assert.AreEqual(-1, Calculator.Calculate("-3+2"));
        }
        [Test]
        public void Calculate_2plusminus4_ReturnsMinus2()
        {
            Assert.AreEqual(-2, Calculator.Calculate("2+-4"));
        }
        [Test]
        public void Calculate_2plus3minus4_Returns1()
        {
            Assert.AreEqual(1, Calculator.Calculate("2+3-4"));
        }
        [Test]
        public void Calculate
public class musicianSimon : Lookable {
	public singerSimon actualSinger;
	public letThemCome actualSinger2;
	int numberOfMyInstrument;
	Animator anim;
	public bool isSimon;
	public enum Instrument
	{
		None = 0,
		Bass = 1,
		Flute = 2,
		Guitare = 4,
		Percu = 8,
		Uku = 16
	}
	public void play()
	{
		AkSoundEngine.SetState (instrument.ToString (), instrument.ToString () + "_is" + "playing");
		anim.SetBool ("isPlayingMusic", true);
	}
	public void stop ()
	{
		AkSoundEngine.SetState (instrument.ToString (), instrument.ToString () + "_not" + "playing");
		anim.SetBool ("isPlayingMusic", false);
	}
	public Instrument instrument;
	protected override void StartLookable ()
	{
		base.StartLookable ();
		isSimon = false;
		anim = GetComponentInChildren<Animator> ();
		switch (instrument)
		{
			case Instrument.Bass:
				numberOfMyInstrument = 0;
				break;
			case Instrument.Flute:
				numberOfMyInstrument = 1;
				break;
			case Instrument.Guitare:
				numberOfMyInstrument = 2;
				break;
namespace Lab.Environment.DataAccess
    public class OrderProjectDispatchDaoImpl
    {
        public void Add(OrderProjectDispatchModel model)
        {
            DBProvider.dbMapper.Insert("Order_ProjectDispatch.Insert", model);
        }
        public void Update(OrderProjectDispatchModel model)
        {
            DBProvider.dbMapper.Update("Order_ProjectDispatch.Update", model);
        }
        public void DeleteById(int DispatchId)
        {
            DBProvider.dbMapper.Delete("Order_ProjectDispatch.DeleteById", DispatchId);
        }
        public OrderProjectDispatchModel GetById(int DispatchId)
        {
            return DBProvider.dbMapper.SelectObject<OrderProjectDispatchModel>("Order_ProjectDispatch.GetByID", DispatchId);
        }
        public IList<OrderProjectDispatchModel> GetAll()
        {
            return DBProvider.dbMapper.SelectList<OrderProjectDispatchModel>("Order_ProjectDispatch.GetAll");
        }
        public void UpdateRecordState(OrderPr
public class WorldChunkHashTable {
	int totalBuckets;
	WorldChunkHTBucket[] buckets;
	public WorldChunkHashTable() {
		totalBuckets = Mathf.FloorToInt (GameSettings.LoadedConfig.getTotalChunks() / GameSettings.LoadedConfig.ChunkHT_BucketSize);
		buckets = new WorldChunkHTBucket[totalBuckets];
		for (int i = 0; i < totalBuckets; ++i) {
			buckets[i] = new WorldChunkHTBucket();
		}
	}
	public void addChunk(WorldChunk chunk) {
		if (!getBucket(WorldChunk.GetAbsoluteIndex (chunk.getX(), chunk.getZ())).elementExists(WorldChunk.GetAbsoluteIndex (chunk.getX(), chunk.getZ())))
			getBucket(WorldChunk.GetAbsoluteIndex (chunk.getX(), chunk.getZ())).addElement(chunk);
	}
	public void removeChunk(int chunk_x, int chunk_z) {
		getBucket(WorldChunk.GetAbsoluteIndex (chunk_x, chunk_z)).removeElement(WorldChunk.GetAbsoluteIndex (chunk_x, chunk_z));
	}
	public bool chunkExists(int abs_chunk_index) {
		return getBucket (abs_chunk_index).elementExists (abs_chunk_index);
	}
	public WorldChunk findChunk(in

		return getBucket (abs_chunk_index).findElement (abs_chunk_index);
	}
	WorldChunkHTBucket getBucket(int abs_chunk_index) {
		return buckets [hash (abs_chunk_index)];
	}
	int hash(int abs_chunk_index) {
		return abs_chunk_index % totalBuckets;
	}
	public List<WorldChunk> getAllChunks() {
		List<WorldChunk> chunks = new List<WorldChunk> ();
		for (int i = 0; i < buckets.Length; ++i) {
			List<WorldChunk> bucketElements = buckets[i].getAllElements ();
			for(int j = 0; j < bucketElements.Count; ++j) {
				chunks.Add(bucketElements[j]);
			}
		}
		return chunks;
	}
public class WorldChunkHTBucket {
	List<WorldChunk> elements;
	public WorldChunkHTBucket() {
		elements = new List<WorldChunk> ();
	}
	public void addElement(WorldChunk elem) {
		if (elements.Count >= GameSettings.LoadedConfig.ChunkHT_BucketSize)
			Debug.LogWarning ("Loaded chunk HT bucket has exceeded it's max size.");
		elements.Add (elem);
	}
	public void removeElement(int abs_chunk_index) {
		for (int i = 0; i < elements.
namespace SevenDigital.ApiSupportLayer.TestData.StubApiWrapper
	public static class ApiWrapper
	{
		public static IFluentApi<Locker> StubbedApi(Locker stubbedLockerToReturn)
		{
			var fluentApi = MockRepository.GenerateStub<IFluentApi<Locker>>();
			fluentApi.Stub(x => x.ForUser("", "")).IgnoreArguments().Return(fluentApi);
			fluentApi.Stub(x => x.WithParameter("", "")).IgnoreArguments().Return(fluentApi);
			fluentApi.Stub(x => x.WithPageNumber(0)).IgnoreArguments().Return(fluentApi);
			fluentApi.Stub(x => x.WithPageSize(0)).IgnoreArguments().Return(fluentApi);
			fluentApi.Stub(x => x.Sort(LockerSortColumn.PurchaseDate, SortOrder.Descending)).IgnoreArguments().Return(fluentApi);
			fluentApi.Stub(x => x.Please()).Return(stubbedLockerToReturn);
			return fluentApi;
		}
		public static IFluentApi<Track> StubbedTrackApi()
		{
			var fluentApi = MockRepository.GenerateStub<IFluentApi<Track>>();
			fluentApi.Stub(x => x.WithParameter("", "")).IgnoreArguments().Return(fluentApi);
			flu

			return fluentApi;
		}
		public static IFluentApi<Release> StubbedApi(Release toReturn)
		{
			var fluentApi = MockRepository.GenerateStub<IFluentApi<Release>>();
			fluentApi.Stub(x => x.WithParameter("", "")).IgnoreArguments().Return(fluentApi);
			fluentApi.Stub(x => x.ForReleaseId(0)).IgnoreArguments().Return(fluentApi);
			fluentApi.Stub(x => x.Please()).Return(toReturn);
			return fluentApi;
		}
		public static IFluentApi<ReleaseTracks> StubbedApi(ReleaseTracks toReturn)
		{
			var fluentApi = MockRepository.GenerateStub<IFluentApi<ReleaseTracks>>();
			fluentApi.Stub(x => x.WithParameter("", "")).IgnoreArguments().Return(fluentApi);
			fluentApi.Stub(x => x.WithParameter("", "")).IgnoreArguments().Return(fluentApi);
			fluentApi.Stub(x => x.ForReleaseId(0)).IgnoreArguments().Return(fluentApi);
			fluentApi.Stub(x => x.Please()).Return(toReturn);
			return fluentApi;
		}
		public static IFluentApi<T> StubbedTypedFluentApi<T>(T toReturn)
		{
			var fluentApi = MockRepository.Ge
namespace RusoCars.DAL
    public class UnitOfWork : IDisposable
    {
        private CarsRusoEntities context = new CarsRusoEntities();
        #region Repositories
        private GenericRepository<Category> categoryRepository;
        public GenericRepository<Category> CategoryRepository
        {
            get
            {
                if (this.categoryRepository == null)
                {
                    this.categoryRepository = new CategoryRepository(context);
                }
                return categoryRepository;
            }
        }
        private GenericRepository<Certification> certificationRepository;
        public GenericRepository<Certification> CertificationRepository
        {
            get
            {
                if (this.certificationRepository == null)
                {
                    this.certificationRepository = new CertificationRepository(context);
                }
                return certificationRepository;
            }
 

        private GenericRepository<Client> clientRepository;
        public GenericRepository<Client> ClientRepository
        {
            get
            {
                if (this.clientRepository == null)
                {
                    this.clientRepository = new ClientRepository(context);
                }
                return clientRepository;
            }
        }
        private GenericRepository<Image> imageRepository;
        public GenericRepository<Image> ImageRepository
        {
            get
            {
                if (this.imageRepository == null)
                {
                    this.imageRepository = new ImageRepository(context);
                }
                return imageRepository;
            }
        }
        private GenericRepository<LinksCategory> linksCategoryRepository;
        public GenericRepository<LinksCategory> LinksCategoryRepository
        {
            get
            {
                if (this.linksCategoryRepository ==

                {
                    this.linksCategoryRepository = new LinksCategoryRepository(context);
                }
                return linksCategoryRepository;
            }
        }
        private GenericRepository<Link> linkRepository;
        public GenericRepository<Link> LinkRepository
        {
            get
            {
                if (this.linkRepository == null)
                {
                    this.linkRepository = new LinkRepository(context);
                }
                return linkRepository;
            }
        }
        private GenericRepository<News> newsRepository;
        public GenericRepository<News> NewsRepository
        {
            get
            {
                if (this.newsRepository == null)
                {
                    this.newsRepository = new NewsRepository(context);
                }
                return newsRepository;
            }
        }
        private GenericRepository<Pilot> pilotRepository;
      
namespace Assets.Core
    
    public class ChunkLoader : MonoBehaviour
    {
        public Plane plane;
        private List<ChunkPos> updateList = new List<ChunkPos>();
        private List<ChunkPos> buildList = new List<ChunkPos>();
        static ChunkPos[] neighbourOrder = {    new ChunkPos( 0, 0,  0), new ChunkPos(-1, 0,  0), new ChunkPos( 0, 0, -1), new ChunkPos( 0, 0,  1), new ChunkPos( 1, 0,  0),
                                                new ChunkPos(-1, 0, -1), new ChunkPos(-1, 0,  1), new ChunkPos( 1, 0, -1), new ChunkPos( 1, 0,  1), new ChunkPos(-2, 0,  0),
                                                new ChunkPos( 0, 0, -2), new ChunkPos( 0, 0,  2), new ChunkPos( 2, 0,  0), new ChunkPos(-2, 0, -1), new ChunkPos(-2, 0,  1),
                                                new ChunkPos(-1, 0, -2), new ChunkPos(-1, 0,  2), new ChunkPos( 1, 0, -2), new ChunkPos( 1, 0,  2), new ChunkPos( 2, 0, -1),
                                                new ChunkPos( 2, 0,  1)

                                                new ChunkPos(-3, 0,  0), new ChunkPos( 0, 0, -3), new ChunkPos( 0, 0,  3), new ChunkPos( 3, 0,  0), new ChunkPos(-3, 0, -1),
                                                new ChunkPos(-3, 0,  1), new ChunkPos(-1, 0, -3), new ChunkPos(-1, 0,  3), new ChunkPos( 1, 0, -3), new ChunkPos( 1, 0,  3),
                                                new ChunkPos( 3, 0, -1), new ChunkPos( 3, 0,  1), new ChunkPos(-3, 0, -2), new ChunkPos(-3, 0,  2), new ChunkPos(-2, 0, -3),
                                                new ChunkPos(-2, 0,  3), new ChunkPos( 2, 0, -3), new ChunkPos( 2, 0,  3), new ChunkPos( 3, 0, -2), new ChunkPos( 3, 0,  2),
                                                new ChunkPos(-4, 0,  0), new ChunkPos( 0, 0, -4), new ChunkPos( 0, 0,  4), new ChunkPos( 4, 0,  0), new ChunkPos(-4, 0, -1),
                                                new ChunkPos(-4, 0,  1), new ChunkPos(-1, 0, -4), new ChunkPos(-1, 0,  4), new ChunkPo

                                                new ChunkPos( 4, 0, -1), new ChunkPos( 4, 0,  1), new ChunkPos(-3, 0, -3), new ChunkPos(-3, 0,  3), new ChunkPos( 3, 0, -3),
                                                new ChunkPos( 3, 0,  3), new ChunkPos(-4, 0, -2), new ChunkPos(-4, 0,  2), new ChunkPos(-2, 0, -4), new ChunkPos(-2, 0,  4),
                                                new ChunkPos( 2, 0, -4), new ChunkPos( 2, 0,  4), new ChunkPos( 4, 0, -2), new ChunkPos( 4, 0,  2), new ChunkPos(-5, 0,  0),
                                                new ChunkPos(-4, 0, -3), new ChunkPos(-4, 0,  3), new ChunkPos(-3, 0, -4), new ChunkPos(-3, 0,  4), new ChunkPos( 0, 0, -5),
                                                new ChunkPos( 0, 0,  5), new ChunkPos( 3, 0, -4), new ChunkPos( 3, 0,  4), new ChunkPos( 4, 0, -3), new ChunkPos( 4, 0,  3),
                                                new ChunkPos( 5, 0,  0), new ChunkPos(-5, 0, -1), new ChunkPos(-5, 0,  1), new ChunkPo
namespace DataAccessLayer
    public class UnitOfWork
    {
        MyTicketContext _context;
        public UnitOfWork()
        {
            _context = new MyTicketContext();
        }
        private UserRepository _userRepository;
        public UserRepository UserRepository {
            get {
                if (_userRepository==null)
                {
                    _userRepository = new UserRepository(_context);
                }
                return _userRepository;
            }
        }
        private CustomerRepository _userProfileRepository;
        public CustomerRepository UserProfileRepository
        {
            get
            {
                if (_userProfileRepository == null)
                {
                    _userProfileRepository = new CustomerRepository(_context);
                }
                return _userProfileRepository;
            }
        }
        private BusRepository _busRepository;
        public BusRepository BusRepository
      

            get
            {
                if (_busRepository == null)
                {
                    _busRepository = new BusRepository(_context);
                }
                return _busRepository;
            }
        }
        private CityRepository _cityRepository;
        public CityRepository CityRepository
        {
            get
            {
                if (_cityRepository == null)
                {
                    _cityRepository = new CityRepository(_context);
                }
                return _cityRepository;
            }
        }
        private RouteRepository _routeRepository;
        public RouteRepository RouteRepository
        {
            get
            {
                if (_routeRepository == null)
                {
                    _routeRepository = new RouteRepository(_context);
                }
                return _routeRepository;
            }
        }
        private ScheduleRepository _scheduleRepository;
    

        {
            get
            {
                if (_scheduleRepository == null)
                {
                    _scheduleRepository = new ScheduleRepository(_context);
                }
                return _scheduleRepository;
            }
        }
        private ScheduleTimeRepository _scheduleTimeRepository;
        public ScheduleTimeRepository ScheduleTimeRepository
        {
            get
            {
                if (_scheduleTimeRepository == null)
                {
                    _scheduleTimeRepository = new ScheduleTimeRepository(_context);
                }
                return _scheduleTimeRepository;
            }
        }
        private TicketRepository _ticketRepository;
        public TicketRepository TicketRepository
        {
            get
            {
                if (_ticketRepository == null)
                {
                    _ticketRepository = new TicketRepository(_context);
                }
                return _
namespace musicTherapy1
    public partial class Legend : Form
    {
        public MainForm parentForm;
        public Legend()
        {
            InitializeComponent();
        }
        private void Legend_Load(object sender, EventArgs e)
        {
            instrumentListView.LargeImageList = new ImageList();
            instrumentListView.LargeImageList.ImageSize = new Size(32, 32);
            instrumentListView.SmallImageList = new ImageList();
            instrumentListView.SmallImageList.ImageSize = new Size(16, 16);
            
            instrumentListView.View = View.List;
            
            instrumentListView.Columns.Add("Name", 120, HorizontalAlignment.Left);
            instrumentListView.Columns.Add("Category", 120, HorizontalAlignment.Left);
            instrumentListView.Columns.Add("Sub-category", 120, HorizontalAlignment.Left);
            instrumentListView.Columns.Add("Description", 120, HorizontalAlignment.Right);
          
            ArrayList ins

            instCategList = ((MainForm)(this.parentForm)).instrumentCategorylist;
            int numOfCategories = instCategList.Count;
            int imageIndexCounter = 0;
            for (int CategoryCount = 0; CategoryCount < instCategList.Count; CategoryCount++)
            {
                Category category = (Category)instCategList[CategoryCount];
           
                if (category.SubCategoryList.Count == 0)
                {
                    ArrayList imageList = (ArrayList)category.ImageList;
                    for (int imageCounter = 0; imageCounter < imageList.Count; imageCounter++)
                    {
                        myImage my_image = (myImage)imageList[imageCounter];
                        Bitmap image = new Bitmap(my_image.instrumentImage,new Size(32,32));
                        instrumentListView.LargeImageList.Images.Add( image);
                        ListViewItem instrumentListItem = instrumentListView.Items.Add(my_image.instrumentName, im

                        image = new Bitmap(my_image.instrumentImage, new Size(16, 16));
                        instrumentListView.SmallImageList.Images.Add(image);
                     
                        instrumentListItem.SubItems.Add(my_image.instrumentInfo.Category);
                        instrumentListItem.SubItems.Add(my_image.instrumentInfo.SubCategory);
                        imageIndexCounter++;
                  
                    }
                  
                }
                {
                    ArrayList subCategoryList = (ArrayList)category.SubCategoryList;
                    for (int subCategoryCounter = 0; subCategoryCounter < subCategoryList.Count; subCategoryCounter++)
                    {
                        SubCategory subCategory = (SubCategory)subCategoryList[subCategoryCounter];
                   
                        ArrayList imageList = (ArrayList)subCategory.ImageList;
                        for (int imageCounter = 0; imageCoun
namespace WeConnect.Core
    public static class ApiClientExtension
    {
        public static Task ExecuteAsync(this IApiClient client, Func<ApiDescriptionBuilder, ApiDescriptionBuilder> builder)
        {
            var apiDescription = BuildApiDescription(builder);
            return client.ExecuteAsync(apiDescription);
        }
        public static Task<T> ExecuteAndGetResultAsync<T>(this IApiClient client, Func<ApiDescriptionBuilder, ApiDescriptionBuilder> builder)
        {
            var apiDescription = BuildApiDescription(builder);
            return client.ExecuteAndGetResultAsync<T>(apiDescription);
        }
        public static Task<FileDescription> ExecuteAndGetFileAsync(this IApiClient client, Func<ApiDescriptionBuilder, ApiDescriptionBuilder> builder)
        {
            var apiDescription = BuildApiDescription(builder);
            return client.ExecuteAndGetFileAsync(apiDescription);
        }
        private static ApiDescription BuildApiDescription(Func<ApiD
namespace MiNET.Worlds
	public class FlatlandWorldProvider : IWorldProvider, ICachingWorldProvider
	{
		private static readonly ILog Log = LogManager.GetLogger(typeof (FlatlandWorldProvider));
		public readonly ConcurrentDictionary<ChunkCoordinates, ChunkColumn> _chunkCache = new ConcurrentDictionary<ChunkCoordinates, ChunkColumn>();
		public bool IsCaching { get; private set; }
		public FlatlandWorldProvider()
		{
			IsCaching = true;
			_spawnPoint = new Vector3(0, 0, 0);
		}
		public void Initialize()
		{
		}
		Random rand = new Random();
		private Vector3 _spawnPoint;
		public ChunkColumn GenerateChunkColumn(ChunkCoordinates chunkCoordinates)
		{
			lock (_chunkCache)
			{
				ChunkColumn cachedChunk;
				if (_chunkCache.TryGetValue(chunkCoordinates, out cachedChunk))
				{
					return cachedChunk;
				}
				ChunkColumn chunk = new ChunkColumn();
				chunk.x = chunkCoordinates.X;
				chunk.z = chunkCoordinates.Z;
				int h = PopulateChunk(chunk);
				chunk.RecalcHeight();
				_spaw

				chunk.GetBatch();
				_chunkCache[chunkCoordinates] = chunk;
				return chunk;
			}
		}
		private void BuildStructures(ChunkColumn chunk)
		{
			if (chunk.x == 0 && chunk.z == 1)
			{
				for (int x = 3; x < 6; x++)
				{
					for (int y = 4; y < 7; y++)
					{
						if (x == 4 && y < 6) continue;
						for (int z = 1; z < 15; z++)
						{
							chunk.SetBlock(x, y, z, 3);
						}
					}
				}
				chunk.SetBlock(4, 4, 14, 3);
				chunk.SetBlock(4, 5, 14, 3);
			}
			if (chunk.x == -1 && chunk.z == 0)
			{
				for (int x = 1; x < 15; x++)
				{
					for (int z = 1; z < 15; z++)
					{
						chunk.SetBlock(x, 8, z, 3);
					}
				}
			}
		}
		public Vector3 GetSpawnPoint()
		{
			return _spawnPoint;
		}
		public long GetTime()
		{
			return 6000;
		}
		public string GetName()
		{
			return "Flatland";
		}
		public int PopulateChunk(ChunkColumn chunk)
		{
			int h = 0;
			for (int x = 0; x < 16; x++)
			{
				for (int z = 0; z < 16; z++)
				{
					h = 0;
				}
			}
			return h;
		}
namespace BattleSystem
    public class Invoke
    {
        private static object _lock = new object();
        private int NextInvokeId = 0;
        private static Dictionary<int,InvokeHandler> InvokingList;
        private Invoke()
        {
            InvokingList = new Dictionary<int, InvokeHandler>();
        }
        static Invoke instance;
        static public Invoke Instance
        {
            get
            {
                lock (_lock)
                {
                    if (instance == null)
                        instance = new Invoke();
                }
                return instance;
			
            }
        }
        public int InvokeOnce(Action action, float delay)
        {
            return InvokeRepeating(action, 1, delay);
        }
        public int InvokeRepeating(Action action, int count, float delay)
        {
            return InvokeRepeating(action, count, delay, delay);
        }
        public int InvokeRepeating(Action action, int count, f

        {
            lock (_lock)
            {
                do
                    NextInvokeId++; while (InvokingList.ContainsKey(NextInvokeId));
            
                InvokeHandler invokeHandler = new InvokeHandler(action, count, delay, period, NextInvokeId, RemoveInvokeFromDictionary);
                InvokingList.Add(NextInvokeId, invokeHandler);
            }
            return NextInvokeId;
        }
        private void RemoveInvokeFromDictionary(int invokeId)
        {
            lock (_lock)
            {
                if (InvokingList.ContainsKey(invokeId))
                    InvokingList.Remove(invokeId);
            }
        }
        public void StopInvoke(int invokeId)
        {
            lock (_lock)
            {
                if (InvokingList.ContainsKey(invokeId))
                {
                    InvokeHandler invokeHandler = InvokingList [invokeId];
                    invokeHandler.DestroyInvoke();
                }
            }
        }

        public InvokeHandler GetInvokeHandler(int invokeId)
        {
            lock (_lock)
            {
                if (InvokingList.ContainsKey(invokeId))
                    return InvokingList [invokeId];
            }
            return null;
        }
        public void ChangePeriod(int invokeId, float period)
        {
            ChangePeriod(invokeId, period, period);
        }
        public void ChangePeriod(int invokeId, float delay, float period)
        {
            lock (_lock)
            {
                if (InvokingList.ContainsKey(invokeId))
                {
                    InvokeHandler invokeHandler = InvokingList [invokeId];
                    invokeHandler.ChangePeriod(delay, period);
                }
            }
        }
        public void RemoveAllInvokes()
        {
            lock (_lock)
            {
                while (InvokingList.Count > 0)
                    InvokingList.Values.Last().DestroyInvoke();
                System.G
namespace Roomie.Web.Persistence.Repositories.DapperRepositories
    public class DapperRepositoryFactory : IRepositoryFactory
    {
        private IDbConnection _connection;
        private Lazy<IRepositoryFactory> _parentFactory;
        private IComputerRepository _computerRepository;
        private IDeviceRepository _deviceRepository;
        private INetworkGuestRepository _networkGuestRepository;
        private INetworkRepository _networkRepositoryWithGuests;
        private INetworkRepository _networkRepositoryWithoutGuests;
        private ISessionRepository _sessionRepository;
        private IScriptRepository _scriptRepository;
        private ITaskRepository _taskRepository;
        private IUserRepository _userRepository;
        public DapperRepositoryFactory(IDbConnection connection, Lazy<IRepositoryFactory> parentFactory)
        {
            _connection = connection;
            _parentFactory = parentFactory;
        }
        public IComputerRepository GetComputer

        {
            if (_computerRepository == null)
            {
                var scriptRepository = GetRepository(x => x.GetScriptRepository());
                var userRepository = GetRepository(x => x.GetUserRepository());
                _computerRepository = new ComputerRepository(_connection, scriptRepository, userRepository);
            }
            return _computerRepository;
        }
        public IDeviceRepository GetDeviceRepository()
        {
            if (_deviceRepository == null)
            {
                var networkRepository = GetRepository(x => x.GetNetworkRepository());
                var scriptRepository = GetRepository(x => x.GetScriptRepository());
                var taskRepository = GetRepository(x => x.GetTaskRepository());
                _deviceRepository = new DeviceRepository(_connection, networkRepository, scriptRepository, taskRepository);
            }
            return _deviceRepository;
        }
        public INetworkGuestReposit

        {
            if (_networkGuestRepository == null)
            {
                var networkRepository = GetNetworkRepositoryWithoutGuests();
                var userRepository = GetRepository(x => x.GetUserRepository());
                _networkGuestRepository = new NetworkGuestRepository(_connection, networkRepository, userRepository);
            }
            return _networkGuestRepository;
        }
        public INetworkRepository GetNetworkRepository()
        {
            if (_networkRepositoryWithGuests == null)
            {
                var networkGuestRepository = GetRepository(x => x.GetNetworkGuestRepository());
                var networkRepository = GetNetworkRepositoryWithoutGuests();
                _networkRepositoryWithGuests = new GuestEnabledNetworkRepository(networkRepository, networkGuestRepository);
            }
            return _networkRepositoryWithGuests;
        }
        private INetworkRepository GetNetworkRepositoryWithoutGuests()
      
namespace Common.ProcessExecution
    public class LongRunningExecutor : ILongRunningExecutor
    {
        private IOutputProcessExecutor _executor;
        private readonly IProcessFactory _processFactory;
        private readonly ProcessInstructions _instructions;
        public string Output => _executor.Output;
        public LongRunningExecutor(IProcessFactory processFactory, IOutputProcessExecutor outputProcessExecutor)
        {
            _processFactory = processFactory;
            _executor = outputProcessExecutor;
        }
        public void Execute(string program, string arguments)
        {
            var instructions = new ProcessInstructions
            {
                Program = program,
                Arguments = arguments
            };
            if (_executor.ProcessInstance == null)
                _executor.ProcessInstance = _processFactory.Create(instructions);
                
            _executor.Execute();
        }
        public void Dispose()
    
namespace WorldServer.Region
    public class ChunkManager
    {
        private static int ChunkWidth = 40 * 25;
        private static int ChunkHeight = 40 * 25;
        private static Dictionary<Vector2, WorldChunk> LoadedChunks = new Dictionary<Vector2, WorldChunk>();
        public static Vector2 North = new Vector2(0, -1);
        public static Vector2 NorthEast = new Vector2(1, -1);
        public static Vector2 East = new Vector2(1, 0);
        public static Vector2 SouthEast = new Vector2(1, 1);
        public static Vector2 South = new Vector2(0, 1);
        public static Vector2 SouthWest = new Vector2(-1, 1);
        public static Vector2 West = new Vector2(-1, 0);
        public static Vector2 NorthWest = new Vector2(-1, -1);
       
        public static List<WorldChunk> GetLocalChunks(WorldChunk CurrentChunk) {
            Vector2 Location = new Vector2(CurrentChunk.BoundingBox.X,
                CurrentChunk.BoundingBox.Y);
            List<WorldChunk> RetVal = new List

            RetVal.Add(CurrentChunk);
            RetVal.Add(GetChunkViaLocation(Location + North));
            RetVal.Add(GetChunkViaLocation(Location + NorthEast));
            RetVal.Add(GetChunkViaLocation(Location + East));
            RetVal.Add(GetChunkViaLocation(Location + SouthEast));
            RetVal.Add(GetChunkViaLocation(Location + South));
            RetVal.Add(GetChunkViaLocation(Location + SouthWest));
            RetVal.Add(GetChunkViaLocation(Location + West));
            RetVal.Add(GetChunkViaLocation(Location + NorthWest));
            return RetVal;
        }
        public static WorldChunk GetChunk(Vector2 WorldLocation) {
            Vector2 ChunkVector = new Vector2();
            ChunkVector.X = (int)WorldLocation.X / ChunkWidth;
            ChunkVector.Y = (int)WorldLocation.Y / ChunkHeight;
            return GetChunkViaLocation(ChunkVector);
        }
        public static WorldChunk GetChunkViaLocation(Vector2 ChunkLocation) {
            MongoDB.Do

            ChunkFind["x"] = ChunkLocation.X;
            ChunkFind["y"] = ChunkLocation.Y;
            if (LoadedChunks.ContainsKey(ChunkLocation))
                return LoadedChunks[ChunkLocation];
            else
            {
                var ChunkDoc = DatabaseManager.GetCollection("test", "world_chunk_bounds").Find(ChunkFind);
                if (ChunkDoc.Documents.Count() > 0)
                {
                    MongoDB.Document Doc = ChunkDoc.Documents.First();
                    var ChunkRect = new Rectangle((int)Doc["x"], (int)Doc["y"], (int)Doc["width"], (int)Doc["height"]);
                    LoadedChunks.Add(ChunkLocation, new WorldChunk(ChunkRect));
                    LoadedChunks[ChunkLocation].LoadFromDB();
                    return LoadedChunks[ChunkLocation];
                }
            }
            LoadedChunks.Add(ChunkLocation, new WorldChunk(new Rectangle(
                (int)ChunkLocation.X,
                (int)ChunkLocation.Y,
                Ch
namespace fluidedotnet
  public delegate void MyCallbackDelegate(SceneParam param);
  public partial class FormParam : Form
  {
    MyCallbackDelegate callback;
    Instrument instrument= new Instrument();
    public FormParam()
    {
      InitializeComponent();
    }
    public void InitParam(string path,MyCallbackDelegate c)
    {
      callback = c;
      var files = from file in Directory.GetFiles(path)
                  orderby file where file.EndsWith(".geo")
                  select file;
      foreach (var file in files)
      {
        FileList.Items.Add(Path.GetFileNameWithoutExtension(file));
      }
      XTrack.Value = 1;
      instrument.zoom = true;
      instrument.zoomx = XTrack.Value;
      instrument.changeinstrument = true;
      SetParams(true);
    }
    private void FormParam_Load(object sender, EventArgs e)
    {
    }
    public void SetParams(bool reinit)
    {
      SceneParam param = new SceneParam();
      param.reinit = reinit;
      if(FileList.SelectedI

        param.file = FileList.SelectedItem.ToString();
      else
      param.file = "triangle";
      param.instrument = instrument;
      callback(param);
    }
    private void FileList_SelectedIndexChanged(object sender, EventArgs e)
    {
      instrument = new Instrument();
      SetParams(true);
    }
    private void XTrack_Scroll(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.zoom = true;
      instrument.zoomx = XTrack.Value;
      instrument.changeinstrument = true;
      SetParams(false);
    }
    private void ButDrop_Click(object sender, EventArgs e)
    {
      instrument = new  Instrument();
      instrument.changeinstrument = true;
      instrument.drop = true;
      SetParams(false);
    }
    private void butPipe_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.pipe = true;
      SetParams(false);
    }
    private void butObstacle_Click(ob

    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.setter = true;
      SetParams(false);
    }
    private void butDelate_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.remover = true;
      SetParams(false);
    }
    private void butForce_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.forceup = true;
      SetParams(false);
    }
    private void butForceDown_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.forcedown = true;
      SetParams(false);
    }
    private void butPush_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.push = true;
      SetParams(false);
    }
    private void 
namespace JInput {
    public class CurrentController : MonoBehaviour {
        private Controller m_Controller;
        public static Controller currentController { get { return m_Singleton.m_Controller; } }
        [Range(0, 5)]
        public int m_ControllerIndex = 0;
        private static CurrentController m_Singleton;
        void Awake() {
            m_Singleton = this;
            getController();
        }
        void OnEnable() {
            m_Singleton = this;
            getController();
        }
        void Update() {
            getController();
        }
        private void updateController() {
            m_Controller = InputManager.getController(m_ControllerIndex);
        }
        private void getController() {
            updateController();
            if (m_Controller == null) {
                m_ControllerIndex--;
                if (m_ControllerIndex == -1) {
                    m_ControllerIndex = 0;
                    return;
                }
         
namespace PP.WaiMai.Repository
	public partial class DbSession : IDbSession 
    { 
		#region 数据接口 ICommentRepository
		private ICommentRepository _CommentRepository;
        public ICommentRepository CommentRepository 
        {
            get
            {
                if (_CommentRepository == null)
                {
                    _CommentRepository = new CommentRepository();
                }
                return _CommentRepository; 
            }
            set
            {
                _CommentRepository = value;
            }
        }
		#endregion
		#region 数据接口 IConfigRepository
		private IConfigRepository _ConfigRepository;
        public IConfigRepository ConfigRepository 
        {
            get
            {
                if (_ConfigRepository == null)
                {
                    _ConfigRepository = new ConfigRepository();
                }
                return _ConfigRepository; 
            }
            set
            {
                

            }
        }
		#endregion
		#region 数据接口 IExpendLogRepository
		private IExpendLogRepository _ExpendLogRepository;
        public IExpendLogRepository ExpendLogRepository 
        {
            get
            {
                if (_ExpendLogRepository == null)
                {
                    _ExpendLogRepository = new ExpendLogRepository();
                }
                return _ExpendLogRepository; 
            }
            set
            {
                _ExpendLogRepository = value;
            }
        }
		#endregion
		#region 数据接口 IFeedbackRepository
		private IFeedbackRepository _FeedbackRepository;
        public IFeedbackRepository FeedbackRepository 
        {
            get
            {
                if (_FeedbackRepository == null)
                {
                    _FeedbackRepository = new FeedbackRepository();
                }
                return _FeedbackRepository; 
            }
            set
            {
                _Feedbac

            }
        }
		#endregion
		#region 数据接口 IFoodMenuRepository
		private IFoodMenuRepository _FoodMenuRepository;
        public IFoodMenuRepository FoodMenuRepository 
        {
            get
            {
                if (_FoodMenuRepository == null)
                {
                    _FoodMenuRepository = new FoodMenuRepository();
                }
                return _FoodMenuRepository; 
            }
            set
            {
                _FoodMenuRepository = value;
            }
        }
		#endregion
		#region 数据接口 IFoodMenuCategoryRepository
		private IFoodMenuCategoryRepository _FoodMenuCategoryRepository;
        public IFoodMenuCategoryRepository FoodMenuCategoryRepository 
        {
            get
            {
                if (_FoodMenuCategoryRepository == null)
                {
                    _FoodMenuCategoryRepository = new FoodMenuCategoryRepository();
                }
                return _FoodMenuCategoryRepository; 
      
﻿/*
 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with this file, You can obtain one at
 */
namespace FSO.Files.Formats.IFF
    public class IffFile : IFileInfoUtilizer
    {
        public static bool RETAIN_CHUNK_DATA = false;
        public string Filename;
        private static Dictionary<string, Type> CHUNK_TYPES = new Dictionary<string, Type>()
        {
            {"STR#", typeof(STR)},
            {"CTSS", typeof(CTSS)},
            {"PALT", typeof(PALT)},
            {"OBJD", typeof(OBJD)},
            {"DGRP", typeof(DGRP)},
            {"SPR#", typeof(SPR)},
            {"SPR2", typeof(SPR2)},
            {"BHAV", typeof(BHAV)},
            {"TPRP", typeof(TPRP)},
            {"SLOT", typeof(SLOT)},
            {"GLOB", typeof(GLOB)},
            {"BCON", typeof(BCON)},
            {"TTAB", typeof(TTAB)},
            {"OBJf", typeof(OBJf)},
            {"TTAs", typeof(TTAs)},
            

            {"BMP_", typeof(BMP)},
            {"PIFF", typeof(PIFF) }
        };
        public IffRuntimeInfo RuntimeInfo = new IffRuntimeInfo();
        private Dictionary<Type, Dictionary<ushort, object>> ByChunkId;
        private Dictionary<Type, List<object>> ByChunkType;
        public List<IffChunk> RemovedOriginal = new List<IffChunk>();
        public IffFile()
        {
            ByChunkId = new Dictionary<Type, Dictionary<ushort, object>>();
            ByChunkType = new Dictionary<Type, List<object>>();
        }
        public IffFile(string filepath) : this()
        {
            {
                this.Read(stream);
                SetFilename(Path.GetFileName(filepath));
            }
        }
        public void Read(Stream stream)
        {
            {
                var identifier = io.ReadCString(60, false).Replace("\0", "");
                if (identifier != "IFF FILE 2.5:TYPE FOLLOWED BY SIZE JAMIE DOORNBOS & MAXIS 1")
                {
                  

                }
                var rsmpOffset = io.ReadUInt32();
                while (io.HasMore)
                {
                    var chunkType = io.ReadCString(4);
                    var chunkSize = io.ReadUInt32();
                    var chunkID = io.ReadUInt16();
                    var chunkFlags = io.ReadUInt16();
                    var chunkLabel = io.ReadCString(64).TrimEnd('\0');
                    var chunkDataSize = chunkSize - 76;
                    /** Do we understand this chunk type? **/
                    if (!CHUNK_TYPES.ContainsKey(chunkType))
                    {
                        /** Skip it! **/
                    }else{
                        Type chunkClass = CHUNK_TYPES[chunkType];
                        IffChunk newChunk = (IffChunk)Activator.CreateInstance(chunkClass);
                        newChunk.ChunkID = chunkID;
                        newChunk.OriginalID = chunkID;
                        newChunk.ChunkFlags = chunkFlags;
  
namespace LendingLibrary_Library.MusicSelection
    public  class ChoralMusicSelection : MusicSelection
    {
        public String Voicing { get; private set; }
        public String Voicing_LowerCase { get; private set; }
        public String Accompaniment { get; private set; }
        public String Accompaniment_LowerCase { get; private set; }
        public Boolean IsSacred { get; private set; }
        private List<ChoralInstrumentPart> InstrumentParts;
        public ChoralMusicSelection(String id, String institution_Id, String title, Contributor composer, Boolean isSacred)
            : base(id, institution_Id, title, composer)
        {
            this.IsSacred = isSacred;
            this.InstrumentParts = new List<ChoralInstrumentPart>();
        }
        public ChoralMusicSelection(String institution_Id, String title, Contributor composer, Boolean isSacred)
            : base(institution_Id, title, composer)
        {
            this.IsSacred = isSacred;
            this

        }
        public void setVoicing(String voicing){
            this.Voicing = String.IsNullOrWhiteSpace(voicing) == true ? "" : voicing.Trim();
            this.Voicing_LowerCase = String.IsNullOrWhiteSpace(voicing) == true ? "" : voicing.Trim().ToLower();
        }
        public void setAccompaniment(String accompaniment)
        {
            this.Accompaniment = String.IsNullOrWhiteSpace(accompaniment) == true ? "" : accompaniment.Trim();
            this.Accompaniment_LowerCase = String.IsNullOrWhiteSpace(accompaniment) == true ? "" : accompaniment.Trim().ToLower();
        }
        public void setIsSacred(Boolean isSacred)
        {
            this.IsSacred = isSacred;
        }
        public void addInstrumentPart(ChoralInstrumentPart instrumentPart)
        {
            if (instrumentPart == null)
            {
                throw new ArgumentNullException("In class ChoralMusicSelection, method AddInstrumentPart().  Argument cannot be null.");
            }
      

            {
                return;
            }
            this.InstrumentParts.Add(instrumentPart);
        }
        public void removeInstrumentPart(ChoralInstrumentPart instrumentPart)
        {
            if (instrumentPart == null)
            {
                throw new ArgumentNullException("In class ChoralMusicSelection, method AddInstrumentPart().  Argument cannot be null.");
            }
            if (this.InstrumentParts.Exists(i => i.InstrumentName == instrumentPart.InstrumentName))
            {
                this.InstrumentParts.RemoveAt(this.InstrumentParts.FindIndex(i => i.InstrumentName == instrumentPart.InstrumentName));
            }
            else
            {
                throw new ArgumentException("In class ChoralMusicSelection, method removeInstrumentPart(). Unable to remove instrument part that does not exist in the list.");
            }
        }
        public void setInstrumentParts(List<ChoralInstrumentPart> instrumentParts)
        {
  
namespace RecensysRepository.Repository.Factory
    public class RepositoryFactoryMemory : IRepositoryFactory
    {
        private static UserRepositoryIm _userRepository;
        private static StudyRepositoryIm _studyRepository;
        private static StageRepositoryIm _stageRepository;
        private static FieldRepositoryIm _fieldRepository;
        private static FieldDataRepositoryIm _fieldDataRepository;
        private static TaskRepositoryIm _taskRepository;
        private static ArticleRepositoryIm _articleRepository;
        private static CredentialsRepositoryIm _credentialsRepository;
        private static UserStudyRelationRepositoryIm _userStudyRelationRepository;
        private static StudyRoleRepositoryIm _studyRoleRepository;
        private static StrategyRepositoryIm _strategyRepository;
        public IUserRepository GetUserRepo()
        {
            return _userRepository ?? (_userRepository = new UserRepositoryIm());
        }
        public IStudyRepositor

        {
            return _studyRepository ?? (_studyRepository = new StudyRepositoryIm());
        }
        public IStageRepository GetStageRepo()
        {
            return _stageRepository ?? (_stageRepository = new StageRepositoryIm());
        }
        public IFieldRepository GetFieldRepo()
        {
            return _fieldRepository ?? (_fieldRepository = new FieldRepositoryIm());
        }
        public IFieldDataRepository GetFieldDataRepo()
        {
            return _fieldDataRepository ?? (_fieldDataRepository = new FieldDataRepositoryIm());
        }
        public ITaskRepository GetTaskRepo()
        {
            return _taskRepository ?? (_taskRepository = new TaskRepositoryIm());
        }
        public IArticleRepository GetArticleRepo()
        {
            return _articleRepository ?? (_articleRepository = new ArticleRepositoryIm());
        }
        public ICredentialsRepository GetCredentialsRepo()
        {
            return _credentialsRepositor
namespace Grabacr07.KanColleWrapper.Models.Raw
	public class kcsapi_combined_battle
	{
		public string api_deck_id { get; set; }
		public int[] api_ship_ke { get; set; }
		public int[] api_ship_lv { get; set; }
		public int[] api_nowhps { get; set; }
		public int[] api_maxhps { get; set; }
		public int[] api_nowhps_combined { get; set; }
		public int[] api_maxhps_combined { get; set; }
		public int api_midnight_flag { get; set; }
		public int[][] api_eSlot { get; set; }
		public int[][] api_eKyouka { get; set; }
		public int[][] api_fParam { get; set; }
		public int[][] api_eParam { get; set; }
		public int[][] api_fParam_combined { get; set; }
		public int[] api_search { get; set; }
		public object[] api_formation { get; set; }
		public int[] api_stage_flag { get; set; }
		public Api_Kouku api_kouku { get; set; }
		public int api_support_flag { get; set; }
		public object api_support_info { get; set; }
		public int api_opening_flag { get; set; }
		public object api_opening_atack { get

		public int[] api_hourai_flag { get; set; }
		public Api_Hougeki1 api_hougeki1 { get; set; }
		public Api_Raigeki api_raigeki { get; set; }
		public Api_Hougeki2 api_hougeki2 { get; set; }
		public Api_Hougeki3 api_hougeki3 { get; set; }
	}
	public class Api_Kouku
	{
		public int[][] api_plane_from { get; set; }
		public Api_Stage1 api_stage1 { get; set; }
		public Api_Stage2 api_stage2 { get; set; }
		public Api_Stage3 api_stage3 { get; set; }
		public Api_Stage3_Combined api_stage3_combined { get; set; }
	}
	public class Api_Stage1
	{
		public int api_f_count { get; set; }
		public int api_f_lostcount { get; set; }
		public int api_e_count { get; set; }
		public int api_e_lostcount { get; set; }
		public int api_disp_seiku { get; set; }
		public int[] api_touch_plane { get; set; }
	}
	public class Api_Stage2
	{
		public int api_f_count { get; set; }
		public int api_f_lostcount { get; set; }
		public int api_e_count { get; set; }
		public int api_e_lostcount { get; set; }
	}
	publi

	{
		public int[] api_frai_flag { get; set; }
		public int[] api_erai_flag { get; set; }
		public int[] api_fbak_flag { get; set; }
		public int[] api_ebak_flag { get; set; }
		public int[] api_fcl_flag { get; set; }
		public int[] api_ecl_flag { get; set; }
		public int[] api_fdam { get; set; }
		public int[] api_edam { get; set; }
	}
	public class Api_Stage3_Combined
	{
		public int[] api_frai_flag { get; set; }
		public int[] api_fbak_flag { get; set; }
		public int[] api_fcl_flag { get; set; }
		public float[] api_fdam { get; set; }
	}
	public class Api_Hougeki1
	{
		public int[] api_at_list { get; set; }
		public int[] api_at_type { get; set; }
		public object[] api_df_list { get; set; }
		public object[] api_si_list { get; set; }
		public object[] api_cl_list { get; set; }
		public object[] api_damage { get; set; }
	}
	public class Api_Raigeki
	{
		public int[] api_frai { get; set; }
		public int[] api_erai { get; set; }
		public int[] api_fdam { get; set; }
		public float[] api
namespace Plants_vs_Crackers
    class Program
    {
        static void Main(string[] args)
        {
            ProcessHandler processHandler = ProcessHandler.getProcessHandler("popcapgame1.exe");
            IntPtr processPointer = Interop.GetTargetProcessAccess(processHandler);
            IntPtr loadLibraryPointer = Interop.GetLoadLibraryANSIProcessAddress();
            string dllName = "foo.exe";
            IntPtr processAllocation = Interop.SetTargetProcessVirtualAllocation(processPointer, dllName);
            Console.WriteLine();
        }
    }
    class ProcessHandler
    {
        public string processName { get; private set; }
        public int processId { get; private set; }
        
        private const int ZERO_INDEX = 0;
        private ProcessHandler(string processName, int processId)
        {
            this.processName = processName;
            this.processId = processId;
        }
        private static IEnumerable<Process> findTargettedProcess(ref string t
namespace MassTransit.Steward.Core.Consumers
    public class ConsumerDispatchContext :
        ConsumeContextProxy,
        DispatchContext
    {
        readonly DispatchMessage _message;
        public ConsumerDispatchContext(ConsumeContext<DispatchMessage> context, string body)
            : base(context)
        {
            _message = context.Message;
            Body = body;
        }
        public DispatchResult Accept()
        {
            return new AcceptDispatchResult();
        }
        public DispatchResult Delay(TimeSpan timeSpan, string reason)
        {
            return new DelayDispatchResult(timeSpan, reason);
        }
        public DispatchResult Discard(string reason)
        {
            return new DiscardDispatchResult(reason);
        }
        public DispatchResult Refuse(string reason)
        {
            return new RefuseDispatchResult(reason);
        }
        public DispatchResult Reject(string reason)
        {
            return new RejectDis
namespace BitAuto.HMC.ServiceBus.MessageLib.Storage
    internal class ChunkManager : IDisposable
    {
        private readonly object _lock;
        private readonly int _maxChunkSize;
        private readonly DirectoryInfo _directory;
        private readonly ChunkNameManager _chunkNameManager;
        private readonly IRecordProtocol _protocol;
        private readonly IChunkConsumeOffset _offset;
        private long _lastOffsetPosition;
        private ReadWriteChunk _writerChunk;
        private Chunk _readerChunk;
        public ChunkManager(int maxChunkSize, DirectoryInfo directory, IRecordProtocol protocol, IChunkConsumeOffset offset)
        {
            _lock = new object();
            _maxChunkSize = maxChunkSize;
            _directory = directory;
            _chunkNameManager = new ChunkNameManager(directory.FullName);
            _protocol = protocol;
            _offset = offset;
            InitWriterChunk();
            InitReaderChunk();
        }
        private

        {
            var chunkName = default(ChunkName);
            if (!_chunkNameManager.TryGetLast(out chunkName))
            {
                chunkName = _chunkNameManager.CreateNext();
                _writerChunk = ReadWriteChunk.CreateNew(chunkName, _maxChunkSize, _protocol);
            }
            else
            {
                _writerChunk = ReadWriteChunk.InitOnGoing(chunkName, _protocol);
            }
            if (_writerChunk.IsCompleted)
            {
                chunkName = _chunkNameManager.CreateNext();
                _writerChunk = ReadWriteChunk.CreateNew(chunkName, _maxChunkSize, _protocol);
            }
        }
        private void InitReaderChunk()
        {
            var chunkName = default(string);
            var position = default(long);
            var readerChunkName = default(ChunkName);
            if (_offset.TryRead(out chunkName, out position) && _chunkNameManager.TryParse(chunkName, out readerChunkName))
            {
         

                _readerChunk = new Chunk(readerChunkName, _protocol);
            }
            else if (_chunkNameManager.TryGetFirst(out readerChunkName))
            {
                _lastOffsetPosition = ChunkHeader.Size;
                _readerChunk = new Chunk(readerChunkName, _protocol);
            }
            else
            {
                throw new Exception("无法读取chunk信息");
            }
        }
        public long Write(byte[] value)
        {
            lock (_lock)
            {
                var result = _writerChunk.Write(value);
                if (result == ChunkWriteResult.NotEnoughSpace)
                {
                    var chunkName = (ChunkName)null;
                    _writerChunk.Complete();
                    _writerChunk.Dispose();
                    chunkName = _chunkNameManager.CreateNext();
                    _writerChunk = ReadWriteChunk.CreateNew(chunkName, _maxChunkSize, _protocol);
                    result = _writerChunk.Write(val
namespace Machine.Partstore.Application
  public class RepositorySets : IManipulateRepositorySets
  {
    private readonly ICurrentProjectRepository _currentProjectRepository;
    private readonly IRepositoryRepository _repositoryRepository;
    private readonly IRepositorySetRepository _repositorySetRepository;
    public RepositorySets(ICurrentProjectRepository currentProjectRepository, IRepositoryRepository repositoryRepository, IRepositorySetRepository repositorySetRepository)
    {
      _currentProjectRepository = currentProjectRepository;
      _repositorySetRepository = repositorySetRepository;
      _repositoryRepository = repositoryRepository;
    }
    #region IManipulateRepositories Members
    public AddingVersionResponse AddNewVersion(string repositoryName, string tags)
    {
      CurrentProject project = _currentProjectRepository.FindCurrentProject();
      if (project.BuildDirectory.IsMissing)
      {
        return new AddingVersionResponse(AddingVersionResponse.Statu

      }
      if (project.BuildDirectory.IsEmpty)
      {
        return new AddingVersionResponse(AddingVersionResponse.Status.BuildDirectoryEmpty);
      }
      RepositorySet repositorySet = project.RepositorySet;
      Repository repository;
      if (repositorySet.HasMoreThanOneRepository)
      {
        if (String.IsNullOrEmpty(repositoryName))
        {
          return new AddingVersionResponse(AddingVersionResponse.Status.AmbiguousRepositoryName);
        }
        repository = repositorySet.FindRepositoryByName(repositoryName);
      }
      else
      {
        repository = repositorySet.DefaultRepository;
      }
      project.AddNewVersion(repository, new Tags(tags));
      _repositoryRepository.SaveRepository(repository);
      return new AddingVersionResponse(AddingVersionResponse.Status.Success);
    }
    
    public bool Refresh()
    {
      RepositorySet repositorySet = _repositorySetRepository.FindDefaultRepositorySet();
      repositorySet.Refresh();
      retur
namespace LimsProject.BusinessLayer
	public class CPrice: BusinessObjectBase
	{
		#region InnerClass
		public enum CPriceFields
		{
			Idprice,
			Cod_price,
			Dispatch_person,
			Dispatch_mail,
			Dispatch_curier,
			Dispatch_transport,
			Dispatch_fax,
			Dispatch_otro,
			Request_reference
		}
		#endregion
		#region Data Members
			int _idprice;
			string _cod_price;
			short? _dispatch_person;
			short? _dispatch_mail;
			short? _dispatch_curier;
			short? _dispatch_transport;
			short? _dispatch_fax;
			short? _dispatch_otro;
			int? _request_reference;
		#endregion
		#region Properties
		public int  Idprice
		{
			 get { return _idprice; }
			 set
			 {
				 if (_idprice != value)
				 {
					_idprice = value;
					 PropertyHasChanged("Idprice");
				 }
			 }
		}
		public string  Cod_price
		{
			 get { return _cod_price; }
			 set
			 {
				 if (_cod_price != value)
				 {
					_cod_price = value;
					 PropertyHasChanged("Cod_price");
				 }
			 }
		}
		public short?  Dispatch

		{
			 get { return _dispatch_person; }
			 set
			 {
				 if (_dispatch_person != value)
				 {
					_dispatch_person = value;
					 PropertyHasChanged("Dispatch_person");
				 }
			 }
		}
		public short?  Dispatch_mail
		{
			 get { return _dispatch_mail; }
			 set
			 {
				 if (_dispatch_mail != value)
				 {
					_dispatch_mail = value;
					 PropertyHasChanged("Dispatch_mail");
				 }
			 }
		}
		public short?  Dispatch_curier
		{
			 get { return _dispatch_curier; }
			 set
			 {
				 if (_dispatch_curier != value)
				 {
					_dispatch_curier = value;
					 PropertyHasChanged("Dispatch_curier");
				 }
			 }
		}
		public short?  Dispatch_transport
		{
			 get { return _dispatch_transport; }
			 set
			 {
				 if (_dispatch_transport != value)
				 {
					_dispatch_transport = value;
					 PropertyHasChanged("Dispatch_transport");
				 }
			 }
		}
		public short?  Dispatch_fax
		{
			 get { return _dispatch_fax; }
			 set
			 {
				 if (_dispatch_fax != value)
				 {
					_dis
namespace FreeQuant.Pricers
  public class IndexPricer : IPricer
  {
    public virtual double Price(Instrument instrument)
    {
      double num = 0.0;
      foreach (Leg leg in (FIXGroupList) instrument.Legs)
      {
        switch (leg.LegSide)
        {
          case '1':
          case '3':
            num += leg.LegRatioQty * leg.Instrument.Price();
            continue;
          case '2':
          case '5':
            num -= leg.LegRatioQty * leg.Instrument.Price();
            continue;
          default:
            throw new ApplicationException( (object) instrument.Symbol + (string) (object) leg.LegSide + leg.Instrument.Symbol);
        }
      }
      return num;
    }
    public virtual double Volatility(Instrument instrument)
    {
      return 0.0;
    }
    public virtual double Delta(Instrument instrument)
    {
      return 0.0;
    }
    public virtual double Gamma(Instrument instrument)
    {
      return 0.0;
    }
    public virtual double Theta(Instrument in

    {
      return 0.0;
    }
    public virtual double Vega(Instrument instrument)
    {
      return 0.0;
    }
    
    public virtual double Rho(Instrument instrument)
    {
      return 0.0;
    }
    public virtual double Price(Instrument instrument, DateTime dateTime)
    {
      double num = 0.0;
      foreach (Leg leg in (FIXGroupList) instrument.Legs)
      {
        switch (leg.LegSide)
        {
          case '1':
          case '3':
            num += leg.LegRatioQty * leg.Instrument.Price(dateTime);
            continue;
          case '2':
          case '5':
            num -= leg.LegRatioQty * leg.Instrument.Price();
            continue;
          default:
            throw new ApplicationException((object) instrument.Symbol + (string) (object) leg.LegSide  + leg.Instrument.Symbol);
        }
      }
      return num;
    }
    
    public virtual double Volatility(Instrument instrument, DateTime dateTime1, DateTime dateTime2)
    {
      return 0.0;
    }
    
    
#region License
/*
 * Copyright 2008,2009 Vitaliy Fedorchenko
 * Distributed under the LGPL licence
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#endregion
namespace NReco.Composition {
	public class DynamicInvokeMethod : IOperation<object>, IProvider<object,object> {
		InvokeMethod InvokeMethodInstance = null;
		public IProvider<object,object> TargetProvider { get; set; }
		public IProvider<object,string> MethodNameProvider { get; set; }
		public IProvider<object,object>[] ArgumentProviders { get; set;	}
		public DynamicInvokeMethod() { }
		public DynamicInvokeMethod(InvokeMethod invokeMethodInstance) {
			InvokeMethodInstance = invokeMethodInstance;
		}
		public void Execute(object context) {
			Provide(c
namespace OpenQuant.API
  public class AltIDGroupList : IEnumerable
  {
    internal Instrument instrument;
    public AltIDGroup this[string altSource]
    {
      get
      {
        foreach (FIXSecurityAltIDGroup group in (FIXGroupList) this.instrument.instrument.SecurityAltIDGroup)
        {
          if (group.SecurityAltIDSource == altSource)
            return new AltIDGroup(this.instrument, group);
        }
        return (AltIDGroup) null;
      }
    }
    public int Count
    {
      get
      {
        return this.instrument.instrument.SecurityAltIDGroup.Count;
      }
    }
    internal AltIDGroupList(Instrument instrument)
    {
      this.instrument = instrument;
    }
    public AltIDGroup Add(string altSource)
    {
      foreach (FIXSecurityAltIDGroup group in (FIXGroupList) this.instrument.instrument.SecurityAltIDGroup)
      {
        if (group.SecurityAltIDSource == altSource)
          return new AltIDGroup(this.instrument, group);
      }
      FIXSecurityAltIDG
namespace MissionPlanner.Controls
    public static class ControlHelpers
    {
        public static void InvokeIfRequired<T>(this T control, Action<T> action) where T : ISynchronizeInvoke
        {
            if (control.InvokeRequired)
            {
                control.Invoke(new Action(() => action(control)), null);
            }
            else
            {
                action(control);
            }
        }
        public static void InvokeIfRequired(this ISynchronizeInvoke control, MethodInvoker action)
        {
            if (control.InvokeRequired)
            {
                control.Invoke(action, null);
            }
            else
            {
                action();
            }
        }
        public static void BeginInvokeIfRequired<T>(this T control, Action<T> action) where T : ISynchronizeInvoke
        {
            if (control.InvokeRequired)
            {
                control.BeginInvoke(new Action(() => action(control)), null);
           
﻿namespace IDockerComposeProcess
    public interface IDockerComposeProcess
    {
        IDockerComposeProcessResult Build(IDockerComposeProcessModel dockerComposeProcessModel);
        IDockerComposeProcessResult Config(IDockerComposeProcessModel dockerComposeProcessModel);
        IDockerComposeProcessResult Create(IDockerComposeProcessModel dockerComposeProcessModel);
        IDockerComposeProcessResult Down(IDockerComposeProcessModel dockerComposeProcessModel);
        IDockerComposeProcessResult Events(IDockerComposeProcessModel dockerComposeProcessModel);
        IDockerComposeProcessResult Help(IDockerComposeProcessModel dockerComposeProcessModel);
        IDockerComposeProcessResult Kill(IDockerComposeProcessModel dockerComposeProcessModel);
        IDockerComposeProcessResult Logs(IDockerComposeProcessModel dockerComposeProcessModel);
        IDockerComposeProcessResult Pause(IDockerComposeProcessModel dockerComposeProcessModel);
        IDockerComposeProcessResult Port(IDock

        IDockerComposeProcessResult ListContainers(IDockerComposeProcessModel dockerComposeProcessModel);
        IDockerComposeProcessResult Pull(IDockerComposeProcessModel dockerComposeProcessModel);
        IDockerComposeProcessResult Restart(IDockerComposeProcessModel dockerComposeProcessModel);
        IDockerComposeProcessResult RemoveContainer(IDockerComposeProcessModel dockerComposeProcessModel);
        IDockerComposeProcessResult Run(IDockerComposeProcessModel dockerComposeProcessModel);
        IDockerComposeProcessResult Scale(IDockerComposeProcessModel dockerComposeProcessModel);
        IDockerComposeProcessResult Start(IDockerComposeProcessModel dockerComposeProcessModel);
        IDockerComposeProcessResult Stop(IDockerComposeProcessModel dockerComposeProcessModel);
        IDockerComposeProcessResult Unpause(IDockerComposeProcessModel dockerComposeProcessModel);
        IDockerComposeProcessResult Up(IDockerComposeProcessModel dockerComposeProcessModel);
        IDock
public class World : MonoBehaviour
    public GameObject chunkPrefab;
    public List<Chunk> spawnedChunkList;
    public SaveLoad saveLoadManager;
    private void Awake()
    {
        spawnedChunkList = new List<Chunk>();
        saveLoadManager = GameObject.Find("Game").GetComponent<SaveLoad>();
    }
    public void CreateNew()
    {
        spawnedChunkList = new List<Chunk>();
        for (int x = -1; x <= 1; x++)
        {
            for (int y = -1; y <= 1; y++)
            {
                Chunk chunk = Instantiate(chunkPrefab).GetComponent<Chunk>();
                chunk.CreateNew(x, y);
                chunk.transform.parent = this.transform;
                spawnedChunkList.Add(chunk);
            }
        }
        Debug.Log("new world created");
    }
    public void Repopulate(int xOffset, int yOffset)
    {
        for (int x = xOffset - 1; x <= xOffset + 1; x++)
        {
            for (int y = yOffset - 1; y <= yOffset + 1; y++)
            {
                if 

                {
                    Chunk newChunk = Instantiate(chunkPrefab).GetComponent<Chunk>();
                    newChunk.name = "Chunk " + x + " " + y;
                    newChunk.transform.parent = this.transform;
                    spawnedChunkList.Add(newChunk);
                    newChunk.xOffset = x;
                    newChunk.yOffset = y;
                    if (saveLoadManager.Exists(newChunk))
                    {
                        Debug.Log("chunk is not spawned, but can be loaded");
                        saveLoadManager.Load(newChunk);
                    }
                    else
                    {
                        Debug.Log("chunk is not exists, creating new");
                        newChunk.CreateNew(x, y);
                    }
                }
            }
        }
        Debug.Log("world repopulated");
    }
    public bool ChunkIsAlreadyInWorld(string name)
    {
        bool chunkIsInList = false;
        foreach (Chunk spawn
public class World : MonoBehaviour {
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public GameObject chunkPrefab;
    public string worldName = "world";
    public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(x, y, z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        var terrainGen = new TerrainGen();
        newChunk = terrainGen.ChunkGen(newChunk);
        newChunk.SetBlocksUnmodified();
        Serialization.Load(newChunk);
    }
    public void DestroyChunk(int x, int y, int z)
    {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
      

            Serialization.SaveChunk(chunk);
            Object.Destroy(chunk.gameObject);
            chunks.Remove(new WorldPos(x, y, z));
        }
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / multiple) * Chunk.chunkSize;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Block GetBlock(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null)
        {
            Block block = containerChunk.GetBlock(
                x - containerChunk.pos.x,
                y - containerChunk.pos.y,
                z - containerChunk.pos.z);
            return block;
        }
        else
        

            return new BlockAir();
        }
    }
    public void SetBlock(int x, int y, int z, Block block)
    {
        Chunk chunk = GetChunk(x, y, z);
        if (chunk != null)
        {
            chunk.SetBlock(x - chunk.pos.x, y - chunk.pos.y, z - chunk.pos.z, block);
            chunk.update = true;
            UpdateIfEqual(x - chunk.pos.x, 0, new WorldPos(x - 1, y, z));
            UpdateIfEqual(x - chunk.pos.x, Chunk.chunkSize - 1, new WorldPos(x + 1, y, z));
            UpdateIfEqual(y - chunk.pos.y, 0, new WorldPos(x, y - 1, z));
            UpdateIfEqual(y - chunk.pos.y, Chunk.chunkSize - 1, new WorldPos(x, y + 1, z));
            UpdateIfEqual(z - chunk.pos.z, 0, new WorldPos(x, y, z - 1));
            UpdateIfEqual(z - chunk.pos.z, Chunk.chunkSize - 1, new WorldPos(x, y, z + 1));
        }
    }
    void UpdateIfEqual(int value1, int value2, WorldPos pos)
    {
        if (value1 == value2)
        {
            Chunk chunk = GetChunk(pos.x, pos.y, pos.z);
        
namespace Middleware.Controller
    public static class ComparisonController
    {
        #region Sesion
        public static List<VFPSesion> GetNewObjects(List<VFPSesion> vfpList, List<APISesion> apiList)
        {
            return vfpList.Where(vfp => !apiList.Exists(api => api.numero == vfp.numero && api.linea == vfp.linea)).ToList();
        }
        public static List<Tuple<int, VFPSesion>> GetUpdatedObjects(List<VFPSesion> vfpList, List<APISesion> apiList)
        {
            return (from vfp in vfpList from api in apiList.Where(api => api.numero == vfp.numero && vfp.linea == api.linea) where !vfp.tipo.Equals(api.tipo) || vfp.correl != api.correl || vfp.va_ifrs != api.va_ifrs || vfp.canbco != api.canbco || !vfp.banco.Equals(api.banco) || !vfp.cuenta.Equals(api.cuenta) || vfp.cheque != api.cheque || !vfp.fecha.Equals(api.fecha) || !vfp.glosa.Equals(api.glosa) || !vfp.benefi.Equals(api.benefi) || !vfp.fechach.Equals(api.fechach) || !vfp.area.Equals(api.area) || !vfp.codigo.E

        }
        public static List<APISesion> GetDeletedObjects(List<VFPSesion> vfpList, List<APISesion> apiList)
        {
            return apiList.Where(api => !vfpList.Exists(vfp => vfp.numero == api.numero && vfp.linea == api.linea)).ToList();
        }
        #endregion
        #region Tabanco
        public static List<VFPTabanco> GetNewObjects(List<VFPTabanco> vfpList, List<APITabanco> apiList)
        {
            return vfpList.Where(vfp => !apiList.Exists(api => api.codbanco.Equals(vfp.codbanco))).ToList();
        }
        public static List<Tuple<int, VFPTabanco>> GetUpdatedObjects(List<VFPTabanco> vfpList, List<APITabanco> apiList)
        {
            return (from vfp in vfpList from api in apiList.Where(api => api.codbanco.Equals(vfp.codbanco)) where !vfp.codempre.Equals(api.codempre) || !vfp.codbanco.Equals(api.codbanco) || !vfp.nombanco.Equals(api.nombanco) || !vfp.codctacc.Equals(api.codctacc) || !vfp.ctacc.Equals(api.ctacc) || !vfp.ctacontab.Equals(api.ctaco

        }
        public static List<APITabanco> GetDeletedObjects(List<VFPTabanco> vfpList, List<APITabanco> apiList)
        {
            return apiList.Where(api => !vfpList.Exists(vfp => vfp.codbanco.Equals(api.codbanco))).ToList();
        }
        #endregion
        #region MaeCue
        public static List<VFPMaeCue> GetNewObjects(List<VFPMaeCue> vfpList, List<APIMaeCue> apiList)
        {
            return vfpList.Where(vfp => !apiList.Exists(api => api.codigo.Equals(vfp.codigo))).ToList();
        }
        public static List<Tuple<int, VFPMaeCue>> GetUpdatedObjects(List<VFPMaeCue> vfpList, List<APIMaeCue> apiList)
        {
            return (from vfp in vfpList from api in apiList.Where(api => api.codigo.Equals(vfp.codigo)) where !vfp.codigofecu.Equals(api.codigofecu) || !vfp.clase.Equals(api.clase) || !vfp.nivel.Equals(api.nivel) || !vfp.subcta.Equals(api.subcta) || !vfp.ctacte.Equals(api.ctacte) || !vfp.ctacte2.Equals(api.ctacte2) || !vfp.ctacte3.Equals(api.ctacte3) |
namespace nsCore.Areas.Products.Controllers
    public class DispatchListsController : BaseProductsController
    {
        public ActionResult Index()
        {
            return View();
        }
        [OutputCache(CacheProfile = "PagedGridData")]
        public virtual ActionResult Get(bool? status, int page, int pageSize, string orderBy, string orderByDirection)
        {
            try
            {
                if (orderByDirection == "Descending")
                {
                    orderByDirection = "desc";
                }
                else
                {
                    orderByDirection = "asc";
                }
                var dispatchLists = DispatchLists.GetFullDispatchListsTable(new PaginationParameters()
                {
                    PageSize = pageSize,
                    PageIndex = page,
                    OrderBy = orderBy,
                    Order = orderByDirection
                });
                if (!dispatchLists.Any())
  

                    return Json(new { result = true, totalPages = 0, page = String.Format("<tr><td colspan=\"6\">{0}</td></tr>", Translation.GetTerm("ThereAreNodispatchLists", "There are no dispatcs")) });
                }
                var builder = new StringBuilder();
                foreach (var dispatchList in dispatchLists)
                {
                    string editUrl = string.Format("~/Products/{0}/Edit?DispatchListID={1}", "DispatchLists", dispatchList.DispatchListID);
                    builder.Append("<tr>")
                        .AppendCheckBoxCell(value: dispatchList.DispatchListID.ToString())
                        .AppendLinkCell(editUrl, dispatchList.Name)
                        .AppendCell(dispatchList.Mercado.ToString())
                        .Append("</tr>");
                }
                return Json(new { result = true, totalPages = dispatchLists.TotalPages, page = dispatchLists.TotalCount == 0 ? "<tr><td colspan=\"7\">There are no Dispatch</td

            }
            catch (Exception ex)
            {
                var exception = EntityExceptionHelper.GetAndLogNetStepsException(ex, NetSteps.Data.Entities.Constants.NetStepsExceptionType.NetStepsApplicationException);
                return Json(new { result = false, message = exception.PublicMessage });
            }
        }
        public virtual ActionResult Create(int? DispatchListID)
        {
            var dispatch = DispatchListID.HasValue ? DispatchLists.GetDispatchListsByDispatchListID(DispatchListID.Value) : new DispatchListsTable { Editable = 1 };
            return View(dispatch);
        }
        public virtual ActionResult Edit(int? DispatchListID)
        {
            try
            {
                var dispatch = DispatchLists.GetDispatchListsByDispatchListID(Convert.ToInt32(DispatchListID));
                dispatch.Accounts = DispatchLists.GetDispatchListItemsById(Convert.ToInt32(DispatchListID));
                DispatchListsModel model = new D
namespace PMTool.Repository
    public class UnitOfWork : IDisposable
    {
        private PMToolContext context;
        public UnitOfWork()
        {
            context = new PMToolContext();
        }
        
        public UnitOfWork(PMToolContext _context)
        {
            this.context = _context;
        }
        private UserProfileRepository _userProfileRepository;
        public UserProfileRepository UserProfileRepository
        {
            get
            {
                if (this._userProfileRepository == null)
                {
                }
                return _userProfileRepository;
            }
        }
        private MembershipRepository _membershipRepository;
        public MembershipRepository MembershipRepository
        {
            get
            {
                if (this._membershipRepository == null)
                {
                }
                return _membershipRepository;
            }
        }
        private TaskMessageReposit

        public TaskMessageRepository TaskMessageRepository
        {
            get
            {
                if (this._taskMessageRepository == null)
                {
                    this._taskMessageRepository = new TaskMessageRepository(context);
                }
                return _taskMessageRepository;
            }
        }
        private LabelRepository _labelRepository;
        public LabelRepository LabelRepository
        { 
            get
            {
                if (this._labelRepository == null)
                {
                    this._labelRepository = new LabelRepository(context);
                }
                return _labelRepository;
            }
        }
        private TaskRepository _taskRepository;
        public TaskRepository TaskRepository
        {
            get
            {
                if (this._taskRepository == null)
                {
                    this._taskRepository = new TaskRepository(context);
             

                return _taskRepository;
            }
        }
        private ProjectRepository _projectRepository;
        public ProjectRepository ProjectRepository
        {
            get
            {
                if (this._projectRepository == null)
                {
                    this._projectRepository = new ProjectRepository(context);
                }
                return _projectRepository;
            }
        }
        private PriorityRepository _priorityRepository;
        public PriorityRepository PriorityRepository
        {
            get
            {
                if (this._priorityRepository == null)
                {
                    this._priorityRepository = new PriorityRepository(context);
                }
                return _priorityRepository;
            }
        }
        private UserRepository _userRepository;
        public UserRepository UserRepository
        {
            get
            {
                if (this._userReposi
namespace MCS.OA.DataObjects.Workflow
	public static class WfProcessExtension
	{
		public static IWfProcess StartClonedProcess(this IWfProcess originalProcess, string newResourceID)
		{
			IWfProcessDescriptor newProcessDesp =
					originalProcess.FirstActivity.Descriptor.Process.GenerateNewProcessDescriptor();
			IWfProcess newProcess = StartNewProcess(newProcessDesp,
					originalProcess,
					newResourceID,
					originalProcess.FirstActivity != null ? originalProcess.FirstActivity.Operator : DeluxeIdentity.CurrentUser,
					originalProcess.OwnerDepartment);
			return newProcess;
		}
		private static IWfProcess StartNewProcess(IWfProcessDescriptor processDesp, IWfProcess originalProcess, string newResourceID, IUser processCreator, IOrganization department)
		{
			WfProcessStartupParams wp =
					new WfProcessStartupParams(processDesp);
			IWfProcess process = WfRuntime.StartWorkflow(typeof(OAWfProcess), wp);
			process.OwnerDepartment = department;
			WfTransferParams tParams = new W
namespace Lab1.Library.DataAccess
	public class TextRepositoryFactory : IRepositoryFactory
	{
		public ReaderRepository CreateReaderRepository()
		{
			return new ReaderTextRepository();
		}
		public BookRepository CreateBookRepository(LibraryDepartmentRepository libraryDepartmentRepository)
		{
			return new BookTextRepository(libraryDepartmentRepository);
		}
		public LibrarianRepository CreateLibrarianRepository(LibraryDepartmentRepository libraryDepartmentRepository)
		{
			return new LibrarianTextRepository(libraryDepartmentRepository);
		}
		public LibraryDepartmentRepository CreateLibraryDepartmentRepository()
		{
			return new LibraryDepartmentTextRepository();
		}
		public OrderRepository CreateOrderRepository(ReaderRepository readerRepository, BookRepository bookRepository, 
			LibraryDepartmentRepository libraryDepartmentRepository, LibrarianRepository librarianRepository)
		{
			return new OrderTextRepository(readerRepository, bookRepository, libraryDepartmentRepository, li
namespace ImageCompressor
    public class Chunk
    {
        public int[][] chunk{ get; set; }
        public Chunk()
        {
            this.chunk = new int[8][];
            for (int i = 0; i < 8; i++)
            {
                chunk[i] = new int[8];
            }
        }
        public Chunk(int[][] a)
        {
            this.chunk = a;
        }
        public static implicit operator int[][](Chunk value)
        {
            return value.chunk;
        }
        public static implicit operator Chunk(int[][] value)
        {
            Chunk t = new Chunk();
            t.chunk = value;
            return t;
        }
        public static Chunk operator -(Chunk a, Chunk b)
        {
            int[][] t = new int[a.chunk.Length][];
            for (int i = 0; i < a.chunk.Length; i++)
            {
                t[i] = new int[a.chunk[i].Length];
                for (int j = 0; j < a.chunk[i].Length; j++)
                {
                    t[i][j] = a.chunk[i]
namespace HospitalRegistryControllers
    public class MainController : Controller
    {
        private Controller doctorsController;
        private Controller patientController;
        private Controller scheduleController;
        private Controller specializationsController;
        public MainController(
            [Named("DoctorsController")]Controller doctorsController,
            [Named("PatientController")]Controller patientController,
            [Named("ScheduleController")]Controller scheduleController,
            [Named("SpecializationsController")]Controller specializationsController
        ) : base("Main")
        {
            this.doctorsController = doctorsController;
            this.patientController = patientController;
            this.scheduleController = scheduleController;
            this.specializationsController = specializationsController;
        }
        public override bool RunChoice(string choice)
        {
            var exit = false;
         
namespace LinFu.AOP.Interfaces
    internal class CompositeAroundInvoke : IAroundInvoke
    {
        private readonly IList<IAroundInvoke> _aroundInvokeList = new List<IAroundInvoke>();
        public CompositeAroundInvoke(IEnumerable<IAroundInvoke> aroundInvokeList)
        {
            if (aroundInvokeList == null)
                throw new ArgumentNullException("aroundInvokeList");
            foreach (var current in aroundInvokeList)
            {
                if (current == null)
                    continue;
                _aroundInvokeList.Add(current);
            }
        }
        public void AfterInvoke(IInvocationInfo context, object returnValue)
        {
            foreach (var invoke in _aroundInvokeList)
            {
                invoke.AfterInvoke(context, returnValue);
            }
        }
        public void BeforeInvoke(IInvocationInfo context)
        {
            foreach (var invoke in _aroundInvokeList)
            {
                invoke.BeforeI
namespace LocationInstrument.Service
    public class InstrumentService
    {
        private LocationInstrumentContext dbContext = new LocationInstrumentContext();
        public void AddInstrument(Instrument instrument)
        {
            dbContext.Instruments.Add(instrument);
            dbContext.SaveChanges();
        }
        public IEnumerable<Instrument> GetAllInstruments()
        {
            return dbContext.Instruments;
        }
        public Instrument GetInstrument(int? numSerie)
        {
            return dbContext.Instruments.Single(x => x.numSerie == numSerie);
        }
        public IEnumerable<Instrument> GetInstrumentLocationDemain()
        {
            return dbContext.Instruments.Where(x => x.locations.Any(y => y.dateLocation.DayOfYear == DateTime.Now.DayOfYear + 1));
        }
        public IEnumerable<Instrument> GetLocationForInstrument(int? numSerie)
        {
            return dbContext.Instruments.Where(x => x.numSerie == numSerie);
        }

namespace ReflectionPresentation.ViewModels
    public class InvocationViewModel : LoggedViewModel
    {
        public ICommand InvokeDirect
        {
            get
            {
                return GetLoggedCommand(DirectInvoke.Run);
            }
        }
        public ICommand InvokeMethodInfo
        {
            get
            {
                return GetLoggedCommand(MethodInfoInvoke.Run);
            }
        }
        public ICommand InvokeCachedMethodInfo
        {
            get
            {
                return GetLoggedCommand(MethodInfoCachedInvoke.Run);
            }
        }
        public ICommand InvokeInterface
        {
            get
            {
                return GetLoggedCommand(InterfaceInvoke.Run);
            }
        }
        public ICommand InvokeDelegate
        {
            get
            {
                return GetLoggedCommand(DelegateInvoke.Run);
            }
        }
        public ICommand InvokeFunc
        {
            
[AddComponentMenu("Map/Map")]
public class Map : MonoBehaviour {
	public const int maxChunkY = 16;
	public const int maxBlockY = maxChunkY * Chunk.SIZE_Y;
	[SerializeField] private BlockSet blockSet;
	private Grid<ChunkData> chunks = new Grid<ChunkData>();
	private Lightmap lightmap = new Lightmap();
	void Awake() {
		ChunkBuilder.Init( blockSet.GetMaterials().Length );
	}
	public void SetBlockAndRecompute(BlockData block, Vector3i pos) {
		SetBlock( block, pos );
		
		Build( Chunk.ToChunkPosition(pos) );
		foreach( Vector3i dir in Vector3i.directions ) {
			Build( Chunk.ToChunkPosition(pos + dir) );
		}
		LightComputer.RecomputeLightAtPosition(this, pos);
	}
	public void BuildColumn(int cx, int cz) {
		for(int cy=chunks.GetMinY(); cy<chunks.GetMaxY(); cy++) {
			Build( new Vector3i(cx, cy, cz) );
		}
	}
	private void Build(Vector3i pos) {
		ChunkData chunk = GetChunkData( pos );
		if(chunk != null) chunk.GetChunkInstance().SetDirty();
	}
	private ChunkData GetChunkDataInstance(Vector3

		if(pos.y < 0) return null;
		ChunkData chunk = GetChunkData(pos);
		if(chunk == null) {
			chunk = new ChunkData(this, pos);
			chunks.AddOrReplace(chunk, pos);
		}
		return chunk;
	}
	public ChunkData GetChunkData(Vector3i pos) {
		return chunks.SafeGet(pos);
	}
	public void SetBlock(BlockData block, Vector3i pos) {
		SetBlock(block, pos.x, pos.y, pos.z);
	}
	public void SetBlock(BlockData block, int x, int y, int z) {
		ChunkData chunk = GetChunkDataInstance( Chunk.ToChunkPosition(x, y, z) );
		if(chunk != null) chunk.SetBlock( block, Chunk.ToLocalPosition(x, y, z) );
	}
	public BlockData GetBlock(Vector3i pos) {
		return GetBlock(pos.x, pos.y, pos.z);
	}
	public BlockData GetBlock(int x, int y, int z) {
		ChunkData chunk = GetChunkData( Chunk.ToChunkPosition(x, y, z) );
		if(chunk == null) return default(BlockData);
		return chunk.GetBlock( Chunk.ToLocalPosition(x, y, z) );
	}
	public Lightmap GetLightmap() {
		return lightmap;
	}
	public BlockSet GetBlockSet() {
		return blockSe
namespace ADMA.Workflow.Core.Persistence
    public interface IPersistenceProvider
    {
        void InitializeProcess (ProcessInstance processInstance);
        void FillProcessParameters(ProcessInstance processInstance);
        void FillPersistedProcessParameters(ProcessInstance processInstance);
        void FillSystemProcessParameters(ProcessInstance processInstance);
        void SavePersistenceParameters(ProcessInstance processInstance);
        void SetWorkflowIniialized(ProcessInstance processInstance);
        void SetWorkflowIdled(ProcessInstance processInstance);
        void SetWorkflowRunning(ProcessInstance processInstance);
        void SetWorkflowFinalized(ProcessInstance processInstance);
        void SetWorkflowTerminated(ProcessInstance processInstance, ErrorLevel level, string errorMessage);
        void ResetWorkflowRunning();
        void UpdatePersistenceState(ProcessInstance processInstance, TransitionDefinition transition);
        bool IsProcessExists(Guid p
namespace Data.Infrastructure
    public interface IUnitOfWork
    {
        void Commit();
        IUserRepository UserRepository { get; }
        IBureauRepository BureauRepository { get; }
        IRegionRepository RegionRepository { get; }
        ISocieteAssuranceRepository SocieteAssuranceRepository { get; }
        IContratMaintennaceRepository ContratMaintennaceRepository { get; }
        IContratAssuranceRepository ContratAssuranceRepository { get; }
        IContratGarantieRepository ContratGarantieRepository { get; }
        ISocieteMaintenanceRepository SocieteMaintenanceRepository { get; }
        IAchatRepository AchatRepository { get; }
        IFournisseurRepository FournisseurRepository { get; }
        IBatimentRepository BatimentRepository { get; }
        IInventaireRepository InventaireRepository { get; }
        IBiensRepository BiensRepository { get; }
        IServiceRepository ServiceRepository { get; }
        IParc_autoRepository Parc_autoRepository { get; }

namespace Repositories
    public class UnitOfWork
    {
        private OnlineShopEntities Context = new OnlineShopEntities();
        private CategoryRepository categoryRepository;
        private CityRepository cityRepository;
        private PCsRepository pcsRepository;
        private ProductRepository productRepository;
        private SalesRepository salesRepository;
        private SmartphonesRepository smartphonesRepository;
        private UserRepository userRepository;
        public CategoryRepository CategoryRepository
        {
            get
            {
                if (this.categoryRepository == null)
                {
                    this.categoryRepository = new CategoryRepository(Context);
                }
                return categoryRepository;
            }
        }
        public CityRepository CityRepository
        {
            get
            {
                if (this.cityRepository == null)
                {
                    this.cityReposi

                }
                return cityRepository;
            }
        }
        public PCsRepository PCsRepository
        {
            get
            {
                if (this.pcsRepository == null)
                {
                    this.pcsRepository = new PCsRepository(Context);
                }
                return pcsRepository;
            }
        }
        public ProductRepository ProductRepository
        {
            get
            {
                if (this.productRepository == null)
                {
                    this.productRepository = new ProductRepository(Context);
                }
                return productRepository;
            }
        }
        public SalesRepository SalesRepository
        {
            get
            {
                if (this.salesRepository == null)
                {
                    this.salesRepository = new SalesRepository(Context);
                }
                return salesRepository;
            
namespace WinstonChurchill.Backend.Repository
    public partial class UnitOfWork : UnitOfWorkBase
    {
        private BaseRepository<Usuario> usuarioRepository;
        public BaseRepository<Usuario> UsuarioRepository
        {
            get
            {
                if (this.usuarioRepository == null)
                {
                    this.usuarioRepository = new BaseRepository<Usuario>(context);
                }
                return usuarioRepository;
            }
        }
        private BaseRepository<UsuarioXGrupoUsuario> usuarioXGrupoUsuarioRepository;
        public BaseRepository<UsuarioXGrupoUsuario> UsuarioXGrupoUsuarioRepository
        {
            get
            {
                if (this.usuarioXGrupoUsuarioRepository == null)
                {
                    this.usuarioXGrupoUsuarioRepository = new BaseRepository<UsuarioXGrupoUsuario>(context);
                }
                return usuarioXGrupoUsuarioRepository;
            }
        }
     

        public BaseRepository<GrupoUsuarioRecurso> GrupoUsuarioRecursoRepository
        {
            get
            {
                if (this.grupoUsuarioRecursoRepository == null)
                {
                    this.grupoUsuarioRecursoRepository = new BaseRepository<GrupoUsuarioRecurso>(context);
                }
                return grupoUsuarioRecursoRepository;
            }
        }
        private BaseRepository<GrupoUsuario> grupoUsuarioRepository;
        public BaseRepository<GrupoUsuario> GrupoUsuarioRepository
        {
            get
            {
                if (this.grupoUsuarioRepository == null)
                {
                    this.grupoUsuarioRepository = new BaseRepository<GrupoUsuario>(context);
                }
                return grupoUsuarioRepository;
            }
        }
        private BaseRepository<Categoria> categoriaRepository;
        public BaseRepository<Categoria> CategoriaRepository
        {
            get
          

                if (this.categoriaRepository == null)
                {
                    this.categoriaRepository = new BaseRepository<Categoria>(context);
                }
                return categoriaRepository;
            }
        }
        private BaseRepository<CategoriaProduto> categoriaProdutoRepository;
        public BaseRepository<CategoriaProduto> CategoriaProdutoRepository
        {
            get
            {
                if (this.categoriaProdutoRepository == null)
                {
                    this.categoriaProdutoRepository = new BaseRepository<CategoriaProduto>(context);
                }
                return categoriaProdutoRepository;
            }
        }
        private BaseRepository<CategoriaImagem> categoriaImagemRepository;
        public BaseRepository<CategoriaImagem> CategoriaImagemRepository
        {
            get
            {
                if (this.categoriaImagemRepository == null)
                {
                    thi
namespace osc.net.unittests.Message
    [TestClass]
    public class MessageDispatchTests
    {
        [TestMethod]
        public void MessageDispatch_Test_Dispatch()
        {
            MessageDispatch dispatch = new MessageDispatch();
            MessageBuilder builder1 = new MessageBuilder();
            builder1.SetAddress("/test1");
            builder1.PushAtom(1);
            MessageBuilder builder2 = new MessageBuilder();
            builder2.SetAddress("/test2");
            builder2.PushAtom("TEST");
            MessageBuilder builder3 = new MessageBuilder();
            builder3.SetAddress("/test3");
            builder3.PushAtom("TEST2");
            String address = "";
            Atom value = new Atom();
            Action<osc.net.Message> callback = m => {
                address = m.Address;
                value = m.Atoms[0];
            };
            dispatch.RegisterMethod("/test1", callback);
            dispatch.RegisterMethod("/test2", callback);
           
public class WorldGenerator : SingletonBehaviour<WorldGenerator> {
    public float Step = 100;
    private float AllowedPosition {
        get {
            return _LastChunkPosition;
        }
    }
    private static Transform ChunksPoolHost {
        get {
            return _ChunksPoolHost;
        }
    }
    private static Transform _ChunksPoolHost;
    private int _LastChunkID;
    private float _LastChunkPosition;
    private Queue<WorldChunk> _CurrentChunks = new Queue<WorldChunk>();
    private static List<WorldChunk> _Chunks = new List<WorldChunk>();
    protected override void Awake() {
        base.Awake();
        InitializeChunkPool();
        _LastChunkPosition = -Step;
        Update();
    }
    protected override void OnDestroy() {
        base.OnDestroy();
        foreach(var chunk in _CurrentChunks) {
            ReleaseChunk(chunk);
        }
    }
    void Update() {
        if (PlayerController.LocalPlayer.transform.position.z > AllowedPosition)
            Pre

    }
    private void InitializeChunkPool() {
        if (_ChunksPoolHost == null) {
            _ChunksPoolHost = new GameObject("ChunksPool").transform;
            DontDestroyOnLoad(_ChunksPoolHost);
            Instance.PreloadChunks();
        }
    }
    private void PreloadChunks() {
        foreach (var chunkData in ChunkConfig.Instance.Chunks) {
            CreateChunk(chunkData.ID);
            CreateChunk(chunkData.ID);
        } 
    }
    private void PrepareNextChunk() {
        var chunkID = EvaluateNextChunkID();
        var chunk = GetChunk(chunkID);
        chunk.transform.SetParent(this.transform);
        chunk.transform.position = new Vector3(0, 0, _LastChunkPosition + Step);
        chunk.gameObject.SetActive(true);
        _CurrentChunks.Enqueue(chunk);
        if(_CurrentChunks.Count > 3) {
           ReleaseChunk(_CurrentChunks.Dequeue());
        }
        _LastChunkPosition += Step;
        _LastChunkID = chunkID;
    }
    private void ReleaseChunk(WorldCh
namespace Test.Web.Models
	public static class RepositoryHelper
	{
		public static IUnitOfWork GetUnitOfWork()
		{
			return new EFUnitOfWork();
		}		
		
		public static CategoryRepository GetCategoryRepository()
		{
			var repository = new CategoryRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static CategoryRepository GetCategoryRepository(IUnitOfWork unitOfWork)
		{
			var repository = new CategoryRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static MainPictureRepository GetMainPictureRepository()
		{
			var repository = new MainPictureRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static MainPictureRepository GetMainPictureRepository(IUnitOfWork unitOfWork)
		{
			var repository = new MainPictureRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static PictureRepository GetPictureRepository()
		{
			var reposi

			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static PictureRepository GetPictureRepository(IUnitOfWork unitOfWork)
		{
			var repository = new PictureRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static ProjectRepository GetProjectRepository()
		{
			var repository = new ProjectRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static ProjectRepository GetProjectRepository(IUnitOfWork unitOfWork)
		{
			var repository = new ProjectRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static RecordRepository GetRecordRepository()
		{
			var repository = new RecordRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static RecordRepository GetRecordRepository(IUnitOfWork unitOfWork)
		{
			var repository = new RecordRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}	
namespace Serialization.Services
    public class InstrumentFactory
    {
        #region Fields
        private readonly Dictionary<string, ConstructorInfo> _instrumentDictionary;
        #endregion
        #region FactoryConstrutor
        public InstrumentFactory()
        {
            _instrumentDictionary = new Dictionary<string, ConstructorInfo>();
            InitializeDictionary();
        }
        private void InitializeDictionary()
        {
            AddToDictionary(typeof(Electric));
            AddToDictionary(typeof(Bass));
            AddToDictionary(typeof(Acoustic));
            AddToDictionary(typeof(Synthesizer));
            InitializePlugins();
        }
        private void InitializePlugins()
        {
            var pluginConfig = new PluginConfig();
            var plugins = pluginConfig.GetPlugins();
            foreach (string plugin in plugins)
            {
                AddToDictionary(CreateExtendedClass(plugin));
            }
        }
        #e

        #region Factory
        private void InitializeInstrument(MusicalInstrument instrument, List<ItemInfo> itemInfo)
        {
            for (int i = 1; i < itemInfo.Count; i++)
            {
                var item = itemInfo.ElementAt(i);
                InitializeField(instrument, item.Type, item.Value);
            }
        }
        private void InitializeField(MusicalInstrument instrument, string name, string value)
        {
            var fieldInfo = instrument.GetType().GetProperty(name);
            fieldInfo.SetValue(instrument, new Description() { Value = value });
        }
        private MusicalInstrument Create(string name)
        {
            var instrument = (MusicalInstrument)_instrumentDictionary[name].Invoke(new object[] { });
            return instrument;
        }
        public MusicalInstrument Create(List<ItemInfo> itemInfo)
        {
            var instrument = Create(itemInfo[0].Type);
            instrument.Value = itemInfo.First().Value;
    

            return instrument;
        }
        public void Initialize(List<ItemInfo> itemInfo, MusicalInstrument instrument)
        {
            foreach (ItemInfo item in itemInfo)
            {
                if (item == itemInfo.First()) continue;
                
                PropertyInfo fieldInfo = instrument.GetType().GetProperty(item.Type);
                string value = (fieldInfo.GetValue(instrument) as Description).Value;
                if (value != null)
                {
                    item.Value = value;
                }
            }
        }
        #endregion
        #region BasicInstrumentConstructors
        protected virtual MusicalInstrument CreateElectricGuitar()
        {
            return new Electric();
        }
        protected virtual MusicalInstrument CreateAcousticGuitar()
        {
            return new Acoustic();
        }
        protected virtual MusicalInstrument CreateBassGuitar()
        {
            return new Bass();
        }
namespace SetGenerator.WebUI.Controllers
    [RoutePrefix("Instruments")]
    public class InstrumentsController : Controller
    {
        private readonly IInstrumentRepository _instrumentRepository;
        private readonly ISongRepository _songRepository;
        private readonly IValidationRules _validationRules;
        private readonly User _currentUser;
        private readonly CommonSong _common;
        public InstrumentsController(   IInstrumentRepository instrumentRepository,
                                        ISongRepository songRepository,
                                        IValidationRules validationRules,
                                        IAccount account)
        {
            _instrumentRepository = instrumentRepository;
            _songRepository = songRepository;
            _validationRules = validationRules;
            var currentUserName = GetCurrentSessionUser();
            if (currentUserName.Length > 0)
                _currentUser = account

            _common = new CommonSong(account, currentUserName);
        }
        [Authorize]
        public ActionResult Index(int? id)
        {
            return View(LoadInstrumentViewModel(0, null));
        }
        [HttpGet]
        public JsonResult GetData()
        {
            var vm = new
            {
                InstrumentList = GetInstrumentList(),
                TableColumnList = _common.GetTableColumnList(_currentUser.Id, Constants.UserTable.InstrumentId)
            };
            return Json(vm, JsonRequestBehavior.AllowGet);
        }
        private IEnumerable<InstrumentDetail> GetInstrumentList()
        {
            var instrumentList = _instrumentRepository.GetAll();
            var songInstrumentIds = _songRepository.GetSongInstrumentIds();
            var result = instrumentList
                .GroupJoin(songInstrumentIds, instrument => instrument.Id, songInstrumentId => songInstrumentId,
                (i, si) => new InstrumentDetail
            

                Id = i.Id,
                Name = i.Name,
                Abbreviation = i.Abbreviation,
                IsSongInstrument = si.Any()
            }).OrderBy(x => x.Name).ToArray();
            return result;
        }
        public string GetCurrentSessionUser()
        {
            return (System.Web.HttpContext.Current.User.Identity.Name);
        }
        private static InstrumentViewModel LoadInstrumentViewModel(int selectedId, List<string> msgs)
        {
            var model = new InstrumentViewModel
            {
                SelectedId = selectedId,
                Success = (msgs == null),
                ErrorMessages = msgs
            };
            return model;
        }
        [HttpGet]
        public PartialViewResult GetInstrumentEditView(int id)
        {
            return PartialView("_InstrumentEdit", LoadInstrumentEditViewModel(id));
        }
        private InstrumentEditViewModel LoadInstrumentEditViewModel(int id)
        {
            
namespace FuzzyLogicSearch.Services
    class InstrumentSearchService
    {
        private LevenshteinDistance distanceCalc = new LevenshteinDistance();
        public List<InstrumentSearchModel> getFilteredInstruments(string filter, List<InstrumentSearchModel> instrumentList, string selectedMatchAlgo, double threshold)
        {
            List<InstrumentModel> instruments = new List<InstrumentModel>();
            InstrumentListDAO instrumentData = new InstrumentListDAO();
            try
            {
                instruments = instrumentData.GetData();
            }
            catch (DAOException ex)
            {
                if (ex.GetErrorCode() == DAOException.FILE_NA)
                {
                    throw new ServiceException(ServiceException.DATA_ACCESS_ERROR, "Could not get data for instruments", ex);
                }
                else if (ex.GetErrorCode() == DAOException.FILE_PARSE_ERROR)
                {
                    throw new ServiceException(S

                }
                else if (ex.GetErrorCode() == DAOException.UNKNOWN_ERROR)
                {
                    throw new ServiceException(ServiceException.UNKNOWN_ERROR, "Could not get data for instruments", ex);
                }
            }
            List<InstrumentSearchModel> filteredInstruments = new List<InstrumentSearchModel>();
            if (instruments != null)
            {
                foreach (InstrumentModel instrument in instruments)
                {
                    double distance;
                    if (selectedMatchAlgo == "Levenshtein Distance")
                    {
                        distance = (double)distanceCalc.CalculateLevenshteinDistance(filter, instrument.InstrumentName);
                    }
                    else if (selectedMatchAlgo == "Dice Coefficient")
                    {
                        distance = Math.Round(DiceCoefficientExtensions.DiceCoefficient(filter, instrument.InstrumentName), 2) * 100;
    

                    else
                    {
                        throw new ArgumentException("Could not find matching algorithm supplied please try again");
                    }
                    if (distance >= threshold)
                    {
                        InstrumentSearchModel instrumentSearch = new InstrumentSearchModel(instrument.Identifier, instrument.InstrumentName, distance);
                        filteredInstruments.Add(instrumentSearch);
                    }
                }
            }
            return filteredInstruments.OrderByDescending(x => x.MatchLikelihood).ToList();
        }
		
        public List<InstrumentSearchModel>  getAllInstruments()
        {
            List<InstrumentModel> instruments = new List<InstrumentModel>();
            InstrumentListDAO instrumentData = new InstrumentListDAO();
            instruments = instrumentData.GetData();
            List<InstrumentSearchModel> instrumentsList = new List<InstrumentSearchModel>();

namespace Vision.Api.Common.Document
    public class ApiAttributeDocumentProvider : IApiDocumentProvider
    {
        public IEnumerable<ApiDocumentApiCategory> GetAllCategories(Assembly assembly)
        {
            var categoriesInAssembly = new List<ApiDocumentApiCategory>();
            var apiCategoryAttributes = assembly.GetCustomAttributes<ApiCategoryAttribute>();
            foreach (var apiCategoryAttribute in apiCategoryAttributes)
            {
                var apiCategory = new ApiDocumentApiCategory()
                {
                    Name = apiCategoryAttribute.Name,
                    DisplayName = apiCategoryAttribute.DisplayName,
                    Description = apiCategoryAttribute.Description,
                    IsDefault = apiCategoryAttribute.IsDefault,
                    Apis = new List<ApiDocumentApi>()
                };
                categoriesInAssembly.Add(apiCategory);
            }
            if (!categoriesInAssembly.Any())
              

            var defaultApiCategory = categoriesInAssembly.FirstOrDefault(c => c.IsDefault) ?? categoriesInAssembly.FirstOrDefault();
            var apiInfoAttributesInAssembly = GetApiNameAttribtues(assembly);
            if (apiInfoAttributesInAssembly.Any())
            {
                foreach (var apiInfo in apiInfoAttributesInAssembly)
                {
                    if (apiInfo.Item1 == null || apiInfo.Item2 == null || apiInfo.Item3 == null)
                        continue;
                    var category = categoriesInAssembly.FirstOrDefault(c => c.Name.Equals(apiInfo.Item3.Category)) ?? defaultApiCategory;
                    if (category != null)
                    {
                        var api = new ApiDocumentApi
                        {
                            Name = apiInfo.Item3.ApiName,
                            DisplayName = apiInfo.Item3.DisplayName,
                            Description = apiInfo.Item3.Description,
                            

                        };
                        var propertyInfos = apiInfo.Item1.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.GetProperty | BindingFlags.SetProperty);
                        foreach (var propertyInfo in propertyInfos)
                        {
                            var apiParameterAttr = propertyInfo.GetCustomAttribute<ApiRequestParameterAttribute>();
                            if (apiParameterAttr != null)
                            {
                                api.Parameters.Add(new ApiDocumentApiParameter
                                {
                                    Name = propertyInfo.Name,
                                    DisplayName = apiParameterAttr.DisplayName,
                                    Description = apiParameterAttr.Description
                                });
                            }
                        }
                        var apiResponseAttr = apiInfo.Item2.GetCustomAttribu
﻿<!--
/Controllers/HomeController.cs
public ActionResult APIIndex()
    ViewBag.Title = "API Index";
    return View();
/View/Home/APIIndex.cshtml
-->
<br />
Chinook<br />
<br />
Album<br />
<a href="/api/album">api/album</a><br />
<a href="/api/album/1">api/album/1</a><br />
<br />
Artist<br />
<a href="/api/artist">api/artist</a><br />
<a href="/api/artist/1">api/artist/1</a><br />
<br />
Customer<br />
<a href="/api/customer">api/customer</a><br />
<a href="/api/customer/1">api/customer/1</a><br />
<br />
CustomerDocument<br />
<a href="/api/customerDocument">api/customerDocument</a><br />
<a href="/api/customerDocument/1">api/customerDocument/1</a><br />
<br />
Employee<br />
<a href="/api/employee">api/employee</a><br />
<a href="/api/employee/1">api/employee/1</a><br />
<br />
Genre<br />
<a href="/api/genre">api/genre</a><br />
<a href="/api/genre/1">api/genre/1</a><br />
<br />
Invoice<br />
<a href="/api/invoice">api/invoice</a><br />
<a href="/api/invoice/1">api/invoice/1</a>
namespace LQT.GUI.Asset
    public partial class InstrumentForm : Form
    {
        private Instrument _instrument;
        private Form _mdiparent;
        private bool _enableCtr;
        public InstrumentForm(Instrument inst, Form mdiparent)
        {
            this._instrument = inst;
            this._mdiparent = mdiparent;
            InitializeComponent();
            lqtToolStrip1.SaveAndCloseClick += new EventHandler(lqtToolStrip1_SaveAndCloseClick);
            lqtToolStrip1.SaveAndNewClick += new EventHandler(lqtToolStrip1_SaveAndNewClick);
            LoadInstrumentCtr();
        }
        private void LoadInstrumentCtr()
        {
            _enableCtr = true;
            SetControlState();
            PopTestingAreas();
            PopControlPeriod();
            BindInstrument();
        }
        void lqtToolStrip1_SaveAndNewClick(object sender, EventArgs e)
        {
            try
            {
                LQTUserMessage msg = SaveOrUpdateObject();
          

                DataRepository.CloseSession();
                TestingArea ta = _instrument.TestingArea;
                _instrument = new Instrument();
                _instrument.TestingArea = ta;
                LoadInstrumentCtr();
                comTestarea.SelectedIndex = -1;
            }
            catch (Exception ex)
            {
                new FrmShowError(CustomExceptionHandler.ShowExceptionText(ex)).ShowDialog();
            }
        }
        void lqtToolStrip1_SaveAndCloseClick(object sender, EventArgs e)
        {
            try
            {
                LQTUserMessage msg = SaveOrUpdateObject();
                ((LqtMainWindowForm)_mdiparent).ShowStatusBarInfo(msg.Message, true);
                DataRepository.CloseSession();
                this.Close();
            }
            catch (Exception ex)
            {
                new FrmShowError(CustomExceptionHandler.ShowExceptionText(ex)).ShowDialog();
            }
        }
        private void Set

        {
            this.txtName.Enabled = _enableCtr;
            this.txtMaxput.Enabled = _enableCtr;
            this.comTestarea.Enabled = _enableCtr;
            this.comperiod.Enabled = _enableCtr;
            this.txtcontrolamount.Enabled = _enableCtr;
            this.txtName.Text = "";
            this.txtMaxput.Text = "0";
            this.txtcontrolamount.Text = "0";
        }
        private void PopTestingAreas()
        {
            comTestarea.DataSource = DataRepository.GetAllTestingArea();
            comTestarea.SelectedIndex = -1;
        }
        private void BindInstrument()
        {
            if (_instrument.Id > 0)
            {
                if (_instrument.TestingArea != null)
                {
                    comTestarea.Text = _instrument.TestingArea.AreaName;
                    comTestarea.Enabled = false;
                }
                this.txtName.Text = _instrument.InstrumentName;
                this.txtMaxput.Text = _instrument.MaxThro
﻿<h4>@NorthwindPresentationResources.TaskNorthwindHelp</h4>
<br />
Category<br />
<a href="@Url.Content("/api/categoryapi")">api/categoryapi</a><br />
<a href="@Url.Content("/api/categoryapi/1")">api/categoryapi/1</a><br />
<br />
CustomerCustomerDemo<br />
<a href="@Url.Content("/api/customercustomerdemoapi")">api/customercustomerdemoapi</a><br />
<a href="@Url.Content("/api/customercustomerdemoapi/1")">api/customercustomerdemoapi/1</a><br />
<br />
CustomerDemographic<br />
<a href="@Url.Content("/api/customerdemographicapi")">api/customerdemographicapi</a><br />
<a href="@Url.Content("/api/customerdemographicapi/1")">api/customerdemographicapi/1</a><br />
<br />
Customer<br />
<a href="@Url.Content("/api/customerapi")">api/customerapi</a><br />
<a href="@Url.Content("/api/customerapi/1")">api/customerapi/1</a><br />
<br />
Employee<br />
<a href="@Url.Content("/api/employeeapi")">api/employeeapi</a><br />
<a href="@Url.Content("/api/employeeapi/1")">api/employeeapi/1</a><br />
<br /

EmployeeTerritory<br />
<a href="@Url.Content("/api/employeeterritoryapi")">api/employeeterritoryapi</a><br />
<a href="@Url.Content("/api/employeeterritoryapi/1")">api/employeeterritoryapi/1</a><br />
<br />
OrderDetail<br />
<a href="@Url.Content("/api/orderdetailapi")">api/orderdetailapi</a><br />
<a href="@Url.Content("/api/orderdetailapi/1")">api/orderdetailapi/1</a><br />
<br />
Order<br />
<a href="@Url.Content("/api/orderapi")">api/orderapi</a><br />
<a href="@Url.Content("/api/orderapi/1")">api/orderapi/1</a><br />
<br />
Product<br />
<a href="@Url.Content("/api/productapi")">api/productapi</a><br />
<a href="@Url.Content("/api/productapi/1")">api/productapi/1</a><br />
<br />
Region<br />
<a href="@Url.Content("/api/regionapi")">api/regionapi</a><br />
<a href="@Url.Content("/api/regionapi/1")">api/regionapi/1</a><br />
<br />
Shipper<br />
<a href="@Url.Content("/api/shipperapi")">api/shipperapi</a><br />
<a href="@Url.Content("/api/shipperapi/1")">api/shipperapi/1</a><br 
public static class ProcessExtensions
    private static string FindIndexedProcessName(int pid)
    {
        var processName = Process.GetProcessById(pid).ProcessName;
        var processesByName = Process.GetProcessesByName(processName);
        string processIndexdName = null;
        for (var index = 0; index < processesByName.Length; index++)
        {
            processIndexdName = index == 0 ? processName : processName + "#" + index;
            var processId = new PerformanceCounter("Process", "ID Process", processIndexdName);
            if ((int)processId.NextValue() == pid)
            {
                return processIndexdName;
            }
        }
        return processIndexdName;
    }
    private static Process FindPidFromIndexedProcessName(string indexedProcessName)
    {
        var parentId = new PerformanceCounter("Process", "Creating Process ID", indexedProcessName);
        return Process.GetProcessById((int)parentId.NextValue());
    }
    public static Proces
namespace DAL.Concrete
    public class UnitOfWork : IUnitOfWork
    {
        public DbContext Context { get; private set; }
        private ClassRoomRepository classRoomRepository;
        private CommentRepository commentRepository;
        private MailRepository mailRepository;
        private ParentRepository parentRepository;
        private PupilRepository pupilRepository;
        private RequisitionRepository requisitionRepository;
        private RoleRepository roleRepository;
        private TeacherRepository teacherRepository;
        private UserRepository userRepository;
        public IClassRoomRepository ClassRoomRepository => classRoomRepository ?? new ClassRoomRepository(Context);
        public ICommentRepository CommentRepository => commentRepository ?? new CommentRepository(Context);
        public IMailRepository MailRepository => mailRepository ?? new MailRepository(Context);
        public IParentRepository ParentRepository => parentRepository ?? new ParentReposi

        public IPupilRepository PupilRepository => pupilRepository ?? new PupilRepository(Context);
        public IRequisitionRepository RequisitionRepository
            => requisitionRepository ?? new RequisitionRepository(Context);
        public IRoleRepository RoleRepository => roleRepository ?? new RoleRepository(Context);
        public ITeacherRepository TeacherRepository => teacherRepository ?? new TeacherRepository(Context);
        public IUserRepository UserRepository => userRepository ?? new UserRepository(Context);
        public UnitOfWork(DbContext context, ClassRoomRepository classRoomRepository, CommentRepository commentRepository, MailRepository mailRepository, ParentRepository parentRepository, PupilRepository pupilRepository, RequisitionRepository requisitionRepository, RoleRepository roleRepository, TeacherRepository teacherRepository, UserRepository userRepository)
        {
            Context = context;
            this.classRoomRepository = classRoomReposito
namespace DX11.Particles.IO
    #region ChunkManager
    public class ChunkManager
    {
        public string ProjectName;
        public Vector3D ChunkSize;
        public Triple<int, int, int> ChunkCount;
        public Vector3D BoundsMin;
        public Vector3D BoundsMax;
        
        public int BytesPerElement;
        public ChunkImporterBase ChunkImporter;
        public ChunkReaderBase ChunkReader;
        public ChunkWriterBase ChunkWriter;
        public List<Chunk> ChunkList;
        public int ElementCount;
        
        public ChunkManager() { }
        private int GetLeadingZeroes()
        {
            return Math.Max(Math.Max(ChunkCount.x.ToString().Length, ChunkCount.y.ToString().Length), ChunkCount.z.ToString().Length);
        }
        public void UpdateElementCount()
        {
            ElementCount = 0;
            foreach (Chunk chunk in ChunkList)
            {
                ElementCount += chunk.ElementCount;
            }
        }
        public 

        {
            return ChunkList[chunkId];
        }
        public void InitChunkList()
        {
            List<Chunk> chunkList = new List<Chunk>();
            int leadingZeroes = GetLeadingZeroes();
            BytesPerElement = Bytes * (DataStructure.Length);
            for (int z = 0; z < ChunkCount.z; z++)
            {
                for (int y = 0; y < ChunkCount.y; y++)
                {
                    for (int x = 0; x < ChunkCount.x; x++)
                    {
                        int id = x +
                                        y * ChunkCount.x +
                                        z * ChunkCount.x * ChunkCount.y;
                        string fileName = x.ToString("D" + leadingZeroes) + "_" + y.ToString("D" + leadingZeroes) + "_" + z.ToString("D" + leadingZeroes) + ".bin";
                        Chunk chunk = new Chunk(id, fileName, BytesPerElement);
                        chunkList.Add(chunk);
                    }
                }
       
namespace LendingLibrary_Library_Tests
    [TestClass]
    public class InstrumentPart_Tests
    {
        [TestMethod]
        [ExpectedException(typeof(ArgumentNullException), "In InstrumentPart Class, constructor.  Argument instrument cannot be null.")]
        public void TestInstrumentPartConstructor_ArgumentInstrumentIsNull_ThrowsArgumentNullException()
        {
            InstrumentPart myInstrumentPart;
            myInstrumentPart = new InstrumentPart(null, 5);
        }
        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "In InstrumentPart Class, constructor.  Argument numberOfCopies must be greater than zero.")]
        public void TestInstrumentPartConstructor_ArgumentNumberOfCopiesIsLessThanZero_ThrowsArgumentException()
        {
            InstrumentPart myInstrumentPart;
            myInstrumentPart = new InstrumentPart(new Instrument("Trombone", true), -1);
        }
        [TestMethod]
        public void TestInstrumentPartConstructorSetsNum

        {
            InstrumentPart myInstrumentPart;
            myInstrumentPart = new InstrumentPart(new Instrument("Trombone", true), 5);
            Assert.AreEqual(5, myInstrumentPart.NumberOfCopies);
        }
        [TestMethod]
        public void TestInstrumentPartConstructorSetsInstrumentNameCorrectly()
        {
            InstrumentPart myInstrumentPart;
            myInstrumentPart = new InstrumentPart(new Instrument("Trombone", true), 5);
            Assert.AreEqual("trombone", myInstrumentPart._Instrument.InstrumentName);
        }
        [TestMethod]
        public void TestInstrumentPartConstructorSetsInstrumentApprovedCorrectly()
        {
            InstrumentPart myInstrumentPart;
            myInstrumentPart = new InstrumentPart(new Instrument("Trombone", true), 5);
            Assert.AreEqual(true, myInstrumentPart._Instrument.Approved);
        }
        [TestMethod]
        public void TestInstrumentPartConstructorSetsInstrumentNumberOfTimesUsedCorrectly(

        {
            InstrumentPart myInstrumentPart;
            myInstrumentPart = new InstrumentPart(new Instrument(instrumentName: "Trombone",  createdByAdministrator: false), 5);
            Assert.AreEqual(1, myInstrumentPart._Instrument.NumberOfTimesUsed);
        }
        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "In InstrumentPart Class, method setNumberOfCopies().  Argument number must be greater than zero.")]
        public void TestInstrumentPart_MethodsetNumberOfCopies_ArgumentNumberIsLessThanZero_ThrowsArgumentException()
        {
            InstrumentPart myInstrumentPart;
            myInstrumentPart = new InstrumentPart(new Instrument("Trombone", true), 5);
            myInstrumentPart.setNumberOfCopies(-1);
        }
        [TestMethod]
        public void TestInstrumentPart_MethodSetNumberOfCopies()
        {
            InstrumentPart myInstrumentPart;
            myInstrumentPart = new InstrumentPart(new Instrument("Trombone", true), 
namespace cozyjozywebapi.Infrastructure
    public class CozyJozyUnitOfWork : Disposable, IUnitOfWork
    {
        private readonly DbContext _context;
        private readonly IFeedingRepository _feedingRepository;
        private readonly IChildRepository _childRepository;
        private readonly IChildPermissionsRepository _childPermissionsRepository;
        private readonly IDiaperChangesRepository _diaperChangesRepository;
        private readonly IRoleRepository _roleRepository;
        private readonly IUserRepository _userRepository;
        private readonly ITitleRepository _titleRepository;
        private readonly ISleepRepository _sleepRepository;
        public CozyJozyUnitOfWork(DbContext context, 
            IFeedingRepository feedingRepository, 
            IChildRepository childRepository, 
            IChildPermissionsRepository childPermissionsRepository,
            IDiaperChangesRepository diaperChangesRepository,
            IRoleRepository roleRepository,
   

            ITitleRepository titleRepository,
            ISleepRepository sleepRepository)
        {
            _context = context;
            _feedingRepository = feedingRepository;
            _childRepository = childRepository;
            _childPermissionsRepository = childPermissionsRepository;
            _diaperChangesRepository = diaperChangesRepository;
            _roleRepository = roleRepository;
            _userRepository = userRepository;
            _titleRepository = titleRepository;
            _sleepRepository = sleepRepository;
        }
        public void Commit()
        {
            _context.SaveChanges();
        }
        public Task<int> CommitAsync()
        {
           return _context.SaveChangesAsync();
        }
        public IFeedingRepository FeedingRepository
        {
            get { return _feedingRepository; }
        }
        public IChildRepository ChildRepository
        {
            get { return _childRepository; }
        }
        pu

        {
            get { return _childPermissionsRepository; }
        }
        public IDiaperChangesRepository DiaperChangesRepository
        {
            get { return _diaperChangesRepository; }
        }
        public IRoleRepository RoleRepository
        {
            get { return _roleRepository; }
        }
        public IUserRepository UserRepository
        {
            get { return _userRepository; }
        }
        public ITitleRepository TitleRepository
        {
            get { return _titleRepository; }
        }
        public ISleepRepository SleepRepository
        {
            get { return _sleepRepository; }
        }
    }
    public class Disposable : IDisposable
    {
        private bool _isDisposed;
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        ~Disposable()
        {
            Dispose(false);
        }
        private void Dispose(bool disposing)
        {
           
namespace EQueue.Broker.Storage
    public class ChunkReader
    {
        private readonly ChunkManager _chunkManager;
        private readonly ChunkWriter _chunkWriter;
        public ChunkReader(ChunkManager chunkManager, ChunkWriter chunkWriter)
        {
            Ensure.NotNull(chunkManager, "chunkManager");
            Ensure.NotNull(chunkWriter, "chunkWriter");
            _chunkManager = chunkManager;
            _chunkWriter = chunkWriter;
        }
        public T TryReadAt<T>(long position, Func<byte[], T> readRecordFunc, bool autoCache = true) where T : class, ILogRecord
        {
            var lastChunk = _chunkWriter.CurrentChunk;
            var maxPosition = lastChunk.GlobalDataPosition;
            if (position >= maxPosition)
            {
                throw new ChunkReadException(
                    string.Format("Cannot read record after the max global data position, data position: {0}, max global data position: {1}, chunk: {2}.",
                         
namespace Future_BTST.Controllers
    public class HomeController : ZerodhaController
    {
        public void Index()
        {
            var redirectUri = ZClient.ZLogin.SiteLogin();
            var context = Request.Properties["MS_HttpContext"] as HttpContext;
            context.Response.Redirect(redirectUri);
        }
        [Route("Home/zerodha_response")]
        public string zerodha_response(string status, string request_token)
        {
            var response = ZClient.ZLogin.GetUserToken(request_token);
            var context = Request.Properties["MS_HttpContext"] as HttpContext;
            context.Session["UserToken"] = response ?? "Default";
            return response;
        }
public List<Instrument>  TestMe(bool test=true)
        {
            InstrumentData instrumentList = new InstrumentData();
            string instrumentFile=@"F:\Projects\MDX\Future_BTST\Future_BTST\InstrumentList.json";
           string instrumentJson=string.Empty;
           if (Syste

               instrumentJson = System.IO.File.ReadAllText(instrumentFile);
           List<Instrument> instrumentDataList = new List<Instrument>();
           if (instrumentJson.Length > 0)
           {
               instrumentDataList = Newtonsoft.Json.JsonConvert.DeserializeObject<List<Instrument>>(instrumentJson);
           }
           else
           {
               instrumentDataList = instrumentList.GetUnderlyingForFUT("aw230frvr95ajkzx", "NFO", "NSE", "FUT", "EQ", TimeSpan.FromDays(30));
               string jsonData = Newtonsoft.Json.JsonConvert.SerializeObject(instrumentDataList);
               System.IO.File.WriteAllText(instrumentFile, jsonData);
           }
           return instrumentDataList;
        }
        [HttpGet]
        public HttpResponseMessage  GetTopGainers(string p1,string p2,string p3)
    List<Instrument> ins = TestMe(true).Skip(0).ToList();
            
    MarketMovement move = new MarketMovement();
  var topG=   move.TopGainers(100, ins.Select(x
namespace fluidedotnet
  public delegate void MyCallbackDelegate(SceneParam param);
  public partial class FormParam : Form
  {
    MyCallbackDelegate callback;
    Instrument instrument= new Instrument();
    public FormParam()
    {
      InitializeComponent();
    }
    public void InitParam(string path,MyCallbackDelegate c)
    {
      callback = c;
      var files = from file in Directory.GetFiles(path)
                  orderby file where file.EndsWith(".geo")
                  select file;
      foreach (var file in files)
      {
        FileList.Items.Add(Path.GetFileNameWithoutExtension(file));
      }
      XTrack.Value = 4;
      instrument.zoom = true;
      instrument.zoomx = XTrack.Value;
      instrument.changeinstrument = true;
      SetParams(true);
    }
    private void FormParam_Load(object sender, EventArgs e)
    {
    }
    public void SetParams(bool reinit)
    {
      SceneParam param = new SceneParam();
      param.reinit = reinit;
      if(FileList.SelectedI

        param.file = FileList.SelectedItem.ToString();
      else
      param.file = "free2";
      param.instrument = instrument;
      callback(param);
    }
    private void FileList_SelectedIndexChanged(object sender, EventArgs e)
    {
      instrument = new Instrument();
      SetParams(true);
    }
    private void XTrack_Scroll(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.zoom = true;
      instrument.zoomx = XTrack.Value;
      instrument.changeinstrument = true;
      SetParams(false);
    }
    private void ButDrop_Click(object sender, EventArgs e)
    {
      instrument = new  Instrument();
      instrument.changeinstrument = true;
      instrument.drop = true;
      SetParams(false);
    }
    private void butPipe_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.pipe = true;
      SetParams(false);
    }
    private void butObstacle_Click(objec

    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.setter = true;
      SetParams(false);
    }
    private void butDelate_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.remover = true;
      SetParams(false);
    }
    private void butForce_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.forceup = true;
      SetParams(false);
    }
    private void butForceDown_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.forcedown = true;
      SetParams(false);
    }
    private void butPush_Click(object sender, EventArgs e)
    {
      instrument = new Instrument();
      instrument.changeinstrument = true;
      instrument.push = true;
      SetParams(false);
    }
    private void 
namespace Microsoft.AspNet.Razor.Generator.Compiler
    public class CodeVisitor<T> : ChunkVisitor<T> where T : CodeWriter
    {
        public CodeVisitor(T writer, CodeGeneratorContext context)
            : base(writer, context) { }
        protected override void Visit(LiteralChunk chunk)
        {
        }
        protected override void Visit(ExpressionBlockChunk chunk)
        {
        }
        protected override void Visit(ExpressionChunk chunk)
        {
        }
        protected override void Visit(StatementChunk chunk)
        {
        }
        protected override void Visit(UsingChunk chunk)
        {
        }
        protected override void Visit(ChunkBlock chunk)
        {
        }
        protected override void Visit(DynamicCodeAttributeChunk chunk)
        {
        }
        protected override void Visit(LiteralCodeAttributeChunk chunk)
        {
        }
        protected override void Visit(CodeAttributeChunk chunk)
        {
        }
        protected ove
public class TileMassNetworker : NetworkBehaviour {
	TileMass tMass;
	void Start(){
		
		tMass = GetComponent<TileMass>();
	}
	[ClientRpc]
	public void RpcSetTileAt(Vector2 position, int id){
		
		TileChunk cPrefab = tMass.tileChunkPrefab.GetComponent<TileChunk>();
		Debug.Log("Yup");
		int x = (int) position.x;
		int y = (int) position.y;
		
		int chunkX = (int) (x / cPrefab.chunkSizeX);
		int chunkY = (int) (y / cPrefab.chunkSizeY);
		
		int tileX = (int) (x - chunkX * cPrefab.chunkSizeX);
		int tileY = (int) (y - chunkY * cPrefab.chunkSizeY);
		
		tMass.tileChunks[chunkX, chunkY].GetComponent<TileChunk>().tiles[tileX, tileY].tileID = id;
		
		tMass.BuildChunk(new Vector2(chunkX, chunkY), false);
		
		if(tileX == 0)
			tMass.BuildChunk(new Vector2(chunkX - 1, chunkY), false);
		
		if(tileX == cPrefab.chunkSizeX - 1)
			tMass.BuildChunk(new Vector2(chunkX + 1, chunkY), false);
		
		if(tileY == 0)
			tMass.BuildChunk(new Vector2(chunkX, chunkY - 1), false);
		
		if(tileY == cPrefab.chu
namespace RecensysRepository.Factory
    public class RepositoryFactoryMemory : IRepositoryFactory
    {
        private UserRepositoryIm _userRepository;
        private StudyRepositoryIm _studyRepository;
        private StageRepositoryIm _stageRepository;
        private FieldRepositoryIm _fieldRepository;
        private DataRepositoryIm _fieldDataRepository;
        private TaskRepositoryIm _taskRepository;
        private ArticleRepositoryIm _articleRepository;
        private CredentialsRepositoryIm _credentialsRepository;
        private UserStudyRelationRepositoryIm _userStudyRelationRepository;
        private StudyRoleRepositoryIm _studyRoleRepository;
        private StrategyRepositoryIm _strategyRepository;
        private DataTypeRepositoryIm _dataTypeRepository;
        public IUserRepository GetUserRepo()
        {
            return _userRepository ?? (_userRepository = new UserRepositoryIm());
        }
        public IStudyRepository GetStudyRepo()
        {
        

        }
        public IStageRepository GetStageRepo()
        {
            return _stageRepository ?? (_stageRepository = new StageRepositoryIm());
        }
        public IFieldRepository GetFieldRepo()
        {
            return _fieldRepository ?? (_fieldRepository = new FieldRepositoryIm());
        }
        public IDataRepository GetDataRepo()
        {
            return _fieldDataRepository ?? (_fieldDataRepository = new DataRepositoryIm());
        }
        public ITaskRepository GetTaskRepo()
        {
            return _taskRepository ?? (_taskRepository = new TaskRepositoryIm());
        }
        public IArticleRepository GetArticleRepo()
        {
            return _articleRepository ?? (_articleRepository = new ArticleRepositoryIm());
        }
        public ICredentialsRepository GetCredentialsRepo()
        {
            return _credentialsRepository ?? (_credentialsRepository = new CredentialsRepositoryIm());
        }
        public IUserStudyRelationRepo
public class SceneManager : MonoBehaviour {
	public enum ProcessType{
		Loading,
		CardSelect,
		CardDetail,
		Dump,
		Battle,
	}
	private ProcessParent mCurrentProcess;
	private ProcessBattle 		mProcessBattle;
	private ProcessCardDetail 	mProcessCardDetail;
	private ProcessCardSelect 	mProcessCardSelect;
	private ProcessLoading 		mProcessLoading;
	private ProcessDump 		mProcessDump;
	void Start () {
		mProcessBattle 		= GetComponentInChildren<ProcessBattle>();
		mProcessCardDetail 	= GetComponentInChildren<ProcessCardDetail>();
		mProcessCardSelect 	= GetComponentInChildren<ProcessCardSelect>();
		mProcessLoading 	= GetComponentInChildren<ProcessLoading>();
		mProcessDump 		= GetComponentInChildren<ProcessDump>();
		mCurrentProcess = mProcessLoading;
		mCurrentProcess.SceneStart();
	}
	public void ChangeScene(ProcessType type){
		mCurrentProcess.SceneEnd();
		switch(type){
		case ProcessType.Battle:
			mCurrentProcess = mProcessBattle;
			break;
		case ProcessType.CardDetail:
			mCurr
namespace GameCore.Core.Services.UI.ViewModel
    public class BindingCommand
    {
        private Action _command;
        public BindingCommand(Action command)
        {
            _command = command;
        }
        public void Bind(Action onInvokeCommand)
        {
            onInvokeCommand += _command;
        }
        public void Bind(UnityEvent onInvokeCommand)
        {
            onInvokeCommand.AddListener(InvokeCommand);
        }
        public void UnBind(Action onInvokeCommand)
        {
            onInvokeCommand -= _command;
        }
        public void UnBind(UnityEvent onInvokeCommand)
        {
            onInvokeCommand.RemoveListener(InvokeCommand);
        }
        public void ClearBindings()
        {
            _command.ClearAllHandlers();
        }
        private void InvokeCommand()
        {
            _command();
        }
    }
    public class BindingCommand<TType>
    {
        private Action<TType> _command;
        public BindingCommand(A
public class World : MonoBehaviour {
    public Dictionary<int, Chunk> chunks = new Dictionary<int, Chunk>();
    public GameObject chunkPrefab;
    public string worldName = "world";
	public static GameManager instance;
	public GameObject fogPrefab;
	public Vector3 spawnPoint;
	IEnumerator Start () {
		yield return new WaitForSeconds(2f);
		RaycastHit hit;
		Debug.DrawRay(new Vector3(1f, 300f, 0f), Vector3.down, Color.red, 5f);
		if(Physics.Raycast(new Vector3(1f, 3000f, 1f), Vector3.down, out hit, 3000f, LayerMask.GetMask("Blocks"))) {
			spawnPoint = new Vector3Int((int)hit.point.x, (int)hit.point.y, (int)hit.point.z);
		} else {
			Debug.LogError("Can't find spawnpoint");
		}
	}
    public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(x, y, z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
  

		newChunkObject.layer = LayerMask.NameToLayer("Blocks");
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos.GetHashCode(), newChunk);
        var terrainGen = new TerrainGenerator();
        newChunk = terrainGen.ChunkGen(newChunk);
        newChunk.SetBlocksUnmodified();
        Serialization.LoadChunk(newChunk);
    }
    void OnApplicationQuit() {
        SaveWorld();
    }
    public void SaveWorld() {
        foreach (Chunk chunk in chunks.Values)
        {
            Serialization.SaveChunk(chunk);
        }
    }
    public void DestroyChunk(WorldPos pos)
    {
        Chunk chunk = null;
        int hash = pos.GetHashCode();
        if (chunks.TryGetValue(hash, out chunk))
        {
            Serialization.SaveChunk(chunk);
            Object.Destroy(chunk.gameObject);
            chunks.Remove(hash);
        }
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        int hash = WorldPos.GenerateHashCode(
            Mathf.

            Mathf.FloorToInt(y / (float)Chunk.CHUNK_SIZE) * Chunk.CHUNK_SIZE,
            Mathf.FloorToInt(z / (float)Chunk.CHUNK_SIZE) * Chunk.CHUNK_SIZE
               );
        Chunk containerChunk = null;
        chunks.TryGetValue(hash, out containerChunk);
        return containerChunk;
    }
    public BlockInstance GetBlock(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null)
        {
            BlockInstance block = containerChunk.GetBlock(
                x - containerChunk.pos.x,
                y - containerChunk.pos.y,
                z - containerChunk.pos.z);
            return block;
        }
        else
        {
            return new BlockInstance();
        }
    }
    public void SetBlock(int x, int y, int z, BlockData block)
    {
        Chunk chunk = GetChunk(x, y, z);
        if (chunk != null)
        {
            chunk.SetBlock(x - chunk.pos.x, y - chunk.pos.y, z - chunk.pos.z, block);
       
namespace VARCalculator.DataAccess
    class ReturnsDAO
    {
        public Frame<DateTime, string> instrumentPricesHistory;
        public void LoadInstrumentPricesMemory()
        {
            
            string fileName = ConfigurationManager.AppSettings["InstrumentDataFileName"].ToString();
            string fullFilePath = Environment.CurrentDirectory + "/" + fileName;
            try
            {
                Frame<int, string> instrumentPrices = Frame.ReadCsv(fullFilePath);
                instrumentPricesHistory = instrumentPrices.IndexRows<DateTime>("Date").SortRowsByKey();
            
            }
            catch(FileNotFoundException ex)
            {
                throw new DAOException(DAOException.FILE_NA, "Could not open file, check it exists or is not already in use", ex);
            }
            catch (Exception ex)
            {
                throw new DAOException(DAOException.UNKNOWN_ERROR, "Unknown error occurred when opening file", ex);
          

        }
        public double[] getInstrumentReturns(string instrumentID, DateTime startDate, DateTime endDate)
        {
            double[] returnsArray = null;
            try
            {
                Series<DateTime, double> instrumentPricesColumn = instrumentPricesHistory.GetColumn<double>(instrumentID);
                Series<DateTime, double> instrumentPrices = instrumentPricesColumn.Between(startDate, endDate);
                Series<DateTime, double> instrumentReturns = (instrumentPrices.Diff(1) / instrumentPrices).DropMissing();
                returnsArray = new double[instrumentReturns.ValueCount];
                int i = 0;
                foreach (double instrumentReturn in instrumentReturns.Values)
                {
                    returnsArray[i] = instrumentReturn;
                    i++;
                }
            }
            catch (Exception ex)
            {
                throw new DAOException(DAOException.UNKNOWN_ERROR, "Unknown error occurred
namespace Shepherd.Service
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
    public class InstrumentService : IInstrumentService
    {
        private IInstrumentBusinessLogic _instrumentBusinessLogic;
        private InstrumentMapper _instrumentMapper;
        public InstrumentService(IInstrumentBusinessLogic instrumentBusinessLogic,
                                 InstrumentMapper instrumentMapper)
        {
            _instrumentBusinessLogic = instrumentBusinessLogic;
            _instrumentMapper = instrumentMapper;
        }
        [ExceptionAspect]
        [TransactionScopeAspect]
        public IList<InstrumentPriceDto> Load(string instrumentsNumber)
        {
            var instruments = _instrumentBusinessLogic.Load(Convert.ToInt16(instrumentsNumber));
            return _instrumentMapper.MapInstrumentsToInstrumentsPriceDto(instruments);
        }
        [ExceptionAspect]
        [TransactionScopeAspect]
        pub

        {
            _instrumentBusinessLogic.UpdatePrices();
        }
        [ExceptionAspect]
        public IList<InstrumentPriceDto> GetStockInstruments()
        {
            var instrumentsPrice = new List<InstrumentPriceDto>();
            var instruments = _instrumentBusinessLogic.GetStockInstruments();
            Price instrumentCurrentPrice;
            foreach(var instrument in instruments)
            {
                instrumentCurrentPrice = _instrumentBusinessLogic.GetInstrumentCurrentPrice(instrument.Id);
                instrumentsPrice.Add(new InstrumentPriceDto
                {
                    InstrumentId = instrument.Id,
                    InstrumentName = instrument.Name,
                    PriceValue = instrumentCurrentPrice.Value,
                    DeltaValue = instrumentCurrentPrice.DeltaValue,
                    DeltaPercentageValue = instrumentCurrentPrice.DeltaPercentageValue
                });
            }
            return instrumentsPri
namespace NetPackCreator.Controllers
    internal sealed class ExchangeGroup
    {
        private readonly IConnectionModeController _connectionModeController;
        private readonly IConnectionStateController _connectionStateController;
        private readonly ICommandController _sendCommandController;
        private readonly IWriteController _writeController;
        private readonly IExchangeViewController _exchangeViewController;
        public ExchangeGroup(IConnectionModeController connectionModeController, IConnectionStateController connectionStateController, ICommandController sendCommandController,
            IWriteController writeController, IExchangeViewController exchangeViewController)
        {
            if (connectionModeController == null) throw new ArgumentNullException("connectionModeController");
            if (connectionStateController == null) throw new ArgumentNullException("connectionStateController");
            if (sendCommandController == null) throw

            if (writeController == null) throw new ArgumentNullException("writeController");
            if (exchangeViewController == null) throw new ArgumentNullException("exchangeViewController");
            this._connectionModeController = connectionModeController;
            this._connectionStateController = connectionStateController;
            this._sendCommandController = sendCommandController;
            this._writeController = writeController;
            this._exchangeViewController = exchangeViewController;
        }
        public IConnectionModeController ConnectionModeController { get { return this._connectionModeController; } }
        public IConnectionStateController ConnectionStateController { get { return this._connectionStateController; } }
        public ICommandController SendCommandController { get { return this._sendCommandController; } }
        public IWriteController WriteController { get { return this._writeController; } }
        public IExchangeViewC
namespace Voxel
    public class WorldData 
    {
	    private IntVec3 m_WorldSizeChunks = new IntVec3(16,16,16);
	    private IntVec3 m_ChunkSizeBlocks = new IntVec3(32,32,32);
	    private IntVec3 m_WorldSize;
	    private Chunk[,,]	m_Chunks;
	    private Block		m_OutsideBlock;
        public delegate void ChunkDelegate(Chunk chk);
        public event ChunkDelegate OnNewChunk;
        private List<Chunk>	m_DirtyChunks = new List<Chunk>();
	    public IntVec3 WorldSizeBlocks { get { return m_WorldSize;}}
	    public IntVec3 WorldSizeChunks { get { return m_WorldSizeChunks;}}
	    public IntVec3 ChunkSizeBlocks { get { return m_ChunkSizeBlocks;}}
        public List<Chunk> DirtyChunks { get { return m_DirtyChunks; }}
        
        public WorldData()
	    {
	    }
        public void SetDimensions(IntVec3 worldSize, IntVec3 chunkSize)
        {
            Debug.Log("WorldData - SetDimensions");
            Debug.Log("World Size in chunks: " + worldSize.ToString());
            Debu

            m_WorldSizeChunks = worldSize;
            m_ChunkSizeBlocks = chunkSize;
        } 
	    public void InitChunks()
	    {
		    m_Chunks = new Chunk[m_WorldSizeChunks.x,m_WorldSizeChunks.y,m_WorldSizeChunks.z];
		
		    m_WorldSize = new IntVec3(m_WorldSizeChunks.x * m_ChunkSizeBlocks.x,m_WorldSizeChunks.y * m_ChunkSizeBlocks.y,m_WorldSizeChunks.z * m_ChunkSizeBlocks.z);
        }
        public void MarkAllChunksDirty()
        {
            foreach (Chunk chunk in m_Chunks)
            {
                if (chunk.MarkDirty())
                    AddDirtyChunk(chunk);
            }
        }
        public void AddDirtyChunk(Chunk chunk)
        {
            m_DirtyChunks.Add(chunk);
        }
	    public bool PosOutsideWorld(int x,int y,int z)
	    {
		    if(	x < 0 || y < 0 || z < 0 || 
			    x >= m_WorldSize.x || y >= m_WorldSize.y || z >= m_WorldSize.z)
			    return true;
			
		    return false;
 	    }
	    public Block GetBlock(int x,int y,int z)
        {
		    

            {
			    return m_OutsideBlock;
            }
		
		    int chunkX = x / m_ChunkSizeBlocks.x;
            int chunkY = y / m_ChunkSizeBlocks.y;
            int chunkZ = z / m_ChunkSizeBlocks.z;
            int blockX = x % m_ChunkSizeBlocks.x;
            int blockY = y % m_ChunkSizeBlocks.y;
            int blockZ = z % m_ChunkSizeBlocks.z;
		    Chunk chunk = m_Chunks[chunkX, chunkY, chunkZ];
		    if(chunk == null)
			    return m_OutsideBlock;
		    else
			    return chunk.Blocks[blockX, blockY, blockZ];
        }
        public Chunk CreateChunk(int chunkX,int chunkY,int chunkZ)
        {
                return m_Chunks[chunkX, chunkY, chunkZ];
            Chunk chunk = new Chunk(this,new IntVec3(chunkX * m_ChunkSizeBlocks.x,chunkY * m_ChunkSizeBlocks.y,chunkZ * m_ChunkSizeBlocks.z));
            chunk.ChunkPos = new IntVec3(chunkX, chunkY, chunkZ);
            chunk.InitBlocks(m_ChunkSizeBlocks);
            m_Chunks[chunkX, chunkY, chunkZ] = chunk;
            retur
namespace RentalModel.Repository.Generic.UnitofWork
    public partial class UnitofWork : IGenericUnitofWork
    {
        public  DbContext Context;
        public UnitofWork()
        {
            Context = new RentalContext();
        }
        public UnitofWork(DbContext context)
        {
            Context = context;
        }
        private IGenericRepository<Agent> _agentRepository;
        public IGenericRepository<Agent> AgentRepository
        {
            get { return  _agentRepository ?? ( _agentRepository = new GenericRepository<Agent>(Context)); }
            set {  _agentRepository = value; }
        }
    
        private IGenericRepository<AgentAcceptedApplication> _agentAcceptedApplicationRepository;
        public IGenericRepository<AgentAcceptedApplication> AgentAcceptedApplicationRepository
        {
            get { return  _agentAcceptedApplicationRepository ?? ( _agentAcceptedApplicationRepository = new GenericRepository<AgentAcceptedApplication>(Context))

            set {  _agentAcceptedApplicationRepository = value; }
        }
    
        private IGenericRepository<AgentAcceptedPostedProject> _agentAcceptedPostedProjectRepository;
        public IGenericRepository<AgentAcceptedPostedProject> AgentAcceptedPostedProjectRepository
        {
            get { return  _agentAcceptedPostedProjectRepository ?? ( _agentAcceptedPostedProjectRepository = new GenericRepository<AgentAcceptedPostedProject>(Context)); }
            set {  _agentAcceptedPostedProjectRepository = value; }
        }
    
        private IGenericRepository<AgentPendingApplication> _agentPendingApplicationRepository;
        public IGenericRepository<AgentPendingApplication> AgentPendingApplicationRepository
        {
            get { return  _agentPendingApplicationRepository ?? ( _agentPendingApplicationRepository = new GenericRepository<AgentPendingApplication>(Context)); }
            set {  _agentPendingApplicationRepository = value; }
        }
    
        pr

        public IGenericRepository<AgentPendingPostedProject> AgentPendingPostedProjectRepository
        {
            get { return  _agentPendingPostedProjectRepository ?? ( _agentPendingPostedProjectRepository = new GenericRepository<AgentPendingPostedProject>(Context)); }
            set {  _agentPendingPostedProjectRepository = value; }
        }
    
        private IGenericRepository<AgentProject> _agentProjectRepository;
        public IGenericRepository<AgentProject> AgentProjectRepository
        {
            get { return  _agentProjectRepository ?? ( _agentProjectRepository = new GenericRepository<AgentProject>(Context)); }
            set {  _agentProjectRepository = value; }
        }
    
        private IGenericRepository<AgentRejectedApplication> _agentRejectedApplicationRepository;
        public IGenericRepository<AgentRejectedApplication> AgentRejectedApplicationRepository
        {
            get { return  _agentRejectedApplicationRepository ?? ( _agentRejectedApp
namespace Cats.Areas.Logistics.Controllers
    [Authorize]
    public class DeliveryReconcileController : Controller
    {
        private readonly IDispatchAllocationService _dispatchAllocationService;
        private readonly IDeliveryService _deliveryService;
        private readonly IDispatchService _dispatchService;
        private readonly Cats.Services.EarlyWarning.ICommodityService _commodityService;
        private readonly Cats.Services.EarlyWarning.IUnitService _unitService;
        private readonly Cats.Services.Transaction.ITransactionService _transactionService;
        private readonly Cats.Services.EarlyWarning.IAdminUnitService _adminUnitService;
        private readonly Cats.Services.EarlyWarning.IFDPService _fdpService;
        private readonly Cats.Services.Logistics.IDeliveryReconcileService _deliveryReconcileService;
        private readonly IUserAccountService _userAccountService;
        public DeliveryReconcileController(IDispatchAllocationService dispatchAlloc

                                      IDeliveryService deliveryService,
            IDispatchService dispatchService,
            Cats.Services.EarlyWarning.ICommodityService commodityService, Cats.Services.EarlyWarning.IUnitService unitService, 
            Cats.Services.Transaction.ITransactionService transactionService,
            Cats.Services.EarlyWarning.IAdminUnitService adminUnitService, Cats.Services.EarlyWarning.IFDPService fdpService,
            Cats.Services.Logistics.IDeliveryReconcileService deliveryReconcileService, IUserAccountService userAccountService)
        {
            _dispatchAllocationService = dispatchAllocationService;
            _deliveryService = deliveryService;
            _dispatchService = dispatchService;
            _commodityService = commodityService;
            _unitService = unitService;
            _transactionService = transactionService;
            _adminUnitService = adminUnitService;
            _fdpService = fdpService;
            _d

            _userAccountService = userAccountService;
        }
        public ActionResult Index(int regionID)
        {
            ViewBag.RegionID = regionID;
            ViewBag.Region = _adminUnitService.FindById(regionID).Name;
            var zonesList = _adminUnitService.GetAllZones(regionID);
            ViewBag.ZoneCollection = BindZoneViewModel(zonesList); 
            return View();
        }
        public ActionResult ReadDispatchesNotReconciled([DataSourceRequest]DataSourceRequest request, int FDPID)
        {
            var dispatch = _dispatchService.Get(t => t.FDPID == FDPID, null, "FDP,DispatchAllocation").OrderByDescending(t => t.DispatchDate);
            var dispatchViewModelForReconciles = BindDispatchViewModelForReconciles(dispatch);
            var dispatchViewModelForReconciled = dispatchViewModelForReconciles as List<DispatchViewModelForReconcile> ?? dispatchViewModelForReconciles.ToList();
            foreach (var dispatchViewModelForReconcile in dispatch
namespace APRST.DAL.Repositories
    public class EFUnitOfWork : IUnitOfWork
    {
        private readonly AprstContext _db;
        private ITestRepository _testRepository;
        private ITestCategoryRepository _testCategoryRepository;
        private ITestQuestionRepository _testQuestionRepository;
        private ITestAnswerRepository _testAnswerRepository;
        private ITestResultRepository _testResultRepository;
        private IUserProfileRepository _userProfileRepository;
        private IRoleRepository _roleRepository;
        private IQuestionnaireCategoryRepository _questionnaireCategoryRepository;
        private IQuestionnaireQuestionRepository _questionnaireQuestionRepository;
        private IQuestionnaireRepository _questionnaireRepository;
        private IQuestionnaireTypeRepository _questionnaireTypeRepository;
        private IQuestionnaireResultRepository _questionnaireResultRepository;
        private ILogRepository _logRepository;
        public EFUnitOfWork

        {
            _db = new AprstContext(connectionString);
        }
        public ITestRepository TestRepository => _testRepository ?? (_testRepository = new TestRepository(_db));
        public ITestCategoryRepository TestCategoryRepository => _testCategoryRepository ?? (_testCategoryRepository = new TestCategoryRepository(_db));
        public ITestQuestionRepository TestQuestionRepository => _testQuestionRepository ?? (_testQuestionRepository = new TestQuestionRepository(_db));
        public ITestAnswerRepository TestAnswerRepository => _testAnswerRepository ?? (_testAnswerRepository = new TestAnswerRepository(_db));
        public ITestResultRepository TestResultRepository => _testResultRepository ?? (_testResultRepository = new TestResultRepository(_db));
        public IUserProfileRepository UserProfileRepository => _userProfileRepository ?? (_userProfileRepository = new UserProfileRepository(_db));
        public IRoleRepository RoleRepository => _roleRepository ?? (_ro

        public IQuestionnaireCategoryRepository QuestionnaireCategoryRepository => _questionnaireCategoryRepository ?? (_questionnaireCategoryRepository = new QuestionnaireCategoryRepository(_db));
        public IQuestionnaireQuestionRepository QuestionnaireQuestionRepository => _questionnaireQuestionRepository ?? (_questionnaireQuestionRepository = new QuestionnaireQuestionRepository(_db));
        public IQuestionnaireRepository QuestionnaireRepository => _questionnaireRepository ?? (_questionnaireRepository = new QuestionnaireRepository(_db));
        public IQuestionnaireTypeRepository QuestionnaireTypeRepository => _questionnaireTypeRepository ?? (_questionnaireTypeRepository = new QuestionnaireTypeRepository(_db));
        public IQuestionnaireResultRepository QuestionnaireResultRepository => _questionnaireResultRepository ?? (_questionnaireResultRepository = new QuestionnaireResultRepository(_db));
        public ILogRepository LogRepository => _logRepository ?? (_logRepositor
namespace FlyweightTräning
    class InstrumentFlyweightFactory
    {
        Dictionary<InstrumentType?, IInstrument> instruments = new Dictionary<InstrumentType?, IInstrument>();
        public IInstrument GetInstrument(InstrumentType type)
        {
            IInstrument instrument = null;
            bool found = instruments.TryGetValue(type, out instrument);
            if (!found)
            {
                if (type == InstrumentType.Violin)
                {
                    instrument = new Violin();
                    instruments.Add(type, instrument);
                }
                else if(type == InstrumentType.Trumpet)
                {
                    instrument = new Trumpet();
                    instruments.Add(type, instrument);
                }
                else
                {
                    instrument = new Drum();
                    instruments.Add(type, instrument);
                }                
            }
            return inst
public class Neighbours {
	public VoxelShell xpos;
	public VoxelShell xneg;
	public VoxelShell ypos;
	public VoxelShell yneg;
	public VoxelShell zpos;
	public VoxelShell zneg;
	public bool xposQuad;
	public bool xnegQuad;
	public bool yposQuad;
	public bool ynegQuad;
	public bool zposQuad;
	public bool znegQuad;
	public Neighbours(ref VoxelShell _xpos, ref VoxelShell _xneg, ref VoxelShell _ypos, ref VoxelShell _yneg, ref VoxelShell _zpos, ref VoxelShell _zneg)
	{
		xpos = _xpos;
		xneg = _xneg; 
		ypos = _ypos; 
		yneg = _yneg;
		zpos = _zpos;
		zneg = _zneg;
		ResetFlags();
	}
	public Neighbours()
	{
	}
	public void ResetFlags()
	{
		xposQuad = false;
		xnegQuad = false;
		yposQuad = false;
		ynegQuad = false;
		zposQuad = false;
		znegQuad = false;
	}
	public void UpdateNeighbours()
	{	
		xpos.parentChunk.systemParent.VSUM.QueueChunkForUpdate(ref xpos.parentChunk);
		if(xneg.filled )
		if(xneg.parentChunk != xneg.neighbours.xpos.parentChunk )
		if(xneg.parentChunk != null)
		if(!xneg

		xneg.parentChunk.systemParent.VSUM.QueueChunkForUpdate(ref xneg.parentChunk);
		if(ypos.filled )
		if(ypos.parentChunk != ypos.neighbours.yneg.parentChunk )
		if(ypos.parentChunk != null)
		if(!ypos.parentChunk.queuedForUpdate)			
		ypos.parentChunk.systemParent.VSUM.QueueChunkForUpdate(ref ypos.parentChunk);			
		if(yneg.filled )
		if(yneg.parentChunk != yneg.neighbours.ypos.parentChunk )
		if(yneg.parentChunk != null)		
		if(!yneg.parentChunk.queuedForUpdate)
		yneg.parentChunk.systemParent.VSUM.QueueChunkForUpdate(ref yneg.parentChunk);
		
		if(zpos.filled )
		if(zpos.parentChunk != zpos.neighbours.zneg.parentChunk )
		if(zpos.parentChunk != null )
		if(!zpos.parentChunk.queuedForUpdate)
		zpos.parentChunk.systemParent.VSUM.QueueChunkForUpdate(ref zpos.parentChunk);
		
		if(zneg.filled )
		if(zneg.parentChunk != zneg.neighbours.zpos.parentChunk )
		if(zneg.parentChunk != null )		
		if(!zneg.parentChunk.queuedForUpdate)
		zneg.parentChunk.systemParent.VSUM.QueueChunkForUpdate(ref 

	}
	public void GetNeighbourDelegate(ref System.Action updateStuff, ref System.Action genMesh)
	{	
		if(xpos.filled )
			if(xpos.parentChunk != xpos.neighbours.xneg.parentChunk )
				if(xpos.parentChunk!= null )
					if(!xpos.parentChunk.queuedForUpdate)
				{
					
					updateStuff += xpos.parentChunk.UpdateMesh;
					genMesh += xpos.parentChunk.GenerateThisMesh;
				}			
		
		if(xneg.filled )
			if(xneg.parentChunk != xneg.neighbours.xpos.parentChunk )
				if(xneg.parentChunk != null)
					if(!xneg.parentChunk.queuedForUpdate)
				{
					
					updateStuff += xneg.parentChunk.UpdateMesh;
					genMesh += xneg.parentChunk.GenerateThisMesh;
				}
		
		if(ypos.filled )
			if(ypos.parentChunk != ypos.neighbours.yneg.parentChunk )
				if(ypos.parentChunk != null)
					if(!ypos.parentChunk.queuedForUpdate)
				{
					
					updateStuff += ypos.parentChunk.UpdateMesh;	
					genMesh += ypos.parentChunk.GenerateThisMesh;
				}			
		
		if(yneg.filled )
			if(yneg.parentChunk != yneg.neighbours.y
﻿namespace VRTK.UnityEventHelper
    [AddComponentMenu("VRTK/Scripts/Utilities/Unity Events/VRTK_HeadsetControllerAware_UnityEvents")]
    public sealed class VRTK_HeadsetControllerAware_UnityEvents : VRTK_UnityEvents<VRTK_HeadsetControllerAware>
    {
        [Serializable]
        public sealed class HeadsetControllerAwareEvent : UnityEvent<object, HeadsetControllerAwareEventArgs> { }
        public HeadsetControllerAwareEvent OnControllerObscured = new HeadsetControllerAwareEvent();
        public HeadsetControllerAwareEvent OnControllerUnobscured = new HeadsetControllerAwareEvent();
        public HeadsetControllerAwareEvent OnControllerGlanceEnter = new HeadsetControllerAwareEvent();
        public HeadsetControllerAwareEvent OnControllerGlanceExit = new HeadsetControllerAwareEvent();
        protected override void AddListeners(VRTK_HeadsetControllerAware component)
        {
            component.ControllerObscured += ControllerObscured;
            component.ControllerUnobscure

            component.ControllerGlanceEnter += ControllerGlanceEnter;
            component.ControllerGlanceExit += ControllerGlanceExit;
        }
        protected override void RemoveListeners(VRTK_HeadsetControllerAware component)
        {
            component.ControllerObscured -= ControllerObscured;
            component.ControllerUnobscured -= ControllerUnobscured;
            component.ControllerGlanceEnter -= ControllerGlanceEnter;
            component.ControllerGlanceExit -= ControllerGlanceExit;
        }
        private void ControllerObscured(object o, HeadsetControllerAwareEventArgs e)
        {
            OnControllerObscured.Invoke(o, e);
        }
        private void ControllerUnobscured(object o, HeadsetControllerAwareEventArgs e)
        {
            OnControllerUnobscured.Invoke(o, e);
        }
        private void ControllerGlanceEnter(object o, HeadsetControllerAwareEventArgs e)
        {
            OnControllerGlanceEnter.Invoke(o, e);
        }
        
namespace SocialNetwork2017.BL
    public class DataManager
    {
        private IUsersRepository usersRepository;
        private IFriendsRepository friendsRepository;
        private IFriendRequestsRepository friendRequestsRepository;
        private IMessagesRepository messagesRepository;
        private PrimaryMembershipProvider provider;
        public DataManager(IUsersRepository usersRepository, IFriendsRepository friendsRepository, IFriendRequestsRepository friendRequestsRepository, IMessagesRepository messagesRepository, PrimaryMembershipProvider provider)
        {
            this.usersRepository = usersRepository;
            this.friendsRepository = friendsRepository;
            this.friendRequestsRepository = friendRequestsRepository;
            this.messagesRepository = messagesRepository;
            this.provider = provider;
        }
        public IUsersRepository Users { get { return usersRepository; } }
        public IFriendsRepository Friends { get { return fr
namespace Projekt2
    public class MyProcess
    {
        private Process process { set; get; }
        public event PropertyChangedEventHandler PropertyChanged;
        public void RaisePropertyChanged(string propertyName)
        {
            if (PropertyChanged != null)
            {
                PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
            }
        }
        public Process Process
        {
            get
            {
                return process;
            }
            set
            {
                if (process != value)
                {
                    process = value;
                    RaisePropertyChanged("Process");
                }
            }
        }
        public string Name
        {
            get
            {
                return process.ProcessName;
            }
        }
        public string ID
        {
            get
            {
                return String.Format("{0,5}",process.Id);
         
public class TutorialUnlocker : MonoBehaviour {
    [SerializeField]
    private ChunkHolder chunkHolder;
    [SerializeField]
    private GenerateChunk generateChunk;
    [SerializeField]
    private PlayerDistance playerDistance;
    public void StartTutorial()
    {
        if (GameObject.FindGameObjectWithTag("Data") && GameObject.FindGameObjectWithTag("Data").GetComponent<OptionsData>().GetTutorial)
        {
            StartCoroutine(ForceIntroChunks());
        }
    }
	IEnumerator ForceIntroChunks()
    {
        print("ahppen");
        generateChunk.MakeChosenChunk(chunkHolder.UncompressChunk("100001100001110301100001100001100001100001100001103011100001100001100001"));
        yield return new WaitForSeconds(6f);
        generateChunk.MakeChosenChunk(chunkHolder.UncompressChunk("111111111111111111111111111121111111111111121111111121111111111111113311113311133331133331333333333333333333000000"));
        yield return new WaitForSeconds(8f);
        generateChunk.MakeChosenChu
namespace OceanChip.Common.Storage
    public class ChunkWriter
    {
        private const string SchdeuleName= "FlushChunk";
        public Chunk CurrentChunk => _currentChunk;
        private readonly ChunkManager _chunkManager;
        private readonly IScheduleService _scheduleService;
        private readonly object _lockSync = new object();
        private bool _isClosed = false;
        private Chunk _currentChunk;
        public ChunkWriter(ChunkManager manager)
        {
            Check.NotNull(manager, nameof(manager));
            this._chunkManager = manager;
            this._scheduleService = ObjectContainer.Resolve<IScheduleService>();
        }
        public void Open()
        {
            _currentChunk = _chunkManager.GetLastChunk();
            if (!_chunkManager.IsMemoryMode && !_chunkManager.Config.SyncFlush)
                _scheduleService.StartTask(SchdeuleName, Flush, 1000, _chunkManager.Config.FlushChunkIntervalMilliseconds);
            _isClosed = false

        }
        public long Write(ILogRecord record)
        {
            lock (_lockSync)
            {
                if (_isClosed)
                    return -1L;
                if (_currentChunk.IsCompleted)
                    _currentChunk = _chunkManager.AddNewChunk();
                var result = _currentChunk.TryAppend(record);
                {
                    _currentChunk.Complete();
                    _currentChunk = _chunkManager.AddNewChunk();
                    if (!result.Success)
                        throw new ChunkWriteException(this.ToString(), "写记录失败");
                }
                if(!_chunkManager.IsMemoryMode && _chunkManager.Config.SyncFlush)
                {
                    _currentChunk.Flush();
                }
                return result.Position;
            }
        }
        public void Close()
        {
            lock (_lockSync)
            {
                if (!_chunkManager.IsMemoryMode && _currentChunk != null)
     
namespace System.Web.Services.Protocols {
    internal class ScatterGatherStream : Stream {
        private const int MemStreamMaxLength = Int32.MaxValue;        
        private MemoryChunk headChunk = null;
        private MemoryChunk currentChunk = null;  
        private long chunkSize = 0;
        private int currentOffset = 0;
        private int endOffset = 0;
        private long currentChunkStartPos = 0;
        internal ScatterGatherStream(int chunkSize) {
            this.chunkSize = chunkSize;
            currentChunk = headChunk = AllocateMemoryChunk(this.chunkSize);
            currentOffset = endOffset = 0;
            currentChunkStartPos = 0;
        }
        internal ScatterGatherStream() : this(1024) { }
        public override bool CanRead { get { return true; } }
        public override bool CanSeek { get { return true; } }
        public override bool CanWrite { get { return true; } }
        
        public override void Close() {            
            headChu

            currentChunk = null;
            endOffset = currentOffset = 0;
            currentChunkStartPos = 0;
        }
        public override void Flush() { }
        public override long Length { 
            get {
                MemoryChunk endChunk;
                return GetLengthInternal(out endChunk);
            }
        }
        private long GetLengthInternal(out MemoryChunk endChunk){
            long length = currentChunkStartPos;
            MemoryChunk chunk = currentChunk;
            while (chunk.Next != null) {
                length += chunk.Buffer.Length;
                chunk = chunk.Next;
            }
            length += endOffset;
            endChunk = chunk;
            return length;
        }
        public override long Position {
            get {
                return Seek(0, SeekOrigin.Current);
            }
             
            set {
                Seek(value, SeekOrigin.Begin);
            }
        }
        
        public override l

            MemoryChunk chunk  = null;;
            long relativeOffset = 0;
            long absoluteOffset = 0;
            
            if(loc == SeekOrigin.Begin){
                absoluteOffset = offset;
                if(offset >= currentChunkStartPos){
                    chunk = currentChunk;
                    relativeOffset = offset - currentChunkStartPos;
                }
                else{
                    chunk = headChunk;
                    relativeOffset = absoluteOffset;
                }
            }
            else if( loc == SeekOrigin.Current){
                absoluteOffset = offset + currentOffset + currentChunkStartPos;
                if( (offset + currentOffset) > 0){
                    chunk = currentChunk;
                    relativeOffset = offset + currentOffset;
                }
                else {
                    chunk = headChunk;
                    relativeOffset = absoluteOffset;
                }
            }
            else
namespace AssemblyCSharp
    public static class ChunkLoader
    {
        private static PCQueue queue = new PCQueue(1);
        public static void GenerateData(Chunk2 chunk)
        {
            queue.EngueueItem(() =>
            {
                PerlinWorldGenerator.CreateChunk(chunk);
                chunk.status = 1;
            });
        }
        public static void GenerateLight(Chunk2 chunk)
        {
            queue.EngueueItem(() =>
            {
                chunk.SpreadDaylight();
                chunk.status = 2;
            });
        }
        public static void RenderChunk(Chunk2 chunk)
        {
            queue.EngueueItem(() =>
            {
                chunk.manager.renderer.RenderChunk(chunk);
                chunk.status = 3;
            });
        }
        /*public static void RequestChunk (ChunkManager manager, int x, int z) 
        {
            Chunk2 chunk = new Chunk2(manager, x, z);
            manager.SetChunk(x, z, chunk);
            q

            {
                PerlinWorldGenerator.CreateChunk(chunk);
                chunk.isDataLoaded = true;
                chunk.manager.renderer.RenderChunk(chunk);
            });
            StatsEngine.QueueLength = queue.QueueLength();
        }
        public static void RequestChunkRegeneration (ChunkManager manager, Chunk2 chunk)
        {
            if (chunk.xPosition == 8 && chunk.zPosition == 10)
            {
                int ii = 0;
            }
            
            queue.EngueueItem(() =>
            {
                if (chunk.xPosition == 8 && chunk.zPosition == 10)
                {
                    int ii = 0;
                }
                try
                {
                    chunk.manager.renderer.RenderChunk(chunk);
                }
                catch(Exception ex)
                {
                    throw new Exception("error");
                }
                chunk.isQueuedForReRender = false;
            });
            
    

        }*/
        /*public static void RequestLightRegeneration (ChunkManager manager, Chunk2 chunk)
        {
            if (chunk.xPosition == 8 && chunk.zPosition == 10)
            {
                int ii = 0;
            }
            queue.EngueueItem(() =>
            {
                if (chunk.xPosition == 8 && chunk.zPosition == 10)
                {
                    int ii = 0;
                }
                chunk.manager.renderer.RenderChunk(chunk);
            });
            
            StatsEngine.QueueLength = queue.QueueLength();
        }*/
        public static void ShutDown()
        {
            queue.Shutdown(false);
        }
    }
    public class PCQueue
    {
        readonly object _locker = new object();
        Thread[] _workers;
        Queue<Action> _itemQ = new Queue<Action>();
        public PCQueue (int workerCount)
        {
            _workers = new Thread[workerCount];
            for (int i = 0; i < workerCount; i++)
            {
   
public override String ToString()
    if (Length == 0)
        return String.Empty;
    string ret = string.FastAllocateString(Length);
    StringBuilder chunk = this;
    unsafe
    {
        fixed (char* destinationPtr = ret)
        {
            do
            {
                if (chunk.m_ChunkLength > 0)
                {
                    char[] sourceArray = chunk.m_ChunkChars;
                    int chunkOffset = chunk.m_ChunkOffset;
                    int chunkLength = chunk.m_ChunkLength;
                    if ((uint)(chunkLength + chunkOffset) <= ret.Length && (uint)chunkLength <= (uint)sourceArray.Length)
                    {
                        fixed (char* sourcePtr = sourceArray)
                            string.wstrcpy(destinationPtr + chunkOffset, sourcePtr, chunkLength);
                    }
                    else
                    {
                        throw new ArgumentOutOfRangeException("chunkLength", Environment.GetResourceString("ArgumentOu
public class Neighbours {
	public VoxelShell xpos;
	public VoxelShell xneg;
	public VoxelShell ypos;
	public VoxelShell yneg;
	public VoxelShell zpos;
	public VoxelShell zneg;
	public bool xposQuad;
	public bool xnegQuad;
	public bool yposQuad;
	public bool ynegQuad;
	public bool zposQuad;
	public bool znegQuad;
	public Neighbours(ref VoxelShell _xpos, ref VoxelShell _xneg, ref VoxelShell _ypos, ref VoxelShell _yneg, ref VoxelShell _zpos, ref VoxelShell _zneg)
	{
		xpos = _xpos;
		xneg = _xneg; 
		ypos = _ypos; 
		yneg = _yneg;
		zpos = _zpos;
		zneg = _zneg;
		ResetFlags();
	}
	public Neighbours()
	{
	}
	public void ResetFlags()
	{
		xposQuad = false;
		xnegQuad = false;
		yposQuad = false;
		ynegQuad = false;
		zposQuad = false;
		znegQuad = false;
	}
	public void UpdateNeighbours()
	{	
		if(!xpos.parentChunk.queuedForUpdate)
		xpos.parentChunk.systemParent.VSUM.QueueChunkForUpdate(ref xpos.parentChunk);
		if(xneg.filled )
		if(xneg.parentChunk != xneg.neighbours.xpos.parentChunk )
	

		if(!xneg.parentChunk.queuedForUpdate)
		xneg.parentChunk.systemParent.VSUM.QueueChunkForUpdate(ref xneg.parentChunk);
		if(ypos.filled )
		if(ypos.parentChunk != ypos.neighbours.yneg.parentChunk )
		if(ypos.parentChunk != null)
		if(!ypos.parentChunk.queuedForUpdate)			
		ypos.parentChunk.systemParent.VSUM.QueueChunkForUpdate(ref ypos.parentChunk);			
		if(yneg.filled )
		if(yneg.parentChunk != yneg.neighbours.ypos.parentChunk )
		if(yneg.parentChunk != null)		
		if(!yneg.parentChunk.queuedForUpdate)
		yneg.parentChunk.systemParent.VSUM.QueueChunkForUpdate(ref yneg.parentChunk);
		
		if(zpos.filled )
		if(zpos.parentChunk != zpos.neighbours.zneg.parentChunk )
		if(zpos.parentChunk != null )
		if(!zpos.parentChunk.queuedForUpdate)
		zpos.parentChunk.systemParent.VSUM.QueueChunkForUpdate(ref zpos.parentChunk);
		
		if(zneg.filled )
		if(zneg.parentChunk != zneg.neighbours.zpos.parentChunk )
		if(zneg.parentChunk != null )		
		if(!zneg.parentChunk.queuedForUpdate)
		zneg.parentChunk.sy

	}
	public void GetNeighbourDelegate(ref System.Action updateStuff, ref System.Action genMesh)
	{	
		if(xpos.filled )
			if(xpos.parentChunk != xpos.neighbours.xneg.parentChunk )
				if(xpos.parentChunk!= null )
					if(!xpos.parentChunk.queuedForUpdate)
				{
					
					updateStuff += xpos.parentChunk.UpdateMesh;
					genMesh += xpos.parentChunk.GenerateThisMesh;
				}			
		
		if(xneg.filled )
			if(xneg.parentChunk != xneg.neighbours.xpos.parentChunk )
				if(xneg.parentChunk != null)
					if(!xneg.parentChunk.queuedForUpdate)
				{
					
					updateStuff += xneg.parentChunk.UpdateMesh;
					genMesh += xneg.parentChunk.GenerateThisMesh;
				}
		
		if(ypos.filled )
			if(ypos.parentChunk != ypos.neighbours.yneg.parentChunk )
				if(ypos.parentChunk != null)
					if(!ypos.parentChunk.queuedForUpdate)
				{
					
					updateStuff += ypos.parentChunk.UpdateMesh;	
					genMesh += ypos.parentChunk.GenerateThisMesh;
				}			
		
		if(yneg.filled )
			if(yneg.parentChunk != yneg.neighbours.y
namespace NEventStore
    public class SynchronousDispatchSchedulerWireup : Wireup
    {
        private static readonly ILog Logger = LogFactory.BuildLogger(typeof (SynchronousDispatchSchedulerWireup));
        public SynchronousDispatchSchedulerWireup(Wireup wireup, IDispatchCommits dispatcher, DispatcherSchedulerStartup startup)
            : base(wireup)
        {
            Logger.Debug(Messages.SyncDispatchSchedulerRegistered);
            Startup(startup);
            DispatchTo(dispatcher ?? new NullDispatcher());
            Container.Register<IScheduleDispatches>(c =>
            {
                var dispatchScheduler = new SynchronousDispatchScheduler(
                    c.Resolve<IDispatchCommits>(),
                    c.Resolve<IPersistStreams>());
                if (c.Resolve<DispatcherSchedulerStartup>() == DispatcherSchedulerStartup.Auto)
                {
                    dispatchScheduler.Start();
                }
                return dispatchScheduler;
   
namespace TShanTC.Service.Provider.WorkShopDispatch
    public class WorkShopDispatchProvider
    {
        IWorkShopDispatchLogic _iWorkShopDispatchLogic;
        public WorkShopDispatchProvider(IWorkShopDispatchLogic iWorkShopDispatchLogic)
        {
            _iWorkShopDispatchLogic = iWorkShopDispatchLogic;
        }
        public int AddWorkShopDispatch(WorkShopDispatchEntity workShopDispatchInfo)
        {
            if (workShopDispatchInfo != null && workShopDispatchInfo.WorkShopDispatchId.HasValue)
            {
                return _iWorkShopDispatchLogic.EditWorkShopDispatch(workShopDispatchInfo);
            }
            else
            {
                return _iWorkShopDispatchLogic.AddWorkShopDispatch(workShopDispatchInfo);
            }
        }
        public QiXiuListResponse<WorkShopDispatchEntity> GetWorkShopDispatchList(WorkShopDispatchListRequest workShopDispatchListRequest)
        {
            QiXiuListResponse<WorkShopDispatchEntity> WorkShopDispatchL
namespace MFDExtractor
    internal interface IInstrumentFactory
    {
        IInstrument Create(InstrumentType instrumentType);
    }
    class InstrumentFactory : IInstrumentFactory
    {
        private readonly IInstrumentStateSnapshotCache _instrumentStateSnapshotCache;
        private readonly IRendererFactory _rendererFactory;
        private readonly IPerformanceCounterInstanceFactory _performanceCounterInstanceFactory;
        public InstrumentFactory(
            InstrumentStateSnapshotCache instrumentStateSnapshotCache = null, 
            IRendererFactory rendererFactory=null,
            IPerformanceCounterInstanceFactory performanceCounterInstanceFactory = null)
        {
            _instrumentStateSnapshotCache = instrumentStateSnapshotCache ?? new InstrumentStateSnapshotCache();
            _rendererFactory = rendererFactory ?? new RendererFactory();
            _performanceCounterInstanceFactory = performanceCounterInstanceFactory ?? new PerformanceCounterInstanceIns

        }
        public IInstrument Create(InstrumentType instrumentType)
        {
            var renderer = _rendererFactory.CreateRenderer(instrumentType);
            var instrument = new Instrument(_instrumentStateSnapshotCache)
            {
                Type = instrumentType,
                Renderer =renderer,
                RenderedFramesCounter = _performanceCounterInstanceFactory.CreatePerformanceCounterInstance(Application.ProductName, string.Format("Rendered Frames per second - {0}", instrumentType)),
                SkippedFramesCounter = _performanceCounterInstanceFactory.CreatePerformanceCounterInstance(Application.ProductName, string.Format("Skipped Frames per second - {0}", instrumentType)),
                TimeoutFramesCounter = _performanceCounterInstanceFactory.CreatePerformanceCounterInstance(Application.ProductName, string.Format("Timeout Frames per second - {0}", instrumentType)),
                TotalFramesCounter = _performanceCounterInstanceFactory.Cre
namespace XMutator {
    public static class ProcessExtensions {
        private static string FindIndexedProcessName(int pid) {
            var processName = Process.GetProcessById(pid).ProcessName;
            var processesByName = Process.GetProcessesByName(processName);
            string processIndexdName = null;
            for (var index = 0; index < processesByName.Length; index++) {
                processIndexdName = index == 0 ? processName : processName + "#" + index;
                var processId = new PerformanceCounter("Process", "ID Process", processIndexdName);
                if ((int)processId.NextValue() == pid) {
                    return processIndexdName;
                }
            }
            return processIndexdName;
        }
        private static Process FindPidFromIndexedProcessName(string indexedProcessName) {
            var parentId = new PerformanceCounter("Process", "Creating Process ID",
                    indexedProcessName);
            retur

        }
        public static Process Parent(this Process process) {
            return FindPidFromIndexedProcessName(FindIndexedProcessName(process.Id));
        }
        public static void KillAllProcessesSpawnedBy(this Process process) {
            KillAllProcessesSpawnedBy((uint)process.Id);
        }
        public static void KillAllProcessesSpawnedBy(uint parentProcessId) {
            Debug.WriteLine("Finding processes spawned by process with Id [" + parentProcessId + "]");
            var searcher = new ManagementObjectSearcher(
                    "SELECT * " +
                    "FROM Win32_Process " +
                    "WHERE ParentProcessId=" + parentProcessId);
            var collection = searcher.Get();
            if (collection.Count <= 0) {
                return;
            }
            Debug.WriteLine("Killing [" + collection.Count
                            + "] processes spawned by process with Id [" + parentProcessId + "]");
            foreach (var i
namespace AudioSynthesis.Sf2.Chunks
    public class InstrumentChunk : Chunk
    {
        private class RawInstrument
        {
            public string name;
            public ushort startInstrumentZoneIndex;
            public ushort endInstrumentZoneIndex;
        }
        private RawInstrument[] rawInstruments;
        public InstrumentChunk(string id, int size, BinaryReader reader)
            : base(id, size)
        {
            if (size % 22 != 0)
                throw new Exception("Invalid SoundFont. The preset chunk was invalid.");
            rawInstruments = new RawInstrument[size / 22];
            RawInstrument lastInstrument = null;
            for (int x = 0; x < rawInstruments.Length; x++)
            {
                RawInstrument i = new RawInstrument();
                i.name = IOHelper.Read8BitString(reader, 20);
                i.startInstrumentZoneIndex = reader.ReadUInt16();
                if (lastInstrument != null)
                    lastInstrument.en
public class World : MonoBehaviour {
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public GameObject chunkPrefab;
    public string worldName = "world";
    public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(x, y, z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        var terrainGen = new TerrainGen();
        newChunk = terrainGen.ChunkGen(newChunk);
        newChunk.SetBlocksUnmodified();
       Serialization.Load(newChunk);
    }
    public void DestroyChunk(int x, int y, int z)
    {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
       

            Serialization.SaveChunk(chunk);
            Object.Destroy(chunk.gameObject);
            chunks.Remove(new WorldPos(x, y, z));
        }
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / multiple) * Chunk.chunkSize;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Block GetBlock(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null)
        {
            Block block = containerChunk.GetBlock(
                x - containerChunk.pos.x,
                y - containerChunk.pos.y,
                z - containerChunk.pos.z);
            return block;
        }
        else
        

            return new BlockAir();
        }
    }
    public Block GetBlock(Vector3 vector)
    {
        int x = Mathf.RoundToInt(vector.x);
        int y = Mathf.RoundToInt(vector.y);
        int z = Mathf.RoundToInt(vector.z);
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null)
        {
            Block block = containerChunk.GetBlock(
                x - containerChunk.pos.x,
                y - containerChunk.pos.y,
                z - containerChunk.pos.z);
            return block;
        }
        else
        {
            return new BlockAir();
        }
    }
    public void SetBlock(int x, int y, int z, Block block)
    {
        Chunk chunk = GetChunk(x, y, z);
        if (chunk != null)
        {
            chunk.SetBlock(x - chunk.pos.x, y - chunk.pos.y, z - chunk.pos.z, block);
            chunk.update = true;
            UpdateIfEqual(x - chunk.pos.x, 0, new WorldPos(x - 1, y, z));
            UpdateIfEqual(x - chunk.pos.x, Chunk
namespace Nixin
    public class GameMapBatchLoader : ResourceBatchLoader
    {
        public GameMapBatchLoader( ResourceSystem resourceSystem, MapChunk mapChunk,
            GameModeChunk gameModeChunk ) 
            : base( resourceSystem, true, GetEntriesToLoad( resourceSystem, mapChunk, gameModeChunk ) )
        {
            this.mapChunk                  = mapChunk;
            this.gameModeChunk             = gameModeChunk;
            this.sceneAssetBundle          = resourceSystem.GetSceneAssetBundle( mapChunk.SceneBundleName.Name );
        }
        public MapChunk MapChunk
        {
            get
            {
                return mapChunk;
            }
        }
        public GameModeChunk GameModeChunk
        {
            get
            {
                return gameModeChunk;
            }
        }
        public AssetBundle SceneAssetBundle
        {
            get
            {
                return sceneAssetBundle;
            }
        }
        private

        private GameModeChunk       gameModeChunk         = null;
        private AssetBundle         sceneAssetBundle      = null;
        private static NixinAssetBundleEntry[] GetEntriesToLoad( ResourceSystem resourceSystem,
            MapChunk mapChunk, GameModeChunk gameModeChunk )
        {
            var ret = mapChunk.GetChunkEntries();
            ret.AddRange( gameModeChunk.GetChunkEntries() );
            if( !gameModeChunk.HudPrefab.IsNull )
            {
                ret.Add( gameModeChunk.HudPrefab.GetEntry( resourceSystem ) );
            }
            if( !gameModeChunk.ManagerPrefab.IsNull )
            {
                ret.Add( gameModeChunk.ManagerPrefab.GetEntry( resourceSystem ) );
            }
            if( !gameModeChunk.LocalManagerPrefab.IsNull )
            {
                ret.Add( gameModeChunk.LocalManagerPrefab.GetEntry( resourceSystem ) );
            }
            if( !gameModeChunk.StatePrefab.IsNull )
            {
                ret.Add( g
namespace Library.UnitOfWork
    public static class LibraryUnit
    {
        static ApplicationDbContext _context;
        public static AuthorRepository AuthorRepository { get; private set; }
        public static BookRepository BookRepository { get; private set; }
        public static CategoryRepository CategoryRepository { get; private set; }
        public static PressRepository PressRepository { get; private set; }
        public static ThemeRepository ThemeRepository { get; private set; }
        public static DepartmentRepository DepartmentRepository { get; private set; }
        public static TeacherRepository TeacherRepository { get; private set; }
        public static FacultyRepository FacultyRepository { get; private set; }
        public static GroupRepository GroupRepository { get; private set; }
        public static StudentRepository StudentRepository { get; private set; }
        public static SCardRepository SCardRepository { get; private set; }
        public stat

        public static LibrarianRepository LibrarianRepository { get; private set; }
        static LibraryUnit()
        {
            _context = new ApplicationDbContext("Library");
            AuthorRepository = new AuthorRepository(_context);
            BookRepository = new BookRepository(_context);
            CategoryRepository = new CategoryRepository(_context);
            PressRepository = new PressRepository(_context);
            ThemeRepository =new ThemeRepository(_context);
            DepartmentRepository = new DepartmentRepository(_context);
            TeacherRepository = new TeacherRepository(_context);
            FacultyRepository = new FacultyRepository(_context);
            GroupRepository = new GroupRepository(_context);
            StudentRepository =new StudentRepository(_context);
            SCardRepository =new SCardRepository(_context);
            TCardRepository =new TCardRepository(_context);
            LibrarianRepository=new LibrarianRepository(_con
/******************************************************************************
 * Copyright (C) Leap Motion, Inc. 2011-2017.                                 *
 * Leap Motion proprietary and  confidential.                                 *
 *                                                                            *
 * Use subject to the terms of the Leap Motion SDK Agreement available at     *
 * between Leap Motion and you, your company or other organization.           *
 ******************************************************************************/
namespace Leap.Unity.Interaction {
  public class ControllerContainer {
    private struct DefinableController<T> where T : IControllerBase {
      public T defaultController;
      public T registeredController;
      public DefinableController(T defaultController) {
        this.defaultController = defaultController;
        registeredController = null;
      }
      public void RegisterCustomController(T customController) {
        

          throw new InvalidOperationException("Cannot register a custom controller because one is already registered.");
        }
        registeredController = customController;
      }
      public void UnregisterCustomController() {
        if (registeredController == null) {
          throw new InvalidOperationException("Cannot unregister a custom controller because no custom controller is registered.");
        }
        registeredController = null;
      }
      public static implicit operator T(DefinableController<T> definableController) {
        if (definableController.registeredController != null) {
          return definableController.registeredController;
        } else {
          return definableController.defaultController;
        }
      }
    }
    private InteractionMaterial _material;
    private DefinableController<IHoldingPoseController> _holdingPoseController;
    private DefinableController<ILayerController> _layerController;
    private DefinableController<IM

    private DefinableController<ISuspensionController> _suspensionController;
    private DefinableController<IThrowingController> _throwingController;
    public ControllerContainer(InteractionBehaviour obj, InteractionMaterial material) {
      _material = material;
      _holdingPoseController = new DefinableController<IHoldingPoseController>(_material.CreateHoldingPoseController(obj));
      _layerController = new DefinableController<ILayerController>(_material.CreateLayerController(obj));
      _moveToController = new DefinableController<IMoveToController>(_material.CreateMoveToController(obj));
      _suspensionController = new DefinableController<ISuspensionController>(_material.CreateSuspensionController(obj));
      _throwingController = new DefinableController<IThrowingController>(_material.CreateThrowingController(obj));
    }
    public IHoldingPoseController HoldingPoseController {
      get {
        return _holdingPoseController;
      }
    }
    public void RegisterCu
namespace FreeQuant.Trading
  [StrategyComponent("{D779BA8E-C0CA-44cf-8745-99105365882F}", ComponentType.CrossExit, Description = "", Name = "Default_CrossExit")]
  public class CrossExit : StrategyMultiComponent
  {
    public const string GUID = "{D779BA8E-C0CA-44cf-8745-99105365882F}";
    
    public virtual SingleOrder EmitSignal(Signal signal)
    {
      return this.Strategy.BgvpSPpUAD(signal);
    }
    
    public virtual SingleOrder LongExit(Instrument instrument, string text)
    {
      if (!this.Strategy.IsInstrumentActive(instrument))
        return (SingleOrder) null;
      Signal signal = new Signal(Clock.Now, ComponentType.CrossExit, SignalType.Market, SignalSide.Sell, instrument, text);
      Position position = this.Portfolio.Positions[instrument];
      if (position == null || position.Side != PositionSide.Long)
      {
        signal.Status = SignalStatus.Rejected;
        signal.Rejecter = ComponentType.CrossExit;
      }
      return this.Strategy.BgvpSPpUAD(sign

    }
    
    public virtual SingleOrder LongExit(Instrument instrument)
    {
      return this.LongExit(instrument,  this.Strategy.Name);
    }
    
    public virtual SingleOrder ShortExit(Instrument instrument, string text)
    {
      if (!this.Strategy.IsInstrumentActive(instrument))
        return (SingleOrder) null;
      Signal signal = new Signal(Clock.Now, ComponentType.CrossExit, SignalType.Market, SignalSide.BuyCover, instrument, text);
      Position position = this.Portfolio.Positions[instrument];
      if (position == null || position.Side != PositionSide.Short)
      {
        signal.Status = SignalStatus.Rejected;
        signal.Rejecter = ComponentType.CrossExit;
      }
      return this.Strategy.BgvpSPpUAD(signal);
    }
    
    public virtual SingleOrder ShortExit(Instrument instrument)
    {
      return this.ShortExit(instrument, this.Strategy.Name);
    }
    
    public virtual SingleOrder LongExit(Instrument instrument, double price, string text)
    {
   

        return (SingleOrder) null;
      Signal signal = new Signal(Clock.Now, ComponentType.CrossExit, SignalType.Market, SignalSide.Sell, instrument, text);
      signal.StrategyFill = true;
      signal.StrategyPrice = price;
      Position position = this.Portfolio.Positions[instrument];
      if (position == null || position.Side != PositionSide.Long)
      {
        signal.Status = SignalStatus.Rejected;
        signal.Rejecter = ComponentType.CrossExit;
      }
      return this.Strategy.BgvpSPpUAD(signal);
    }
    
    public virtual SingleOrder LongExit(Instrument instrument, double price)
    {
      return this.LongExit(instrument, price, this.Strategy.Name);
    }
    
    public virtual SingleOrder ShortExit(Instrument instrument, double price, string text)
    {
      if (!this.Strategy.IsInstrumentActive(instrument))
        return (SingleOrder) null;
      Signal signal = new Signal(Clock.Now, ComponentType.CrossExit, SignalType.Market, SignalSide.BuyCover, instrumen
public class World : MonoBehaviour 
	public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
	public GameObject chunkPrefab;
	void Start()
	{
		
		for (int x = -2; x < 2; x++)
		{
			for (int y = -1; y < 1; y++)
			{
				for (int z = -1; z < 1; z++)
				{
					CreateChunk(x * 16, y* 16, z * 16);
				}
			}
		}
	}
	public void CreateChunk(int x, int y, int z)
	{
		WorldPos worldPos = new WorldPos(x, y , z);
		
		GameObject newChunkObject = Instantiate(chunkPrefab, new Vector3(x, y, z),Quaternion.Euler(Vector3.zero)) as GameObject;
		
		Chunk newChunk = newChunkObject.GetComponent<Chunk>();
		
		newChunk.pos = worldPos;
		newChunk.world = this;
		
		chunks.Add(worldPos, newChunk);
	}
	public Chunk GetChunk(int x, int y, int z)
	{
		WorldPos pos = new WorldPos();
		float multiple = Chunk.chunkSize;
		pos.x = Mathf.FloorToInt(x / multiple ) * Chunk.chunkSize;
		pos.y = Mathf.FloorToInt(y / multiple ) * Chunk.chunkSize;
		pos.z = Mathf.FloorToInt(z / multiple ) * Chun

		
		Chunk containerChunk = null;
		
		chunks.TryGetValue(pos, out containerChunk);
		for (int xi = 0; xi < 16; xi++)
		{
			for (int yi = 0; yi < 16; yi++)
			{
				for (int zi = 0; zi < 16; zi++)
				{
					if (yi <= 7)
					{
						SetBlock(x+xi, y+yi, z+zi, new BlockGrass());
					}
					else
					{
						SetBlock(x + xi, y + yi, z + zi, new BlockAir());
					}
				}
			}
		}
		return containerChunk;
	}
	public BlockScript GetBlock(int x, int y, int z)
	{
		Chunk containerChunk = GetChunk(x, y, z);
		
		if (containerChunk != null)
		{
			BlockScript block = containerChunk.GetBlock(
				x - containerChunk.pos.x,
				y -containerChunk.pos.y, 
				z - containerChunk.pos.z);
			
			return block;
		}
		else
		{
			return new BlockAir();
		}
		
	}
	public void SetBlock(int x, int y, int z, BlockScript block)
	{
		Chunk chunk = GetChunk(x, y, z);
		
		if (chunk != null)
		{
			chunk.SetBlock(x - chunk.pos.x, y - chunk.pos.y, z - chunk.pos.z, block);
			chunk.update = true;
		}
	}
	public
namespace com.jonthysell.Chordious.Core
    public class InstrumentSet : IReadOnly, IEnumerable<Instrument>
    {
        public bool ReadOnly { get; private set; }
        public string Level
        {
            get
            {
                return _level;
            }
            set
            {
                if (StringUtils.IsNullOrWhiteSpace(value))
                {
                    throw new ArgumentNullException();
                }
                if (ReadOnly)
                {
                    throw new ObjectIsReadOnlyException(this);
                }
                _level = value;
            }
        }
        private string _level;
        public InstrumentSet Parent
        {
            get
            {
                return _parent;
            }
            set
            {
                if (ReadOnly)
                {
                    throw new ObjectIsReadOnlyException(this);
                }
                _parent = value;
            

        }
        private InstrumentSet _parent;
        private List<Instrument> _instruments;
        internal InstrumentSet(string level)
        {
            Level = level;
            ReadOnly = false;
            _instruments = new List<Instrument>();
        }
        internal InstrumentSet(InstrumentSet parent, string level) : this(level)
        {
            if (null == parent)
            {
                throw new ArgumentNullException("parent");
            }
            Parent = parent;
        }
        public void MarkAsReadOnly()
        {
            ReadOnly = true;
            foreach (Instrument i in _instruments)
            {
                i.MarkAsReadOnly();
            }
        }
        public IEnumerator<Instrument> GetEnumerator()
        {
            foreach (Instrument instrument in _instruments)
            {
                yield return instrument;
            }
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return

        }
        public Instrument Get(string name)
        {
            if (StringUtils.IsNullOrWhiteSpace(name))
            {
                throw new ArgumentNullException("name");
            }
            Instrument instrument;
            if (TryGet(name, out instrument))
            {
                return instrument;
            }
            throw new InstrumentNotFoundException(this, name);
        }
        public bool TryGet(string name, out Instrument instrument)
        {
            if (StringUtils.IsNullOrWhiteSpace(name))
            {
                throw new ArgumentNullException("name");
            }
            foreach (Instrument i in _instruments)
            {
                if (i.Name == name)
                {
                    instrument = i;
                    return true;
                }
            }
            instrument = null;
            return false;
        }
        
        public Instrument Add(string name, int numStrings)
        {
namespace BusinessLogic
  public  class DataManager
    {
        private IUserRepository usersRepository;
        private IFriendsRepository friendsRepository;
        private IFriendRequestsRepository friendRequestsRepository;
        private IMessagesRepository messagesRepository;
        private IPictureRepository pictureRepository;
        private IMusicRepository musicRepository;
      
        private PrimaryMembershipProvider provider;
        public DataManager(IUserRepository usersRepository, IFriendsRepository friendsRepository, IFriendRequestsRepository friendRequestsRepository, 
            IMessagesRepository messagesRepository, IPictureRepository pictureRepository,IMusicRepository musicRepository,IPostRepository postRepository,
            ICommentRepository commentReposiyory, PrimaryMembershipProvider provider)
        {
            this.usersRepository = usersRepository;
            this.friendsRepository = friendsRepository;
            this.friendRequestsRepository =
namespace Microsoft.AspNetCore.Razor.CodeGenerators.Visitors
    public class CodeVisitor<TWriter> : ChunkVisitor<TWriter>
        where TWriter : CodeWriter
    {
        public CodeVisitor(TWriter writer, CodeGeneratorContext context)
            : base(writer, context)
        {
            if (writer == null)
            {
                throw new ArgumentNullException(nameof(writer));
            }
            if (context == null)
            {
                throw new ArgumentNullException(nameof(context));
            }
        }
        protected override void Visit(LiteralChunk chunk)
        {
        }
        protected override void Visit(ParentLiteralChunk chunk)
        {
        }
        protected override void Visit(ExpressionBlockChunk chunk)
        {
        }
        protected override void Visit(ExpressionChunk chunk)
        {
        }
        protected override void Visit(StatementChunk chunk)
        {
        }
        protected override void Visit(UsingChu

        {
        }
        protected override void Visit(ParentChunk chunk)
        {
        }
        protected override void Visit(DynamicCodeAttributeChunk chunk)
        {
        }
        protected override void Visit(TagHelperChunk chunk)
        {
        }
        protected override void Visit(TagHelperPrefixDirectiveChunk chunk)
        {
        }
        protected override void Visit(AddTagHelperChunk chunk)
        {
        }
        protected override void Visit(RemoveTagHelperChunk chunk)
        {
        }
        protected override void Visit(LiteralCodeAttributeChunk chunk)
        {
        }
        protected override void Visit(CodeAttributeChunk chunk)
        {
        }
        protected override void Visit(SectionChunk chunk)
        {
        }
        protected override void Visit(TypeMemberChunk chunk)
        {
        }
        protected override void Visit(SetBaseTypeChunk chunk)
        {
        }
        protected override void Visit(TemplateChunk
namespace EventManagementSystem.Data.UnitOfWork.Interfaces
    public interface IEventDataUnit : IDataUnitOfWork
    {
        IEventsRepository EventsRepository { get; }
        ICorresponcencesRepository CorresponcencesRepository { get; }
        IEventUpdatesRepository EventUpdatesRepository { get; }
        IRoomsRepository RoomsRepository { get; }
        IGolfsRepository GolfsRepository { get; }
        IEventRoomsRepository EventRoomsRepository { get; }
        IEventGolfsRepository EventGolfsRepository { get; }
        IEventCateringsRepository EventCateringsRepository { get; }
        IContactTitlesRepository ContactTitlesRepository { get; }
        IContactsRepository ContactsRepository { get; }
        IEventStatusesRepository EventStatusesRepository { get; }
        IEventTypesRepository EventTypesRepository { get; }
        IEventContactsRepository EventContactsRepository { get; }
        IEventChargesRepository EventChargesRepository { get; }
        IEventBookedProductsR

        IEventInvoicesRepository EventInvoicesRepository { get; }
        IEventNotesRepository EventNotesRepository { get; }
        IEventPaymentsRepository EventPaymentsRepository { get; }
        IReportsRepository ReportsRepository { get; }
        IProductsRepository ProductsRepository { get; }
        IInvoicesRepository InvoicesRepository { get; }
        IMailTemplatesRepository MailTemplatesRepository { get; }
        ICorresponcenceTypesRepository CorresponcenceTypesRepository { get; }
        ICorrespondenceDocumentsRepository CorrespondenceDocumentsRepository { get; }
        ICCContactsCorrespondenceRepository CCContactsCorrespondenceRepository { get; }
        IDocumentsRepository DocumentsRepository { get; }
        IGolfHolesRepository GolfHolesRepository { get; }
        IUsersRepository UsersRepository { get; }
        IEventNoteTypesRepository EventNoteTypesRepository { get; }
        IPaymentMethodsRepository PaymentMethodsRepository { get; }
        ICalendarNote
namespace com.espertech.esper.multithread.dispatchmodel
    public class UpdateDispatchViewOrderEnforcingModel : UpdateDispatchViewModel
    {
        private DispatchService dispatchService;
        private DispatchListener dispatchListener;
    
        private DispatchFuture currentFuture;
        internal class ThreadLocalData
        {
            public bool IsDispatchWaiting;
            public LinkedList<int[]> Received;
            internal ThreadLocalData()
            {
                IsDispatchWaiting = false;
                Received = new LinkedList<int[]>();
            }
        }
        private readonly IThreadLocal<ThreadLocalData> threadLocalData =
            ThreadLocalManager.Create<ThreadLocalData>(() => new ThreadLocalData());
    
        private ThreadLocalData LocalData
        {
            get { return threadLocalData.GetOrCreate(); }
        }
    
        public UpdateDispatchViewOrderEnforcingModel(DispatchService dispatchService, DispatchListener disp

        {
            this.dispatchService = dispatchService;
            this.dispatchListener = dispatchListener;
        }
    
        public void Add(int[] payload)
        {
            var local = LocalData;
            local.Received.AddLast(payload);
            if (!local.IsDispatchWaiting)
            {
                DispatchFuture nextFuture;
                lock(this)
                {
                    nextFuture = new DispatchFuture(this, currentFuture);
                    currentFuture.Later = nextFuture;
                    currentFuture = nextFuture;
                }
                dispatchService.AddExternal(nextFuture);
                local.IsDispatchWaiting = true;
            }
        }
    
        public void Execute()
        {
            var local = LocalData;
            LinkedList<int[]> payloads = local.Received;
            int[][] result = new int[payloads.Count][];
    
            int count = 0;
            foreach (int[] entry in payloads)
 
namespace AccidentalFish.Commanding
    public class CommandDispatchException<TCommand> : Exception where TCommand : class
    {
        public CommandDispatchException(TCommand command, ICommandDispatchContext commandDispatchContext, Type dispatcherType)
        {
            Command = command;
            CommandDispatchContext = commandDispatchContext;
            DispatcherType = dispatcherType;
        }
        
        public CommandDispatchException(TCommand command, ICommandDispatchContext commandDispatchContext, Type dispatcherType, string message) : base(message)
        {
            Command = command;
            CommandDispatchContext = commandDispatchContext;
            DispatcherType = dispatcherType;
        }
        public CommandDispatchException(TCommand command, ICommandDispatchContext commandDispatchContext, Type dispatcherType, string message, Exception innerException) : base(message, innerException)
        {
            Command = command;
            CommandD
namespace Tester
    public class Applications
    {
        private List<Process> process = new List<Process>();
        
        public Applications(int processID)
        {
            IntPtr handle = Kernel32Functions.OpenProcess(0x400 | 0x010, false, Convert.ToUInt32(processID));
            if(handle != IntPtr.Zero && handle != null)
            {
                this.process.Add(new Process(handle)); 
            }
            else
            {
                throw new ProcessNotFoundException(ErrorMessages.CouldNotFindPid); 
            }
        }
        public Applications(string processName)
        {
            System.Diagnostics.Process[] proc = System.Diagnostics.Process.GetProcessesByName(processName);
            if (proc == null || proc.Length == 0)
                throw new ProcessNotFoundException(ErrorMessages.CouldNotFindProcessName);
            else
            {
                for(int x = 0; x < proc.Length; x++)
                {
                    this.p

                }
            }
        }
        public Applications(string processName, string description)
        {
            System.Diagnostics.Process[] proc = System.Diagnostics.Process.GetProcessesByName(processName);
            if (proc == null || proc.Length == 0)
                throw new ProcessNotFoundException(ErrorMessages.CouldNotFindProcessName);
            else
            {
                for (int x = 0; x < proc.Length; x++)
                {
                    Process tempProcess = new Process(proc[x]); 
                    if(tempProcess.processDescription.Contains(description))
                    {
                        this.process.Add(new Process(proc[x]));
                    }
                }
            }
        }
        #region get/set 
        public List<Process> VisibleProcesses
        {
            get
            {
                if(process.Count > 0)
                {
                    List<Process> lstProcess = new List<Process>(); 
namespace ESB.Core.Monitor
    public class ESBTraceContext
    {
        public String TraceID { get; private set; }
        public String ParentInvokeID { get; private set; }
        public Int32 InvokeLevel { get; private set; }
        public Int32 InvokeOrder { get; private set; }
        public String InvokeID { 
            get {
                if (InvokeLevel == 0 && String.IsNullOrEmpty(ParentInvokeID))
                {
                    return "00";
                }
                else
                {
                    return String.Format("{0}.{1}{2}", ParentInvokeID, InvokeLevel, InvokeOrder);
                }
            } 
        }
        public ESBTraceContext(String traceID, Int32 invokeLevel, String parentInvokeID)
        {
            TraceID = traceID;
            InvokeLevel = invokeLevel;
            InvokeOrder = 0;
            ParentInvokeID = parentInvokeID;
        }
        public override string ToString()
        {
            return String.For
namespace Core.TransactionServer.Agent.BLL.InstrumentBusiness
    internal sealed class TradingInstrument
    {
        private static readonly ILog Logger = LogManager.GetLogger(typeof(TradingInstrument));
        internal TradingInstrument(Settings.Instrument instrument)
        {
            this.SettingInstrument = instrument;
            this.TradingStatus = new TradingStatus(instrument.Id);
        }
        internal Guid Id
        {
            get
            {
                return this.SettingInstrument.Id;
            }
        }
        internal DateTime TradeDay { get; set; }
        internal Settings.Instrument SettingInstrument { get; private set; }
        internal Protocal.TradingInstrument.TradingSession CurrentTradingSession
        {
            get
            {
                return ServerFacade.Default.GatewayProxy.GetCurrentTradingSession(this.Id);
            }
        }
        internal TradingStatus TradingStatus { get; private set; }
        internal Date

        {
            get { return this.SettingInstrument.DayOpenTime; }
        }
        internal DateTime DayCloseTime
        {
            get { return this.SettingInstrument.DayCloseTime; }
        }
        internal DateTime ValueDate
        {
            get { return this.SettingInstrument.ValueDate; }
        }
        internal DateTime NextDayOpenTime
        {
            get { return this.SettingInstrument.NextDayOpenTime; }
        }
        internal bool IsActive
        {
            get
            {
                return this.SettingInstrument.IsActive;
            }
        }
        internal bool IsPriceEnabled
        {
            get
            {
                return this.SettingInstrument.IsPriceEnabled;
            }
        }
        internal bool IsPlaceAllowed
        {
            get
            {
                return this.TradingStatus.IsPlaceAllowed;
            }
        }
        internal bool CanPlacePendingOrderAtAnyTime
        {
            

            {
                return this.SettingInstrument.CanPlacePendingOrderAtAnyTime;
            }
        }
        internal bool MustUseNightNecessaryWhenTrading
        {
            get
            {
                return this.SettingInstrument.MustUseNightNecessaryWhenTrading;
            }
        }
        internal bool ShouldUseDayNecessary
        {
            get
            {
#if RESET
                return !this.MustUseNightNecessaryWhenTrading;
#else
                if (this.TradingStatus.Status.IsTradeDayClose())
                {
                    return false;
                }
                else
                {
                    if (this.IsTrading)
                    {
                        return !this.MustUseNightNecessaryWhenTrading;
                    }
                    else
                    {
                        return !Settings.Setting.Default.SystemParameter.UseNightNecessaryWhenBreak;
                    }
                }
#endi
namespace Aroochi.Services.Maker.Helpers
    public static class ProcessHelper
    {
        public static Process Execute(string command, bool waitForExit = true)
        {
            Process process = new Process();
            ProcessStartInfo processInfo = new ProcessStartInfo("cmd", $"/c {command}");
            processInfo.RedirectStandardOutput = true;
            processInfo.RedirectStandardError = true;
            processInfo.RedirectStandardInput = true;
            processInfo.UseShellExecute = false;
            processInfo.CreateNoWindow = true;
            process.StartInfo = processInfo;
            process.Start();
            if (waitForExit)
                process.WaitForExit();
            return process;
        }
        public static void FillStepInfo(MakeStep step, Process process)
        {
            string processLog = process.StandardOutput.ReadToEnd();
            {
                step.Status = false;
                processLog = process.StandardError.R
﻿namespace SDK.Lib
    /**
     * @brief 全局委托，只要初始化后，就可以注册和使用这些委托，不用等到哪一个资源创建完成
     */
    public class GlobalDelegate
    {
        public AddOnceEventDispatch mMainChildMassChangedDispatch;
        public AddOnceEventDispatch mCameraOrientChangedDispatch;
        public AddOnceEventDispatch mMainChildChangedDispatch;
        public AddOnceEventDispatch mMainChildNumChangedDispatch;
        public GlobalDelegate()
        {
            this.mMainChildMassChangedDispatch = new AddOnceEventDispatch();
            this.mCameraOrientChangedDispatch = new AddOnceEventDispatch();
            this.mMainOrientChangedDispatch = new AddOnceEventDispatch();
            this.mMainPosChangedDispatch = new AddOnceEventDispatch();
            this.mMainOrientStopChangedDispatch = new AddOnceEventDispatch();
            this.mMainPosStopChangedDispatch = new AddOnceEventDispatch();
            this.mMainChildChangedDispatch = new AddOnceEventDispatch();
            this.mMainChildNumChangedDispatch 
public class TerrainGen {
	float stoneBaseHeight = -24;
	float stoneBaseNoise = 0.05f;
	float stoneBaseNoiseHeight = 4;
	float stoneMountainHeight = 48;
	float stoneMountainFrequency = 0.008f;
	float stoneMinHeight = -12;
	float dirtBaseHeight = 1;
	float dirtNoise = 0.04f;
	float dirtNoiseHeight = 3;
	public Chunk ChunkGen(Chunk chunk)
	{
		for (int x = chunk.pos.x; x < chunk.pos.x + Chunk.chunkSize; x++)
		{
			for (int z = chunk.pos.z; z < chunk.pos.z + Chunk.chunkSize; z++)
			{
				chunk = ChunkColumnGen(chunk, x, z);
			}
		}
		return chunk;
	}
	public Chunk ChunkColumnGen(Chunk chunk, int x, int z)
	{
		int stoneHeight = Mathf.FloorToInt(stoneBaseHeight);
		stoneHeight += GetNoise(x, 0, z, stoneMountainFrequency, Mathf.FloorToInt(stoneMountainHeight));
		
		if (stoneHeight < stoneMinHeight)
			stoneHeight = Mathf.FloorToInt(stoneMinHeight);
		
		stoneHeight += GetNoise(x, 0, z, stoneBaseNoise, Mathf.FloorToInt(stoneBaseNoiseHeight));
		
		int dirtHeight = stoneHeight + Mathf.Flo
public class TerrainGen
    float stoneBaseHeight = -24;
    float stoneBaseNoise = 0.05f;
    float stoneBaseNoiseHeight = 4;
    float stoneMountainHeight = 48;
    float stoneMountainFrequency = 0.008f;
    float stoneMinHeight = -12;
    float dirtBaseHeight = 1;
    float dirtNoise = 0.04f;
    float dirtNoiseHeight = 3;
    public Chunk ChunkGen(Chunk chunk)
    {
        for (int x = chunk.pos.x; x < chunk.pos.x + Chunk.chunkSize; x++)
        {
            for (int z = chunk.pos.z; z < chunk.pos.z + Chunk.chunkSize; z++)
            {
                chunk = ChunkColumnGen(chunk, x, z);
            }
        }
        return chunk;
    }
    public Chunk ChunkColumnGen(Chunk chunk, int x, int z)
    {
        int stoneHeight = Mathf.FloorToInt(stoneBaseHeight);
        stoneHeight += GetNoise(x, 0, z, stoneMountainFrequency, Mathf.FloorToInt(stoneMountainHeight));
        if (stoneHeight < stoneMinHeight)
            stoneHeight = Mathf.FloorToInt(stoneMinHeight);
        stone
namespace WebApplication1.Models
	public static class RepositoryHelper
	{
		public static IUnitOfWork GetUnitOfWork()
		{
			return new EFUnitOfWork();
		}		
		
		public static ClientRepository GetClientRepository()
		{
			var repository = new ClientRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static ClientRepository GetClientRepository(IUnitOfWork unitOfWork)
		{
			var repository = new ClientRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OccupationRepository GetOccupationRepository()
		{
			var repository = new OccupationRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OccupationRepository GetOccupationRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OccupationRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OrderRepository GetOrderRepository()
		{
			var repository = new Orde

			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OrderRepository GetOrderRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OrderRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OrderLineRepository GetOrderLineRepository()
		{
			var repository = new OrderLineRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OrderLineRepository GetOrderLineRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OrderLineRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static ProductRepository GetProductRepository()
		{
			var repository = new ProductRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static ProductRepository GetProductRepository(IUnitOfWork unitOfWork)
		{
			var repository = new ProductRepository();
			repository.UnitOfWork = unitOfWork;
			return repo
namespace Voxelist.Mapping
    public class ChunkCache
    {
        private Map Map { get; set; }
        private int EntitySpawnRadius { get { return Map.EntitySpawnRadius; } }
        private Chunk tempChunk;
        public ChunkCache(Map map, int cacheRadius)
        {
            this.Map = map;
            this.Radius = cacheRadius;
            this.savedChunkData = new Dictionary<ChunkCoordinate, CacheData>();
            tempChunk = new Chunk(map);
            LoadStartingData();
        }
        public void Dispose()
        {
            lock (CacheLock)
            {
                loaderShouldKeepRunning = false;
            }
        }
        public void Update(GameTime gametime)
        {
        }
        #region Geometry Recalculation
        private void RecalculateNeighborGeometry(int loadChunkX, int loadChunkZ)
        {
            Chunk left = null;
            Chunk right = null;
            Chunk forward = null;
            Chunk backward = null;
            l

            {
                if (IsReady(loadChunkX - 1, loadChunkZ))
                    left = this[loadChunkX - 1, loadChunkZ].Chunk;
                if (IsReady(loadChunkX + 1, loadChunkZ))
                    right = this[loadChunkX + 1, loadChunkZ].Chunk;
                if (IsReady(loadChunkX, loadChunkZ - 1))
                    forward = this[loadChunkX, loadChunkZ - 1].Chunk;
                if (IsReady(loadChunkX, loadChunkZ + 1))
                    backward = this[loadChunkX, loadChunkZ + 1].Chunk;
            }
            if (left != null)
                left.RecalculateVisualGeometry();
            if (right != null)
                right.RecalculateVisualGeometry();
            if (forward != null)
                forward.RecalculateVisualGeometry();
            if (backward != null)
                backward.RecalculateVisualGeometry();
        }
        #endregion
        private int IntendedCenterX { get; set; }
        private int IntendedCenterZ { get; set; }
  

        {
            lock (CacheLock)
            {
                int newCenterX = IntendedCenterX + dx;
                int newCenterZ = IntendedCenterZ + dz;
                DespawnFarawayChunks(newCenterX, newCenterZ);
                IntendedCenterX = newCenterX;
                IntendedCenterZ = newCenterZ;
            }
        }
        private void DespawnFarawayChunks(int newCenterX, int newCenterZ)
        {
            for (int x = IntendedCenterX - EntitySpawnRadius; x <= IntendedCenterX + EntitySpawnRadius; x++)
            {
                for (int z = IntendedCenterZ - EntitySpawnRadius; z <= IntendedCenterZ + EntitySpawnRadius; z++)
                {
                    if (IsReady(x, z))
                    {
                        int dist = Math.Abs(x - newCenterX) + Math.Abs(z - newCenterZ);
                        if (dist > EntitySpawnRadius)
                            this[x, z].Despawn();
                    }
                }
            }
        }
   
namespace PixelShare.Core
    public static class ChunkUtils
    {
        #region Packing Methods
        public static void Pack(BufferChunk aChunk, int x, int y)
        {
            aChunk += x;
            aChunk += y;
        }
        public static void Pack(BufferChunk aChunk, int left, int top, int right, int bottom)
        {
            aChunk += left;
            aChunk += top;
            aChunk += right;
            aChunk += bottom;
        }
        public static void Pack(BufferChunk chunk, Point aPoint)
        {
            chunk += aPoint.X;
            chunk += aPoint.Y;
        }
        public static void Pack(BufferChunk chunk, Point[] points)
        {
            chunk += points.Length;
            for (int i = 0; i < points.Length; i++)
            {
                Pack(chunk, points[i].X, points[i].Y);
            }
        }
        public static void Pack(BufferChunk chunk, Guid uniqueID)
        {
            chunk += uniqueID.ToByteArray();
        }
 

        {
            chunk += aTrans.eDx;
            chunk += aTrans.eDy;
            chunk += aTrans.eM11;
            chunk += aTrans.eM12;
            chunk += aTrans.eM21;
            chunk += aTrans.eM22;
        }
        public static void Pack(BufferChunk chunk, TRIVERTEX[] vertices)
        {
            int nVertices = vertices.Length;
            chunk += nVertices;
            for (int i = 0; i < nVertices; i++)
            {
                chunk += vertices[i].x;
                chunk += vertices[i].y;
                chunk += vertices[i].Alpha;
                chunk += vertices[i].Blue;
                chunk += vertices[i].Green;
                chunk += vertices[i].Red;
            }
        }
        public static void Pack(BufferChunk chunk, GRADIENT_RECT[] gRect)
        {
            int nRects = gRect.Length;
            chunk += nRects;
            for (int i = 0; i < nRects; i++)
            {
                chunk += gRect[i].UpperLeft;
                chunk 

            }
        }
        public static void Pack(BufferChunk chunk, GDIBrush aBrush)
        {
            chunk += GDI32.EMR_CREATEBRUSHINDIRECT;
            chunk += (int)aBrush.Style;
            chunk += (int)aBrush.Hatching;
            chunk += aBrush.Color;
            Pack(chunk, aBrush.UniqueID);
        }
        public static void Pack(BufferChunk chunk, GDIPen aPen)
        {
            chunk += GDI32.EMR_CREATEPEN;
            chunk += (int)aPen.Style;
            chunk += 1;
            chunk += aPen.Color;
            Pack(chunk, aPen.UniqueID);
        }
        public static void Pack(BufferChunk chunk, GDIFont aFont)
        {
            chunk += GDI32.EMR_EXTCREATEFONTINDIRECTW;
            chunk += aFont.FaceName.Length;
            chunk += aFont.FaceName;
            chunk += (int)aFont.Height;
            Pack(chunk, aFont.UniqueID);
        }
        #endregion
        #region Unpacking routines
        public static GDIPen UnpackGPen(BufferChunk chunk
namespace Monitor_Process
    class MonitorProcess
    {
        private DateTime _processExitCode;
        private Process someNewProcess;
        private Process currentProcess;
        List<int> processBuffer = new List<int>();
        public MonitorProcess()
        {
            this.someData = "hello";
        }
        public MonitorProcess(int _totalNumberOfProcess, int _processToBeActive, int _logAfterProcess)
        {
            this._logAfterProcess = _logAfterProcess;
            this._processToBeActive = _processToBeActive;
            this._totalNumberOfProcess = _totalNumberOfProcess;
            this.someData = "hello";
            this._currentActiveProcess = 0;
            this._activeProcesscount = 0;
        }
        public void startProcess()
        {
            for (int i = 1; i <= this._processToBeActive; i++)
            {
                this.someNewProcess = new Process();
                someNewProcess.StartInfo.FileName = "iexplore.exe";
               

                someNewProcess.EnableRaisingEvents = true;
                someNewProcess.Exited += (sender, name) => myProcess_Exited(someNewProcess, someNewProcess.Id);
                someNewProcess.Start();
                this._currentActiveProcess++;
                this._activeProcesscount++;
                processBuffer.Add(someNewProcess.Id);
            }
        }
        public void afterStart()
        {
                this.someNewProcess = new Process();
               
                someNewProcess.StartInfo.FileName = "iexplore.exe";
                string curDir = Directory.GetCurrentDirectory();
                someNewProcess.EnableRaisingEvents = true;
                someNewProcess.Exited += (sender, name) => myProcess_Exited(someNewProcess, someNewProcess.Id);
                someNewProcess.Start();
                this._currentActiveProcess++;
                this._activeProcesscount++;
                processBuffer.Add(someNewProcess.Id);
        }
        pr
namespace mtm.Tourism.Repository
    public class IToursRepository
    {
        private CategoryRepository _CategoryRepository;
        public CategoryRepository category
        {
            get
            {
                if (_CategoryRepository == null)
                    _CategoryRepository = new CategoryRepository();
                return _CategoryRepository;
            }
        }
        private ToursRepository _ToursRepository;
        public ToursRepository tours
        {
            get
            {
                if (_ToursRepository == null)
                    _ToursRepository = new ToursRepository();
                return _ToursRepository;
            }
        }
        private VariantyRepository _VariantyRepository;
        public VariantyRepository variants
        {
            get
            {
                if (_VariantyRepository == null)
                    _VariantyRepository = new VariantyRepository();
                return _VariantyRepository;
   
namespace BusinessLogic
    public class DataManager
    {
        private ICityRepository cityRepository;
        private ICountryRepository countryRepository;
        private IFriendRequestRepository friendRequestRepository;
        private IGroupNewseRepository groupNewseRepository;
        private IGroupProfileRepository groupProfileRepository;
        private IGroupRepository groupRepository;
        private IGroupRequestRepository groupRequestRepository;
        private IGroupTypeRepository groupTypeRepository;
        private IMemberRoleRepository memberRoleRepository;
        private IMessageRepository messagesRepository;
        private IRegionRepository regionRepository;
        private IApplicationUserRepository userRepository;
        private IUserProfileRepository userProfileRepository;
        private IWallOfUserRepository wallOfUserRepository;
        public DataManager(
            ICityRepository cityRepository,
            ICountryRepository countryRepository,
       

            IGroupNewseRepository groupNewseRepository,
            IGroupProfileRepository groupProfileRepository,
            IGroupRepository groupRepository,
            IGroupRequestRepository groupRequestRepository,
            IGroupTypeRepository groupTypeRepository,
            IMemberRoleRepository memberRoleRepository,
            IMessageRepository messageRepository,
            IRegionRepository regionRepository,
            IApplicationUserRepository userRepository,
            IUserProfileRepository userProfileRepository,
            IWallOfUserRepository wallOfUserRepository
            )
        {
            this.cityRepository = cityRepository;
            this.countryRepository = countryRepository;
            this.friendRequestRepository = friendRequestRepository;
            this.groupNewseRepository = groupNewseRepository;
            this.groupProfileRepository = groupProfileRepository;
            this.groupRepository = groupRepository;
            this.groupR

            this.groupTypeRepository = groupTypeRepository;
            this.memberRoleRepository = memberRoleRepository;
            this.messagesRepository = messageRepository;
            this.regionRepository = regionRepository;
            this.userRepository = userRepository;
            this.userProfileRepository = userProfileRepository;
            this.wallOfUserRepository = wallOfUserRepository;
        }
        public ICityRepository Cities { get { return cityRepository; } }
        public ICountryRepository Countries { get { return countryRepository; } }
        public IFriendRequestRepository FriendRequests { get { return friendRequestRepository; } }
        public IGroupNewseRepository GroupNewses { get { return groupNewseRepository; } }
        public IGroupProfileRepository GroupProfiles { get { return groupProfileRepository; } }
        public IGroupRepository Groups { get { return groupRepository; } }
        public IGroupRequestRepository GroupRequests { get { retu
namespace Frankfort.Threading.Internal
	public class ThreadDispatchAction<T> : DispatchAction
	{
		private bool executed = false;
		public object dispatchExecutionResult = null;
		public T dispatchExecutionResult2 = default(T);
		private CallBack dispatchCallClean;
		private CallBackArg<T> dispatchCallArg;
		private CallBackArgRturn<T> dispatchCallArgReturn;
		private CallBackReturn<T> dispatchCallReturn2;
		private CallBackReturn dispatchCallReturn;
		private T dispatchArgParam;
		private bool safeMode;
		public bool Executed
		{
			get
			{
				return this.executed;
			}
		}
		public void Init(CallBack dispatchCall, bool waitForExecution, bool safeMode)
		{
			this.safeMode = safeMode;
			this.dispatchCallClean = dispatchCall;
			this.ValidateExecutionOnInit(waitForExecution);
		}
		public void Init(CallBackArg<T> dispatchCall, T dispatchArgumentParameter, bool waitForExecution, bool safeMode)
		{
			this.safeMode = safeMode;
			this.dispatchCallArg = dispatchCall;
			this.dispatchAr

			this.ValidateExecutionOnInit(waitForExecution);
		}
		public void Init(CallBackArgRturn<T> dispatchCall, T dispatchArgumentParameter, bool safeMode)
		{
			this.safeMode = safeMode;
			this.dispatchCallArgReturn = dispatchCall;
			this.dispatchArgParam = dispatchArgumentParameter;
			this.ValidateExecutionOnInit(true);
		}
		public void Init(CallBackReturn dispatchCall, bool safeMode)
		{
			this.safeMode = safeMode;
			this.dispatchCallReturn = dispatchCall;
			this.ValidateExecutionOnInit(true);
		}
		public void Init(CallBackReturn<T> dispatchCall, bool safeMode)
		{
			this.safeMode = safeMode;
			this.dispatchCallReturn2 = dispatchCall;
			this.ValidateExecutionOnInit(true);
		}
		private void ValidateExecutionOnInit(bool waitForExecution)
		{
			if (waitForExecution)
			{
				bool flag = !MainThreadWatchdog.CheckIfMainThread();
				if (flag)
				{
					while (!this.executed && Loom.CheckUnityActive())
					{
						Thread.Sleep(5);
					}
				}
				else
				{
					this.Execute

				}
			}
		}
		public void ExecuteDispatch()
		{
			bool flag = this.safeMode;
			if (flag)
			{
				try
				{
					bool flag2 = this.dispatchCallClean != null;
					if (flag2)
					{
						this.dispatchCallClean();
					}
					else
					{
						bool flag3 = this.dispatchCallArg != null;
						if (flag3)
						{
							this.dispatchCallArg(this.dispatchArgParam);
						}
						else
						{
							bool flag4 = this.dispatchCallArgReturn != null;
							if (flag4)
							{
								this.dispatchExecutionResult = this.dispatchCallArgReturn(this.dispatchArgParam);
							}
							else
							{
								bool flag5 = this.dispatchCallReturn != null;
								if (flag5)
								{
									this.dispatchExecutionResult = this.dispatchCallReturn();
								}
								else
								{
									bool flag6 = this.dispatchCallReturn2 != null;
									if (flag6)
									{
										this.dispatchExecutionResult2 = this.dispatchCallReturn2();
									}
								}
							}
						}
					}
				}
				catch 
namespace VoxelEngine.Generation {
    public class WorldGeneratorFlat : WorldGeneratorBase {
        private FeatureTreeBasic tree;
        public WorldGeneratorFlat(World world, int seed) : base(world, seed) {
            this.tree = new FeatureTreeBasic();
        }
        public override Vector3 getSpawnPoint(World world) {
            return new Vector3(7.5f, 25, 7.5f);
        }
        public override void generateChunk(Chunk chunk) {
            for (int x = 0; x < Chunk.SIZE; x++) {
                for (int z = 0; z < Chunk.SIZE; z++) {
                    for (int y = 0; y < Chunk.SIZE; y++) {
                        chunk.setBlock(x, y, z, this.getBlockForHeight(y + chunk.worldPos.y));
                    }
                }
            }
        }
        public override ChunkLoaderBase getChunkLoader(EntityPlayer player) {
            return new ChunkLoaderInfinite(player.world, player);
        }
        public override void populateChunk(Chunk chunk) {
            if(ch
namespace Polygon.Connector
    [PublicAPI]
    public abstract class InstrumentConverter<T>
        where T : InstrumentData
    {
        #region Преобразование Symbol -> Instrument
        private readonly ConcurrentDictionary<string, Instrument> _instrumentBySymbol = new ConcurrentDictionary<string, Instrument>();
        [NotNull, ItemCanBeNull]
        public async Task<Instrument> ResolveSymbolAsync(
            IInstrumentConverterContext<T> context,
            string symbol,
            string dependentObjectDescription = null)
        {
            if (_instrumentBySymbol.TryGetValue(symbol, out var instrument))
            {
                return instrument;
            }
            instrument = await ResolveSymbolImplAsync(context, symbol, dependentObjectDescription);
            if (instrument == null)
            {
                return null;
            }
            _instrumentBySymbol.TryAdd(symbol, instrument);
            return instrument;
        }
        [Not

        protected abstract Task<Instrument> ResolveSymbolImplAsync(
            IInstrumentConverterContext<T> context,
            string symbol,
            string dependentObjectDescription);
        #endregion
        #region Преобразование Instrument -> Metadata
        private readonly ConcurrentDictionary<Instrument, T> _instrumentDataByInstrument = new ConcurrentDictionary<Instrument, T>();
        [NotNull, ItemCanBeNull]
        public async Task<T> ResolveInstrumentAsync(
            IInstrumentConverterContext<T> context,
            Instrument instrument,
            bool isTestVendorCodeRequired = false)
        {
            if (_instrumentDataByInstrument.TryGetValue(instrument, out var data))
            {
                return data;
            }
            data = await ResolveInstrumentImplAsync(context, instrument, isTestVendorCodeRequired);
            if (data == null)
            {
                return null;
            }
            if (isTestVendorCodeRequ
namespace PSoC.ManagementService.Data.Repositories
    public class UnitOfWork : IUnitOfWork
    {
        private IAccessPointRepository _accessPointRepository;
        private IAdminRepository _adminRepository;
        private IDistrictRepository _districtRepository;
        private ISchoolRepository _schoolRepository;
        public IAccessPointRepository AccessPointRepository
        {
            get { return _accessPointRepository ?? (_accessPointRepository = new AccessPointRepository()); }
        }
        public IAdminRepository AdminRepository
        {
            get { return _adminRepository ?? (_adminRepository = new AdminRepository()); }
        }
        public IDistrictRepository DistrictRepository
        {
            get { return _districtRepository ?? (_districtRepository = new DistrictRepository()); }
        }
        public ISchoolRepository SchoolRepository
        {
            get { return _schoolRepository ?? (_schoolRepository = new SchoolRepository()); }
 
public class ProceduralGeneratorOfChunk : MonoBehaviour
	public Transform playersTransform;
	public string levelName;
	public int currentChunkId = 0;
	public Chunk currentChunk;
	public int chunckInAdvanceOfPlayer = 4;
	public int chunckBackOfPlayer = 4;
	public ChunkBag chunkBag;
	public List<ChunkFlow> chunkFlowsToAdd = new List<ChunkFlow>();
	public List<ChunkFlow> chunkFlowsToRemove = new List<ChunkFlow>();
	public List<ChunkFlow> chunkFlows = new List<ChunkFlow>();
	public List<Chunk> chunksToAdd = new List<Chunk>();
	public List<Chunk> chunksToRemove = new List<Chunk>();
	public List<Chunk> chunks = new List<Chunk>();
	void Awake()
	{
		StartGeneration(GameData.seed, GameData.chunkId);
	}
	public void StartGeneration(int seed, int startingChunkId)
	{
		currentChunkId = startingChunkId;
		
		chunkBag = new ChunkBag(levelName);
		
		ChunkFlow chunkFlow = new ChunkFlow(this, null, chunkBag, seed, currentChunkId, Vector3.zero, 0);
		chunkFlows.Add(chunkFlow);
		Chunk newChunk = chunk

		Vector2 start = newChunk.checkPointLocation;
		playersTransform.position = new Vector3(start.x - 2, start.y - 1, 0);
		References.Runner.rigidbody2D.velocity = Vector2.zero;
		
		chunkFlow.lastChunk.playerPassedThrought = true;
	}
	public void setCurrentChunk(Chunk chunk)
	{
		if (chunk.chunkId > this.currentChunkId) {
			currentChunk = chunk;
			currentChunkId = chunk.chunkId;
		}
		
	}
	void Start()
	{
		
	}
	void Update()
	{
		foreach (var chunk in chunkFlows) {
			chunk.update();
		}
		
		foreach (var chunkFlowToRemove in chunkFlowsToRemove) {
			chunkFlows.Remove(chunkFlowToRemove);
		}
		chunkFlowsToRemove.Clear();
		
		foreach (var chunkFlowToAdd in chunkFlowsToAdd) {
			chunkFlows.Add(chunkFlowToAdd);
		}
		chunkFlowsToAdd.Clear();
		
		
		
		
		foreach (var chunk in chunks) {
			if (chunk.chunkId + chunckBackOfPlayer < currentChunkId) {
				chunksToRemove.Add(chunk);
			}
		}
		
		foreach (var chunkToRemove in chunksToRemove) {
			if (chunkToRemove != null & chunkToRemove.g
#region license
#endregion
namespace Cecil.FlowAnalysis.Utilities {
	public class InstructionDispatcher {
		public static void Dispatch (Instruction instruction, IInstructionVisitor visitor)
		{
			InstructionVisitorDelegate handler = (InstructionVisitorDelegate)_handlers[instruction.OpCode.Value];
			if (null == handler) throw new ArgumentException (Formatter.FormatInstruction (instruction), "instruction");
			handler (visitor, instruction);
		}
		delegate void InstructionVisitorDelegate (IInstructionVisitor visitor, Instruction instruction);
		static IDictionary _handlers = new Dictionary<short, InstructionVisitorDelegate> ();
		static InstructionDispatcher ()
		{
			Bind (new InstructionVisitorDelegate (DispatchNop), OpCodes.Nop);
			Bind (new InstructionVisitorDelegate (DispatchBreak), OpCodes.Break);
			Bind (new InstructionVisitorDelegate (DispatchLdarg_0), OpCodes.Ldarg_0);
			Bind (new InstructionVisitorDelegate (DispatchLdarg_1), OpCodes.Ldarg_1);
			Bind (new InstructionVisit

			Bind (new InstructionVisitorDelegate (DispatchLdarg_3), OpCodes.Ldarg_3);
			Bind (new InstructionVisitorDelegate (DispatchLdloc_0), OpCodes.Ldloc_0);
			Bind (new InstructionVisitorDelegate (DispatchLdloc_1), OpCodes.Ldloc_1);
			Bind (new InstructionVisitorDelegate (DispatchLdloc_2), OpCodes.Ldloc_2);
			Bind (new InstructionVisitorDelegate (DispatchLdloc_3), OpCodes.Ldloc_3);
			Bind (new InstructionVisitorDelegate (DispatchStloc_0), OpCodes.Stloc_0);
			Bind (new InstructionVisitorDelegate (DispatchStloc_1), OpCodes.Stloc_1);
			Bind (new InstructionVisitorDelegate (DispatchStloc_2), OpCodes.Stloc_2);
			Bind (new InstructionVisitorDelegate (DispatchStloc_3), OpCodes.Stloc_3);
			Bind (new InstructionVisitorDelegate (DispatchLdarg), OpCodes.Ldarg, OpCodes.Ldarg_S);
			Bind (new InstructionVisitorDelegate (DispatchLdarga), OpCodes.Ldarga, OpCodes.Ldarga_S);
			Bind (new InstructionVisitorDelegate (DispatchStarg), OpCodes.Starg, OpCodes.Starg_S);
			Bind (new InstructionVisitorDe

			Bind (new InstructionVisitorDelegate (DispatchLdloca), OpCodes.Ldloca, OpCodes.Ldloca_S);
			Bind (new InstructionVisitorDelegate (DispatchStloc), OpCodes.Stloc, OpCodes.Stloc_S);
			Bind (new InstructionVisitorDelegate (DispatchLdnull), OpCodes.Ldnull);
			Bind (new InstructionVisitorDelegate (DispatchLdc_I4_M1), OpCodes.Ldc_I4_M1);
			Bind (new InstructionVisitorDelegate (DispatchLdc_I4_0), OpCodes.Ldc_I4_0);
			Bind (new InstructionVisitorDelegate (DispatchLdc_I4_1), OpCodes.Ldc_I4_1);
			Bind (new InstructionVisitorDelegate (DispatchLdc_I4_2), OpCodes.Ldc_I4_2);
			Bind (new InstructionVisitorDelegate (DispatchLdc_I4_3), OpCodes.Ldc_I4_3);
			Bind (new InstructionVisitorDelegate (DispatchLdc_I4_4), OpCodes.Ldc_I4_4);
			Bind (new InstructionVisitorDelegate (DispatchLdc_I4_5), OpCodes.Ldc_I4_5);
			Bind (new InstructionVisitorDelegate (DispatchLdc_I4_6), OpCodes.Ldc_I4_6);
			Bind (new InstructionVisitorDelegate (DispatchLdc_I4_7), OpCodes.Ldc_I4_7);
			Bind (new InstructionVisi
namespace Tests.Unit.Entities
    [TestFixture]
    public class PaymentTokenInstrumentUnitTests
    {
        [Test]
        public void TestConstructIsInstanceOfEntity()
        {
            var CurrentPaymentInstrument = new PaymentTokenInstrument();
            Assert.IsInstanceOf<PaymentTokenInstrument>(CurrentPaymentInstrument);
        }
        [Test]
        public void TestPanDefaultIsEqualTo()
        {
            var CurrentPaymentInstrument = new PaymentTokenInstrument();
            Assert.IsNull(CurrentPaymentInstrument.Pan);
        }
        [Test]
        public void TestPanIsEqualTo()
        {
            var CurrentPaymentInstrument = new PaymentTokenInstrument();
            CurrentPaymentInstrument.Pan = "Pan1";
            Assert.AreEqual("Pan1", CurrentPaymentInstrument.Pan);
        }
        [Test]
        public void TestExpMonthDefaultIsEqualTo()
        {
            var CurrentPaymentInstrument = new PaymentTokenInstrument();
            Assert.AreEqual

        }
        [Test]
        public void TestExpMonthIsEqualTo()
        {
            var CurrentPaymentInstrument = new PaymentTokenInstrument();
            CurrentPaymentInstrument.ExpMonth = 3;
            Assert.AreEqual(3, CurrentPaymentInstrument.ExpMonth);
        }
        [Test]
        public void TestExpYearDefaultIsEqualTo()
        {
            var CurrentPaymentInstrument = new PaymentTokenInstrument();
            Assert.AreEqual(0, CurrentPaymentInstrument.ExpYear);
        }
        [Test]
        public void TestExpYearIsEqualTo()
        {
            var CurrentPaymentInstrument = new PaymentTokenInstrument();
            CurrentPaymentInstrument.ExpYear = 2018;
            Assert.AreEqual(2018, CurrentPaymentInstrument.ExpYear);
        }
        [Test]
        public void TestCvvDefaultIsEqualTo()
        {
            var CurrentPaymentInstrument = new PaymentTokenInstrument();
            Assert.IsNull(CurrentPaymentInstrument.Cvv);
        }
        [Te

        public void TestCvvIsEqualTo()
        {
            var CurrentPaymentInstrument = new PaymentTokenInstrument();
            CurrentPaymentInstrument.Cvv = "Cvv1";
            Assert.AreEqual("Cvv1", CurrentPaymentInstrument.Cvv);
        }
        [Test]
        public void TestRoutingNumberDefaultIsEqualTo()
        {
            var CurrentPaymentInstrument = new PaymentTokenInstrument();
            Assert.AreEqual(0, CurrentPaymentInstrument.RoutingNumber);
        }
        [Test]
        public void TestRoutingNumberIsEqualTo()
        {
            var CurrentPaymentInstrument = new PaymentTokenInstrument();
            CurrentPaymentInstrument.RoutingNumber = 2018;
            Assert.AreEqual(2018, CurrentPaymentInstrument.RoutingNumber);
        }
        [Test]
        public void TestAccountNumberDefaultIsEqualTo()
        {
            var CurrentPaymentInstrument = new PaymentTokenInstrument();
            Assert.AreEqual(0, CurrentPaymentInstrument.AccountNumbe
namespace ZephirCollection.Domain.Services
    public class PokemonCardListTestService : ServiceBase<PokemonCard>, IPokemonCardListTestService
    {
        private readonly IPokemonCardRepository _pokemonCardRepository;
        private readonly ICardRepository _cardRepository;
        private readonly IRarityRepository _rarityRepository;
        private readonly ISeriesRepository _seriesRepository;
        private readonly ICollectorRepository _collectorRepository;
        private readonly ICollectionRepository _collectionRepository;
        public PokemonCardListTestService(IPokemonCardRepository pokemonCardRepository, 
            ICardRepository cardRepository, 
            IRarityRepository rarityRepository,
            ISeriesRepository seriesRepository,
            ICollectorRepository collectorRepository,
            ICollectionRepository collectionRepository
            )
        {
            _pokemonCardRepository = pokemonCardRepository;
            _cardRepository = cardRe
namespace RicksGuitarsStart.Model
    public class InstrumentSpecification
    {
        private Dictionary<string, object> _properties;
        public IDictionary<string, object> Properties => _properties;
        public InstrumentSpecification(IDictionary<string, object> properties) 
            => _properties = properties is null ? new Dictionary<string, object>() : new Dictionary<string, object>(properties);
        public bool Matches(InstrumentSpecification other)
        {
            if (other == null)
                throw new ArgumentNullException(nameof(other));
            foreach (KeyValuePair<string, object> property in other.Properties)
            {
                if (!Properties.Contains(property))
                    return false;
            }
            return true;
        }
        public object GetProperty(string name) => Properties.ContainsKey(name) ? Properties[name] : null;
        public bool Equals(InstrumentSpecification other) => other != null && Propert

       
        public override bool Equals(object obj)
        {
            InstrumentSpecification other = obj as InstrumentSpecification;
            return Equals(other);
        }
        public override int GetHashCode() => Properties.GetHashCode();
        public static bool operator ==(InstrumentSpecification instrumentSpecification1, InstrumentSpecification instrumentSpecification2)
            => instrumentSpecification1 is null || instrumentSpecification2 is null ?
                Object.Equals(instrumentSpecification1, instrumentSpecification2)
                : instrumentSpecification1.Equals(instrumentSpecification2);
        public static bool operator !=(InstrumentSpecification instrumentSpecification1, InstrumentSpecification instrumentSpecification2)
            => !(instrumentSpecification1 is null || instrumentSpecification2 is null ?
                Object.Equals(instrumentSpecification1, instrumentSpecification2)
                : instrumentSpecification1.Equals
public class World : MonoBehaviour {
	public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
	public GameObject chunkPrefab;
    public string worldName = "world";
    
    public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(worldPos.x, worldPos.y, worldPos.z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        var terrainGen = new TerrainGen();
        newChunk = terrainGen.ChunkGen(newChunk);
    }
    private IEnumerator LoadChunk(Chunk chunk)
    {
        yield return new WaitForSeconds(0.1f);
    }
    /*
    void OnApplicationQuit()
    {
        for (int i = 0; i < chunks.Count; i++)
        {
   

        }
    }
    */
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / multiple) * Chunk.chunkSize;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Block GetBlock(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null)
        {
            Block block = containerChunk.GetBlock(
                x - containerChunk.pos.x,
                y - containerChunk.pos.y,
                z - containerChunk.pos.z);
            return block;
        }
        else
        {
            return new BlockAir();
        }
    }
    public void SetBlockItemDrop(int x, int y, int z, Block block, bool changed 

    {
        Chunk chunk = GetChunk(x, y, z);
        if (chunk != null)
        {
            chunk.SetBlockItemDrop(x - chunk.pos.x, y - chunk.pos.y, z - chunk.pos.z, block, changed);
            if (changed)
            {
                chunk.update = true;
            }
            UpdateIfEqual(x - chunk.pos.x, 0, new WorldPos(x - 1, y, z));
            UpdateIfEqual(x - chunk.pos.x, Chunk.chunkSize - 1, new WorldPos(x + 1, y, z));
            UpdateIfEqual(y - chunk.pos.y, 0, new WorldPos(x, y - 1, z));
            UpdateIfEqual(y - chunk.pos.y, Chunk.chunkSize - 1, new WorldPos(x, y + 1, z));
            UpdateIfEqual(z - chunk.pos.z, 0, new WorldPos(x, y, z - 1));
            UpdateIfEqual(z - chunk.pos.z, Chunk.chunkSize - 1, new WorldPos(x, y, z + 1));
        }
    }
    public void SetBlock(int x, int y, int z, Block block, bool changed = false)
    {
        Chunk chunk = GetChunk(x, y, z);
        if (chunk != null)
        {
            chunk.SetBlock(x - chunk.pos.x,
namespace B4F.TotalGiro.Instruments
    public class InstrumentExchangeCollection : TransientDomainCollection<IInstrumentExchange>, IInstrumentExchangeCollection
    {
        public InstrumentExchangeCollection()
            : base() { }
        public InstrumentExchangeCollection(ITradeableInstrument parent)
            : base()
        {
            Parent = parent;
        }
        internal InstrumentExchangeCollection(IExchange exchange, ITradeableInstrument parent)
            : base()
        {
            IInstrumentExchange ie = new InstrumentExchange(parent, exchange, Convert.ToByte(parent.DecimalPlaces));
            Add(ie);
            this.Parent = parent;
        }
        public ITradeableInstrument Parent { get; set; }
        public IInstrumentExchange GetItemByExchange(int exchangeID)
        {
            foreach (IInstrumentExchange instrumentExchange in this)
            {
                if (exchangeID == instrumentExchange.Exchange.Key)
                    retu
namespace VSMFacadePattern
    class VehicleFacade:IVehicleFacade
    {
        private readonly IEngineController _engineController;
        private readonly ITractionController _tractionController;
        private readonly ITransmissionController _transmissionController;
        private readonly ITachometerController _tachometerController;
        public VehicleFacade(IEngineController engineController
                             ,ITractionController tractionController
                             , ITransmissionController transmissionController
                              , ITachometerController tachometerController)
        {
            _engineController = engineController;
            _tachometerController = tachometerController;
            _tractionController = tractionController;
            _transmissionController = transmissionController;
        }
        public void Start()
        {
            _engineController.Start();
            _tractionController.Enable();
      
﻿namespace THOK.UDP.Dispatch
    public class DispatchClient : Client
    {
        private string dispatchServerName;
        private string name;
        public DispatchClient(string dispatchServerName, string hostIP, int port) : base(hostIP, port)
        {
            this.dispatchServerName = "Dispatcher";
            this.name = "Client";
            this.dispatchServerName = dispatchServerName;
            this.name = Dns.GetHostName();
        }
        public DispatchClient(string dispatchServerName, string hostIP, int port, string name) : base(hostIP, port)
        {
            this.dispatchServerName = "Dispatcher";
            this.name = "Client";
            this.dispatchServerName = dispatchServerName;
            this.name = name;
        }
        public void GetRegistedClient()
        {
            MessageGenerator generator = new MessageGenerator("CLIENTS", this.name);
            generator.AddReceiver(this.dispatchServerName);
            base.Send(generator.GetMe

        }
        public void Register(int port)
        {
            string ip = "127.0.0.1";
            IPHostEntry hostEntry = Dns.GetHostEntry(Dns.GetHostName());
            if (hostEntry.AddressList.Length != 0)
            {
                ip = hostEntry.AddressList[0].ToString();
            }
            this.Register(ip, port);
        }
        public void Register(string ip, int port)
        {
            MessageGenerator generator = new MessageGenerator("REG", this.name);
            generator.AddReceiver(this.dispatchServerName);
            generator.AddReceiver(this.name);
            generator.AddParameter("IP", ip);
            generator.AddParameter("Port", port.ToString());
            base.Send(generator.GetMessage());
        }
        public void Unregister()
        {
            MessageGenerator generator = new MessageGenerator("UNREG", this.name);
            generator.AddReceiver(this.dispatchServerName);
            base.Send(generator.GetMessage());
  
public class World : MonoBehaviour
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public GameObject chunkPrefab;
    public string worldName = "world";
    public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(chunkPrefab, new Vector3(worldPos.x, worldPos.y, worldPos.z), Quaternion.Euler(Vector3.zero)) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        var terrainGen = new TerrainGen();
        newChunk = terrainGen.ChunkGen(newChunk);
        newChunk.SetBlocksUnmodified();
        bool loaded = Serialization.Load(newChunk);
    }
    public void DestroyChunk(int x, int y, int z)
    {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
        {
            Serialization.S

            Object.Destroy(chunk.gameObject);
            chunks.Remove(new WorldPos(x, y, z));
        }
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / multiple) * Chunk.chunkSize;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Block GetBlock(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null)
        {
            Block block = containerChunk.GetBlock(x - containerChunk.pos.x, y - containerChunk.pos.y, z - containerChunk.pos.z);
            return block;
        }
        else
        {
            return new BlockAir();
        }
    }
    public void SetBlock(int x, int y, i
namespace sidebar
	public partial class RootViewController : UIViewController
	{
		private UIStoryboard _storyboard;
		public SidebarController SidebarController { get; private set; }
		public NavigationController NavController { get; private set; }
		public override UIStoryboard Storyboard
		{
			get
			{
				if (_storyboard == null)
					_storyboard = UIStoryboard.FromName("Main", null);
				return _storyboard;
			}
		}
		public RootViewController() : base(null, null)
		{
		}
		public override void ViewDidLoad()
		{
			base.ViewDidLoad();
			var introController = (IntroController)Storyboard.InstantiateViewController("IntroController");
			var menuController = (MenuController)Storyboard.InstantiateViewController("MenuController");
			NavController = new NavigationController();
			NavController.PushViewController(introController, false);
			SidebarController = new SidebarController(this, NavController, menuController);
			SidebarController.MenuWidth = 220;
			SidebarController.ReopenOn
namespace MyUpdate.Utils
    public class ProcessHelper
    {
        public static bool IsRunningProcess(string processName)
        {
            Process[] arrPro = GetProcess();
            foreach (Process p in arrPro)
            {
                if (p.ProcessName == processName) return true;
            }
            return false;
        }
        public static void CloseProcess(string processName)
        {
            Process process = Process.GetProcessesByName(processName).FirstOrDefault();
            process.CloseMainWindow();
            if (Process.GetProcessesByName(processName).Length != 0)
                process.Kill();
        }
        public static void StartProcess(string fileName)
        {
            Process process = new Process();
            process.StartInfo = new ProcessStartInfo(fileName);
            process.Start();
        }
        public static Process[] GetProcess(string ip = "")
        {
            if (string.IsNullOrEmpty(ip))
                
﻿namespace SDK.Lib
    /**
     * @brief 鼠标分发系统
     */
    public class MMouseDispatch
    {
        private AddOnceEventDispatch mOnMouseDownDispatch;
        private AddOnceEventDispatch mOnMouseUpDispatch;
        private AddOnceEventDispatch mOnMousePressDispatch;
        private AddOnceEventDispatch mOnMouseMoveDispatch;
        private AddOnceEventDispatch mOnMousePressMoveDispatch;
        private AddOnceEventDispatch mOnMouseCanceledDispatch;
        public MMouseDispatch()
        {
            this.mOnMouseDownDispatch = new AddOnceEventDispatch();
            this.mOnMouseUpDispatch = new AddOnceEventDispatch();
            this.mOnMousePressDispatch = new AddOnceEventDispatch();
            this.mOnMouseMoveDispatch = new AddOnceEventDispatch();
            this.mOnMousePressMoveDispatch = new AddOnceEventDispatch();
            this.mOnMouseCanceledDispatch = new AddOnceEventDispatch();
        }
        public void init()
        {
        }
        public void dispose()

        {
        }
        public void addMouseListener(EventId evtID, MAction<IDispatchObject> handle)
        {
            if (EventId.MOUSEDOWN_EVENT == evtID)
            {
                this.mOnMouseDownDispatch.addEventHandle(null, handle);
            }
            else if (EventId.MOUSEUP_EVENT == evtID)
            {
                this.mOnMouseUpDispatch.addEventHandle(null, handle);
            }
            else if (EventId.MOUSEPRESS_EVENT == evtID)
            {
                this.mOnMousePressDispatch.addEventHandle(null, handle);
            }
            else if (EventId.MOUSEMOVE_EVENT == evtID)
            {
                this.mOnMouseMoveDispatch.addEventHandle(null, handle);
            }
            else if (EventId.MOUSEPRESS_MOVE_EVENT == evtID)
            {
                this.mOnMousePressMoveDispatch.addEventHandle(null, handle);
            }
        }
        public void removeMouseListener(EventId evtID, MAction<IDispatchObject> handle)
       

            if (EventId.KEYUP_EVENT == evtID)
            {
                this.mOnMouseDownDispatch.removeEventHandle(null, handle);
            }
            else if (EventId.KEYDOWN_EVENT == evtID)
            {
                this.mOnMouseUpDispatch.removeEventHandle(null, handle);
            }
            else if (EventId.KEYPRESS_EVENT == evtID)
            {
                this.mOnMousePressDispatch.removeEventHandle(null, handle);
            }
            else if (EventId.MOUSEMOVE_EVENT == evtID)
            {
                this.mOnMouseMoveDispatch.removeEventHandle(null, handle);
            }
            else if (EventId.MOUSEPRESS_MOVE_EVENT == evtID)
            {
                this.mOnMousePressMoveDispatch.removeEventHandle(null, handle);
            }
        }
        public bool hasEventHandle()
        {
            if (this.mOnMouseDownDispatch.hasEventHandle())
            {
                return true;
            }
            if (this.mOnMouseUpDispat
namespace Repository.Base
    public class UnitOfWork : IUnitOfWork
    {
        private TShopDbContext dbContext;
        private ICategoryRepository _categoryRepository;
        private IMenuRepositorycs _menuRepository;
        private IMenuGroupRepository _menuGroupRepository;
        private IOrderRepository _orderRepository;
        private IOrderDetailsRepository _orderDetailsRepository;
        private IProductRepository _productRepository;
        private ISlidetRepository _slidetRepository;
        private IVenderRepository _venderRepository;
        
        public UnitOfWork()
        {
            dbContext = new TShopDbContext();
        }
        public TShopDbContext DbContext
        {
            get { return dbContext ?? (dbContext = new TShopDbContext()); }
        }
        public ICategoryRepository CategoryRepository
        {
            get { return _categoryRepository ?? (_categoryRepository= new CategoryRepository(DbContext)); }
        }
        public IMen

        {
            get { return _menuGroupRepository ?? (_menuGroupRepository = new MenuGroupRepository(DbContext)); }
        }
        public IOrderRepository OrderRepository
        {
            get { return _orderRepository ?? (_orderRepository = new OrderRepository(DbContext)); }
        }
        public IOrderDetailsRepository OrderDetailsRepository
        {
            get { return _orderDetailsRepository ?? (_orderDetailsRepository = new OrderDetailsRepository(DbContext)); }
        }
        public IProductRepository ProductRepository
        {
            get { return _productRepository ?? (_productRepository = new ProductRepository(DbContext)); }
        }
        public ISlidetRepository SlidetRepository
        {
            get { return _slidetRepository ?? (_slidetRepository = new SlidetRepository(DbContext)); }
        }
        public IVenderRepository VenderRepository
        {
            get { return _venderRepository ?? (_venderRepository = new VenderReposito

        }
        public IMenuRepositorycs MenuRepositorycs
        {
            get { return _menuRepository ?? (_menuRepository = new MenuRepository(DbContext)); }
        }
        public void Commit()
        {
            try
            {
                DbContext.SaveChanges();
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ResetRepositories();
            }
        }
        public void Dispose()
        {
            GC.SuppressFinalize(this);
        }
        private void Disposing(bool v)
        {
            throw new NotImplementedException();
        }
        private void ResetRepositories()
        {
            _categoryRepository = null;
            _menuRepository = null;
            _menuGroupRepository = null;
            _orderRepository = null;
            _orderDetailsRepository = null;
            _productRepository = null;
            _slidetRepository = null;
namespace CallfireApiClient
    public class CallfireClient
    {
        public void SetClientConfig(ClientConfig config)
        {
            RestApiClient.ClientConfig = config;
        }
        public RestApiClient RestApiClient { get; set; }
        readonly Lazy<MeApi> _MeApi;
        readonly Lazy<OrdersApi> _OrdersApi;
        readonly Lazy<BatchesApi> _BatchesApi;
        readonly Lazy<CampaignSoundsApi> _CampaignSoundsApi;
        readonly Lazy<ContactsApi> _ContactsApi;
        readonly Lazy<ContactListsApi> _ContactListsApi;
        readonly Lazy<NumbersApi> _NumbersApi;
        readonly Lazy<NumberLeasesApi> _NumberLeasesApi;
        readonly Lazy<KeywordsApi> _KeywordsApi;
        readonly Lazy<KeywordLeasesApi> _KeywordLeasesApi;
        readonly Lazy<DncApi> _DncApi;
        readonly Lazy<CallsApi> _CallsApi;
        readonly Lazy<TextsApi> _TextsApi;
        readonly Lazy<TextAutoRepliesApi> _TextAutoRepliesApi;
        readonly Lazy<TextBroadcastsApi> _TextBroadcast

        readonly Lazy<CallBroadcastsApi> _CallBroadcastsApi;
        readonly Lazy<MediaApi> _MediaApi;
        readonly Lazy<WebhooksApi> _WebhooksApi;
        public MeApi MeApi { get { return _MeApi.Value; } }
        public OrdersApi OrdersApi { get { return _OrdersApi.Value; } }
        public BatchesApi BatchesApi { get { return _BatchesApi.Value; } }
        public CampaignSoundsApi CampaignSoundsApi { get { return _CampaignSoundsApi.Value; } }
        public ContactsApi ContactsApi { get { return _ContactsApi.Value; } }
        public ContactListsApi ContactListsApi { get { return _ContactListsApi.Value; } }
        public NumbersApi NumbersApi { get { return _NumbersApi.Value; } }
        public NumberLeasesApi NumberLeasesApi { get { return _NumberLeasesApi.Value; } }
        public WebhooksApi WebhooksApi { get { return _WebhooksApi.Value; } }
        public KeywordsApi KeywordsApi { get { return _KeywordsApi.Value; } }
        public KeywordLeasesApi KeywordLeasesApi { get

        public DncApi DncApi { get { return _DncApi.Value; } }
        public CallsApi CallsApi { get { return _CallsApi.Value; } }
        public TextsApi TextsApi { get { return _TextsApi.Value; } }
        public TextAutoRepliesApi TextAutoRepliesApi { get { return _TextAutoRepliesApi.Value; } }
        public TextBroadcastsApi TextBroadcastsApi { get { return _TextBroadcastsApi.Value; } }
        public CallBroadcastsApi CallBroadcastsApi { get { return _CallBroadcastsApi.Value; } }
        public MediaApi MediaApi { get { return _MediaApi.Value; } }
        public CallfireClient(string username, string password)
        {
            RestApiClient = new RestApiClient(new HttpBasicAuthenticator(username, password));
            _MeApi = new Lazy<MeApi>(() => new MeApi(RestApiClient));
            _OrdersApi = new Lazy<OrdersApi>(() => new OrdersApi(RestApiClient));
            _BatchesApi = new Lazy<BatchesApi>(() => new BatchesApi(RestApiClient));
            _CampaignSoundsApi =
namespace Voxels.Workers {
    class RasterizeWorker : Worker {
        private Chunk chunk;
        private ChunkMesh mesh;
        private ChunkView chunkView;
        private ChunkRenderer renderer;        
        private Stopwatch timer = new Stopwatch();
        public RasterizeWorker(Chunk chunk) {
            this.chunk = chunk;
            this.chunk.Working = true;            
            mesh = new ChunkMesh();
            renderer = new ChunkRenderer();
            chunkView = new ChunkView(chunk);
        }
        public override void Process() {
            timer.Start();
            if (chunk.Dirty) {
                foreach (var position in Configuration.ChunkRegion) {
                    Block block = chunkView.GetBlock(position);
                    if (block.IsVisible)
                        renderer.GenerateMesh(mesh, chunkView, block, position);
                }
                Statistics.ChunkMeshes++;
            }
            chunk.ChunkMesh = mesh;
         
namespace CSharpGL.FileParser._3DSParser.Chunks
    public static partial class ChunkBaseHelper
    {
        private static readonly Dictionary<Type, ushort> chunkTypeDict = new Dictionary<Type, ushort>();
        private static readonly Dictionary<ushort, Type> chunkIDDict = new Dictionary<ushort, Type>();
        static ChunkBaseHelper()
        {
            chunkTypeDict.Add(typeof(MainChunk), 0x4D4D);
            {
                chunkTypeDict.Add(typeof(VersionChunk), 0x0002);
                chunkTypeDict.Add(typeof(_3DEditorChunk), 0x3D3D);
                {
                    chunkTypeDict.Add(typeof(ObjectBlockChunk), 0x4000);
                    {
                        chunkTypeDict.Add(typeof(TriangularMeshChunk), 0x4100);
                        {
                            chunkTypeDict.Add(typeof(VerticesListChunk), 0x4110);
                            chunkTypeDict.Add(typeof(FacesDescriptionChunk), 0x4120);
                            {
                          

                                chunkTypeDict.Add(typeof(SmoothingGroupListChunk), 0x4150);
                            }
                            chunkTypeDict.Add(typeof(MappingCoordinatesListChunk), 0x4140);
                            chunkTypeDict.Add(typeof(LocalCoordinatesSystemChunk), 0x4160);
                        }
                        chunkTypeDict.Add(typeof(LightChunk), 0x4600);
                        {
                            chunkTypeDict.Add(typeof(SpotlightChunk), 0x4610);
                        }
                        chunkTypeDict.Add(typeof(CameraChunk), 0x4700);
                    }
                    chunkTypeDict.Add(typeof(MaterialBlockChunk), 0xAFFF);
                    {
                        chunkTypeDict.Add(typeof(MaterialNameChunk), 0xA000);
                        chunkTypeDict.Add(typeof(AmbientColorChunk), 0xA010);
                        chunkTypeDict.Add(typeof(DiffuseColorChunk), 0xA020);
                        chunkTypeDict.Ad

                        chunkTypeDict.Add(typeof(MatShininessChunk), 0xA040);
                        chunkTypeDict.Add(typeof(TextureMapChunk), 0xA200);
                        chunkTypeDict.Add(typeof(BumpMapChunk), 0xA230);
                        chunkTypeDict.Add(typeof(ReflectionMapChunk), 0xA220);
                        {
                            chunkTypeDict.Add(typeof(MappingFilenameChunk), 0xA300);
                            chunkTypeDict.Add(typeof(MappingParametersChunk), 0xA351);
                        }
                    }
                }
                chunkTypeDict.Add(typeof(KeyframeChunk), 0xB000);
                {
                    chunkTypeDict.Add(typeof(MeshInformationBlockChunk), 0xB002);
                    chunkTypeDict.Add(typeof(SpotLightInformationBlockChunk), 0xB007);
                    chunkTypeDict.Add(typeof(FramesChunk), 0xB008);
                    {
                        chunkTypeDict.Add(typeof(ObjectNameChunk), 0xB010);
          
namespace QDMS.Server.NancyModules
    public class InstrumentModule : NancyModule
    {
        public InstrumentModule(IInstrumentSource instrumentRepo, IDataStorage dataStorage) : base("/instruments")
        {
            this.RequiresAuthentication();
            Get["/", true] = async (_, token) => await instrumentRepo.FindInstruments().ConfigureAwait(false);
            Get["/{Id:int}", true] = async (parameters, token) =>
            {
                var id = (int)parameters.Id;
                var instrument = (await instrumentRepo.FindInstruments(x => x.ID == id).ConfigureAwait(false)).FirstOrDefault();
                if (instrument == null) return HttpStatusCode.NotFound;
                return instrument;
            };
            Get["/search", true] = async (_, token) =>
            {
                var inst = this.Bind<Instrument>();
                if (inst == null) return HttpStatusCode.BadRequest;
                return await instrumentRepo.FindInstruments(inst).C

            };
            Get["/predsearch", true] = async (parameters, token) =>
            {
                var predReq = this.Bind<PredicateSearchRequest>();
                if (predReq == null) return HttpStatusCode.BadRequest;
                Expression<Func<Instrument, bool>> expression;
                try
                {
                    expression = predReq.Filter;
                }
                catch (Exception ex)
                {
                    return Negotiate
                        .WithModel(new ValidationErrorResponse("Malformed predicate: " + ex.Message))
                        .WithStatusCode(HttpStatusCode.BadRequest);
                }
                var instruments = await instrumentRepo.FindInstruments(expression).ConfigureAwait(false);
                return instruments;
            };
            Post["/", true] = async (parameters, token) =>
            {
                Instrument instrument = this.BindAndValidate<Instrument>();
          

                {
                    return this.ValidationFailure();
                }
                var addedInstrument = await instrumentRepo.AddInstrument(instrument);
                return addedInstrument;
            };
            Put["/", true] = async (parameters, token) =>
            {
                var instrument = this.BindAndValidate<Instrument>();
                if (ModelValidationResult.IsValid == false)
                {
                    return this.ValidationFailure();
                }
                Instrument instrumentFromDB = (await instrumentRepo.FindInstruments(x => x.ID == instrument.ID).ConfigureAwait(false)).FirstOrDefault();
                if (instrumentFromDB == null) return HttpStatusCode.NotFound;
                await instrumentRepo.UpdateInstrument(instrumentFromDB, instrument).ConfigureAwait(false);
                return instrumentFromDB;
            };
            Delete["/{Id:int}", true] = async (parameters, token) =>
            {
  
namespace Hjg.Pngcs.Chunks
	internal class PngMetadata
	{
		private readonly ChunksList chunkList;
		private readonly bool ReadOnly;
		internal PngMetadata ( ChunksList chunks )
		{
			this.chunkList = chunks;
			if ( chunks is ChunksListForWrite )
			{
				this.ReadOnly = false;
			}
			else
			{
				this.ReadOnly = true;
			}
		}
		public void QueueChunk ( PngChunk chunk, bool lazyOverwrite )
		{
			ChunksListForWrite cl = getChunkListW ();
			if ( ReadOnly )
				throw new PngjException ( "cannot set chunk : readonly metadata" );
			if ( lazyOverwrite )
			{
				ChunkHelper.TrimList ( cl.GetQueuedChunks (), new ChunkPredicateEquiv ( chunk ) );
			}
			cl.Queue ( chunk );
		}
		public void QueueChunk ( PngChunk chunk )
		{
			QueueChunk ( chunk, true );
		}
		private ChunksListForWrite getChunkListW ()
		{
			return ( ChunksListForWrite ) chunkList;
		}
		public double [] GetDpi ()
		{
			PngChunk c = chunkList.GetById1 ( ChunkHelper.pHYs, true );
			if ( c == null )
				return new do

			else
				return ( ( PngChunkPHYS ) c ).GetAsDpi2 ();
		}
		public void SetDpi ( double dpix, double dpiy )
		{
			PngChunkPHYS c = new PngChunkPHYS ( chunkList.imageInfo );
			c.SetAsDpi2 ( dpix, dpiy );
			QueueChunk ( c );
		}
		public void SetDpi ( double dpi )
		{
			SetDpi ( dpi, dpi );
		}
		public PngChunkTIME SetTimeNow ( int nsecs )
		{
			PngChunkTIME c = new PngChunkTIME ( chunkList.imageInfo );
			c.SetNow ( nsecs );
			QueueChunk ( c );
			return c;
		}
		public PngChunkTIME SetTimeNow ()
		{
			return SetTimeNow ( 0 );
		}
		public PngChunkTIME SetTimeYMDHMS ( int year, int mon, int day, int hour, int min, int sec )
		{
			PngChunkTIME c = new PngChunkTIME ( chunkList.imageInfo );
			c.SetYMDHMS ( year, mon, day, hour, min, sec );
			QueueChunk ( c, true );
			return c;
		}
		public PngChunkTIME GetTime ()
		{
			return ( PngChunkTIME ) chunkList.GetById1 ( ChunkHelper.tIME );
		}
		public String GetTimeAsString ()
		{
			PngChunkTIME c = GetTime ();
			return c == nu

		}
		public PngChunkTextVar SetText ( String key, String val, bool useLatin1, bool compress )
		{
			if ( compress && !useLatin1 )
				throw new PngjException ( "cannot compress non latin text" );
			PngChunkTextVar c;
			if ( useLatin1 )
			{
				if ( compress )
				{
					c = new PngChunkZTXT ( chunkList.imageInfo );
				}
				else
				{
					c = new PngChunkTEXT ( chunkList.imageInfo );
				}
			}
			else
			{
				c = new PngChunkITXT ( chunkList.imageInfo );
			}
			c.SetKeyVal ( key, val );
			QueueChunk ( c, true );
			return c;
		}
		public PngChunkTextVar SetText ( String key, String val )
		{
			return SetText ( key, val, false, false );
		}
		public List<PngChunkTextVar> GetTxtsForKey ( String key )
		{
			List<PngChunkTextVar> li = new List<PngChunkTextVar> ();
			foreach ( PngChunk c in chunkList.GetById ( ChunkHelper.tEXt, key ) )
				li.Add ( ( PngChunkTextVar ) c );
			foreach ( PngChunk c in chunkList.GetById ( ChunkHelper.zTXt, key ) )
				li.Add ( ( PngChunkTextVar 
namespace ProcessShutdownTimer
    public class ProcessManager
    {
        public ObservableCollection<ProcessContainer> ProcessList
        {
            get { return processList; }
            set { processList = value; }
        }
        public ObservableCollection<ProcessContainer> ScheduledList
        {
            get { return scheduledList; }
            set { scheduledList = value; }
        }
        public CollectionView ProcessView;
        public CollectionView ScheduledView;
        ObservableCollection<ProcessContainer> processList;
        ObservableCollection<ProcessContainer> scheduledList;
        
        public ProcessManager()
        {
            processList = new ObservableCollection<ProcessContainer>();
            scheduledList = new ObservableCollection<ProcessContainer>();
            RefreshProcessList();
        }
        public void RefreshProcessList()
        {
            foreach (Process process in Process.GetProcesses())
            {
           

                {
                    processList.Add(new ProcessContainer(process.ProcessName, (int)(process.WorkingSet64 / 1024), process.Id));
                }
            }
        }
        public void ScheduleShutdown(IList processes, DateTime time)
        {
            foreach (ProcessContainer process in processes)
            {
                SetTimer(process, time);
            }
            ProcessView.Refresh();
        }
        public bool RemoveProcess(ProcessContainer processToRemove)
        {
            if (Process.GetProcessById(processToRemove.Id).ProcessName == processToRemove.ProcessName)
            {
                processList.Remove(processToRemove);
            }
            return true;
        }
        private void SetTimer(ProcessContainer process, DateTime time)
        {
            DispatcherTimer timer = new DispatcherTimer();
            timer.Tick += HandleTick;
            timer.Interval = time - DateTime.Now < TimeSpan.FromSeconds(1) ? TimeSp
public class World : MonoBehaviour
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public GameObject chunkPrefab;
    public string worldName = "world";
    public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(chunkPrefab, new Vector3(x, y, z), Quaternion.Euler(Vector3.zero)) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        var terrainGen = new TerrainGen();
        newChunk = terrainGen.ChunkGen(newChunk);
        newChunk.SetBlockUnmodified();
        Serialization.Load(newChunk);
    }
    public void DestroyChunk(int x, int y, int z)
    {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
        {
            Serialization.SaveChunk(chunk);
            Object.Destro

            chunks.Remove(new WorldPos(x, y, z));
        }
    }
    public Chunk GetChunk(int x, int y, int z) 
    {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.CHUNK_SIZE;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.CHUNK_SIZE;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.CHUNK_SIZE;
        pos.z = Mathf.FloorToInt(z / multiple) * Chunk.CHUNK_SIZE;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Block GetBlock(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null)
        {
            Block block = containerChunk.GetBlock(x - containerChunk.pos.x,
                                                  y - containerChunk.pos.y,
                                                  z - containerChunk.pos.z);
            return block;
        }
        else
        {
            return new BlockAir(

        }
    }
    public void SetBlock(int x, int y, int z, Block block)
    {
        Chunk chunk = GetChunk(x, y, z);
        
        if (chunk != null)
        {
            chunk.SetBlock(x - chunk.pos.x, y - chunk.pos.y, z - chunk.pos.z, block);
            chunk.update = true;
            UpdateIfEqual(x - chunk.pos.x, 0, new WorldPos(x - 1, y, z));
            UpdateIfEqual(x - chunk.pos.x, Chunk.CHUNK_SIZE - 1, new WorldPos(x + 1, y, z));
            UpdateIfEqual(y - chunk.pos.y, 0, new WorldPos(x, y - 1, z));
            UpdateIfEqual(y - chunk.pos.y, Chunk.CHUNK_SIZE - 1, new WorldPos(x, y + 1, z));
            UpdateIfEqual(z - chunk.pos.z, 0, new WorldPos(x, y, z - 1));
            UpdateIfEqual(z - chunk.pos.z, Chunk.CHUNK_SIZE - 1, new WorldPos(x, y, z + 1));
        }
    }
    void UpdateIfEqual(int value1, int value2, WorldPos pos)
    {
        if (value1 == value2)
        {
            Chunk chunk = GetChunk(pos.x, pos.y, pos.z);
            if (chunk != null)

namespace Cats.Areas.Logistics.Controllers
    [Authorize]
    public class DeliveryReconcileController : Controller
    {
        private readonly IDispatchAllocationService _dispatchAllocationService;
        private readonly IDeliveryService _deliveryService;
        private readonly IDispatchService _dispatchService;
        private readonly Cats.Services.EarlyWarning.ICommodityService _commodityService;
        private readonly Cats.Services.EarlyWarning.IUnitService _unitService;
        private readonly Cats.Services.Transaction.ITransactionService _transactionService;
        private readonly Cats.Services.EarlyWarning.IAdminUnitService _adminUnitService;
        private readonly Cats.Services.EarlyWarning.IFDPService _fdpService;
        private readonly Cats.Services.Logistics.IDeliveryReconcileService _deliveryReconcileService;
        private readonly IUserAccountService _userAccountService;
        private readonly ILossReasonService _lossReasonService;
        public Deli

                                      IDeliveryService deliveryService,
            IDispatchService dispatchService,
            Cats.Services.EarlyWarning.ICommodityService commodityService, Cats.Services.EarlyWarning.IUnitService unitService, 
            Cats.Services.Transaction.ITransactionService transactionService,
            Cats.Services.EarlyWarning.IAdminUnitService adminUnitService, Cats.Services.EarlyWarning.IFDPService fdpService,
            Cats.Services.Logistics.IDeliveryReconcileService deliveryReconcileService, IUserAccountService userAccountService, ILossReasonService lossReasonService)
        {
            _dispatchAllocationService = dispatchAllocationService;
            _deliveryService = deliveryService;
            _dispatchService = dispatchService;
            _commodityService = commodityService;
            _unitService = unitService;
            _transactionService = transactionService;
            _adminUnitService = adminUnitService;
            _f

            _deliveryReconcileService = deliveryReconcileService;
            _userAccountService = userAccountService;
            _lossReasonService = lossReasonService;
        }
        public ActionResult Index(int regionID)
        {
            ViewBag.RegionID = regionID;
            ViewBag.Region = _adminUnitService.FindById(regionID).Name;
            var zonesList = _adminUnitService.GetAllZones(regionID);
            ViewBag.ZoneCollection = BindZoneViewModel(zonesList);
            var lossReasons = _lossReasonService.GetAllLossReason().Select(t => new
                                                                                    {
                                                                                        name =
                                                                                    t.LossReasonCodeEg + "-" +
                                                                                    t.LossReasonEg,
                                  
namespace Demo
    internal class Program
    {
        private static void DemoAction()
        {
            var w = new DemoWidget();
            w.InvokeAction("A");
            w.InvokeAction("B");
            w.WaitAndDump("Action").Wait();
        }
        private static void DemoTask()
        {
            var w = new DemoWidget();
            w.InvokeTask("A");
            w.InvokeTask("B");
            w.WaitAndDump("Task").Wait();
        }
        private static void DemoTaskAtomic()
        {
            var w = new DemoWidget();
            w.InvokeTask("A", InvokeOptions.Atomic);
            w.InvokeTask("B", InvokeOptions.Atomic);
            w.WaitAndDump("Task").Wait();
        }
        private static void DemoTaskAtomic2()
        {
            var w = new DemoWidget();
            w.InvokeTask("A");
            w.InvokeTask("B", InvokeOptions.Atomic);
            w.WaitAndDump("Task").Wait();
        }
        private static void DemoBarrier()
        {
         
namespace BlogAppDAL.UoW
    public class UnitOfWork:IDisposable
    {
        private readonly BlogAppContext _context = null;
        private Repository<Blog> _blogRepository = null;
        private Repository<Category> _categoryRepository;
        private Repository<Comment> _commentRepository = null;
        private Repository<Role> _roleRepository = null;
        private Repository<User> _userRepository = null;
        private Repository<Author> _authorRepository = null;
        private Repository<Archives> _archivesRepository = null;
        private Repository<DailySentence> _dailySentenceRepository = null;
        private Repository<CommentReply> _commentReplyRepository = null;
        private Repository<SEO> _SEORepository = null;
        private Repository<SearchDetails> _SearchDetailsRepository = null;
        private Repository<SearchTotal> _SearchTotalsRepository = null;
        private Repository<Topic> _topicRepository = null;
        private Repository<TopicList> _topicL

        private Repository<TopicFirst> _topicFirstRepository = null;
        public UnitOfWork()
        {
            _context=new BlogAppContext();
        }
        public Repository<Blog> BlogRepository
        {
            get { return _blogRepository ?? (_blogRepository = new Repository<Blog>(_context)); }
        }
        public Repository<Category> CategoryRepository
        {
            get { return _categoryRepository ?? (_categoryRepository = new Repository<Category>(_context)); }
        }
        public Repository<Comment> CommentRepository
        {
            get { return _commentRepository ?? (_commentRepository = new Repository<Comment>(_context)); }
        }
        public Repository<Role> RoleRepository
        {
            get { return _roleRepository ?? (_roleRepository = new Repository<Role>(_context)); }
        }
        public Repository<User> UserRepository
        {
            get { return _userRepository ?? (_userRepository = new Repository<User>(_co

        }
        public Repository<Author> AuthorRepostiory
        {
            get { return _authorRepository ?? (_authorRepository = new Repository<Author>(_context)); }        
        }
        public Repository<Archives> ArchivesRepostiory
        {
            get { return _archivesRepository ?? (_archivesRepository = new Repository<Archives>(_context)); }
        }
        public Repository<DailySentence> DailySentenceRepostiory
        {
            get { return _dailySentenceRepository ?? (_dailySentenceRepository = new Repository<DailySentence>(_context)); }
        }
        public Repository<CommentReply> CommentReplyRepostiory
        {
            get { return _commentReplyRepository ?? (_commentReplyRepository = new Repository<CommentReply>(_context)); }
        }
        public Repository<SEO> SEORepostiory
        {
            get { return _SEORepository ?? (_SEORepository = new Repository<SEO>(_context)); }
        }
        public Repository<SearchDetails> Searc
#if UNITY_EDITOR
#endif
namespace VoxelBusters.Utility
#if UNITY_EDITOR
	[InitializeOnLoad]
#endif
	public class EditorInvoke 
	{
		#region Properties
#pragma warning disable
		private static DateTime				m_cachedTimeSinceStartup;
#pragma warning restore
		private static Dictionary<System.Action, Dictionary<string, float>>	invokeMethodsContainer;
		#endregion
		#region Constants
		
		private const string 				kTimeSinceLastInvoke		= "time-since-last-invoke";
		private const string				kRepeatRate					= "repeat-rate";
		private const string 				kInvokeAfter				= "invoke-after";
		#endregion
		#region Constructors
		static EditorInvoke ()
		{
			invokeMethodsContainer		= new Dictionary<System.Action, Dictionary<string, float>>();
#if UNITY_EDITOR
			EditorApplication.update	-= ManageMethodInvoke;
			EditorApplication.update	+= ManageMethodInvoke;
#endif
		}
		#endregion
		#region Invoke Methods
#if UNITY_EDITOR
		private static void ManageMethodInvoke ()
		{
			float _dt					= (DateTime.Now

			System.Action[] _methodList	= invokeMethodsContainer.Keys.ToArray<System.Action>();
			for (int _iter = 0; _iter < _methodList.Length; _iter++)
			{
				System.Action _invokeMethod						= _methodList[_iter];
				Dictionary<string, float> _invokeMethodDetails	= invokeMethodsContainer[_invokeMethod];
				_invokeMethodDetails[kTimeSinceLastInvoke] 		+= _dt;
				
				if (_invokeMethodDetails[kTimeSinceLastInvoke] > _invokeMethodDetails[kInvokeAfter])
				{
					_invokeMethod();
					if (!_invokeMethodDetails.ContainsKey(kRepeatRate))
					{
						invokeMethodsContainer.Remove(_invokeMethod);
						continue;
					}
					_invokeMethodDetails[kTimeSinceLastInvoke]	= 0f;
					_invokeMethodDetails[kInvokeAfter]			= _invokeMethodDetails[kRepeatRate];
				}
			}
			
			m_cachedTimeSinceStartup		= DateTime.Now;
		}
#endif
		public static void Invoke (System.Action _method, float _time)
		{
			invokeMethodsContainer[_method]	= new Dictionary<string, float>() 
			{
				{ kTimeSinceLastInvoke, 0f
namespace Bd.Icm
    [Serializable]
    public class InstrumentCommitList : ReadOnlyBindingListBase<InstrumentCommitList, InstrumentCommitInfo>
    {
        #region [Factory Methods]
        public static InstrumentCommitList GetInstrumentCommitList(int instrumentId)
        {
            return
                DataPortal.Fetch<InstrumentCommitList>(instrumentId);
        }
        #endregion
        #region [Data Access]
        [UsedImplicitly]
        private void DataPortal_Fetch(int instrumentId)
        {
            {
                var items = repository.FetchAll().Where(x => x.InstrumentId == instrumentId).OrderByDescending(x => x.CreatedDate);
                AddItems(items);
            }
        }
        private void AddItems(IEnumerable<DataAccess.Database.InstrumentCommit> items)
        {
            RaiseListChangedEvents = false;
            IsReadOnly = false;
            foreach (var item in items)
            {
                Add(InstrumentCommitInfo.GetInstrume
public class World : MonoBehaviour {
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public GameObject chunkPrefab;
    void Start()
    {
		for (int x = -3; x < 4; x++)
		{
			for (int y = 0; y < 3; y++)
			{
				for (int z = -4; z < 4; z++)
				{
					CreateChunk(x * 16, y * 16, z * 16);
				}
			}
		}
    }
	void Update () {
	}
    public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(x, y, z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
		/*
        for (int xi = 0; xi < 16; xi++)
        {
            for (int yi = 0; yi < 16; yi++)
            {
                for (int zi = 0; zi < 16; 

                {
                    if (yi <= 16)
                    {
                        SetBlock(x + xi, y + yi, z + zi, new BlockGrass());
                    }
                    else
                    {
                        SetBlock(x + xi, y + yi, z + zi, new BlockAir());
                    }
                }
            }
        }
        */
		var terrainGen = new TerrainGen();
		newChunk = terrainGen.ChunkGen(newChunk);
    }
    public void DestroyChunk(int x, int y, int z)
    {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
        {
            Object.Destroy(chunk.gameObject);
            chunks.Remove(new WorldPos(x, y, z));
        }
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
      

        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Block GetBlock(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null)
        {
            Block block = containerChunk.GetBlock(
                x - containerChunk.pos.x,
                y - containerChunk.pos.y,
                z - containerChunk.pos.z);
            return block;
        }
        else
        {
            return new BlockAir();
        }
    }
    public void SetBlock(int x, int y, int z, Block block)
    {
        Chunk chunk = GetChunk(x, y, z);
        if (chunk != null)
        {
            chunk.SetBlock(x - chunk.pos.x, y - chunk.pos.y, z - chunk.pos.z, block);
            chunk.update = true;
			UpdateIfEqual(x - chunk.pos.x, 0, new WorldPos(x - 1, y, z));
			UpdateIfEqual(x - chunk.pos.x, Chunk.chunkSize - 1, new WorldPos(x + 1, y, z));
			UpdateIfEqual(y - chun
namespace IGSoft.CarPack.Mobile.Repository
    public class RepositoryManager : IRepositoryManager
    {
        private readonly ICompanyRepository _companyRepository;
        private readonly IRecordRepository _recordRepository;
        private readonly IExpertRepository _expertRepository;
        private readonly IPhotoRepository _photoRepository;
        public RepositoryManager(ICompanyRepository companyRepository,
            IRecordRepository recordRepository,
            IExpertRepository expertRepository,
            IPhotoRepository photoRepository)
        {
            _companyRepository = companyRepository;
            _recordRepository = recordRepository;
            _expertRepository = expertRepository;
            _photoRepository = photoRepository;
        }
        public async Task Initialize()
        {
            await _companyRepository.Load();
            await _recordRepository.Load();
            await _expertRepository.Load();
            await _photoReposito
namespace VoxelEngine.ChunkLoaders {
    [Obsolete("May contain bugs!", true)]
    public class ChunkLoaderLockedY : ChunkLoaderBase {
        private int worldHeight = 4;
        public ChunkLoaderLockedY(World world, EntityPlayer player) : base(world, player, 2) {}
        protected override bool isOutOfBounds(ChunkPos occupiedChunkPos, Chunk chunk) {
            if (this.toFar(occupiedChunkPos.x, chunk.chunkPos.x) || this.toFar(occupiedChunkPos.z, chunk.chunkPos.z)) {
                return true;
            }
            return false;
        }
        protected override void loadYAxis(ChunkPos occupiedChunkPos, int x, int z, bool isReadOnly) {
            for (int y = 0; y < this.worldHeight; y++) {
                NewChunkInstructions instructions = new NewChunkInstructions(x + occupiedChunkPos.x, y + occupiedChunkPos.y, z + occupiedChunkPos.z, isReadOnly);
                Chunk chunk = world.getChunk(instructions.chunkPos);
                if (chunk == null) {
                  
namespace Rasengan.Operations
    public class BinaryExpressionOperation : IOperation
    {
        private IOperation _left;
        private IOperation _rigth;
        private string _operation;
        public BinaryExpressionOperation(dynamic expression)
        {
            _left = OpFactory.Factory(expression.Left);
            _rigth = OpFactory.Factory(expression.Right);
            _operation = expression.Operator;
        }
        public dynamic Invoke(Context context)
        {
            switch (_operation)
            {
                case "+":
                    return _left.Invoke(context) + _rigth.Invoke(context);
                case "-":
                    return _left.Invoke(context) - _rigth.Invoke(context);
                case "*":
                    return _left.Invoke(context) * _rigth.Invoke(context);
                case "/":
                    return _left.Invoke(context) / _rigth.Invoke(context);
                case ">":
                    return _le

                case "<":
                    return _left.Invoke(context) < _rigth.Invoke(context);
                case ">=":
                    return _left.Invoke(context) >= _rigth.Invoke(context);
                case "<=":
                    return _left.Invoke(context) <= _rigth.Invoke(context);
                case "==":
                    return _left.Invoke(context).ToString() == _rigth.Invoke(context).ToString();
                case "===":
                    return _left.Invoke(context) == _rigth.Invoke(context);
                case "!=":
                    return _left.Invoke(context).ToString() != _rigth.Invoke(context).ToString();
                case "!==":
                    return _left.Invoke(context) != _rigth.Invoke(context);
                case "%":
                    return _left.Invoke(context) % _rigth.Invoke(context);
                case "&":
                    return _left.Invoke(context) & _rigth.Invoke(context);
                case "&&":
     
namespace RicksGuitarsStart.Model
    public class Instrument : IEquatable<Instrument>
    {
        public string SerialNumber { get; protected set; }
        public decimal Price { get; protected set; }
        public InstrumentSpecification Specification { get; protected set; }
        public Instrument(string serialNumber, decimal price, InstrumentSpecification specification)
        {
            SerialNumber = serialNumber;
            Price = price;
            this.Specification = specification;
        }
        public bool Equals(Instrument other) => other != null && SerialNumber == other.SerialNumber;
        public override bool Equals(object obj)
        {
            Instrument other = obj as Instrument;
            return Equals(other);
        }
        public override int GetHashCode() => SerialNumber.GetHashCode();
        public static bool operator ==(Instrument instrument1, Instrument instrument2)
            => instrument1 is null || instrument2 is null ?
        
$AvatarAPI::smileyCount = -1;
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "BrownSmiley";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "ChefSmiley";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "KleinerSmiley";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "Male07Smiley";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "Orc";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "AdamSavage";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "Jamie";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "AsciiTerror";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "MemeBlockMongler";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "MemeCats";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "MemeDesu";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "MemeGrinMan";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "MemeHappy";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "MemePBear";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "MemeYaranika";
$AvatarAPI::smiley[$AvatarAPI::smileyCount

$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "SmileyCreepy";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "SmileyEvil1";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "SmileyEvil2";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "SmileyOld";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "SmileyPirate1";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "SmileyPirate2";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "SmileyPirate3";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "SmileyRedBeard";
$AvatarAPI::smiley[$AvatarAPI::smileyCount++] = "SmileyRedBeard2";
$AvatarAPI::smileyCount++;
$AvatarAPI::hatCount = -1;
$AvatarAPI::hat[$AvatarAPI::hatCount++] = "Helmet";
$AvatarAPI::hat[$AvatarAPI::hatCount++] = "PointyHelmet";
$AvatarAPI::hat[$AvatarAPI::hatCount++] = "FlareHelmet";
$AvatarAPI::hat[$AvatarAPI::hatCount++] = "ScoutHat";
$AvatarAPI::hat[$AvatarAPI::hatCount++] = "Bicorn";
$AvatarAPI::hat[$AvatarAPI::hatCount++] = "Cophat";
$AvatarAPI::hat[$AvatarAPI::hatCount++] =

$AvatarAPI::hatCount++;
$AvatarAPI::accentCount = -1;
$AvatarAPI::accent[$AvatarAPI::accentCount++] = "Plume";
$AvatarAPI::accent[$AvatarAPI::accentCount++] = "Triplume";
$AvatarAPI::accent[$AvatarAPI::accentCount++] = "Septplume";
$AvatarAPI::accentCount++;
$AvatarAPI::decalCount = -1;
$AvatarAPI::decal[$AvatarAPI::decalCount++] = "Alyx";
$AvatarAPI::decal[$AvatarAPI::decalCount++] = "Archer";
$AvatarAPI::decal[$AvatarAPI::decalCount++] = "Chef";
$AvatarAPI::decal[$AvatarAPI::decalCount++] = "DKnight";
$AvatarAPI::decal[$AvatarAPI::decalCount++] = "DrKleiner";
$AvatarAPI::decal[$AvatarAPI::decalCount++] = "HCZombie";
$AvatarAPI::decal[$AvatarAPI::decalCount++] = "Knight";
$AvatarAPI::decal[$AvatarAPI::decalCount++] = "LinkTunic";
$AvatarAPI::decal[$AvatarAPI::decalCount++] = "Hoodie";
$AvatarAPI::decal[$AvatarAPI::decalCount++] = "Medieval-Eagle";
$AvatarAPI::decal[$AvatarAPI::decalCount++] = "Medieval-Lion";
$AvatarAPI::decal[$AvatarAPI::decalCount++] = "Medieval-Rider";
$AvatarAPI:
namespace OpenTKTest
    public class World
    {
        Dictionary<Vector3i, Chunk> chunks = new Dictionary<Vector3i, Chunk>();
        Chunk c1 = new Chunk(), c2 = new Chunk();
        public World()
        {
            c1.GenerateTerrain(1);
            c2.GenerateTerrain(0);
            c1.GenerateBuffers();
            c2.GenerateBuffers();
            chunks[Vector3i.Zero] = c1;
            chunks[new Vector3i(1, 0, 0)] = c2;            
        }
        public void AddNewChunkAt(Vector3i location)
        {
        }
        public void DrawChunks(Matrix4 modelViewMatrix)
        {
            foreach (var kvp in chunks)
            {
                GL.LoadMatrix(ref modelViewMatrix);
                GL.Translate(kvp.Key.X * Chunk.CHUNK_SIZE_1D,
                    kvp.Key.Y * Chunk.CHUNK_SIZE_1D,
                    kvp.Key.Z * Chunk.CHUNK_SIZE_1D);
                kvp.Value.Draw();
            }
        }
        public void SetBlock(Vector3i location, BlockType type)
   

            Chunk chunk = GetChunkContainingBlockCoordinates(this, location);
            if (chunk == null) return;
            Vector3i blockPositionWithinChunk = location % Chunk.CHUNK_SIZE_1D;
            chunk.setBlockTypeAt(blockPositionWithinChunk, type);
            chunk.GenerateBuffers();
        }
        {
            Chunk chunk = GetChunkContainingBlockCoordinates(this, location);
            if (chunk == null) return null;
            Vector3i blockPositionWithinChunk = location % Chunk.CHUNK_SIZE_1D;
            return new Block(location, chunk.getBlockTypeAt(blockPositionWithinChunk));
        }
        public Chunk GetChunkContainingBlockCoordinates(Vector3i blockCoordinates)
        {
            Vector3i chunkPosition = new Vector3i(blockCoordinates.X < 0 ? blockCoordinates.X - Chunk.CHUNK_SIZE_1D : blockCoordinates.X, blockCoordinates.Y < 0 ? blockCoordinates.Y - Chunk.CHUNK_SIZE_1D : blockCoordinates.Y, blockCoordinates.Z < 0 ? blockCoordinates.Z - Chunk.CHUNK_SI
namespace MonkeyCancelTest
    public class InstrumentFactory_Test
    {
        [Fact]
        public void CreateInstrumetTest_Create_BasicModel_Test()
        {
            var factory = new InstrumentFactory();
            var instrumentState = Substitute.For<ITTInstrumentState>();
            var def = new InstrDef("CME", "ZN", "FUTURE", "Dec15", "ZNZ5", "Basic");
            Instrument instrument = factory.CreateInstrument(def, instrumentState);
            Assert.IsType<Instrument>(instrument);
            Assert.IsNotType<InstrumentSpread>(instrument);
            Assert.IsNotType<InstrumentFutureSpreadImplied>(instrument);
        }
        [Fact]
        public void CreateInstrumetTest_Create_SpreadImpliedModel_Test()
        {
            var factory = new InstrumentFactory();
            var instrumentState = Substitute.For<ITTInstrumentState>();
            var def = new InstrDef("CME", "ZN", "FUTURE", "Dec15", "ZNZ5", "SpreadImplied");
            Instrument instrument = f

            Assert.IsType<InstrumentFutureSpreadImplied>(instrument);
        }
        [Fact]
        public void CreateInstrumetTest_Create_SpreadImpliedNonlinearModel_Test()
        {
            var factory = new InstrumentFactory();
            var instrumentState = Substitute.For<ITTInstrumentState>();
            var def = new InstrDef("CME", "ZN", "FUTURE", "Dec15", "ZNZ5", "SpreadImpliedNonlinear");
            Instrument instrument = factory.CreateInstrument(def, instrumentState);
            Assert.IsType<InstrumentFutureSpreadImplied>(instrument);
        }
        [Fact]
        public void CreateInstrumetTest_Create_Spread_Test()
        {
            var factory = new InstrumentFactory();
            var instrumentState = Substitute.For<ITTInstrumentState>();
            var def = new InstrDef("CME", "ZN", "SPREAD", "CME Reduced Tick Spread: 1xZN Dec15:-1xMar16", "+ZNZ5-ZNH6", "Basic");
            Instrument instrument = factory.CreateInstrument(def, instrumentState);


        }
        [Fact]
        public void CreateInstrumetTest_Create_FlowdownSpread_Test()
        {
            var factory = new InstrumentFactory();
            var instrumentState = Substitute.For<ITTInstrumentState>();
            var def = new InstrDef("CME", "ZN", "SPREAD", "CME Reduced Tick Spread: 1xZN Dec15:-1xMar16", "+ZNZ5-ZNH6", "FlowdownSpread");
            Instrument instrument = factory.CreateInstrument(def, instrumentState);
            Assert.IsType<InstrumentSpreadFlowdown>(instrument);
        }
        [Fact]
        public void CreateInstrumetTest_Create_WrongModel_Test()
        {
            var factory = new InstrumentFactory();
            var instrumentState = Substitute.For<ITTInstrumentState>();
            var def = new InstrDef("CME", "ZN", "FUTURE", "Dec15", "ZNZ5", "");
            Instrument instrument = factory.CreateInstrument(def, instrumentState);
            Assert.IsType<Instrument>(instrument);
            Assert.IsNotType<InstrumentSpread>
namespace MathSite.Repository.Core
    public class RepositoryManager : IRepositoryManager
    {
        public RepositoryManager(
            IGroupsRepository groupsRepository,
            IPersonsRepository personsRepository,
            IUsersRepository usersRepository,
            IFilesRepository filesRepository,
            ISiteSettingsRepository siteSettingsRepository,
            IRightsRepository rightsRepository,
            IPostsRepository postsRepository,
            IPostSeoSettingsRepository postSeoSettingsRepository,
            IPostSettingRepository postSettingRepository,
            IPostTypeRepository postTypeRepository, 
            IGroupTypeRepository groupTypeRepository
        )
        {
            GroupsRepository = groupsRepository;
            PersonsRepository = personsRepository;
            UsersRepository = usersRepository;
            FilesRepository = filesRepository;
            SiteSettingsRepository = siteSettingsRepository;
            RightsRe
namespace Tp.MashupManager.MashupLibrary.Repository.Synchronizer
	public class LibraryRepositorySynchronizer : ILibraryRepositorySynchronizer
	{
		private class CountableReaderWriterLockSlim : ReaderWriterLockSlim
		{
			public int ReadLockCount { get; set; }
			public int WriteLockCount { get; set; }
		}
		private readonly Dictionary<string, CountableReaderWriterLockSlim> _repositoryLocks;
		public LibraryRepositorySynchronizer()
		{
			_repositoryLocks = new Dictionary<string, CountableReaderWriterLockSlim>();
		}
		public void BeginRead(ISynchronizableLibraryRepository repository)
		{
			CountableReaderWriterLockSlim repositoryLock;
			lock (_repositoryLocks)
			{
				repositoryLock = _repositoryLocks.GetOrAdd(repository.Id, repositoryDescriptor => new CountableReaderWriterLockSlim());
				repositoryLock.ReadLockCount++;
			}
			repositoryLock.EnterReadLock();
		}
		public void EndRead(ISynchronizableLibraryRepository repository)
		{
			lock (_repositoryLocks)
			{
				if (_reposito

				{
					var repositoryLock = _repositoryLocks[repository.Id];
					repositoryLock.ReadLockCount--;
					repositoryLock.ExitReadLock();
					ReleaseLockIfUnused(repository, repositoryLock);
				}
			}
		}
		public bool TryBeginWrite(ISynchronizableLibraryRepository repository)
		{
			CountableReaderWriterLockSlim repositoryLock;
			lock (_repositoryLocks)
			{
				if (_repositoryLocks.ContainsKey(repository.Id))
				{
					repositoryLock = _repositoryLocks[repository.Id];
					if (repositoryLock.WriteLockCount > 0)
					{
						return false;
					}
				}
				else
				{
					repositoryLock = new CountableReaderWriterLockSlim();
					_repositoryLocks.Add(repository.Id, repositoryLock);
				}
				repositoryLock.WriteLockCount++;
			}
			repositoryLock.EnterWriteLock();
			return true;
		}
		public void EndWrite(ISynchronizableLibraryRepository repository)
		{
			lock (_repositoryLocks)
			{
				if (_repositoryLocks.ContainsKey(repository.Id) && _repositoryLocks[repository.Id].WriteLock
namespace Microsoft.AspNet.Razor.Generator.Compiler
    public abstract class ChunkVisitor<T> : IChunkVisitor where T : CodeWriter
    {
        public ChunkVisitor(T writer, CodeGeneratorContext context)
        {
            Writer = writer;
            Context = context;
        }
        protected T Writer { get; private set; }
        protected CodeGeneratorContext Context { get; private set; }
        public void Accept(IList<Chunk> chunks)
        {
            if (chunks == null)
            {
                throw new ArgumentNullException("chunks");
            }
            foreach (Chunk chunk in chunks)
            {
                Accept(chunk);
            }
        }
        public virtual void Accept(Chunk chunk)
        {
            if (chunk == null)
            {
                throw new ArgumentNullException("chunk");
            }
            if (chunk is LiteralChunk)
            {
                Visit((LiteralChunk)chunk);
            }
            else if (

            {
                Visit((ExpressionBlockChunk)chunk);
            }
            else if (chunk is ExpressionChunk)
            {
                Visit((ExpressionChunk)chunk);
            }
            else if (chunk is StatementChunk)
            {
                Visit((StatementChunk)chunk);
            }
            else if(chunk is SetLayoutChunk)
            {
                Visit((SetLayoutChunk)chunk);
            }
            else if (chunk is ResolveUrlChunk)
            {
                Visit((ResolveUrlChunk)chunk);
            }
            else if (chunk is TypeMemberChunk)
            {
                Visit((TypeMemberChunk)chunk);
            }            
            else if (chunk is UsingChunk)
            {
                Visit((UsingChunk)chunk);
            }
            else if(chunk is HelperChunk)
            {
                Visit((HelperChunk)chunk);
            }
            else if (chunk is SetBaseTypeChunk)
            {
               

            }
            else if (chunk is DynamicCodeAttributeChunk)
            {
                Visit((DynamicCodeAttributeChunk)chunk);
            }
            else if (chunk is LiteralCodeAttributeChunk)
            {
                Visit((LiteralCodeAttributeChunk)chunk);
            }
            else if (chunk is CodeAttributeChunk)
            {
                Visit((CodeAttributeChunk)chunk);
            }
            else if (chunk is SectionChunk)
            {
                Visit((SectionChunk)chunk);
            }
            else if (chunk is TemplateChunk)
            {
                Visit((TemplateChunk)chunk);
            }
            else if (chunk is ChunkBlock)
            {
                Visit((ChunkBlock)chunk);
            }
            else if(chunk is SessionStateChunk)
            {
                Visit((SessionStateChunk)chunk);
            }
        }
        protected abstract void Visit(LiteralChunk chunk);
        protected abstract void V
namespace NetSteps.Data.Entities.Business
    public partial class DispatchLists
    {
        {
            object RowsCount;
            var resultDispatch = DataAccess.ExecWithStoreProcedureListParam<DispatchListsSearchData>("Core", "uspFullDispatchLists", out RowsCount,
                new SqlParameter("PageSize", SqlDbType.Int) { Value = param.PageSize },
                new SqlParameter("PageNumber", SqlDbType.Int) { Value = param.PageIndex },
                new SqlParameter("Colum", SqlDbType.VarChar) { Value = param.OrderBy },
                new SqlParameter("Order", SqlDbType.VarChar) { Value = param.Order },
                new SqlParameter("RowsCount", SqlDbType.Int) { Value = 0, Direction = ParameterDirection.Output }).ToList();
            IQueryable<DispatchListsSearchData> matchingItems = resultDispatch.AsQueryable<DispatchListsSearchData>();
            return matchingItems.ToPaginatedList<DispatchListsSearchData>(param, resultTotalCount);
        }
                  

        public static DispatchListsTable GetDispatchListsByDispatchListID(int DispatchListID)
        {
            DispatchListsTable dispatch = DataAccess.ExecWithStoreProcedureListParam<DispatchListsTable>("Core", "uspGetDispatchListsByDispatchListID",
                new SqlParameter("DispatchListID", SqlDbType.Int) { Value = DispatchListID }).ToList()[0];
            
            return dispatch;
        }
        public static List<DispatchsItemsListTable> GetDispatchListItemsById(int DispatchListID)
        {
            var items = DataAccess.ExecWithStoreProcedureListParam<DispatchsItemsListTable>("Core", "uspGetDispatchListItemsById",
                new SqlParameter("DispatchListID", SqlDbType.Int) { Value = DispatchListID }).ToList();
            
            return items;
        }
        public static int InsertDispatch(DispatchListsTable entidad)
        { 
            var result = DataAccess.ExecWithStoreProcedureScalarType<int>("Core", "uspInsertDispatchLists",
     

                new SqlParameter("Name", SqlDbType.VarChar, 200) { Value = entidad.Name },
                new SqlParameter("MarketID", SqlDbType.Int) { Value = 56 }
                );
            return result;
        }
        public static int UPDDispatchLists(string Name, int DispatchListID)
        {
            var result = DataAccess.ExecWithStoreProcedureScalarType<int>("Core", "uspUPDDispatchLists",
                new SqlParameter("Name", SqlDbType.VarChar, 200) { Value = Name },
                new SqlParameter("DispatchListID", SqlDbType.Int) { Value = DispatchListID }
                );
            return result;
        }
        public static int DelDispatchLists(int DispatchListID)
        {
            var result = DataAccess.ExecWithStoreProcedureScalarType<int>("Core", "uspDelDispatchLists", 
                new SqlParameter("DispatchListID", SqlDbType.Int) { Value = DispatchListID }
                );
            return result;
        }
         
        public s
namespace JustGiving.Api.Sdk.WindowsPhone7
    public class JustGivingMobileClient : JustGivingClientBase
    {
        public JustGivingMobileClient(string apiKey)
            : base(new ClientConfiguration(apiKey), new SilverlightHttpClient(), null, null, null, null, null, null, null, null, null, null, null)
        {
        }
        public JustGivingMobileClient(ClientConfiguration clientConfiguration)
            : base(clientConfiguration, new SilverlightHttpClient(), null, null, null, null, null, null, null, null, null, null, null)
        {
        }
        public JustGivingMobileClient(ClientConfiguration clientConfiguration, IHttpClient httpClient)
            : base(clientConfiguration, httpClient, null, null, null, null, null, null, null, null, null, null, null)
        {
        }
        public JustGivingMobileClient(ClientConfiguration clientConfiguration, IHttpClient httpClient,
                                      IAccountApi accountApi,
                            
namespace SisOpe.Domain.Interfaces.Repositories
    public interface IUnitOfWork : IDisposable
    {
        #region propriedades
        IAcessoRepository AcessoRepository { get;  }
        IAcessoUsuarioRepository AcessoUsuarioRepository { get; }
        IArquivosOrdemServicoRepository ArquivosOrdemServicoRepository { get; }
        IContato_PJRepository Contato_PJRepository { get; }
        ICotacaoRepository CotacaoRepository { get; }
        IDepartamentoRepository DepartamentoRepository { get; }
        IEmailRepository EmailRepository { get; }
        IEnderecoRepository EnderecoRepository { get; }
        IEntradaProdutoNFRepository EntradaProdutoNFRepository { get; }
        IEntradaProdutoRepository EntradaProdutoRepository { get; }
        IEquipeOrdemServicoRepository EquipeOrdemServicoRepository { get; }
        IFinalidadeRepository FinalidadeRepository { get; }
        IFormaPagamentoRepository FormaPagamentoRepository { get; }
        IFornecedorCotacaoRepository Fornec

        IFuncionarioRepository FuncionarioRepository { get; }
        IHistoricoOrdemServicoRepository HistoricoOrdemServicoRepository { get; }
        IHistoricoStatusCotacaoRepository HistoricoStatusCotacaoRepository { get; }
        IItemEntradaEstoqueRepository ItemEntradaEstoqueRepository { get; }
        IItemEstoqueRepository ItemEstoqueRepository { get; }
        IItemPedidoCompraCotacaoRepository ItemPedidoCompraCotacaoRepository { get; }
        IItemPedidoCompraRepository ItemPedidoCompraRepository { get; }
        IItemProdutoNotaFiscalRepository ItemProdutoNotaFiscalRepository { get; }
        IItemReservaVendaProdutoRepository ItemReservaVendaProdutoRepository { get; }
        IItemRetornoCotacaoRepository ItemRetornoCotacaoRepository { get; }
        IItemSolicitacaoCompraCotacaoRepository ItemSolicitacaoCompraCotacaoRepository { get; }
        IItemSolicitacaoCompraRepository ItemSolicitacaoCompraRepository { get; }
        IItemTransferenciaEstoqueRepository ItemTrans

        IItemVendaEstoqueRepository ItemVendaEstoqueRepository { get; }
        IMarcaProdutoRepository MarcaProdutoRepository { get; }
        INotaFiscalRepository NotaFiscalRepository { get; }
        IOrdemServicoRepository OrdemServicoRepository { get; }
        IPagamentoOrdemServicoRepository PagamentoOrdemServicoRepository { get; }
        IPagamentoPedidoCompraRepository PagamentoPedidoCompraRepository { get; }
        IPagamentoRetornoCotacaoRepository PagamentoRetornoCotacaoRepository { get; }
        IPedidoCompraRepository PedidoCompraRepository { get; }
        IPessoaFisicaRepository PessoaFisicaRepository { get; }
        IPessoaJuridicaRepository PessoaJuridicaRepository { get;  }
        IPessoaRepository PessoaRepository { get; }
        IProdutoCotacaoRepository ProdutoCotacaoRepository { get; }
        IProdutoRepository ProdutoRepository { get; }
        IProfissaoFuncionarioRepository ProfissaoFuncionarioRepository { get; }
        IProfissaoRepository Profissao
public class World : MonoBehaviour {
    public string worldName = "world";
    public GameObject chunkPrefab;
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(x, y, z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        /*bool loaded = Serialization.Load(newChunk);
        if (loaded)
            return;*/
        newChunk = TerrainGen.ChunkGen(newChunk);
        newChunk.SetBlocksUnmodified();
        bool loaded = Serialization.Load(newChunk);
    }
    public void DestroyChunk(int x, int y, int z)
    {
        Chunk chunk = null;
     

        {
            Serialization.SaveChunk(chunk);
            Object.Destroy(chunk.gameObject);
            chunks.Remove(new WorldPos(x, y, z));
        }
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / multiple) * Chunk.chunkSize;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Block GetBlock(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null)
        {
            Block block = containerChunk.GetBlock(
                x - containerChunk.pos.x,
                y - containerChunk.pos.y,
                z - containerChunk.pos.z);
            return block;
        }
        els

        {
            return new BlockAir();
        }
    }
    public void SetBlock(int x, int y, int z, Block block)
    {
        Chunk chunk = GetChunk(x, y, z);
        if (chunk != null)
        {
            chunk.SetBlock(x - chunk.pos.x, y - chunk.pos.y, z - chunk.pos.z, block);
            chunk.update = true;
            UpdateIfEqual(x - chunk.pos.x, 0, new WorldPos(x - 1, y, z));
            UpdateIfEqual(x - chunk.pos.x, Chunk.chunkSize - 1, new WorldPos(x + 1, y, z));
            UpdateIfEqual(y - chunk.pos.y, 0, new WorldPos(x, y - 1, z));
            UpdateIfEqual(y - chunk.pos.y, Chunk.chunkSize - 1, new WorldPos(x, y + 1, z));
            UpdateIfEqual(z - chunk.pos.z, 0, new WorldPos(x, y, z - 1));
            UpdateIfEqual(z - chunk.pos.z, Chunk.chunkSize - 1, new WorldPos(x, y, z + 1));
        }
    }
    void UpdateIfEqual(int value1, int value2, WorldPos pos)
    {
        if (value1 == value2)
        {
            Chunk chunk = GetChunk(pos.x, pos.y, pos.z)
namespace FProj.Api
    public static class ApiToData
    {
        public static Film FilmApiToData(FilmApi filmApi)
        {
            return new Film() {
                Description = filmApi.Description,
                Director = filmApi.Director,
                Duration = filmApi.Duration,
                Id = filmApi.Id,
                PremiereDate = filmApi.PremiereDate,
                Rate = filmApi.Rate,
                Title = filmApi.Title,
                DateCreated = filmApi.DateCreated,
                UserIdCreator = filmApi.User.Id               
            };
        }
        public static Image ImageApiToData(ImageApi imageApi, int filmId, bool isPoster = false)
        {
            return new Image() {
                FilmId = filmId,
                IsPoster = isPoster,
                Id = imageApi.Id,
                Name = imageApi.Path?.Replace(WebConfigurationManager.AppSettings["ImageFolder"], "")
            };
        }
        public static Actor

        {
            return new Actor()
            {
                FirstName = actorApi.FirstName,
                Id = actorApi.Id,
                LastName = actorApi.LastName
            };
        }
        public static Genre GenreApiToData(GenreApi genreApi)
        {
            return new Genre()
            {
                Description = genreApi.Description,
                Id = genreApi.Id,
                Title = genreApi.Title
            };
        }
        public static User UserApiToData(UserApi userApi)
        {
            return new User() {
                FirtsName = userApi.FirstName,
                Id = userApi.Id,
                LastName = userApi.LastName,
                Login = userApi.Login
            };
        }
        public static Comment CommentApiToData(CommentApi commentApi)
        {
            return new Comment()
            {
                Text = commentApi.Text,
                DateCreated = commentApi.DateCreated,
                
namespace IOPriorityGuard.Native
    internal enum PROCESS_INFORMATION_CLASS
    {
        ProcessBasicInformation = 0,
        ProcessQuotaLimits,
        ProcessIoCounters,
        ProcessVmCounters,
        ProcessTimes,
        ProcessBasePriority,
        ProcessRaisePriority,
        ProcessDebugPort,
        ProcessExceptionPort,
        ProcessAccessToken,
        ProcessLdtInformation,
        ProcessLdtSize,
        ProcessDefaultHardErrorMode,
        ProcessIoPortHandlers,
        ProcessPooledUsageAndLimits,
        ProcessWorkingSetWatch,
        ProcessUserModeIOPL,
        ProcessEnableAlignmentFaultFixup,
        ProcessPriorityClass,
        ProcessWx86Information,
        ProcessHandleCount,
        ProcessAffinityMask,
        ProcessPriorityBoost,
        ProcessDeviceMap,
        ProcessSessionInformation,
        ProcessForegroundInformation,
        ProcessWow64Information,
        ProcessImageFileName,
        ProcessLUIDDeviceMapsEnabled,
        ProcessBreakO

        ProcessDebugObjectHandle,
        ProcessDebugFlags,
        ProcessHandleTracing,
        ProcessIoPriority,
        ProcessExecuteFlags,
        ProcessResourceManagement,
        ProcessCookie,
        ProcessImageInformation,
        ProcessCycleTime,
        ProcessPagePriority,
        ProcessInstrumentationCallback,
        ProcessThreadStackAllocation,
        ProcessWorkingSetWatchEx,
        ProcessImageFileNameWin32,
        ProcessImageFileMapping,
        ProcessAffinityUpdateMode,
        ProcessMemoryAllocationMode,
        MaxProcessInfoClass
    }
    internal enum STANDARD_RIGHTS : uint
    {
        WRITE_OWNER = 524288,
        WRITE_DAC = 262144,
        READ_CONTROL = 131072,
        DELETE = 65536,
        SYNCHRONIZE = 1048576,
        STANDARD_RIGHTS_REQUIRED = 983040,
        STANDARD_RIGHTS_WRITE = READ_CONTROL,
        STANDARD_RIGHTS_EXECUTE = READ_CONTROL,
        STANDARD_RIGHTS_READ = READ_CONTROL,
        STANDARD_RIGHTS_ALL = 2031616,
        

        ACCESS_SYSTEM_SECURITY = 16777216,
        MAXIMUM_ALLOWED = 33554432,
        GENERIC_WRITE = 1073741824,
        GENERIC_EXECUTE = 536870912,
        GENERIC_READ = UInt16.MaxValue,
        GENERIC_ALL = 268435456
    }
    internal enum PROCESS_RIGHTS : uint
    {
        PROCESS_TERMINATE = 1,
        PROCESS_CREATE_THREAD = 2,
        PROCESS_SET_SESSIONID = 4,
        PROCESS_VM_OPERATION = 8,
        PROCESS_VM_READ = 16,
        PROCESS_VM_WRITE = 32,
        PROCESS_DUP_HANDLE = 64,
        PROCESS_CREATE_PROCESS = 128,
        PROCESS_SET_QUOTA = 256,
        PROCESS_SET_INFORMATION = 512,
        PROCESS_QUERY_INFORMATION = 1024,
        PROCESS_SUSPEND_RESUME = 2048,
        PROCESS_QUERY_LIMITED_INFORMATION = 4096,
        PROCESS_ALL_ACCESS = STANDARD_RIGHTS.STANDARD_RIGHTS_REQUIRED | STANDARD_RIGHTS.SYNCHRONIZE | 65535
    }
    internal class Win32
    {
        [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        internal static ext
namespace InstrumentApp
    class Inventory
    {
        private List<Instrument> _inventory;
        #region Initialization
        public Inventory()
        {
            _inventory = new List<Instrument>();
        }
        #endregion
        #region Methods: Internal
        public void addInstrument(string serialNumber,
                                  double price,
                                  InstrumentSpec spec)
        {
            Instrument instrument = null;
            if (spec is GuitarSpec)
            {
                instrument  = new Guitar(serialNumber, price, (GuitarSpec)spec);
            }
            else if (spec is MandolinSpec)
            {
                instrument = new Mandolin(serialNumber, price, (MandolinSpec)spec);
            }
            
            _inventory.Add(instrument);
        }
        public Instrument get(string serialNumber)
        {
            for (int i = 0; i < _inventory.Count; i++)
            {
                Instru

                if (instrument.serialNumber.Equals(serialNumber))
                {
                    return instrument;
                }
            }
            return null;
        }
        public List<Instrument> search(InstrumentSpec searchSpec)
        {
            List<Instrument> matchingInstruments = new List<Instrument>();
            for (int i = 0; i < _inventory.Count; i++)
            {
                Instrument instrument = _inventory[i];
                if (instrument.spec.matches(searchSpec))
                {
                    matchingInstruments.Add(instrument);
                }
                
            }
            return matchingInstruments;
        }
        public List<Mandolin> search(MandolinSpec searchSpec)
        {
            List<Mandolin> matchingMandolins = new List<Mandolin>();
            for (int i = 0; i < _inventory.Count; i++)
            {
                if (!(_inventory[i] is Mandolin)) { continue; }
                Mandolin mand
namespace LiteDispatch.Web.BusinessAdapters
  public class DispatchAdapter : BaseAdapter
  {
    public DispatchNoteModel GetDispathNoteById(long id)
    {
      return ExecuteCommand(locator => GetDispathNoteByIdImpl(locator, id));
    }
    private DispatchNoteModel GetDispathNoteByIdImpl(IRepositoryLocator locator, long id)
    {
      var instance = locator.GetById<DispatchNote>(id);
      return Mapper.Map<DispatchNote, DispatchNoteModel>(instance);
    }
    public IEnumerable<DispatchNoteModel> GetAllDispatches()
    {
      return ExecuteCommand(GetAllDispatchesImpl);
    }
    private IEnumerable<DispatchNoteModel> GetAllDispatchesImpl(IRepositoryLocator locator)
    {
      var instances = locator.FindAll<DispatchNote>().ToList();
      return Mapper.Map<List<DispatchNote>, List<DispatchNoteModel>>(instances);
    }
    public DispatchNoteModel SaveDispatch(DispatchNoteModel dispatchModel)
    {
      return ExecuteCommand(locator => SaveDispatchImpl(locator, dispatchModel));

    }
    private DispatchNoteModel SaveDispatchImpl(IRepositoryLocator locator, DispatchNoteModel dispatchModel)
    {
      var entity = DispatchNote.Create(locator, dispatchModel);
      return Mapper.Map<DispatchNote, DispatchNoteModel>(entity);
    }
    public DispatchNoteModel GetLastDispatch()
    {
      return ExecuteCommand(GetLastDispatchImpl);
    }
      
    private DispatchNoteModel GetLastDispatchImpl(IRepositoryLocator locator)
    {
      var entity = locator.FindAll<DispatchNote>().OrderByDescending(d => d.CreationDate).FirstOrDefault();
      return Mapper.Map<DispatchNote, DispatchNoteModel>(entity);
    }
    public List<DispatchNoteModel> GetDispatchesBetweenDates(DateTime startDate, DateTime endDate)
    {
      return ExecuteCommand(locator => GetDispatchesBetweenDatesImpl(locator, startDate, endDate));
    }
    private List<DispatchNoteModel> GetDispatchesBetweenDatesImpl(IRepositoryLocator locator, DateTime startDate, DateTime endDate)
    {
      var disp
namespace iRocks.WebAPI.Controllers
    public class BaseApiController : ApiController
    {
        private IPostRepository    _PostRepository;
        private ICategoryRepository _CategoryRepository;
        private IVoteRepository _VoteRepository;
        private IUserRepository _UserRepository;
        public BaseApiController(IUserRepository userRepository, IPostRepository postRepository, IVoteRepository voteRepository, ICategoryRepository categoryRepository)
        {
            _UserRepository = userRepository;
            _PostRepository = postRepository;
            _VoteRepository = voteRepository;
            _CategoryRepository = categoryRepository;
        }
        protected IPostRepository ThePostRepository
        {
            get
            {
                return _PostRepository;
            }
        }
        protected ICategoryRepository TheCategoryRepository
        {
            get
            {
                return _CategoryRepository;
            }
     
namespace DAL
    public class EntityConvert
    {
        public static DispatchList ConvertToDispatchList(DataRow row)
        {
            DispatchList dispatchList = new DispatchList();
            dispatchList.cVouchType = Cast.ToString(row["cVouchType"]);
            dispatchList.cVouchName = Cast.ToString(row["cVouchName"]);
            dispatchList.cDLCode = Cast.ToString(row["cDLCode"]);
            dispatchList.dDate = Cast.ToDateTime(row["dDate"]);
            dispatchList.cBusType = Cast.ToString(row["cBusType"]);
            dispatchList.DLID = Cast.ToInteger(row["DLID"]);
            dispatchList.cSTCode = Cast .ToString(row["cSTCode"]);
            dispatchList.cSTName = Cast.ToString(row["cSTName"]);
            dispatchList.cCusCode = Cast.ToString(row["cCusCode"]);
            dispatchList.cCusAbbName = Cast.ToString(row["cCusAbbName"]);
            dispatchList.cCusName = Cast.ToString(row["cCusName"]);
            dispatchList.cDepCode = Cast.ToString(row["cDepCode

            dispatchList.cDepName = Cast.ToString(row["cDepName"]);
            dispatchList.cPersonCode = Cast.ToString(row["cPersonCode"]);
            dispatchList.cPersonName = Cast.ToString(row["cPersonName"]);
            dispatchList.cMaker = Cast.ToString(row["cMaker"]);
            dispatchList.cVerifier = Cast.ToString(row["cVerifier"]);
            dispatchList.cShipAddress = Cast.ToString(row["cShipAddress"]);
            dispatchList.ufts = Cast.ToString(row["ufts"]);
            dispatchList.cDefine1 = Cast.ToString(row["cDefine1"]);
            dispatchList.cDefine2 = Cast.ToString(row["cDefine2"]);
            dispatchList.cDefine3 = Cast.ToString(row["cDefine3"]);
            dispatchList.cDefine4 = Cast.ToDateTime(row["cDefine4"]);
            dispatchList.cDefine5 = Cast.ToInteger(row["cDefine5"]);
            dispatchList.cDefine6 = Cast.ToDateTime(row["cDefine6"]);
            dispatchList.cDefine7 = Cast.ToDouble(row["cDefine7"]);
            dispatchList.cDefine

            dispatchList.cDefine9 = Cast.ToString(row["cDefine9"]);
            dispatchList.cDefine10 = Cast.ToString(row["cDefine10"]);
            dispatchList.cDefine11 = Cast.ToString(row["cDefine11"]);
            dispatchList.cDefine12 = Cast.ToString(row["cDefine12"]);
            dispatchList.cDefine13 = Cast.ToString(row["cDefine13"]);
            dispatchList.cDefine14 = Cast.ToString(row["cDefine14"]);
            dispatchList.cDefine15 = Cast.ToInteger(row["cDefine15"]);
            dispatchList.cDefine16 = Cast.ToDouble(row["cDefine16"]);
            dispatchList.cMemo = Cast.ToString(row["cMemo"]);
            dispatchList.bReturnFlag = Cast.ToBoolean(row["bReturnFlag"]);
            return dispatchList;
        }
        public static DispatchLists ConvertToDispatchLists(DataRow row)
        {
            DispatchLists dispatchLists = new DispatchLists();
            dispatchLists.DLID = Cast.ToInteger(row["DLID"]);
            dispatchLists.AutoID = Cast.ToInteger(row
namespace LordJZ.Threading
    public static class DispatcherExtensions
    {
        public static void InvokeOrDo(this IDispatcher dispatcher, Action action)
        {
            Contract.Requires(action != null, "action");
            if (dispatcher != null && dispatcher.InvokeRequired)
                dispatcher.Invoke(action);
            else
                action();
        }
        public static T InvokeOrDo<T>(this IDispatcher dispatcher, Func<T> func)
        {
            Contract.Requires(func != null, "func");
            if (dispatcher != null && dispatcher.InvokeRequired)
                return dispatcher.Invoke(func);
            else
                return func();
        }
        public static void BeginInvokeOrDo(this IDispatcher dispatcher, Action action)
        {
            Contract.Requires(action != null, "action");
            if (dispatcher != null && dispatcher.InvokeRequired)
                dispatcher.BeginInvoke(action);
            else
             
namespace Lab.Environment.Business
    public class OrderProjectDispatchDetailServiceImpl
    {
        public void DeleteById(int DetailId)
		{
            DBProvider.OrderProjectDispatchDetailDao.DeleteById(DetailId);
		}
		public void Save(OrderProjectDispatchDetailModel model)
		{
            if (model.DetailId == 0) DBProvider.OrderProjectDispatchDetailDao.Add(model);
            else DBProvider.OrderProjectDispatchDetailDao.Update(model);
		}
        public OrderProjectDispatchDetailModel GetById(int DetailId)
		{
            return DBProvider.OrderProjectDispatchDetailDao.GetById(DetailId);
		}
		public IList<OrderProjectDispatchDetailModel> GetAll()
		{
            return DBProvider.OrderProjectDispatchDetailDao.GetAll();
		}
        public IList<OrderProjectDispatchDetailModel> GetByDispatchId(int DispatchId)
        {
            return DBProvider.OrderProjectDispatchDetailDao.GetByDispatchId(DispatchId);
        }
        public int GetCountByDispatchId(int DispatchId)
     
namespace NigelGott.Terra.Terrain
    public class ChunkRenderer
    {
        public GameObject BuildGameObject(Chunk chunk)
        {
            var terrainData = new TerrainData
            {
                heightmapResolution = chunk.Size,
                size = TerrainConfig.CreateTerrainWorldSizeFromTile(chunk),
                baseMapResolution = Mathf.Clamp(chunk.Size, 16, 2048)
            };
            terrainData.SetDetailResolution(chunk.Size, 8);
            terrainData.SetHeights(0, 0, chunk.heights);
            return UnityEngine.Terrain.CreateTerrainGameObject(terrainData);
        }
        public GameObject CreateAndSpawnChunk(Chunk chunk, GameObject parent)
        {
            var terrainObject = BuildGameObject(chunk);
            SpawnChunk(chunk, parent, terrainObject);
            return terrainObject;
        }
        public void SpawnChunk(Chunk chunk, GameObject parent, GameObject terrainObject)
        {
            terrainObject.transform.parent = par
namespace Microsoft.AspNetCore.Mvc.RazorPages.Razevolution.IR
    public class ChunkVisitor : IChunkVisitor
    {
        public void Accept(IList<Chunk> chunks)
        {
            if (chunks == null)
            {
                throw new ArgumentNullException(nameof(chunks));
            }
            foreach (Chunk chunk in chunks)
            {
                Accept(chunk);
            }
        }
        public virtual void Accept(Chunk chunk)
        {
            if (chunk == null)
            {
                throw new ArgumentNullException(nameof(chunk));
            }
            if (chunk is InjectChunk)
            {
                Visit((InjectChunk)chunk);
            }
            else if (chunk is ModelChunk)
            {
                Visit((ModelChunk)chunk);
            }
            else if (chunk is LiteralChunk)
            {
                Visit((LiteralChunk)chunk);
            }
            else if (chunk is ParentLiteralChunk)
            {
        

            }
            else if (chunk is ExpressionBlockChunk)
            {
                Visit((ExpressionBlockChunk)chunk);
            }
            else if (chunk is ExpressionChunk)
            {
                Visit((ExpressionChunk)chunk);
            }
            else if (chunk is StatementChunk)
            {
                Visit((StatementChunk)chunk);
            }
            else if (chunk is TagHelperChunk)
            {
                Visit((TagHelperChunk)chunk);
            }
            else if (chunk is TagHelperPrefixDirectiveChunk)
            {
                Visit((TagHelperPrefixDirectiveChunk)chunk);
            }
            else if (chunk is AddTagHelperChunk)
            {
                Visit((AddTagHelperChunk)chunk);
            }
            else if (chunk is RemoveTagHelperChunk)
            {
                Visit((RemoveTagHelperChunk)chunk);
            }
            else if (chunk is TypeMemberChunk)
            {
                Visit(

            }
            else if (chunk is UsingChunk)
            {
                Visit((UsingChunk)chunk);
            }
            else if (chunk is SetBaseTypeChunk)
            {
                Visit((SetBaseTypeChunk)chunk);
            }
            else if (chunk is DynamicCodeAttributeChunk)
            {
                Visit((DynamicCodeAttributeChunk)chunk);
            }
            else if (chunk is LiteralCodeAttributeChunk)
            {
                Visit((LiteralCodeAttributeChunk)chunk);
            }
            else if (chunk is CodeAttributeChunk)
            {
                Visit((CodeAttributeChunk)chunk);
            }
            else if (chunk is SectionChunk)
            {
                Visit((SectionChunk)chunk);
            }
            else if (chunk is TemplateChunk)
            {
                Visit((TemplateChunk)chunk);
            }
            else if (chunk is RazorDirectiveChunk)
            {
                Visit((RazorDirectiveC
namespace GameTools.Process
    public class ProcessManager
    {
        private List<MultiTickProcess> processes;
        public ProcessManager()
        {
            processes = new List<MultiTickProcess>();
        }
        public void Update(GameTime gameTime)
        {
            List<MultiTickProcess> toRemove = new List<MultiTickProcess>();
            foreach(MultiTickProcess process in processes)
            {
                process.Update(gameTime);
                if(process.Dead)
                    toRemove.Add(process);
            }
            RemoveTemporaryProcesses(toRemove);
        }
        public void AttachProcess(MultiTickProcess process)
        {
            processes.Add(process);
        }
        private void FinishProcess(MultiTickProcess process)
        {
            if(process.Next.Valid)
                processes.Add(process.Next.Data);
        }
        private void RemoveTemporaryProcesses(List<MultiTickProcess> toRemove)
        {
            
namespace EzTextingApiClient
    public class EzTextingClient
    {
        public RestApiClient RestApiClient { get; set; }
        private readonly Lazy<MessagingApi> _messagingApi;
        private readonly Lazy<InboxApi> _inboxApi;
        private readonly Lazy<CreditsApi> _creditsApi;
        private readonly Lazy<KeywordsApi> _keywordsApi;
        private readonly Lazy<ContactsApi> _contactsApi;
        private readonly Lazy<GroupsApi> _groupsApi;
        private readonly Lazy<MediaLibraryApi> _mediaLibraryApi;
        private readonly Lazy<ToolboxApi> _toolboxApi;
        public MessagingApi MessagingApi => _messagingApi.Value;
        public InboxApi InboxApi => _inboxApi.Value;
        public CreditsApi CreditsApi => _creditsApi.Value;
        public KeywordsApi KeywordsApi => _keywordsApi.Value;
        public ContactsApi ContactsApi => _contactsApi.Value;
        public GroupsApi GroupsApi => _groupsApi.Value;
        public MediaLibraryApi MediaLibraryApi => _mediaLibraryApi

        public ToolboxApi ToolboxApi => _toolboxApi.Value;
        public EzTextingClient(string username, string password) : this(Brand.Ez, username, password)
        {
        }
        public EzTextingClient(Brand brand, string username, string password)
        {
            RestApiClient = new RestApiClient(brand, new RequestParamAuth(username, password));
            _messagingApi = new Lazy<MessagingApi>(() => new MessagingApi(RestApiClient));
            _inboxApi = new Lazy<InboxApi>(() => new InboxApi(RestApiClient));
            _creditsApi = new Lazy<CreditsApi>(() => new CreditsApi(RestApiClient));
            _keywordsApi = new Lazy<KeywordsApi>(() => new KeywordsApi(RestApiClient));
            _contactsApi = new Lazy<ContactsApi>(() => new ContactsApi(RestApiClient));
            _groupsApi = new Lazy<GroupsApi>(() => new GroupsApi(RestApiClient));
            _mediaLibraryApi = new Lazy<MediaLibraryApi>(() => new MediaLibraryApi(RestApiClient));
            _toolboxA
namespace OptingZ.DAL
    public class UnitOfWork : IDisposable
    {
        private OptingzDbContext context = new OptingzDbContext();
        private ProductRepository productRepository;
        private ProductCategoryRepository productCategoryRepository;
        private UserFileRepository userFileRepository;
        private UserRepository userRepository;
        private UserDetailRepository userDetailRepository;
        private CategoryRepository categoryRepository;
        private SubCategoryRepository subCategoryRepository;
        private StickerRepository stickerRepository;
        #region Repos
        public ProductRepository ProductRepository
        {
            get
            {
                if (this.productRepository == null)
                {
                    this.productRepository = new ProductRepository(context);
                }
                return productRepository;
            }
        }
        public ProductCategoryRepository ProductCategoryRepository


            get
            {
                if (this.productCategoryRepository == null)
                {
                    this.productCategoryRepository = new ProductCategoryRepository(context);
                }
                return productCategoryRepository;
            }
        }
        public UserFileRepository UserFileRepository
        {
            get
            {
                if (this.userFileRepository == null)
                {
                    this.userFileRepository = new UserFileRepository(context);
                }
                return userFileRepository;
            }
        }
        public UserRepository UserRepository
        {
            get
            {
                if (this.userRepository == null)
                {
                    this.userRepository = new UserRepository(context);
                }
                return userRepository;
            }
        }
        public UserDetailRepository UserDetailRepository
        {
       

            {
                if (this.userDetailRepository == null)
                {
                    this.userDetailRepository = new UserDetailRepository(context);
                }
                return userDetailRepository;
            }
        }
        public CategoryRepository CategoryRepository
        {
            get
            {
                if (this.categoryRepository == null)
                {
                    this.categoryRepository = new CategoryRepository(context);
                }
                return categoryRepository;
            }
        }
        public SubCategoryRepository SubCategoryRepository
        {
            get
            {
                if (this.subCategoryRepository == null)
                {
                    this.subCategoryRepository = new SubCategoryRepository(context);
                }
                return subCategoryRepository;
            }
        }
        public StickerRepository StickerRepository
        {
       
﻿namespace Allors.Web
    public class InvokeResponseBuilder
    {
        private readonly ISession session;
        private readonly InvokeRequest invokeRequest;
        private string @group;
        private User user;
        public InvokeResponseBuilder(ISession session, User user, InvokeRequest invokeRequest, string @group)
        {
            this.session = session;
            this.user = user;
            this.invokeRequest = invokeRequest;
            this.group = group;
        }
        public InvokeResponse Build()
        {
            if (this.invokeRequest.M == null || this.invokeRequest.I == null || this.invokeRequest.V == null)
            {
                throw new ArgumentException();
            }
            var obj = this.session.Instantiate(this.invokeRequest.I);
            var composite = (Composite)obj.Strategy.Class;
            var methodTypes = composite.MethodTypesByGroup[@group];
            var methodType = methodTypes.FirstOrDefault(x => x.Name.Equa

            if (methodType == null)
            {
                throw new Exception("Method " + this.invokeRequest.M + " not found.");   
            }
            
            var invokeResponse = new InvokeResponse();
            if (!this.invokeRequest.V.Equals(obj.Strategy.ObjectVersion.ToString()))
            {
                invokeResponse.AddVersionError(obj);
            }
            else
            {
                var acl = new AccessControlList(obj, this.user);
                if (acl.CanExecute(methodType))
                {
                    var method = obj.GetType().GetMethod(methodType.Name, new Type[] { });
                    method.Invoke(obj, null);
                    var derivationLog = this.session.Derive();
                    if (!derivationLog.HasErrors)
                    {
                        this.session.Commit();
                    }
                    else
                    {
                        invokeResponse.AddDerivationErrors(de
namespace GameServer.Logic
    public class PorcessCmdMoniter
    {
        public int cmd;
        public int processNum = 0;
        public long processTotalTime = 0;
        public long processMaxTime = 0;
        public long waitProcessTotalTime = 0;
        public long maxWaitProcessTime = 0;
        public long Num_Faild;
        public long Num_OK;
        public long Num_WithData;
        public PorcessCmdMoniter(int cmd, long processTime)
        {
            this.cmd = cmd;
            processNum++;
            processTotalTime += processTime;
            processMaxTime = processTime;
        }
        public void onProcess(long processTime, long waitTime)
        {
            processNum++;
            processTotalTime += processTime;
            processMaxTime = processMaxTime >= processTime ? processMaxTime : processTime;
            waitProcessTotalTime += waitTime;
            maxWaitProcessTime = maxWaitProcessTime >= waitTime ? maxWaitProcessTime : waitTime;
        }
namespace Instrument.DataAccess
    public class InstrumentRepairPlanDaoImpl
    {
        public void DeleteByInstrumentId(int InstrumentId)
        {
            DBProvider.dbMapper.Delete("Instrument_RepairPlan.DeleteByInstrumentId", InstrumentId);
        }
        public void Add(InstrumentRepairPlanModel model)
        {
            DBProvider.dbMapper.Insert("Instrument_RepairPlan.Insert", model);
        }
        public void Update(InstrumentRepairPlanModel model)
        {
            DBProvider.dbMapper.Update("Instrument_RepairPlan.Update", model);
        }
        public void DeleteById(int PlanId)
        {
            DBProvider.dbMapper.Delete("Instrument_RepairPlan.DeleteById", PlanId);
        }
        public InstrumentRepairPlanModel GetById(int PlanId)
        {
            return DBProvider.dbMapper.SelectObject<InstrumentRepairPlanModel>("Instrument_RepairPlan.GetByID", PlanId);
        }
        public IList<InstrumentRepairPlanModel> GetAll()
        {
       
﻿/*
* SXZ Reference Implementation
* Copyright (c) 2014, Dark Lilac. All rights reserved.
* This library is free software; you can redistribute it and/or
* modify it under the terms of the GNU Lesser General Public
* License as published by the Free Software Foundation; either
* version 2.1 of the License, or (at your option) any later version.
* This library is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
* You should have received a copy of the GNU Lesser General Public
* License along with this library; if not, write to the Free Software
* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
* MA 02110-1301 USA
*/
namespace Library
    public class Frame
    {
        public Frame()
        {
            Chunks = new List<Chunk>();
        }
        public static string Label { get { return "FR"

        public List<Chunk> Chunks { get; private set; }
        public Chunk GetSelected(int x, int y)
        {
            for (int i = this.Chunks.Count - 1; i >= 0; i--)
            {
                Chunk chunk = this.Chunks[i];
                if (chunk.IsPalette())
                {
                    continue;
                }
                if (chunk.IsBackground())
                {
                    continue;
                }
                SxzPoint boundingBox = new SxzPoint(0, 0);
                SxzPoint origin = chunk.Origin;
                chunk.EnsureDimensions(boundingBox);
                if (x >= origin.X && y >= origin.Y && x < (boundingBox.X) && y < (boundingBox.Y))
                {
                    if (chunk.GetColor(x, y) != null)
                    {
                        return chunk;
                    }
                }
            }
            return null;
        }
        public byte[] GetData()
        {
            List<byte> result =

            byte[] byteLabel = Encoding.ASCII.GetBytes(Label);
            Writer.AddBytes(result, byteLabel);
            foreach (Chunk chunk in Chunks)
            {
                result.AddRange(chunk.GetData());
            }
            Writer.WriteSizeInt(result);
            return result.ToArray();
        }
        public void SetData(byte[] data)
        {
            int index = 0;
            PaletteChunk paletteChunk = new DefaultPaletteChunk();
            while (index < data.Length)
            {
                string label = Encoding.ASCII.GetString(data, index, 2);
                if (label.Equals(ColorBitPlaneChunk.Label))
                {
                  int size = BitConverter.ToInt16(data, index + 2);
                  byte[] chunkData = new byte[size + 4];
                  Array.Copy(data, index, chunkData, 0, chunkData.Length);
                  ColorBitPlaneChunk colorChunk = new ColorBitPlaneChunk();
                  colorChunk.Palette = paletteChunk;
#region Copyright
#endregion
namespace Potato.Net.Shared.Test {
    [TestFixture]
    public class PacketDispatchTest {
        [Test]
        public void TestPacketDispatchEquality() {
            PacketDispatch dispatchA = new PacketDispatch() {
                Name = "equal"
            };
            PacketDispatch dispatchB = new PacketDispatch() {
                Name = "equal"
            };
            Assert.IsTrue(dispatchA.Equals(dispatchB));
        }
        [Test]
        public void TestPacketDispatchEqualityAgainstNull() {
            PacketDispatch dispatch = new PacketDispatch() {
                Name = "equal"
            };
            Assert.IsFalse(dispatch.Equals(null));
        }
        [Test]
        public void TestPacketDispatchEqualityCastToObjectAgainstNull() {
            Object dispatch = new PacketDispatch() {
                Name = "equal"
            };
            Assert.IsFalse(dispatch.Equals(null));
        }
        [Test]
        public void Tes

            PacketDispatch dispatchA = new PacketDispatch() {
                Name = "equal"
            };
            PacketDispatch dispatchB = dispatchA;
            Assert.IsTrue(dispatchA.Equals(dispatchB));
        }
        [Test]
        public void TestPacketDispatchEqualityAgainstReferenceToSameObjectCastToObject() {
            PacketDispatch dispatchA = new PacketDispatch() {
                Name = "equal"
            };
            Object dispatchB = dispatchA;
            Assert.IsTrue(dispatchA.Equals(dispatchB));
        }
        [Test]
        public void TestPacketDispatchEqualityAgainstDifferenceType() {
            PacketDispatch dispatchA = new PacketDispatch() {
                Name = "equal"
            };
            String dispatchB = "equal";
            Assert.IsFalse(dispatchA.Equals(dispatchB));
        }
        [Test]
        public void TestPacketDispatchEqualityHashCode() {
            PacketDispatch dispatchA = new PacketDispatch() {
               
namespace QuantBox.Demo.Extension
    public enum StopIndicator
    {
        Price,
        Value,
    }
    public class StopEx : Stop
    {
        StopIndicator indicator;
        double _trailPrice;
        double _trailValue;
        public StopEx(SmartQuant.Strategy strategy, SmartQuant.Position position, DateTime time)
            : base(strategy, position, time)
        {
        }
        public StopEx(SmartQuant.Strategy strategy, SmartQuant.Position position, double level, StopType type, StopMode mode, StopIndicator stopIndicator)
            :base(strategy, position, level, type, mode)
        {
            this.indicator = stopIndicator;
        }
            
        protected override double GetPrice(double price)
        {
            if (this.indicator == StopIndicator.Price)
            {
                return base.GetPrice(price);
            }
            double  factor = (instrument.Factor == 0.0 ? 1.0 : instrument.Factor);
            return price * factor * pos
namespace LendingLibrary_Library_Tests.MusicSelectionTests
    [TestClass]
    public class InstrumentPartTests
    {
        [TestMethod]
        [ExpectedException(typeof(ArgumentNullException), "In class InstrumentPart, constructor.  String argument instrumentName cannot be null.")]
        public void InstrumentPart_Constructor_StringArgumentInstrumentNameIsNull_ThrowsArgumentNullException()
        {
            InstrumentPart myInstrumentPart;
            myInstrumentPart = new InstrumentPart(null, 1);
        }
        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "In class InstrumentPart, constructor.  String argument instrumentName cannot be empty.")]
        public void InstrumentPart_Constructor_StringArgumentInstrumentNameIsEmpty_ThrowsArgumentException()
        {
            InstrumentPart myInstrumentPart;
            myInstrumentPart = new InstrumentPart("", 1);
        }
        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "In

        public void InstrumentPart_Constructor_StringArgumentInstrumentNameIsWhiteSpace_ThrowsArgumentException()
        {
            InstrumentPart myInstrumentPart;
            myInstrumentPart = new InstrumentPart("  ", 1);
        }
        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "In class InstrumentPart, constructor.  Int argument numberOfCopies cannot be less than zero.")]
        public void InstrumentPart_Constructor_IntArgumentNumberOfCopiesLessThanZero_ThrowsArgumentException()
        {
            InstrumentPart myInstrumentPart;
            myInstrumentPart = new InstrumentPart("Flute", -1);
        }
        [TestMethod]
        public void InstrumentPart_Constructor_ClassFieldInstrumentNameCorrectlySet()
        {
            InstrumentPart myInstrumentPart;
            myInstrumentPart = new InstrumentPart("  Flute ", 1);
            Assert.AreEqual("Flute", myInstrumentPart.InstrumentName);
        }
        [TestMethod]
        public voi
namespace Dux.Infrastructure
    public interface IUnitOfWork
    {
        INomeListaRepository NomeListaRepository { get; }
        IUsuarioListaRepository UsuarioListaRepository { get; }
        IUsuarioCasaSelecRepository UsuarioCasaSelecRepository { get; }
        ICasaRepository CasaRepository { get; }
        IClientRepository ClientRepository { get; }
        IDistribuicaoRepository DistribuicaoRepository { get; }
        IListaRepository ListaRepository { get; }
        IAgendamentoRepository AgendamentoRepository { get; }
        IEventoRepository EventoRepository { get; }
        IGrupoRepository GrupoRepository { get; }
        ILayoutAgendamentoRepository LayoutAgendamentoRepository { get; }
        ILayoutDistribuicaoRepository LayoutDistribuicaoRepository { get; }
        ILayoutListaRepository LayoutListaRepository { get; }
        IPerfilDistribuicaoRepository PerfilDistribuicaoRepository { get; }
        IPerfilListaRepository PerfilListaRepository { get; }
        IR
namespace Shion.Ast
    [AstType("BinaryExpression")]
    public class BinaryExpression : INode, IOperation
    {
        public INode Left { get; set; }
        public INode Right { get; set; }
        public string Operator { get; set; }
        public INode New(dynamic node)
        {
            Left = AstTree.Factory(node.Left);
            Right = AstTree.Factory(node.Right);
            Operator = node.Operator;
            return this;
        }
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("(");
            sb.Append(Left.ToString());
            sb.Append(" ");
            sb.Append(Operator);
            sb.Append(" ");
            sb.Append(Right.ToString());
            sb.Append(")");
            return sb.ToString();
        }
        public dynamic Invoke(Scope scope)
        {
            switch (Operator)
            {
                case "+":
                    return ((IOperation)Left).Invoke(sc

                case "-":
                    return ((IOperation)Left).Invoke(scope) - ((IOperation)Right).Invoke(scope);
                case "*":
                    return ((IOperation)Left).Invoke(scope) * ((IOperation)Right).Invoke(scope);
                case "/":
                    return ((IOperation)Left).Invoke(scope) / ((IOperation)Right).Invoke(scope);
                case ">":
                    return ((IOperation)Left).Invoke(scope) > ((IOperation)Right).Invoke(scope);
                case "<":
                    return ((IOperation)Left).Invoke(scope) < ((IOperation)Right).Invoke(scope);
                case ">=":
                    return ((IOperation)Left).Invoke(scope) >= ((IOperation)Right).Invoke(scope);
                case "<=":
                    return ((IOperation)Left).Invoke(scope) <= ((IOperation)Right).Invoke(scope);
                case "==":
                    return ((IOperation)Left).Invoke(scope).ToString() == ((IOperation)Right).Invoke(scope)

                case "===":
                    return ((IOperation)Left).Invoke(scope) == ((IOperation)Right).Invoke(scope);
                case "!=":
                    return ((IOperation)Left).Invoke(scope).ToString() != ((IOperation)Right).Invoke(scope).ToString();
                case "!==":
                    return ((IOperation)Left).Invoke(scope) != ((IOperation)Right).Invoke(scope);
                case "%":
                    return ((IOperation)Left).Invoke(scope) % ((IOperation)Right).Invoke(scope);
                case "&":
                    return ((IOperation)Left).Invoke(scope) & ((IOperation)Right).Invoke(scope);
                case "&&":
                    return ((IOperation)Left).Invoke(scope) && ((IOperation)Right).Invoke(scope);
                case "|":
                    return ((IOperation)Left).Invoke(scope) | ((IOperation)Right).Invoke(scope);
                case "||":
                    return ((IOperation)Left).Invoke(scope) || ((IOperation)Rig
namespace WebApplication1.Models
	public static class RepositoryHelper
	{
		public static IUnitOfWork GetUnitOfWork()
		{
			return new EFUnitOfWork();
		}		
		
		public static ClientRepository GetClientRepository()
		{
			var repository = new ClientRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static ClientRepository GetClientRepository(IUnitOfWork unitOfWork)
		{
			var repository = new ClientRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OccupationRepository GetOccupationRepository()
		{
			var repository = new OccupationRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OccupationRepository GetOccupationRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OccupationRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OrderRepository GetOrderRepository()
		{
			var repository = new Orde

			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OrderRepository GetOrderRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OrderRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OrderLineRepository GetOrderLineRepository()
		{
			var repository = new OrderLineRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OrderLineRepository GetOrderLineRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OrderLineRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static ProductRepository GetProductRepository()
		{
			var repository = new ProductRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static ProductRepository GetProductRepository(IUnitOfWork unitOfWork)
		{
			var repository = new ProductRepository();
			repository.UnitOfWork = unitOfWork;
			return repo
namespace OneDbgClient.ViewModels
    public class ProcessViewModel : CommonViewModel
    {
        private int _pid;
        private string _name;
        private string _processType;
        private Process _innerProcess;
        public int PID
        {
            get { return _pid; }
            set
            {
                _pid = value;
                RaisePropertyChanged();
            }
        }
        public string Name
        {
            get { return _name; }
            set
            {
                _name = value;
                RaisePropertyChanged();
            }
        }
        public string ProcessType
        {
            get { return _processType; }
            set
            {
                _processType = value; 
                RaisePropertyChanged();
            }
        }
        public Process InnerProcess
        {
            get { return _innerProcess; }
            set
            {
                _innerProcess = value; 
              
namespace Onshape.Api.Client
    internal static class Constants
    {
        #region OAuth
        internal const string AUTH_FORM_TEMPLATE = "code={0}&client_id={1}&client_secret={2}&grant_type=authorization_code&redirect_uri={3}";
        internal const string TOKEN_URI_TEMPLATE = @"{0}/oauth/token";
        #endregion
        #region Onshape REST API URIs
        public const string DOCUMENTS_API_URI = @"/api/documents";
        public const string DOCUMENT_API_URI = @"/api/documents/{0}";
        public const string WORKSPACES_API_URI = @"/api/documents/d/{0}/workspaces";
        public const string WORKSPACE_API_URI = @"/api/documents/d/{0}/workspaces/{1}";
        public const string VERSIONS_API_URI = @"/api/documents/d/{0}/versions";
        public const string VERSION_API_URI = @"/api/documents/d/{0}/versions/{1}";
        public const string ELEMENTS_API_URI = @"/api/documents/d/{0}/{1}/{2}/elements";
        public const string ELEMENT_API_URI = @"/api/documents/d/{0}/{1}/

        public const string USER_API_URI = @"/api/users/{0}";
        public const string EXPORT_PARTSTUDIO_API_URI = @"/api/partstudios/d/{0}/{1}/{2}/e/{3}/{4}";
        public const string EXPORT_PART_API_URI = @"/api/parts/d/{0}/{1}/{2}/e/{3}/partid/{4}/{5}";
        public const string PURCHASES_API_URI = @"/api/accounts/purchases";
        public const string PURCHASE_API_URI = @"/api/accounts/purchases/{0}";
        public const string CONSUME_PURCHASE_API_URI = @"/api/accounts/purchases/{0}/consume";
        public const string BILLING_PLAN_API_URI = @"/api/billing/plans/{0}";
        public const string CLIENT_BILLING_PLANS_API_URI = @"/api/billing/plans/client/{0}";
        public const string ELEMENT_TRANSLATIONS_API_URI = @"/api/{0}/d/{1}/w/{2}/e/{3}/translations";
        public const string ELEMENT_TRANSLATION_FORMATS_API_URI = @"/api/{0}/d/{1}/w/{2}/e/{3}/translationformats";
        public const string CREATE_TRANSLATION_API_URI = @"/api/translations/d/{0}/w/{1}";
     
namespace Rabbit.Rpc.ProxyGenerator.Implementation
    public abstract class ServiceProxyBase
    {
        #region Field
        private readonly IRemoteInvokeService _remoteInvokeService;
        private readonly ITypeConvertibleService _typeConvertibleService;
        #endregion Field
        #region Constructor
        protected ServiceProxyBase(IRemoteInvokeService remoteInvokeService, ITypeConvertibleService typeConvertibleService)
        {
            _remoteInvokeService = remoteInvokeService;
            _typeConvertibleService = typeConvertibleService;
        }
        #endregion Constructor
        #region Protected Method
        protected async Task<T> Invoke<T>(IDictionary<string, object> parameters, string serviceId)
        {
            var message = await _remoteInvokeService.InvokeAsync(new RemoteInvokeContext
            {
                InvokeMessage = new RemoteInvokeMessage
                {
                    Parameters = parameters,
                    Serv
namespace MultiMethods.Tests
	[TestFixture]
	public class CombinatorialDispatchTests
	{
		[Test, Combinatorial]
		public void Combinatorial_Test_All_4_Argument_Dispatch(
			[Values("A", "B", "C", "D")] string arg1,
			[Values("A", "B", "C", "D")] string arg2,
			[Values("A", "B", "C", "D")] string arg3,
			[Values("A", "B", "C", "D")] string arg4)
		{
			A a1 = DispatchTestHelper.CreateInstance(arg1);
			A a2 = DispatchTestHelper.CreateInstance(arg2);
			A a3 = DispatchTestHelper.CreateInstance(arg3);
			A a4 = DispatchTestHelper.CreateInstance(arg4);
			DispatchTestHelper check = new DispatchTestHelper();
			string expected = arg1 + arg2 + arg3 + arg4;
			Assert.AreEqual(expected, check.FF4(a1, a2, a3, a4));
		}
		[Test, Combinatorial]
		public void Combinatorial_Test_All_3_Argument_Dispatch(
			[Values("A", "B", "C", "D")] string arg1,
			[Values("A", "B", "C", "D")] string arg2,
			[Values("A", "B", "C", "D")] string arg3)
		{
			A a1 = DispatchTestHelper.CreateInstance(arg1);
			A 
namespace PlayGen.SUGAR.Data.EntityFramework.UnitTests
	public abstract class ControllerLocator
	{
		public const string ConnectionString = "Server=localhost;Port=3306;Database=sugarunittests;Uid=root;Pwd=t0pSECr3t;Convert Zero Datetime=true;Allow Zero Datetime=true;Pooling=false";
		public static readonly SUGARContextFactory ContextFactory = new SUGARContextFactory(ConnectionString);
		private static AccountController _accountController;
		private static AccountSourceController _accountSourceController;
		private static ActorController _actorController;
		private static ActorClaimController _actorClaimController;
		private static ActorRoleController _actorRoleController;
		private static ClaimController _claimController;
		private static GameController _gameController;
		private static EvaluationDataController _evaluationDataController;
		private static GroupController _groupController;
		private static GroupRelationshipController _groupRelationshipController;
		private static Leaderb

		private static EvaluationController _evaluationController;
		private static RoleController _roleController;
		private static RoleClaimController _roleClaimController;
		private static UserController _userController;
		private static UserRelationshipController _userRelationshipController;
		private static MatchController _matchController;
		public static AccountController AccountController
			=> _accountController ?? (_accountController = new AccountController(ContextFactory));
		public static AccountSourceController AccountSourceController
			=> _accountSourceController ?? (_accountSourceController = new AccountSourceController(ContextFactory));
		public static EvaluationController EvaluationController
			=> _evaluationController ?? (_evaluationController = new EvaluationController(ContextFactory));
		public static ActorController ActorController
			=> _actorController ?? (_actorController = new ActorController(ContextFactory));
		public static ActorClaimController ActorClaimControl

			=> _actorClaimController ?? (_actorClaimController = new ActorClaimController(ContextFactory));
		public static ActorRoleController ActorRoleController
			=> _actorRoleController ?? (_actorRoleController = new ActorRoleController(ContextFactory));
		public static ClaimController ClaimController
			=> _claimController ?? (_claimController = new ClaimController(ContextFactory));
		public static GameController GameController
			=> _gameController ?? (_gameController = new GameController(ContextFactory));
		public static EvaluationDataController EvaluationDataController
			=> _evaluationDataController ?? (_evaluationDataController = new EvaluationDataController(ContextFactory));
		public static GroupController GroupController
			=> _groupController ?? (_groupController = new GroupController(ContextFactory));
		public static GroupRelationshipController GroupRelationshipController
			=> _groupRelationshipController ?? (_groupRelationshipController = new GroupRelationshipController(Contex
namespace InstrumentApp
    class FindInstrumentTester
    {
        public static void testInstrumentSearch()
        {
            Inventory inventory = new Inventory();
            initializeInventory(inventory);
            Dictionary<string, object> guitarSpec = new Dictionary<string, object>{
                                                                { "instrumentType", InstrumentType.Guitar },
                                                                { "builder", Builder.Fender},
                                                                { "model", "Stratocastor" },
                                                                { "type", Type.electric},
                                                                { "topWood", Wood.Alder},
                                                                { "backWood", Wood.Adirondack},
                                                                { "numStrings", 6}
                                             

            InstrumentSpec whatErinLikes = new InstrumentSpec(guitarSpec);
            findInstrument("Erin", whatErinLikes, inventory);
            Dictionary<string, object> mandolinSpec = new Dictionary<string, object>{
                                                                { "instrumentType", InstrumentType.Mandolin },
                                                                { "builder", Builder.Fender},
                                                                { "model", "Stratocastor" },
                                                                { "type", Type.acoustic},
                                                                { "topWood", Wood.Alder},
                                                                { "backWood", Wood.Alder},
                                                                { "style", Style.A}
                                                        };
            InstrumentSpec whatPhilLikes = new InstrumentSpec(ma

            findInstrument("Phil", whatPhilLikes, inventory);
            Dictionary<string, object> multiInstrumentSpec = new Dictionary<string, object>{
                                                                { "builder", Builder.Gibson},
                                                                { "backWood", Wood.Maple},
                                                        };
            InstrumentSpec whatSallyLikes = new InstrumentSpec(multiInstrumentSpec);
            findInstrument("Sally", whatSallyLikes, inventory);
        }
        private static void findInstrument(string name, InstrumentSpec instrumentSpec, Inventory inventory)
        {
            List<Instrument> instruments = inventory.search(instrumentSpec);
            if (instruments.Count > 0)
            {
                try
                {
                    string msgSuccess = string.Format("{0}, you might like these instruments: ", name);
                    foreach (Instrument instrument 
public class GenerateEndlessLevel : MonoBehaviour {
	public GameObject[] availableChunks;
	public int[] chunkSpawnChances;
	public List<GameObject> currentChunks;
	private float screenWidthInPoints;
	void Start () {
		float height = 2.0f * Camera.main.orthographicSize;
		screenWidthInPoints = height * Camera.main.aspect;
	}
	void FixedUpdate () {
		GenerateChunkIfRequired();
	}
	public void AddChunk(float FarthestChunkEndX) {
		int randomChunkIndex = Random.Range(0, chunkSpawnChances.Length);
		GameObject chunk = (GameObject)Instantiate(availableChunks[chunkSpawnChances[randomChunkIndex]]);
		float chunkWidth = chunk.transform.FindChild("void").localScale.x;
		float chunkCenter = FarthestChunkEndX + chunkWidth * 0.5f;
		chunk.transform.position = new Vector3(chunkCenter, 0, 0);
		currentChunks.Add(chunk);
	}
	void GenerateChunkIfRequired() {
		List<GameObject> chunksToRemove = new List<GameObject>();
		bool addChunks = true;        
		float playerX = transform.position.x;
		float remov
namespace Nest
	public partial class ElasticClient
	{
		public IDeleteResponse Delete<T>(Func<DeleteDescriptor<T>, DeleteDescriptor<T>> deleteSelector) 
			where T : class
		{
			return this.Dispatcher.Dispatch<DeleteDescriptor<T>, DeleteRequestParameters, DeleteResponse>(
				deleteSelector,
				(p, d) => this.RawDispatch.DeleteDispatch<DeleteResponse>(p)
			);
		}
		public IDeleteResponse Delete(IDeleteRequest deleteRequest) 
		{
			return this.Dispatcher.Dispatch<IDeleteRequest, DeleteRequestParameters, DeleteResponse>(
				deleteRequest,
				(p, d) => this.RawDispatch.DeleteDispatch<DeleteResponse>(p)
			);
		}
		public Task<IDeleteResponse> DeleteAsync<T>(Func<DeleteDescriptor<T>, DeleteDescriptor<T>> deleteSelector)
			where T : class
		{
			return this.Dispatcher.DispatchAsync<DeleteDescriptor<T>, DeleteRequestParameters, DeleteResponse, IDeleteResponse>(
				deleteSelector,
				(p, d) => this.RawDispatch.DeleteDispatchAsync<DeleteResponse>(p)
			);
		}
		public Task<IDeleteResp
public class Stairway : MonoBehaviour {
	public Transform player;
	public float distanceToPlayer = 5.0f;
	public GameObject firstChunk;
	public int totalSteps;
	public int chunkSizeInStepts = 10;
	public Vector3 chunkPosIncremental;
	public GameObject[] chunks;
	private List<GameObject> chunkInstances;
	private GameObject currentChunk;
	void Start () {
		currentChunk = firstChunk;
		totalSteps = chunkSizeInStepts;
		chunkInstances = new List<GameObject> ();
		chunkInstances.Add (currentChunk);
	}
	void Update () {
		
	}
	public GameObject addRandomChunk(){
		int max = chunks.Length;
		int value = Random.Range (0, max);
		return instantiateChunk (value);
	}
	private GameObject instantiateChunk(int index){
		GameObject chunk = (GameObject)Instantiate (chunks [index], Vector3.zero, Quaternion.identity);
		chunk.transform.parent = this.transform;
		chunk.transform.localPosition = currentChunk.transform.position + chunkPosIncremental;
		currentChunk.GetComponent<Chunk> ().nextChunk = chunk.
﻿/*
 * Original author: Vagisha Sharma <vsharma .at. u.washington.edu>,
 *                  MacCoss Lab, Department of Genome Sciences, UW
 *
 * Copyright 2012 University of Washington - Seattle, WA
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
namespace pwiz.SkylineTestA
    [TestClass]
    public class InstrumentInfoUtilTest : AbstractUnitTest
    {
        [TestMethod]
        public void TestParse()
        {
            var instrumentConfigList = InstrumentInfoUtil.GetInstrumentInfo(null).ToList();
            Assert.AreEq

            instrumentConfigList = InstrumentInfoUtil.GetInstrumentInfo("").ToList();
            Assert.AreEqual(0, instrumentConfigList.Count());
            var str = "\n\n";
            instrumentConfigList = InstrumentInfoUtil.GetInstrumentInfo(str).ToList();
            Assert.AreEqual(0, instrumentConfigList.Count(), str);
            str = "\n" + InstrumentInfoUtil.MODEL;
            instrumentConfigList = InstrumentInfoUtil.GetInstrumentInfo(str).ToList();
            Assert.AreEqual(0, instrumentConfigList.Count(), str);
            instrumentConfigList = InstrumentInfoUtil.GetInstrumentInfo(INFO1).ToList();
            Assert.AreEqual(0, instrumentConfigList.Count(), INFO1);
            
            instrumentConfigList = InstrumentInfoUtil.GetInstrumentInfo(INFO2).ToList();
            Assert.AreEqual(1, instrumentConfigList.Count(), INFO2);
            Assert.AreEqual("MS_TSQ_Vantage", instrumentConfigList[0].Model);
            Assert.AreEqual("", instrumentConfigList[0]

            Assert.AreEqual("", instrumentConfigList[0].Analyzer);
            Assert.IsNull(instrumentConfigList[0].Detector);
            instrumentConfigList = InstrumentInfoUtil.GetInstrumentInfo(INFO3).ToList();
            Assert.AreEqual(1, instrumentConfigList.Count(), INFO3);
            instrumentConfigList = InstrumentInfoUtil.GetInstrumentInfo(INFO4).ToList();
            Assert.AreEqual(2, instrumentConfigList.Count(), INFO4);
            Assert.AreEqual("MS_TSQ_Vantage", instrumentConfigList[0].Model);
            Assert.AreEqual("MS_LTQ_FT", instrumentConfigList[1].Model);
            Assert.AreEqual("", instrumentConfigList[0].Ionization);
            Assert.AreEqual("MS_ionization_type", instrumentConfigList[1].Ionization);
            Assert.AreEqual("", instrumentConfigList[0].Analyzer);
            Assert.AreEqual("", instrumentConfigList[1].Analyzer);
            Assert.IsNull(instrumentConfigList[0].Detector);
            Assert.AreEqual("", instrumentConfigList[
namespace Nest
	public partial class ElasticClient
	{
		public ISuggestResponse Suggest<T>(Func<SuggestDescriptor<T>, SuggestDescriptor<T>> selector)
			where T : class
		{
			return this.Dispatcher.Dispatch<SuggestDescriptor<T>, SuggestRequestParameters, SuggestResponse>(
				selector,
				(p, d) => this.RawDispatch.SuggestDispatch<SuggestResponse>(p, d)
			);
		}
		public ISuggestResponse Suggest(ISuggestRequest suggestRequest)
		{
			return this.Dispatcher.Dispatch<ISuggestRequest, SuggestRequestParameters, SuggestResponse>(
				suggestRequest,
				(p, d) => this.RawDispatch.SuggestDispatch<SuggestResponse>(p, d)
			);
		}
		public Task<ISuggestResponse> SuggestAsync<T>(Func<SuggestDescriptor<T>, SuggestDescriptor<T>> selector)
			where T : class
		{
			return this.Dispatcher.DispatchAsync<SuggestDescriptor<T>, SuggestRequestParameters, SuggestResponse, ISuggestResponse>(
				selector,
				(p, d) => this.RawDispatch.SuggestDispatchAsync<SuggestResponse>(p, d)
			);
		}
		public Task
public class World : MonoBehaviour {
	public Chunk chunk;
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public static int chunkMargin = 2;
    public static int chunkHeight = 128;
    public static int chunkSize = 30;
	void Start()
	{
        /*
		for(int x = 0; x < sizeX; ++x)
		{
			for(int z = 0; z < sizeZ; ++z)
			{
				for(int y = 0; y < sizeY; ++y)
				{
					pending.Add (new WorldPos(x, y, z));
				}
			}
		}
		CreateChunk();
        */
	}
	void Update()
	{
        /*
		if(pending.Count > 0)
		{
			if(temp.Complete())
			{
				CreateChunk();
			}
		}
        */
	}
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float multiple = chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * chunkSize;
        pos.z = Mathf.FloorToInt(z / multiple) * chunkSize;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out 
namespace Excel_Interface
    public abstract class InstrumentInfoViewModel : IXmlData
    {
        #region Event
        public event PropertyChangedEventHandler PropertyChanged;
        
        protected void NotifyPropertyChanged(string propertyName)
        {
            if (PropertyChanged != null)
            {
                PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
            }
        }
        #endregion
        
        public InstrumentInfoViewModel() { }
        
        #region Type_
        private string type_;
        public string Type_
        {
            get { return this.type_; }
            set
            {
                if (this.type_ != value)
                {
                    this.type_ = value;
                    this.NotifyPropertyChanged("Type_");
                }
            }
        }
        #endregion
        
        #region StandardInstrumentViewModel_
        private StandardInstrumentViewModel standardInstrume

        public StandardInstrumentViewModel StandardInstrumentViewModel_
        {
            get { return this.standardInstrumentViewModel_; }
            set
            {
                if (this.standardInstrumentViewModel_ != value)
                {
                    this.standardInstrumentViewModel_ = value;
                    this.NotifyPropertyChanged("StandardInstrumentViewModel_");
                }
            }
        }
        #endregion
        
        #region StandardSwapInstrumentViewModel_
        private StandardSwapInstrumentViewModel standardSwapInstrumentViewModel_;
        public StandardSwapInstrumentViewModel StandardSwapInstrumentViewModel_
        {
            get { return this.standardSwapInstrumentViewModel_; }
            set
            {
                if (this.standardSwapInstrumentViewModel_ != value)
                {
                    this.standardSwapInstrumentViewModel_ = value;
                    this.NotifyPropertyChanged("StandardSwap

                }
            }
        }
        #endregion
        
        #region CreditInstrumentViewModel_
        private CreditInstrumentViewModel creditInstrumentViewModel_;
        public CreditInstrumentViewModel CreditInstrumentViewModel_
        {
            get { return this.creditInstrumentViewModel_; }
            set
            {
                if (this.creditInstrumentViewModel_ != value)
                {
                    this.creditInstrumentViewModel_ = value;
                    this.NotifyPropertyChanged("CreditInstrumentViewModel_");
                }
            }
        }
        #endregion
        
        #region FixedBondInstrumentViewModel_
        private FixedBondInstrumentViewModel fixedBondInstrumentViewModel_;
        public FixedBondInstrumentViewModel FixedBondInstrumentViewModel_
        {
            get { return this.fixedBondInstrumentViewModel_; }
            set
            {
                if (this.fixedBondInstrumentViewModel_ != va
namespace DAL.UoW
    public sealed class UnitOfWork : IDisposable
    {
        private readonly ApplicationContext _context;
        private bool _disposed;
        private CompanyRepository _companyRepository;
        private UserRepository _userRepository;
        private CompanyCommentRepository _companyCommentRepository;
        private CompanyRecallRepository _companyRecallRepository;
        private VacancyRepository _vacancyRepository;
        private AddressRepository _addressRepository;
        private CityRepository _cityRepository;
        private RegionRepository _regionRepository;
        private EventRepository _eventRepository;
        private PublicationRepository _publicationRepository;
        public UnitOfWork()
        {
            _context = new ApplicationContext();
        }
        public PublicationRepository Publications => _publicationRepository ?? (_publicationRepository = new PublicationRepository(_context));
        public EventRepository Events => _eve

        public RegionRepository Regions => _regionRepository ?? (_regionRepository = new RegionRepository(_context));
        public CityRepository Cities => _cityRepository ?? (_cityRepository = new CityRepository(_context));
        public AddressRepository Addresses => _addressRepository ?? (_addressRepository = new AddressRepository(_context));
        public VacancyRepository Vacancies => _vacancyRepository ?? (_vacancyRepository = new VacancyRepository(_context));
        public CompanyRecallRepository CompanyRecalls => _companyRecallRepository ?? (_companyRecallRepository = new CompanyRecallRepository(_context));
        public CompanyCommentRepository CompanyComments => _companyCommentRepository ?? (_companyCommentRepository = new CompanyCommentRepository(_context));
        public CompanyRepository Companies => _companyRepository ?? (_companyRepository = new CompanyRepository(_context));
        public UserRepository Users => _userRepository ?? (_userRepository = new UserRepo
namespace IoPokeMikuClient.Model
    public class Orchestra : MidiPlayer
    {
        List<Instrument> channels = new List<Instrument>();
        public Orchestra(string deviceName, IMidiOutPort port) : base(deviceName, port)
        {
            const byte kMikuVelocity = 0;
            const byte kInstVelocity = 127;
            channels = new List<Instrument>{
                /*
            };
        }
        public override void SetupProgram()
        {
            byte counter = 0;
            foreach (var inst in channels)
            {
                var msg = new MidiProgramChangeMessage(Convert.ToByte(counter), Convert.ToByte(inst.InstNum));
                m_port.SendMessage(msg);
                counter++;
            }
        }
        public override void NoteOn(Byte note)
        {
            Byte counter = 0;
            lock (m_lock)
            {
                NoteOff();
                foreach (var ch in channels)
                {
                    base.No
public class World : MonoBehaviour {
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public GameObject chunkPrefab;
    void Start()
    {
        for (int x = -2; x < 2; x++)
        {
            for (int y = -1; y < 1; y++)
            {
                for (int z = -1; z < 1; z++)
                {
                    CreateChunk(x * 16, y * 16, z * 16);
                }
            }
        }
    }
	void Update () {
	}
    public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(x, y, z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        for (int xi = 0; xi < 16; xi++)
        {
        

            {
                for (int zi = 0; zi < 16; zi++)
                {
                    if (yi <= 7)
                    {
                        SetBlock(x + xi, y + yi, z + zi, new BlockGrass());
                    }
                    else
                    {
                        SetBlock(x + xi, y + yi, z + zi, new BlockAir());
                    }
                }
            }
        }
    }
    public void DestroyChunk(int x, int y, int z)
    {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
        {
            Object.Destroy(chunk.gameObject);
            chunks.Remove(new WorldPos(x, y, z));
        }
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / 
namespace MME.Data
    public class SongData
    {
        public static float Bpm = 140;
        private static readonly Dictionary<string, bool[]> IsNotePlaying = new Dictionary<string, bool[]>();
        private static readonly Dictionary<string, WaveFunction> Instruments = new Dictionary<string, WaveFunction>();
        public static readonly Dictionary<string, List<Note>> NoteDb = new Dictionary<string, List<Note>>();
        private static readonly List<WaveGenerator> Voices = new List<WaveGenerator>();
        private static void _checkInstrAndNote(string instrumentName, int noteIndex)
        {
            if (noteIndex > 49 || noteIndex < 0)
                throw new IndexOutOfRangeException("Note index must be between 0 and 49");
            if (!Instruments.ContainsKey(instrumentName))
                throw new NullReferenceException("Instrument has not been added");
        }
        public static void AddNote(string instrumentName, int noteIndex, float amp, float startBeat

        {
            _checkInstrAndNote(instrumentName, noteIndex);
            NoteDb[instrumentName].Add(new Note
            {
                Index = noteIndex,
                Volume = amp,
                StartBeat = startBeat,
                LengthBeats = lengthBeats
            });
        }
        public static void RemoveNote(NoteAndInstrument note)
        {
            NoteDb[note.InstrumentName].Remove(note);
        }
        public static WaveGenerator PlayInstrumentNote(string instrumentName, int noteIndex, float amp)
        {
            _checkInstrAndNote(instrumentName, noteIndex);
            Instruments.TryGetValue(instrumentName, out WaveFunction instrClone);
            instrClone = instrClone.Clone();
            instrClone.Frequency = Notes.NoteFreqs[noteIndex];
            instrClone.Amplitude = amp;
            var generator = new WaveGenerator(instrClone);
            generator.Play();
            Voices.Add(generator);
            return generator;
   

        public static WaveGenerator PlayInstrumentNote(string instrumentName, Note note)
        {
            return PlayInstrumentNote(instrumentName, note.Index, note.Volume);
        }
        public static WaveGenerator PlayInstrumentNote(NoteAndInstrument note)
        {
            return PlayInstrumentNote(note.InstrumentName, note);
        }
        public static void StopInstrumentNote(WaveGenerator generator)
        {
            generator.Stop();
            if (Voices.Contains(generator))
                Voices.Remove(generator);
        }
        public static void AddInstrument(string instrumentName, WaveFunction instrument)
        {
            if (Instruments.ContainsKey(instrumentName)) throw new InstrumentException("Instrument already exists");
            Instruments.Add(instrumentName, instrument);
            IsNotePlaying.Add(instrumentName, new bool[49]);
            MainWindow.InstrumentsList.Items.Add(instrumentName);
            NoteDb.Add(instrumentName,
namespace HitThatLine.Tests.Utility
    public class MockActionBehavior : IActionBehavior
    {
        private Action _invokeAction = () => { };
        private Action _invokePartialAction = () => { };
        private bool _invoked;
        private bool _partialInvoked;
        public MockActionBehavior()
        {
            _invoked = false;
            _partialInvoked = false;
        }
        public MockActionBehavior OnInvoke(Action invokeAction)
        {
            _invokeAction = invokeAction;
            return this;
        }
        public MockActionBehavior OnInvokePartial(Action invokePartialAction)
        {
            _invokePartialAction = invokePartialAction;
            return this;
        }
        public void Invoke()
        {
            _invoked = true;
            _invokeAction();
        }
        public void InvokePartial()
        {
            _partialInvoked = true;
            _invokePartialAction();
        }
        public void VerifyInvoked()
    
namespace KyaniCan.Mobile.Service
    public class ApiRequestSelector<T>
    {
        private readonly PriorityType _priority;
        private readonly IApiRequest<T> _apiRequest;
        public ApiRequestSelector(IApiRequest<T> apiService, PriorityType priority)
        {
            _priority = priority;
            _apiRequest = apiService;
        }
        public T GetApiRequestByPriority()
        {
            T apiRequest;
            switch (_priority)
            {
                case PriorityType.Speculative:
                    apiRequest = _apiRequest.Speculative;
                    break;
                case PriorityType.UserInitiated:
                    apiRequest = _apiRequest.UserInitiated;
                    break;
                case PriorityType.Background:
                    apiRequest = _apiRequest.Background;
                    break;
                default:
                    apiRequest = _apiRequest.UserInitiated;
                    break;
         
namespace HCS_Encoder {
	public class ChunkDetail : IComparable<ChunkDetail> {
		public int StreamIndex { get; set; }
		public int ChunkIndex { get; set; }
		public double ChunkDuration { get; set; }
		public string SourceFilePath { get; set; }
		public ChunkDetail (int chunkIndex, int streamIndex, double duration) {
			this.ChunkIndex = chunkIndex;
			this.StreamIndex = streamIndex;
			this.ChunkDuration = duration;
		}
		public ChunkDetail (string path, int chunkIndex, int streamIndex, double duration) {
			this.ChunkIndex = chunkIndex;
			this.StreamIndex = streamIndex;
			this.ChunkDuration = duration;
			this.SourceFilePath = path;
		}
		#region IComparable<ChunkDetail> Members
		public int CompareTo (ChunkDetail other) {
			return this.ChunkIndex.CompareTo(other.ChunkIndex);
		}
		#endregion
	}
	public class ChunkUploadedEventArgs : EventArgs {
		public int ChunkIndex { get; set; }
		public int StreamIndex { get; set; }
		public double ChunkDuration { get; set; }
		public string 
public class World : MonoBehaviour
    public Dictionary<Vector3, Chunk> chunks = new Dictionary<Vector3, Chunk>();
    public struct ChunkData
    {
        public Vector3 WorldPosition;
        public Chunk Chunk;
        public World World;
        public ChunkData(Vector3 wPos, Chunk c, World w)
        {
            WorldPosition = wPos;
            Chunk = c;
            World = w;
        }
    }
    private static Vector3[] defaultChunkPositions =
    {
        new Vector3( 0, 0,  0), new Vector3(-1, 0,  0), new Vector3( 0, 0, -1), new Vector3( 0, 0,  1), new Vector3( 1, 0,  0),
        new Vector3(-1, 0, -1), new Vector3(-1, 0,  1), new Vector3( 1, 0, -1), new Vector3( 1, 0,  1), new Vector3(-2, 0,  0),
        new Vector3( 0, 0, -2), new Vector3( 0, 0,  2), new Vector3( 2, 0,  0), new Vector3(-2, 0, -1), new Vector3(-2, 0,  1),
        new Vector3(-1, 0, -2), new Vector3(-1, 0,  2), new Vector3( 1, 0, -2), new Vector3( 1, 0,  2), new Vector3( 2, 0, -1),
        new Vector3( 2

    };
    [SerializeField] private Transform chunkContainer;
    [SerializeField] private GameObject chunkPrefab;
    private Chunk[] chunkPool;
    private List<ChunkData> chunkQueue;
    private bool isBuilding = false;
    public string worldName = "World";
    private TerrainGenerator terrainGen = new TerrainGenerator();
    private Vector3 previousPlayerPos = new Vector3();
    private Vector3 currentPlayerPos = new Vector3();
    private float chunkRange = 40;
    private int queueBuildSize = 10;
    private BuildJob _buildJob;
    
    private void Start()
    {
        VSEventManager.Instance.AddListener<GameEvents.PlayerPositionUpdateEvent>(OnPlayerPositionUpdated);
        int numChunks = 300;
        Init(numChunks);
    }
    private void OnDestroy()
    {
        VSEventManager.Instance.RemoveListener<GameEvents.PlayerPositionUpdateEvent>(OnPlayerPositionUpdated);
    }
    public void Init(int numChunks)
    {
        chunkPool = new Chunk[numChunks];
        for (int i

        {
            SpawnChunkObj(i);
        }
        chunkQueue = new List<ChunkData>();
        _buildJob = new BuildJob();
        _buildJob.Setup();
    }
    private void OnPlayerPositionUpdated(GameEvents.PlayerPositionUpdateEvent e)
    {
        previousPlayerPos = currentPlayerPos;
        currentPlayerPos.x = SimplexNoise.Noise.FastFloor(e.PlayerPosition.x / Chunk.chunkSize) * Chunk.chunkSize;
        currentPlayerPos.y = SimplexNoise.Noise.FastFloor(e.PlayerPosition.y / Chunk.chunkSize) * Chunk.chunkSize;
        currentPlayerPos.z = SimplexNoise.Noise.FastFloor(e.PlayerPosition.z / Chunk.chunkSize) * Chunk.chunkSize;
        if (currentPlayerPos.x != previousPlayerPos.x ||
            currentPlayerPos.z != previousPlayerPos.z)
        {
            ProcessChunks(currentPlayerPos);
        }
    }
    private void ProcessChunks(Vector3 playerPos)
    {
        for (int i = 0; i < defaultChunkPositions.Length; i++)
        {
            Vector3 newChunkPos = new Vector3(
namespace WebApplication2.Models
	public static class RepositoryHelper
	{
		public static IUnitOfWork GetUnitOfWork()
		{
			return new EFUnitOfWork();
		}		
		
		public static ClientRepository GetClientRepository()
		{
			var repository = new ClientRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static ClientRepository GetClientRepository(IUnitOfWork unitOfWork)
		{
			var repository = new ClientRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OccupationRepository GetOccupationRepository()
		{
			var repository = new OccupationRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OccupationRepository GetOccupationRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OccupationRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OrderRepository GetOrderRepository()
		{
			var repository = new Orde

			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OrderRepository GetOrderRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OrderRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OrderLineRepository GetOrderLineRepository()
		{
			var repository = new OrderLineRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OrderLineRepository GetOrderLineRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OrderLineRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static ProductRepository GetProductRepository()
		{
			var repository = new ProductRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static ProductRepository GetProductRepository(IUnitOfWork unitOfWork)
		{
			var repository = new ProductRepository();
			repository.UnitOfWork = unitOfWork;
			return repo
namespace PacketCompare.Classes
    class ChunkedFile
    {
        private List<Chunk> _chunkList;
        private int _chunkSize;
        public ChunkedFile(string FileContents, int chunkSize)
        {
            _chunkSize = chunkSize;
            _chunkList = chunkString(FileContents, chunkSize);
        }
        public List<Chunk> chunkList
        {
            get { return _chunkList; }
            set { _chunkList = value; }
        }
        public int chunkSize
        {
            get { return _chunkSize; }
            set { _chunkSize = value; }
        }
        private List<Chunk> chunkString(string fileContents, int chunkSize)
        {
            List<Chunk> theChunkList = new List<Chunk>();
            for (int i = 0; i <= fileContents.Length - chunkSize; i++)
            {
                theChunkList.Add(new Chunk(fileContents.Substring(i, chunkSize), i));
            }
            return theChunkList;
        }
        public List<Chunk> compareChunkLists(Chunk

        {
            List<Chunk> matchList = new List<Chunk>();
            for (int i = 0; i < _chunkList.Count; i++)
            {
                for (int j = 0; j < comparisonFile.chunkList.Count; j++)
                {
                    if (_chunkList.ElementAt<Chunk>(i).value.Equals(comparisonFile.chunkList.ElementAt<Chunk>(j).value))
                    {
                        matchList.Add(_chunkList.ElementAt<Chunk>(i));
                        break;
                    }
                }
            }
            return matchList;
        }
        public void eliminateDuplicates()
        {
            for (int i = 0; i <= chunkList.Count -1; i++)
            {
                for (int j = chunkList.Count-1; j >= i+1; j--)
                {
                    if(chunkList.ElementAt<Chunk>(i).value.Equals(chunkList.ElementAt<Chunk>(j).value))
                    {
                        chunkList.RemoveAt(j);
                    }
                }
            }
   

        public static List<Chunk> reassambleChunks(List<Chunk> inputList)
        {
            List<Chunk> reassembledChunks = new List<Chunk>();
            int previousIndex = -1;
            string reassembledChunk = "";
            int chunkSize = 0;
            if(inputList.Count>0)
                chunkSize = inputList.ElementAt<Chunk>(0).value.Length;
            for (int i = 0; i < inputList.Count; i++)
            {
                if (inputList.ElementAt<Chunk>(i).index == previousIndex + 1)
                {
                    previousIndex += 1;
                    reassembledChunk += inputList.ElementAt<Chunk>(i).value.Substring(chunkSize - 1, 1);
                }
                else
                {
                    if (previousIndex > -1)
                        reassembledChunks.Add(new Chunk(reassembledChunk, previousIndex - reassembledChunk.Length + chunkSize));
                    previousIndex = inputList.ElementAt<Chunk>(i).index;
                    reass
﻿namespace Huoyaoyuan.AdmiralRoom.API
    public class api_start2
    {
        public api_mst_ship[] api_mst_ship { get; set; }
        public api_mst_slotitem_equiptype[] api_mst_slotitem_equiptype { get; set; }
        public api_mst_stype[] api_mst_stype { get; set; }
        public api_mst_slotitem[] api_mst_slotitem { get; set; }
        public api_mst_useitem[] api_mst_useitem { get; set; }
        public api_mst_maparea[] api_mst_maparea { get; set; }
        public api_mst_mapinfo[] api_mst_mapinfo { get; set; }
        public api_mst_mapcell[] api_mst_mapcell { get; set; }
        public api_mst_mission[] api_mst_mission { get; set; }
        public api_mst_shipupgrade[] api_mst_shipupgrade { get; set; }
    }
    public class api_mst_ship
    {
        public int api_id { get; set; }
        public int api_sortno { get; set; }
        public string api_name { get; set; }
        public string api_yomi { get; set; }
        public int api_stype { get; set; }
        public in

        public int api_aftershipid { get; set; }
        public int[] api_taik { get; set; }
        public int[] api_souk { get; set; }
        public int[] api_houg { get; set; }
        public int[] api_raig { get; set; }
        public int[] api_tyku { get; set; }
        public int[] api_luck { get; set; }
        public int api_soku { get; set; }
        public int api_leng { get; set; }
        public int api_slot_num { get; set; }
        public int[] api_maxeq { get; set; }
        public int api_buildtime { get; set; }
        public int[] api_broken { get; set; }
        public int[] api_powup { get; set; }
        public int api_backs { get; set; }
        public string api_getmes { get; set; }
        public int api_afterfuel { get; set; }
        public int api_afterbull { get; set; }
        public int api_fuel_max { get; set; }
        public int api_bull_max { get; set; }
        public int api_voicef { get; set; }
    }
    public class api_mst_slotitem_equiptype
   

        public int api_id { get; set; }
        public string api_name { get; set; }
        public int api_show_flg { get; set; }
    }
    public class api_mst_stype
    {
        public int api_id { get; set; }
        public int api_sortno { get; set; }
        public string api_name { get; set; }
        public int api_scnt { get; set; }
        public int api_kcnt { get; set; }
    }
    public class api_mst_slotitem
    {
        public int api_id { get; set; }
        public int api_sortno { get; set; }
        public string api_name { get; set; }
        public int[] api_type { get; set; }
        public int api_taik { get; set; }
        public int api_souk { get; set; }
        public int api_houg { get; set; }
        public int api_raig { get; set; }
        public int api_soku { get; set; }
        public int api_baku { get; set; }
        public int api_tyku { get; set; }
        public int api_tais { get; set; }
        public int api_atap { get; set; }
        public 
namespace Hexpoint.Blox.Hosts.World
	public struct Blocks
	{
		internal Blocks(int chunkSizeX, int chunkHeight, int chunkSizeZ)
		{
			Array = new ushort[chunkHeight, chunkSizeX, chunkSizeZ];
		}
		internal Block this[Coords coords]
		{
			get { return new Block(Array[coords.Yblock, coords.Xblock % Chunk.CHUNK_SIZE, coords.Zblock % Chunk.CHUNK_SIZE]); }
			set { Array[coords.Yblock, coords.Xblock % Chunk.CHUNK_SIZE, coords.Zblock % Chunk.CHUNK_SIZE] = value.BlockData; }
		}
		internal Block this[Position position]
		{
			get { return new Block(Array[position.Y, position.X % Chunk.CHUNK_SIZE, position.Z % Chunk.CHUNK_SIZE]); }
			set { Array[position.Y, position.X % Chunk.CHUNK_SIZE, position.Z % Chunk.CHUNK_SIZE] = value.BlockData; }
		}
		internal Block this[int x, int y, int z]
		{
			get { return new Block(Array[y, x, z]); }
			set { Array[y, x, z] = value.BlockData; }
		}
		internal readonly ushort[, ,] Array;
		[Obsolete("This was for world diffs. Not being used currently.")]
		in
namespace NVIDIASurroundToggle.InterProcess
    internal static class Helper
    {
        public static bool QueryStatus(InstanceStatus status)
        {
            var thisProcess = Process.GetCurrentProcess();
            return Utility.DoTimeout(
                () =>
                {
                    try
                    {
                        return
                            Process.GetProcessesByName(thisProcess.ProcessName)
                                .Where(process => process.Id != thisProcess.Id)
                                .Select(process => new Client(process))
                                .Any(client => client.Status == status);
                    }
                    catch (Exception)
                    {
                        return false;
                    }
                },
                500);
        }
        public static bool IsAnyProgramActive()
        {
            var thisProcess = Process.GetCurrentProcess();
            retu
public class World : MonoBehaviour {
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public GameObject chunkPrefab;
    public string worldName = "world";
    public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(x, y, z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        var terrainGen = new TerrainGen();
        newChunk = terrainGen.ChunkGen(newChunk);
        newChunk.SetBlocksUnmodified();
        bool loaded = Serialization.Load(newChunk);
    }
    void UpdateIfEqual(int value1, int value2, WorldPos pos)
    {
        if (value1 == value2)
        {
            Chunk chunk = GetChunk(

            if (chunk != null)
                chunk.update = true;
        }
    }
    public void DestroyChunk(int x, int y, int z)
    {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
        {
            Serialization.SaveChunk(chunk);
            UnityEngine.Object.Destroy(chunk.gameObject);
            chunks.Remove(new WorldPos(x, y, z));
        }
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / multiple) * Chunk.chunkSize;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Block GetBlock(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChun

        {
            Block block = containerChunk.GetBlock(x - containerChunk.pos.x, y - containerChunk.pos.y, z - containerChunk.pos.z);
            return block;
        }
        else
        {
            return new BlockAir();
        }
    }
    public void SetBlock(int x, int y, int z, Block block)
    {
        Chunk chunk = GetChunk(x, y, z);
        if (chunk != null)
        {
            chunk.SetBlock(x - chunk.pos.x, y - chunk.pos.y, z - chunk.pos.z, block);
            chunk.update = true;
        }
        UpdateIfEqual(x - chunk.pos.x, 0, new WorldPos(x - 1, y, z));
        UpdateIfEqual(x - chunk.pos.x, Chunk.chunkSize - 1, new WorldPos(x + 1, y, z));
        UpdateIfEqual(y - chunk.pos.y, 0, new WorldPos(x, y - 1, z));
        UpdateIfEqual(y - chunk.pos.y, Chunk.chunkSize - 1, new WorldPos(x, y + 1, z));
        UpdateIfEqual(z - chunk.pos.z, 0, new WorldPos(x, y, z - 1));
        UpdateIfEqual(z - chunk.pos.z, Chunk.chunkSize - 1, new WorldPos(x, y, z + 1));
    
namespace HCM.Web.Controllers
    public class InstrumentSnapsController : Controller
    {
        private HcmContext db = new HcmContext();
        public async Task<ActionResult> Index()
        {
            var instrumentSnaps = db.InstrumentSnaps.Include(i => i.Instrument);
            return View(await instrumentSnaps.ToListAsync());
        }
        public async Task<ActionResult> Details(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            InstrumentSnap instrumentSnap = await db.InstrumentSnaps.FindAsync(id);
            if (instrumentSnap == null)
            {
                return HttpNotFound();
            }
            return View(instrumentSnap);
        }
        public ActionResult Create()
        {
            ViewBag.InstrumentId = new SelectList(db.Instruments, "Id", "Name");
            return View();
        }
        [HttpPost]
        [ValidateAntiF

        public async Task<ActionResult> Create([Bind(Include = "Id,InstrumentId,Date,Time,Open,Last,High,Low,Close")] InstrumentSnap instrumentSnap)
        {
            if (ModelState.IsValid)
            {
                db.InstrumentSnaps.Add(instrumentSnap);
                await db.SaveChangesAsync();
                return RedirectToAction("Index");
            }
            ViewBag.InstrumentId = new SelectList(db.Instruments, "Id", "Name", instrumentSnap.InstrumentId);
            return View(instrumentSnap);
        }
        public async Task<ActionResult> Edit(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            InstrumentSnap instrumentSnap = await db.InstrumentSnaps.FindAsync(id);
            if (instrumentSnap == null)
            {
                return HttpNotFound();
            }
            ViewBag.InstrumentId = new SelectList(db.Instruments, "Id", "Name

            return View(instrumentSnap);
        }
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<ActionResult> Edit([Bind(Include = "Id,InstrumentId,Date,Time,Open,Last,High,Low,Close")] InstrumentSnap instrumentSnap)
        {
            if (ModelState.IsValid)
            {
                db.Entry(instrumentSnap).State = EntityState.Modified;
                await db.SaveChangesAsync();
                return RedirectToAction("Index");
            }
            ViewBag.InstrumentId = new SelectList(db.Instruments, "Id", "Name", instrumentSnap.InstrumentId);
            return View(instrumentSnap);
        }
        public async Task<ActionResult> Delete(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            InstrumentSnap instrumentSnap = await db.InstrumentSnaps.FindAsync(id);
            if (instrumentSnap == null)
            {
          
namespace GestionServer.Controller
    public static class ControllerFactory
    {
        private static GestionController gestionController;
        private static DeckController deckController;
        private static UserController userController;
        public static GestionController getGestionController()
        {
            if(ControllerFactory.gestionController == null)
            {
                ControllerFactory.gestionController = new GestionController();
            }
            return ControllerFactory.gestionController;
        }
        public static DeckController getDeckController()
        {
            if (ControllerFactory.deckController == null)
            {
                ControllerFactory.deckController = new DeckController();
            }
            return ControllerFactory.deckController;
        }
        public static UserController getUserController()
        {
            if(ControllerFactory.userController == null)
            {
                
public class DelayInvokeExample : MonoBehaviour
    #region properties
    int startFrame;
    float startTime;
    #endregion
    #region override unity methods
    void Start()
    {
        startFrame = Time.frameCount;
        startTime = Time.realtimeSinceStartup;
        InvokeAfterDelay.Call(() =>
        {
            Debug.Log(string.Format("InvokeAfterDelay called! delayedTime: {0}", Time.realtimeSinceStartup - startTime));
        }, 1.0f);
        InvokeAfterFrame.Call(() =>
        {
            Debug.Log(string.Format("InvokeAfterFrame called! startFrame: {0}, currentFrame: {1}", startFrame, Time.frameCount));
        }, 5);
        InvokeNextFrame.Call(() =>
        {
            Debug.Log(string.Format("InvokeNextFrame called! startFrame: {0}, currentFrame: {1}", startFrame, Time.frameCount));
        });
        InvokeAfterDelay invokeAfterDelay = InvokeAfterDelay.Call(() =>
        {
            throw new Exception("Exception from InvokeAfterDelay");
        }, 2.0f);
namespace IndignaFwk.UI.Process
    public class UserProcessFactory
    {
        private UserProcessFactory() { }
        private static UserProcessFactory _instance;
        public static UserProcessFactory Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = new UserProcessFactory();
                }
                return _instance;
            }
        }
        private ContenidoUserProcess _contenidoUserProcess;
        public ContenidoUserProcess ContenidoUserProcess
        {
            get
            {
                if (_contenidoUserProcess == null)
                {
                    _contenidoUserProcess = new ContenidoUserProcess();
                }
                return _contenidoUserProcess;
            }
        }
        private ConvocatoriaUserProcess _convocatoriaUserProcess;
        public ConvocatoriaUserProcess ConvocatoriaUserProcess
        {
            get
          

                if (_convocatoriaUserProcess == null)
                {
                    _convocatoriaUserProcess = new ConvocatoriaUserProcess();
                }
                return _convocatoriaUserProcess;
            }
        }
        private GrupoUserProcess _grupoUserProcess;
        public GrupoUserProcess GrupoUserProcess
        {
            get
            {
                if (_grupoUserProcess == null)
                {
                    _grupoUserProcess = new GrupoUserProcess();
                }
                return _grupoUserProcess;
            }
        }
        private UsuarioUserProcess _usuarioUserProcess;
        public UsuarioUserProcess UsuarioUserProcess
        {
            get
            {
                if (_usuarioUserProcess == null)
                {
                    _usuarioUserProcess = new UsuarioUserProcess();
                }
                return _usuarioUserProcess;
            }
        }
        private AdministradorUserP
@{
    ViewBag.Title = "Dispatch";
    Layout = "~/Views/Shared/_Layout.cshtml";
<div class="container">
    @Html.DevExpress().PageControl(pcDispatchSettings =>
    {
    pcDispatchSettings.Name = "pcDispatch";
    pcDispatchSettings.Width = System.Web.UI.WebControls.Unit.Percentage(100);
    pcDispatchSettings.EnableClientSideAPI = true;
    pcDispatchSettings.ActiveTabIndex = 0;
    pcDispatchSettings.Width = System.Web.UI.WebControls.Unit.Percentage(75);
    pcDispatchSettings.TabPages.Add("Progress").SetContent(
        Html.Partial("_DispatchProgressPartial").ToHtmlString()
    );
    pcDispatchSettings.TabPages.Add("New").SetContent(
        Html.Partial("_DispatchNewPartial").ToHtmlString()
    );
    pcDispatchSettings.TabPages.Add("Scheduling").SetContent(
        Html.Partial("_DispatchNewPartial").ToHtmlString()
    );
    pcDispatchSettings.TabPages.Add("Driver Requested").SetContent(
        Html.Partial("_DispatchNewPartial").ToHtmlString()
    );
    pcDispatchSettings.
namespace W3DT.Formats
    abstract public class ChunkedFormatBase : FormatBase, IChunkedFormat
    {
        public abstract string getFormatName();
        public abstract Chunk_Base lookupChunk(UInt32 magic);
        public abstract void storeChunk(Chunk_Base chunk);
        public List<Chunk_Base> Chunks { get; private set; }
        public ChunkedFormatBase(string path) : base(path)
        {
            Chunks = new List<Chunk_Base>();
        }
        public override void parse()
        {
            while (!isEndOfStream() && !isOutOfBounds(seek + 4))
            {
                int startSeek = seek + 8;
                Chunk_Base chunk = lookupChunk(readUInt32());
                if (chunk.ChunkID != 0x0)
                {
                    storeChunk(chunk);
                }
                else
                {
                    string hex = chunk.ChunkID.ToString("X");
                    Log.Write(getFormatName() + ": Unknown chunk encountered = {0} (0x{1}) at {2
namespace Tandorosti.DomainService.CoreServices
    public interface IInstrumentService
    {       
        IQueryable<Instrument> GetAll();
        void Update(Instrument Instrument);
        void Create(Instrument Instrument);
        void Delete(Instrument Instrument);
    }
    public class InstrumentService : IInstrumentService
    {
        private readonly IInstrumentRepository _InstrumentRepository;
       
        public InstrumentService(IInstrumentRepository InstrumentRepository)
        {
            _InstrumentRepository = InstrumentRepository;
          
        }
        public IQueryable<Instrument> GetAll()
        {
            return _InstrumentRepository.GetAll();
        }
        public void Update(Instrument Instrument)
        {
            _InstrumentRepository.Update(Instrument);
        }
        public void Create(Instrument Instrument)
        {
            _InstrumentRepository.Create(Instrument);
        }
        public void Delete(Instrument Instrument
namespace BlingBackend.Web.Controllers
    public class HomeController : Controller
    {
        private readonly IUserRepository _userRepository;
        private readonly ICategoryRepository _categoryRepository;
        private readonly ITaskRepository _taskRepository;
        private readonly IBoardRepository _boardRepository;
        private readonly IReminderRepository _reminderRepository;
        public HomeController(
            IUserRepository userRepository,
            ICategoryRepository categoryRepository,
            ITaskRepository taskRepository,
            IBoardRepository boardRepository,
            IReminderRepository reminderRepository)
        {
            _userRepository = userRepository;
            _categoryRepository = categoryRepository;
            _taskRepository = taskRepository;
            _boardRepository = boardRepository;
            _reminderRepository = reminderRepository;
        }
        public ActionResult Index()
        {
            return 
namespace com.gm.cat.geets.application {
    public interface IGeetsApplication {
        IInventoryExRepository InventoryEx();
        IInventoryRepository Inventory();
        ICalibrationRepository Calibration();
        ICalLabLimitExcursionRepository CalLabLimitExcursionRepository();
        ICalLabTempAndHumidStationRepository CalLabTempAndHumidStationRepository();
        ICalLabTempAndHumidRepository CalLabTempAndHumidRepository();
        ICC_AnalysisResultsRepository CC_AnalysisResultsRepository();
        ICC_BridgeAxisCalRepository CC_BridgeAxisCalRepository();
        ISecurityRepository SecurityRepository();
        ICcTransducerRepository CcTransducerRepository();
        IAoUnitRepository AoUnitRepository();
        IAoPhysicalDimensionRepository AoPhysicalDimensionRepository();
        ICcAxisInfoRepository CcAxisInfoRepository();
        ICcCriteriaListRepository CcCriteriaListRepository();
        ICcIrTraccAxisInfoRepository CcIrTraccAxisInfoRepository();
        IA
namespace AbstractFactory
    public class EntityFrameworkFactory:IFactory
    {
        public IBookRepository ReturnBookRepository()
        {
            return new BookRepository();
        }
        public ICountryRepository ReturnCountryRepository()
        {
            return new CountryRepository();
        }
        public IEditionRepository ReturnEditionRepository()
        {
            return new EditionRepository();
        }
        public IIntentionRepository ReturnIntentionRepository()
        {
            return new IntentionRepository();
        }
        public ILanguageRepository ReturnLanguageRepository()
        {
            return new LanguageRepository();
        }
        public INameRepository ReturnNameRepository()
        {
            return new NameRepository();
        }
        public IProfileRepository ReturnProfileRepository()
        {
            return new ProfileRepository();
        }
        public IPublishingRepository ReturnPublishingReposit
namespace Frankfort.Threading.Internal
    public class ThreadDispatchAction
    {
        public bool executed = false;
        public object dispatchExecutionResult = null;
        private ThreadDispatchDelegate          dispatchCallClean;
        private ThreadDispatchDelegateArg       dispatchCallArg;
        private ThreadDispatchDelegateArgReturn dispatchCallArgReturn;
        private ThreadDispatchDelegateReturn    dispatchCallReturn;
        
        private object dispatchArgParam;
        private bool safeMode;
        
        public ThreadDispatchAction()
        {
        }
        #region 4 DIFFERENT OVERLOADS
        public void Init(ThreadDispatchDelegate dispatchCall, bool waitForExecution, bool safeMode)
        {
            this.safeMode = safeMode;
            this.dispatchCallClean = dispatchCall;
            ValidateExecutionOnInit(waitForExecution);
        }
        public void Init(ThreadDispatchDelegateArg dispatchCall, object dispatchArgumentParameter, bool 

        {
            this.safeMode = safeMode;
            this.dispatchCallArg = dispatchCall;
            this.dispatchArgParam = dispatchArgumentParameter;
            ValidateExecutionOnInit(waitForExecution);
        }
        public void Init(ThreadDispatchDelegateArgReturn dispatchCall, object dispatchArgumentParameter, bool safeMode)
        {
            this.safeMode = safeMode;
            this.dispatchCallArgReturn = dispatchCall;
            this.dispatchArgParam = dispatchArgumentParameter;
        }
        public void Init(ThreadDispatchDelegateReturn dispatchCall, bool safeMode)
        {
            this.safeMode = safeMode;
            this.dispatchCallReturn = dispatchCall;
        } 
        #endregion
			
        private void ValidateExecutionOnInit(bool waitForExecution)
        {
            if (waitForExecution)
            {
                if (!MainThreadWatchdog.CheckIfMainThread())
                {
                    while (!executed)
                  

                }
                else
                {
                    ExecuteDispatch();
                }
            }
        }
        public void ExecuteDispatch()
        {
            if (safeMode)
            {
                try
                {
                    if (dispatchCallClean != null)
                    {
                        dispatchCallClean();
                    }
                    else if (dispatchCallArg != null)
                    {
                        dispatchCallArg(dispatchArgParam);
                    }
                    else if (dispatchCallArgReturn != null)
                    {
                        dispatchExecutionResult = dispatchCallArgReturn(dispatchArgParam);
                    }
                    else if (dispatchCallReturn != null)
                    {
                        dispatchExecutionResult = dispatchCallReturn();
                    }
                }
                catch (Exception e)
                
public abstract class SlantedBlock : IBlock {
    public abstract byte BlockID { get; }
    public virtual Vector2 TopUV { get { return BlockDetails.nullUV; } }
    public virtual Vector2 NorthUV { get { return TopUV; } }
    public virtual Vector2 SouthUV { get { return TopUV; } }
    public virtual Vector2 WestUV { get { return TopUV; } }
    public virtual Vector2 EastUV { get { return TopUV; } }
    public virtual Vector2 BottomUV { get { return TopUV; } }
    public bool IsOpaque
    {
        get { return true; }
    }
    public void ConstructBlock(int x, int y, int z, Chunk chunk)
    {
        if (BlockID != null)
        {
            if (chunk.world.GetBlockWorldCoordinate(chunk.ChunkPosition + new IntVector3(x, y + 1, z)) == null)
            {
                CreateTopFace(x, y, z, chunk);
            }
            if (chunk.world.GetBlockWorldCoordinate(chunk.ChunkPosition + new IntVector3(x, y - 1, z)) == null)
            {
                CreateBottomFace(x, y, z, chun

            }
            if (chunk.world.GetBlockWorldCoordinate(chunk.ChunkPosition + new IntVector3(x + 1, y, z)) == null)
            {
                CreateEastFace(x, y, z, chunk);
            }
            if (chunk.world.GetBlockWorldCoordinate(chunk.ChunkPosition + new IntVector3(x - 1, y, z)) == null)
            {
                CreateWestFace(x, y, z, chunk);
            }
            if (chunk.world.GetBlockWorldCoordinate(chunk.ChunkPosition + new IntVector3(x, y, z + 1)) == null)
            {
                CreateNorthFace(x, y, z, chunk);
            }
            if (chunk.world.GetBlockWorldCoordinate(chunk.ChunkPosition + new IntVector3(x, y, z - 1)) == null)
            {
                CreateSouthFace(x, y, z, chunk);
            }
        }
    }
    protected void CreateTopFace(int x, int y, int z, Chunk chunk)
    {
        chunk.meshVertices.Add(new Vector3(x, y - 1, z + 1));
        chunk.meshVertices.Add(new Vector3(x + 1, y, z + 1));
        chunk.mesh

        chunk.meshVertices.Add(new Vector3(x, y - 1, z));
        chunk.colVertices.Add(new Vector3(x, y - 1, z + 1));
        chunk.colVertices.Add(new Vector3(x + 1, y, z + 1));
        chunk.colVertices.Add(new Vector3(x + 1, y, z));
        chunk.colVertices.Add(new Vector3(x, y - 1, z));
        AddMeshTriangles(chunk);
        AddCollisionTriangles(chunk);
        AddUV(TopUV, chunk);
    }
    protected void CreateBottomFace(int x, int y, int z, Chunk chunk)
    {
        chunk.meshVertices.Add(new Vector3(x, y - 1, z));
        chunk.meshVertices.Add(new Vector3(x + 1, y - 1, z));
        chunk.meshVertices.Add(new Vector3(x + 1, y - 1, z + 1));
        chunk.meshVertices.Add(new Vector3(x, y - 1, z + 1));
        chunk.colVertices.Add(new Vector3(x, y - 1, z));
        chunk.colVertices.Add(new Vector3(x + 1, y - 1, z));
        chunk.colVertices.Add(new Vector3(x + 1, y - 1, z + 1));
        chunk.colVertices.Add(new Vector3(x, y - 1, z + 1));
        AddMeshTriangles(chunk)
public class ChunkHandler : InjectedMonoBehaviour
    [SerializeField]
    private int chunkSizeX = 16;
    [SerializeField]
    private int chunkSizeY = 16;
    [SerializeField]
    private int chunkSizeZ = 16;
    [Inject]
    private World world;
	void Start () {
        world.OnWorldCreated.AddListener(onWorldCreated);
	}
    private void onWorldCreated()
    {
        foreach (Transform child in transform)
        {
            GameObject.Destroy(child.gameObject);
        }
        int chunksX = Mathf.CeilToInt(1.0f * world.WorldSizeX / chunkSizeX);
        int chunksY = Mathf.CeilToInt(1.0f * world.WorldSizeY / chunkSizeY);
        int chunksZ = Mathf.CeilToInt(1.0f * world.WorldSizeZ / chunkSizeZ);
        for (int chunkX = 0; chunkX < chunksX; chunkX++)
        {
            for (int chunkY = 0; chunkY < chunksY; chunkY++)
            {
                for (int chunkZ = 0; chunkZ < chunksZ; chunkZ++)
                {
                    GameObject chunkContainer = new GameObj
namespace Silentor.TB.Client.Maps
    public class SimpleMapLoader : IMapLoader
    {
        private readonly IMapEditor _map;
        private readonly IServer _server;
        private readonly IChunkFactory _chunkFactory;
        private readonly IPlayer _player;
        private readonly IChunkStorage _chunkStorage;
        private Vector2i _oldPlayerChunkPosition;
        private static Logger Log = LogManager.GetLogger("Client.Map.SimpleMapLoader");
        public SimpleMapLoader(IMapEditor map, IServer server, IChunkFactory chunkFactory, IPlayer player, 
            IChunkStorage chunkStorage)
        {
            if (map == null) throw new ArgumentNullException("map");
            if (server == null) throw new ArgumentNullException("server");
            if (chunkFactory == null) throw new ArgumentNullException("chunkFactory");
            if (player == null) throw new ArgumentNullException("player");
            _map = map;
            _server = server;
            _server.Clie

            _chunkFactory = chunkFactory;
            _player = player;
            _chunkStorage = chunkStorage;
            _chunkStorage.Retrieved += ChunkStorageOnRetrieved;
            _player.Moved += OnPlayerMoved;
            _oldPlayerChunkPosition = Chunk.ToChunkPosition(_player.Position.ToMapPosition());
            foreach (var chunkPos in _map.Bounds)
                if (!_map.IsChunkPresent(chunkPos))
                    _server.ServerConnection.GetChunk(chunkPos);
        }
        private void OnPlayerMoved()
        {
            var newPlayerChunkPosition = Chunk.ToChunkPosition(_player.Position.ToMapPosition());
            if (newPlayerChunkPosition != _oldPlayerChunkPosition)
            {
                var offset = newPlayerChunkPosition - _oldPlayerChunkPosition;
                var removedChunks = new List<Chunk>();
                var addedChunkPlaces = new List<Vector2i>();
                _map.Resize(offset, removedChunks, addedChunkPlaces);
              
﻿namespace InstrumentProcessorKata
    public class InstrumentProcessor : IInstrumentProcessor, IDisposable
    {
        private bool _disposed;
        private readonly IInstrument instrument;
        private ITaskDispatcher dispatcher;
        private IConsoleWriter consoleWriter;
        public InstrumentProcessor(ITaskDispatcher taskDispatcher, IInstrument instrument, IConsoleWriter console)
        {
            this.consoleWriter = console;
            this.dispatcher = taskDispatcher;
            this.instrument = instrument;
            this.instrument.Finished += this.InstrumentOnFinished;
            this.instrument.Error += this.InstrumentOnError;
        }
        public void Process()
        {
            var task = this.dispatcher.GetTask();
            this.instrument.Execute(task);
        }
        private void InstrumentOnError(object sender, EventArgs eventArgs)
        {
            var instrumentErrorEventArgs = (InstrumentErrorEventArgs)eventArgs;
            th
namespace BlowOut.Controllers
    [RequireHttps]
    public class InstrumentsController : Controller
    {
        private AICContext db = new AICContext();
        public ActionResult Index()
        {
            return View(db.Instruments.ToList());
        }
        public ActionResult Details(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            Instrument instrument = db.Instruments.Find(id);
            if (instrument == null)
            {
                return HttpNotFound();
            }
            return View(instrument);
        }
        public ActionResult Create()
        {
            return View();
        }
        [HttpPost]
        [ValidateAntiForgeryToken]
        public ActionResult Create([Bind(Include = "InstrumentID,Description,Type,Price,ClientID")] Instrument instrument)
        {
            if (ModelState.IsValid)
            {
                db

                db.SaveChanges();
                return RedirectToAction("Index");
            }
            return View(instrument);
        }
        public ActionResult Edit(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            Instrument instrument = db.Instruments.Find(id);
            if (instrument == null)
            {
                return HttpNotFound();
            }
            return View(instrument);
        }
        [HttpPost]
        [ValidateAntiForgeryToken]
        public ActionResult Edit([Bind(Include = "InstrumentID,Description,Type,Price,ClientID")] Instrument instrument, int InstrumentID)
        {
            instrument.InstrumentID = InstrumentID;
            if (ModelState.IsValid)
            {
                var instrumentInDb = db.Instruments.Single(c => c.InstrumentID == instrument.InstrumentID);
                db.Entry(instrumentInDb).Curre

                instrumentInDb.Type = instrumentInDb.Type.Substring(0, 1).ToUpper() + instrumentInDb.Type.Substring(1).ToLower();
                db.SaveChanges();
                return RedirectToAction("Index");
            }
            return View(instrument);
        }
        public ActionResult Delete(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            Instrument instrument = db.Instruments.Find(id);
            if (instrument == null)
            {
                return HttpNotFound();
            }
            return View(instrument);
        }
        [HttpPost, ActionName("Delete")]
        [ValidateAntiForgeryToken]
        public ActionResult DeleteConfirmed(int id)
        {
            Instrument instrument = db.Instruments.Find(id);
            db.Instruments.Remove(instrument);
            db.SaveChanges();
            return RedirectToAction("Index");
     
namespace SGT
    public partial class Technology
    {
        public void Calculate(Object sender, CommutatorEventArgs e)
        {
            if (cal_slim.TryEnterWriteLock(50))
            {
                try
                {
                    TechnologyTime = DateTime.Now;
                    InitializeTechData(e.Slice);
                    CalculateSimple(e.Slice, TechnologyTime);
                    CalculateComplex(e.Slice, TechnologyTime);
                    CalculateDrilling(e.Slice, TechnologyTime);
                    TechnologicalStage = p206.Stage;
                    TechnologicalRegime = p206.Regime;
                    TechnologicalHook = p206.Hook;
                    if (onComplete != null)
                    {
                        onComplete(this, EventArgs.Empty);
                    }
                }
                finally
                {
                    cal_slim.ExitWriteLock();
                }
            }
        }
        protected void 

        {
            p1.Calculate(slice);
            p2.Calculate(slice);
            p3.Calculate(slice);
            p4.Calculate(slice);
            p5.Calculate(slice);
            p6.Calculate(slice);
            p6_1.Calculate(slice);
            p6_2.Calculate(slice);
            p6_3.Calculate(slice);
            p6_4.Calculate(slice);
            p6_5.Calculate(slice);
            p6_6.Calculate(slice);
            p6_7.Calculate(slice);
            p6_8.Calculate(slice);
            p6_9.Calculate(slice);
            p7.Calculate(slice);
            p7_1.Calculate(slice);
            p7_2.Calculate(slice);
            p7_3.Calculate(slice);
            p7_4.Calculate(slice);
            p7_5.Calculate(slice);
            p7_6.Calculate(slice);
            p7_7.Calculate(slice);
            p7_8.Calculate(slice);
            p7_9.Calculate(slice);
            p7_10.Calculate(slice);
            p7_11.Calculate(slice);
            p7_12.Calculate(slice);
            p7_13.Ca

            p8.Calculate(slice);
            p8_1.Calculate(slice);
            p9.Calculate(slice);
            p9_1.Calculate(slice);
            p9_2.Calculate(slice);
            p9_3.Calculate(slice);
            p9_4.Calculate(slice);
            p9_5.Calculate(slice);
            p9_6.Calculate(slice);
            p9_7.Calculate(slice);
            p9_8.Calculate(slice);
            p9_9.Calculate(slice);
            p9_10.Calculate(slice);
            p9_11.Calculate(slice);
            p9_12.Calculate(slice);
            p9_13.Calculate(slice);
            p10.Calculate(slice);
            p11.Calculate(slice);
            p11_1.Calculate(slice);
            p12.Calculate(slice);
            p13.Calculate(slice);
            p14.Calculate(slice);
            p14_1.Calculate(slice);
            p15.Calculate(slice);
            p16.Calculate(slice);
            p17.Calculate(slice);
            p18.Calculate(slice);
        }
        protected void CalculateComplex(float[] sli
public class CardDispatcher : MonoBehaviour{
    public float dispatchDuration = 0.5f;
    public float flipDelay = 0.3f;
    private Table table;
    private Dispatcher<CardEvent> dispatcher { get { return table.dispatcher; } }
    private bool start_flip;
    private float timer;
    public void Init(Table table) {
        this.table = table;
    }
    public void DispatchRandom() {
        throw new System.NotImplementedException();
    }
    public void Dispatch(string cardID) {
        Dispatch(DataManager.Instance.card.GetEntry(cardID));
    }
    public void Dispatch(CardDataEntry cardData)
    {
        Debug.Log("Dispatch");
        table.StartDispatch();
        table.card = new Card(cardData);
        timer = dispatchDuration;
        start_flip = false;
    }
    void Update() {
        UpdateDispatchTimer();
    }
    private void UpdateDispatchTimer() {
        if (table.state == TableState.Dispatching) {
            timer -= Time.deltaTime;
            if (timer <= dispa
namespace Dargon.LeagueOfLegends.Session {
   public class LeagueSessionServiceImpl : LeagueSessionService
   {
      private static readonly Logger logger = LogManager.GetCurrentClassLogger();
      private readonly IProcessProxy processProxy;
      private readonly LeagueProcessWatcherService leagueProcessWatcherService;
      private readonly Dictionary<int, LeagueSession> sessionsByProcessId = new Dictionary<int, LeagueSession>();
      private readonly object synchronization = new object();
      public event LeagueSessionCreatedHandler SessionCreated;
      public LeagueSessionServiceImpl(IProcessProxy processProxy,  LeagueProcessWatcherService leagueProcessWatcherService) {
         this.processProxy = processProxy;
         this.leagueProcessWatcherService = leagueProcessWatcherService;
         leagueProcessWatcherService.RadsUserKernelLaunched += HandleLeagueProcessLaunched;
         leagueProcessWatcherService.LauncherLaunched += HandleLeagueProcessLaunched;
         leagueP

         leagueProcessWatcherService.AirClientLaunched += HandleLeagueProcessLaunched;
         leagueProcessWatcherService.GameClientLaunched += HandleLeagueProcessLaunched;
      }
      public ILeagueSession GetProcessSessionOrNull(int processId) { return sessionsByProcessId.GetValueOrDefault(processId); }
      private void HandleLeagueProcessLaunched(LeagueProcessDetectedArgs e)
      {
         lock (synchronization) {
            var processId = e.ProcessDescriptor.ProcessId;
            var process = processProxy.GetProcessOrNull(processId);
            if (process == null) {
               logger.Error("League process " + processId + " of type " + e.ProcessType + " quit too quickly!");
               return;
            }
            logger.Info("Handling process " + processId + " launch");
            if (e.ProcessType == LeagueProcessType.RadsUserKernel && sessionsByProcessId.Any()) {
               var sessions = sessionsByProcessId.Values.Distinct();
               var se

               IProcess foregroundProcess;
               if (session.TryGetProcess(LeagueProcessType.GameClient, out foregroundProcess) ||
                   session.TryGetProcess(LeagueProcessType.PvpNetClient, out foregroundProcess) ||
                   session.TryGetProcess(LeagueProcessType.Launcher, out foregroundProcess)) {
                  var foregroundProcessDerp= Process.GetProcessById(foregroundProcess.Id);
                  List<IntPtr> processWindowHandles = new List<IntPtr>();
                  foreach (ProcessThread thread in foregroundProcessDerp.Threads) {
                     WinAPI.EnumThreadWindows(thread.Id, (hWnd, lparam) => {
                        processWindowHandles.Add(hWnd);
                        return true;
                     }, IntPtr.Zero);
                  }
                  foreach (var processWindowHandle in processWindowHandles) {
                     if (WinAPI.IsWindowVisible(processWindowHandle)) {
                        WinAPI.SetFore
namespace Tests.Unit.Entities
    [TestFixture]
    public class PaymentCardPaymentInstrumentUnitTests
    {
        [Test]
        public void TestConstructIsInstanceOfEntity()
        {
            var PaymentInstrument = new PaymentCardPaymentInstrument();
            Assert.IsInstanceOf<PaymentCardPaymentInstrument>(PaymentInstrument);
        }
        [Test]
        public void TestMethodIsEqualTo()
        {
            var PaymentInstrument = new PaymentCardPaymentInstrument();
            Assert.AreEqual("payment-card", PaymentInstrument.Method);
        }
        [Test]
        public void TestPaymentCardIdDefaultIsEqualTo()
        {
            var PaymentInstrument = new PaymentCardPaymentInstrument();
            Assert.IsNull(PaymentInstrument.PaymentCardId);
        }
        [Test]
        public void TestPaymentCardIdIsEqualTo()
        {
            var PaymentInstrument = new PaymentCardPaymentInstrument();
            PaymentInstrument.PaymentCardId = "test2";
    
namespace Application_ARWDA.Controllers
    public class MasterInstrumentsController : ApiController
    {
        private ARWDADatabaseEntities4 db = new ARWDADatabaseEntities4();
        public IQueryable<MasterInstrument> GetMasterInstruments()
        {
            return db.MasterInstruments;
        }
        [ResponseType(typeof(MasterInstrument))]
        public IHttpActionResult GetMasterInstrument(int id)
        {
            MasterInstrument masterInstrument = db.MasterInstruments.Find(id);
            if (masterInstrument == null)
            {
                return NotFound();
            }
            return Ok(masterInstrument);
        }
        [ResponseType(typeof(void))]
        public IHttpActionResult PutMasterInstrument(int id, MasterInstrument masterInstrument)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }
            if (id != masterInstrument.DividendID)
            {
                

            }
            db.Entry(masterInstrument).State = EntityState.Modified;
            try
            {
                db.SaveChanges();
            }
            catch (DbUpdateConcurrencyException)
            {
                if (!MasterInstrumentExists(id))
                {
                    return NotFound();
                }
                else
                {
                    throw;
                }
            }
            return StatusCode(HttpStatusCode.NoContent);
        }
        [ResponseType(typeof(MasterInstrument))]
        public IHttpActionResult PostMasterInstrument(MasterInstrument masterInstrument)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }
            db.MasterInstruments.Add(masterInstrument);
            try
            {
                db.SaveChanges();
            }
            catch (DbUpdateException)
            {
                if (MasterInstrumentExis

                {
                    return Conflict();
                }
                else
                {
                    throw;
                }
            }
            return CreatedAtRoute("DefaultApi", new { id = masterInstrument.DividendID }, masterInstrument);
        }
        [ResponseType(typeof(MasterInstrument))]
        public IHttpActionResult DeleteMasterInstrument(int id)
        {
            MasterInstrument masterInstrument = db.MasterInstruments.Find(id);
            if (masterInstrument == null)
            {
                return NotFound();
            }
            db.MasterInstruments.Remove(masterInstrument);
            db.SaveChanges();
            return Ok(masterInstrument);
        }
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                db.Dispose();
            }
            base.Dispose(disposing);
        }
        private bool MasterInstrumentExists(int id)
        {

namespace Bloom.Services
    public class ProcessService : IProcessService
    {
        [DllImport("user32.dll")]
        static extern bool SetForegroundWindow(IntPtr hWnd);
        public void GoToBrowserProcess()
        {
            var browserProcessName = Settings.BrowserProcessName;
            var runningProcess = Process.GetCurrentProcess();
            if (runningProcess.ProcessName.StartsWith(browserProcessName))
                return;
            foreach (var process in Process.GetProcesses())
            {
                if (process.ProcessName.StartsWith(browserProcessName))
                {
                    SetForegroundWindow(process.MainWindowHandle);
                    return;
                }
            }
            var executablePath = Settings.BrowserExecutablePath;
            Process.Start(executablePath);
        }
        public void GoToPlayerProcess()
        {
            var playerProcessName = Settings.PlayerProcessName;
            var running

            if (runningProcess.ProcessName.StartsWith(playerProcessName))
                return;
            foreach (var process in Process.GetProcesses())
            {
                if (process.ProcessName.StartsWith(playerProcessName))
                {
                    SetForegroundWindow(process.MainWindowHandle);
                    return;
                }
            }
            var executablePath = Settings.PlayerExecutablePath;
            Process.Start(executablePath);
        }
        public void GoToAnalyticsProcess()
        {
            var analyticsProcessName = Settings.AnalyticsProcessName;
            var runningProcess = Process.GetCurrentProcess();
            if (runningProcess.ProcessName.StartsWith(analyticsProcessName))
                return;
            foreach (var process in Process.GetProcesses())
            {
                if (process.ProcessName.StartsWith(analyticsProcessName))
                {
                    SetForegroundWindow(pr
namespace ManagerConsole.Model
    public class TestData
    {
        public static InstrumentClient GetInstrument(QuotePriceClient quotePriceClient)
        {
            InstrumentClient instrument = new InstrumentClient();
            instrument.Id = quotePriceClient.InstrumentId;
            instrument.Code = "GBP" + GetCode();
            instrument.Origin = "1.1";
            instrument.Ask = "1.5";
            instrument.Bid = "1.2";
            instrument.Denominator = 10;
            instrument.NumeratorUnit = 1;
            instrument.MaxAutoPoint = 100;
            instrument.MaxSpread = 100;
            instrument.AutoPoint = 1;
            instrument.Spread = 3;
            return instrument;
        }
        public static string GetCode()
        {
            int number;
            char code;
            string checkCode = String.Empty;
            Random random = new Random();
            for (int i = 0; i < 4; i++)
            {
                number = random.Next(

                if (number % 2 == 0)
                    code = (char)('0' + (char)(number % 10));
                else
                    code = (char)('A' + (char)(number % 26));
                checkCode += code.ToString();
            } return checkCode;
        }
        public static Dictionary<Guid, InstrumentClient> GetInitializeTestDataForInstrument()
        {
            Dictionary<Guid, InstrumentClient> instruments = new Dictionary<Guid,InstrumentClient>();
            for (int i = 0; i < 10; i++)
            {
                InstrumentClient instrument = new InstrumentClient();
                string guidStr = "66adc06c-c5fe-4428-867f-be97650eb3b" + i;
                instrument.Id = new Guid(guidStr);
                instrument.Code = "GBPUSA" + i;
                instrument.ExchangeCode = "WF01";
                instrument.Ask = "121.32";
                instrument.Bid = "121.30";
                if (i == 1)
                {
                    instrument.Denominato

                }
                else
                {
                    instrument.Denominator = 100;
                }
                instrument.NumeratorUnit = 1;
                instrument.MaxSpread = 100;
                instrument.MaxAutoPoint = 100;
                instrument.AcceptDQVariation = 10;
                instrument.Spread = 2;
                instrument.AutoPoint = 10;
                instrument.Origin = "121.30";
                if (i == 3 || i == 2)
                {
                    instrument.IsNormal = false;
                }
                else
                {
                    instrument.IsNormal = true;
                }
                if (i < 3)
                {
                    instrument.SummaryGroupId = new Guid();
                    instrument.SummaryGroupCode = "AAA";
                }
                else if(i == 4)
                {
                    instrument.SummaryGroupId = new Guid();
                    instrument.SummaryGr
namespace LMPlatform.Data.Repositories
    public class LmPlatformRepositoriesContainer : IRepositoriesContainer
    {
        private readonly LmPlatformModelsContext _dataContext = new LmPlatformModelsContext();
        public IRepositoryBase<TModel> RepositoryFor<TModel>() where TModel : ModelBase, new()
        {
            IRepositoryBase<TModel> result = new RepositoryBase<LmPlatformModelsContext, TModel>(_dataContext);
            return result;
        }
        public IUsersRepository UsersRepository { get; set; }
        public IBugsRepository BugsRepository { get; set; }
        public IBugLogsRepository BugLogsRepository { get; set; }
        public IGroupsRepository GroupsRepository { get; set; }
        public IProjectsRepository ProjectsRepository { get; set; }
        public IProjectUsersRepository ProjectUsersRepository { get; set; }
        public IProjectCommentsRepository ProjectCommentsRepository { get; set; }
        public IStudentsRepository StudentsRepository 

        public ISubjectRepository SubjectRepository { get; set; }
        public ITestsRepository TestsRepository { get; set; }
        public ITestUnlocksRepository TestUnlocksRepository { get; set; }
        public IQuestionsRepository QuestionsRepository { get; set; }
        public IModulesRepository ModulesRepository { get; set; }
        public ILecturerRepository LecturerRepository { get; set; }
        public IMessageRepository MessageRepository { get; set; }
        public IFoldersRepository FoldersRepository { get; set; }
        public IMaterialsRepository MaterialsRepository { get; set; }
        public ISubGroupRepository SubGroupRepository { get; set; }
        public IAttachmentRepository AttachmentRepository { get; set; }
        public ILecturesRepository LecturesRepository { get; set; }
        public ILabsRepository LabsRepository { get; set; }
        public IPracticalRepository PracticalRepository { get; set; }
        public IConceptRepository ConceptRepository {

        public void ApplyChanges()
        {
            _dataContext.SaveChanges();
        }
        public void Dispose()
        {
            _dataContext.Dispose();
        }
        public LmPlatformRepositoriesContainer()
        {
            UsersRepository = new UsersRepository(_dataContext);
            BugsRepository = new BugsRepository(_dataContext);
            BugLogsRepository = new BugLogsRepository(_dataContext);
            GroupsRepository = new GroupsRepository(_dataContext);
            ProjectsRepository = new ProjectsRepository(_dataContext);
            ProjectUsersRepository = new ProjectUsersRepository(_dataContext);
            ProjectCommentsRepository = new ProjectCommentsRepository(_dataContext);
            StudentsRepository = new StudentsRepository(_dataContext);
            SubjectRepository = new SubjectRepository(_dataContext);
            TestsRepository = new TestsRepository(_dataContext);
            TestUnlocksRepository = new TestUnlockRepos
namespace Lte.WebApp.Controllers.Topic
    public class CollegeCellsController : ApiController
    {
        private readonly IInfrastructureRepository _repository;
        private readonly ICellRepository _cellRepository;
        private readonly IENodebRepository _eNodebRepository;
        public CollegeCellsController(IInfrastructureRepository repository, ICellRepository cellRepository,
            IENodebRepository eNodebRepository)
        {
            _repository = repository;
            _cellRepository = cellRepository;
            _eNodebRepository = eNodebRepository;
        }
        [HttpGet]
        public IEnumerable<CellView> Get(string collegeName)
        {
            return
                _repository.QueryCollegeCells(_cellRepository, collegeName)
                    .Select(x => new CellView(x, _eNodebRepository));
        }
    }
    public class CollegeCdmaCellsController : ApiController
    {
        private readonly IInfrastructureRepository _repository;
     
namespace MsgQueue.Storage
    internal class ChunkManager
    {
        private readonly object _lockObj = new object();
        public string ChunkPath { get; set; }
        public ChunkManager()
        {
            ChunkPath = HostingEnvironment.MapPath(ChunkManagerConfig.BasePath);
        }
        public Chunk InitNewChunk()
        {
            return GetNewChunkStrategy(null);
        }
        public Chunk GetNewChunkStrategy(Chunk chunk)
        {
            lock (_lockObj)
            {
                int num = 0;
                if (chunk != null)
                {
                    num = Convert.ToInt32(chunk.ChunkFileName.Split('.')[0].Split('_')[1]);
                }
                string fileName = string.Format(ChunkManagerConfig.FileNamingStrategy, num + 1) +
                                  ChunkManagerConfig.FileNameSuffix;
                if (chunk != null)
                {
                    chunk.ChunkFileName = fileName;
                    return ch

                }
                return new Chunk
                {
                    IsCompleted = false,
                    ChunkSize = 0,
                    ChunkFileName = fileName,
                    ChunkPath = ChunkPath
                };
            }
        }
        public Chunk GetLastChunk()
        {
            lock (_lockObj)
            {
                var fileInfo =
                    new DirectoryInfo(ChunkPath).GetFiles()
                        .OrderByDescending(x => x.LastWriteTime)
                        .FirstOrDefault();
                if (fileInfo == null)
                {
                    return InitNewChunk();
                }
                var chunk = new Chunk();
                if (fileInfo.Length > ChunkManagerConfig.ChunkDataSize ||
                    fileInfo.LastWriteTime.AddHours(ChunkManagerConfig.DataSynchronousHours) < DateTime.Now)
                {
                    chunk.IsCompleted = true;
                    File.SetAtt
namespace Diese.Scheduling
    public class Scheduler<T> : SchedulerBase<Scheduler<T>.Controller, T>
    {
        protected override Controller CreateController(SchedulerGraph<T>.Vertex vertex)
        {
            return new Controller(this, vertex);
        }
        public class Controller : IRelativeController<Controller, T>, IPriorityController<Controller>
        {
            protected readonly PriorityController<Controller, T> PriorityController;
            protected readonly RelativeController<Controller, T> RelativeController;
            public Controller(SchedulerBase<Controller, T> scheduler, SchedulerGraph<T>.Vertex vertex)
            {
                PriorityController = new PriorityController<Controller,T>(scheduler, vertex);
                RelativeController = new RelativeController<Controller, T>(scheduler, vertex);
            }
            public Controller After(T item)
            {
                RelativeController.After(item);
                return this;
namespace YacqPlugin
    partial class YacqFilter
    {
        internal static class Symbols
        {
            [YacqSymbol(DispatchTypes.Unknown, null)]
            public static Expression Missing(DispatchExpression e, SymbolTable s, Type t)
            {
                Type type;
                if (e.DispatchType == DispatchTypes.Method
                    && !s.ExistsKey(DispatchTypes.Method, e.Name)
                    && (type = FilterRegistrant.GetFilter(e.Name).FirstOrDefault()) != null
                )
                {
                    return YacqExpression.Dispatch(
                        s,
                        DispatchTypes.Constructor,
                        YacqExpression.TypeCandidate(type),
                        null,
                        e.Arguments
                    )
                        .Method(s, "Filter", YacqExpression.Identifier(s, "it"));
                }
                return DispatchExpression.DefaultMissing(e, s, t);
            }
namespace RevolutionEntities.Process
    public class SystemProcess : Process, ISystemProcess
    {
        public SystemProcess(IProcess process, IMachineInfo machineInfo) : base(process.Id,process.ParentProcessId,process.Name,process.Description, process.Symbol, process.User)
        {
            MachineInfo = machineInfo;
        }
        public SystemProcess(ISystemProcessInfo systemProcessInfo, IUser user, IMachineInfo machineInfo) : base(systemProcessInfo.Id, systemProcessInfo.ParentProcessId, systemProcessInfo.Name, systemProcessInfo.Description, systemProcessInfo.Symbol, user)
        {
            MachineInfo = machineInfo;
        }
        public IMachineInfo MachineInfo { get; }
   
    }
    public class ProcessState : IProcessState
    {
        public ProcessState(ISystemProcess process, IProcessStateInfo stateInfo)
        {
            StateInfo = stateInfo;
            Process = process;
            ProcessId = process.Id;
        }
        public int ProcessId { ge

        public IProcessStateInfo StateInfo { get; }
        public ISystemProcess Process { get; }
    }
    public class ProcessStateEntity :ProcessState, IProcessStateEntity
    {
        public ProcessStateEntity(ISystemProcess process, IDynamicEntity entity, IStateInfo info) : base(process, info)
        {
            Entity = entity;
        }
        public IDynamicEntity Entity { get; set; }
    }
    public class ProcessStateList : ProcessState, IProcessStateList
    {
        public ProcessStateList(ISystemProcess process, IDynamicEntity entity, IEnumerable<IDynamicEntity> entitySet, IEnumerable<IDynamicEntity> selectedEntities, IProcessStateInfo stateInfo) : base(process, stateInfo)
        {
            Entity = entity;
            EntitySet = entitySet;
            SelectedEntities = selectedEntities;
        }
        public IDynamicEntity Entity { get; }
        public IEnumerable<IDynamicEntity> EntitySet { get; }
        public IEnumerable<IDynamicEntity> SelectedEntit
namespace Dermatologic.Data
    public abstract class AbstractRepositoryFactory
    {
        public static readonly Type REPOSITORY_FACTORY = typeof(RepositoryFactory);
        public static RepositoryFactory Instance(Type factory)
        {
            try
            {
                return (RepositoryFactory)Activator.CreateInstance(factory);
            }
            catch (Exception ex)
            {
                throw new Exception(string.Format("No se crear Factory de Repositorios: -> {0}", ex.Message));
            }
        }
        public abstract IOfficeRepository GetOfficeRepository();
        public abstract IAppointmentRepository GetAppointmentRepository();
        public abstract IMedicalCareRepository GetMedicalCareRepository();
        public abstract IServiceRepository GetServiceRepository();
        public abstract IMenuRepository GetMenuRepository();
        public abstract ISessionRepository GetSessionRepository();
        public abstract IUbigeoRepository Ge

        public abstract IUsersInRolesRepository GetUsersInRolesRepository();
        public abstract IUsersRepository GetUsersRepository();
        public abstract IRoleRepository GetRoleRepository();
        public abstract IMenuRoleRepository GetMenuRoleRepository();
        public abstract IMedicationRepository GetMedicationRepository();
        public abstract IRateRepository GetRateRepository();
        public abstract ISupplyRepository GetSupplyRepository();
        public abstract IPersonRepository GetPersonRepository();
        public abstract IPersonTypeRepository GetPersonTypeRepository();
        public abstract IExchangeRateRepository GetExchangeRateRepository();
        public abstract IAccountRepository GetAccountRepository();
        public abstract ICostCenterRepository GetCostCenterRepository();
        public abstract IInvoiceRepository GetInvoiceRepository();
        public abstract ICashMovementRepository GetCashMovementRepository();
        public abstract IPatien
[RequireComponent(typeof(Collider), typeof(Rigidbody))]
public class InteractableObject : MonoBehaviour
	public UnityEvent 
	ControllerEnter, ControllerStay, ControllerExit,
	ControllerTriggerDown, ControllerTriggerStay, ControllerTriggerUp,
	TrackerEnter, TrackerStay, TrackerUp;
	public virtual void OnControllerEnter(Controller controller){ControllerEnter.Invoke();}
	public virtual void OnControllerStay(Controller controller){ControllerStay.Invoke();}
	public virtual void OnControllerExit(Controller controller){ControllerExit.Invoke();}
	public virtual void OnControllerTriggerDown(Controller controller){ControllerTriggerDown.Invoke();}
	public virtual void OnControllerTriggerStay(Controller controller){ControllerTriggerStay.Invoke();}
	public virtual void OnControllerTriggerUp(Controller controller){ControllerTriggerUp.Invoke();}
	public virtual void OnTrackerEnter(Controller controller){TrackerEnter.Invoke();}
	public virtual void OnTrackerStay(Controller controller){TrackerEnter.Inv
namespace SharpWired.Controller {
    public class SharpWiredController {
        private ChatController chatController;
        private UserController userController;
        private NewsController newsController;
        private FileListingController fileListingController;
        private FileTransferController fileTransferController;
        private GroupController groupController;
        private PrivateMessageController privateMessagesController;
        private readonly SharpWiredModel model;
        private Server Server { get; set; }
        private static SharpWiredController instance;
        public static SharpWiredController Instance {
            get { return instance; }
            set {
                if (instance == null) {
                    instance = value;
                } else {
                    throw new SingletonException("Singleton already created");
                }
            }
        }
        public FileTransferController FileTransferController { ge

        public FileListingController FileListingController { get { return fileListingController; } }
        public ChatController ChatController { get { return chatController; } }
        public UserController UserController { get { return userController; } }
        public SharpWiredController(SharpWiredModel model) {
            this.model = model;
            this.model.Connected += OnConnected;
        }
        private void OnConnected(Server server) {
            Server = server;
            Server.Online += OnOnline;
        }
        private void OnOnline() {
            Server.Offline += OnOffline;
            chatController = new ChatController(model);
            userController = new UserController(model);
            groupController = new GroupController(model);
            newsController = new NewsController(model);
            fileListingController = new FileListingController(model);
            fileTransferController = new FileTransferController(model);
            pri
namespace BandAide.Web.Models.ViewModels
    public class NeedBandQueryViewModel
    {
        private readonly IEnumerable<Instrument> _instruments;
        public ApplicationUser User { get; set; }
        public Instrument SelectedInstrument { get; set; }
        public SelectList MyInstrumentsSelectList { get; set; }
        public SelectListItem SelectedInstrumentSelectListItem { get; set; }
        public Guid SelectedInstrumentId { get; set; }
        public List<InstrumentSkill> MyInstrumentSkills { get; set; }
        public List<Band> SearchResults { get; set; }
        public NeedBandQueryViewModel(ApplicationUser user)
        {
            User = user;
            MyInstrumentSkills = user.InstrumentSkills.OrderByDescending(x => x.Proficiency).ToList();
            List<Instrument> instruments= MyInstrumentSkills.Select(instrumentSkill => instrumentSkill.Instrument).ToList();
            MyInstrumentsSelectList = new SelectList(instruments, "Id", "Name");
        }
       
﻿/*
    This code was automatically generated.
    Changes to this file may be lost if regeneration occurs.
*/
namespace EcoDomus.Data.Common.UnitOfWork
	public interface IRepositoryUnitOfWork : IUnitOfWork
	{
		DateTime GetCurrentTimestamp();
		DateTime GetUtcDateTime();
		IActionRepository ActionRepository { get; }
		IActionTypeUserTransportRepository ActionTypeUserTransportRepository { get; }
		IActivityLogRepository ActivityLogRepository { get; }
		IActivityLogStatusRepository ActivityLogStatusRepository { get; }
		IAggregatedActionRepository AggregatedActionRepository { get; }
		IAggregatorRepository AggregatorRepository { get; }
		IAlarmRuleRepository AlarmRuleRepository { get; }
		IAnalyzerRepository AnalyzerRepository { get; }
		IApplicationLanguageRepository ApplicationLanguageRepository { get; }
		IApprovalByRepository ApprovalByRepository { get; }
		IAssetAreaServedRepository AssetAreaServedRepository { get; }
		IAssetAttributeRepository AssetAttributeRepository { get; }
		I

		IAssetChangeLogRepository AssetChangeLogRepository { get; }
		IAssetRepository AssetRepository { get; }
		IAssetTypeRepository AssetTypeRepository { get; }
		IAttributeHyperlinkRepository AttributeHyperlinkRepository { get; }
		IAttributeTemplateClassificationLinkupRepository AttributeTemplateClassificationLinkupRepository { get; }
		IAttributeTemplateRepository AttributeTemplateRepository { get; }
		IAttributeTypeRepository AttributeTypeRepository { get; }
		IAttributeWorkOrderTableSequenceWithfilterRepository AttributeWorkOrderTableSequenceWithfilterRepository { get; }
		IBarcodeConfigDetailRepository BarcodeConfigDetailRepository { get; }
		IBarcodeEntityFieldTypeRepository BarcodeEntityFieldTypeRepository { get; }
		IBarcodeStructureRepository BarcodeStructureRepository { get; }
		IBarcodeTypeRepository BarcodeTypeRepository { get; }
		IBasAttributeEventDispatchRepository BasAttributeEventDispatchRepository { get; }
		IBasAttributeEventParametersRepository BasAttributeEventParam

		IBasAttributeEventRepository BasAttributeEventRepository { get; }
		IBasAttributeEventTypeRepository BasAttributeEventTypeRepository { get; }
		IBasAttributeHistoryRepository BasAttributeHistoryRepository { get; }
		IBasAttributeQualityRepository BasAttributeQualityRepository { get; }
		IBasRecordingTypeRepository BasRecordingTypeRepository { get; }
		IBasServerProtocolParametersRepository BasServerProtocolParametersRepository { get; }
		IBasServerProtocolRepository BasServerProtocolRepository { get; }
		IBasServerRepository BasServerRepository { get; }
		IBasWeatherHistoryRepository BasWeatherHistoryRepository { get; }
		IBasWeatherStationRepository BasWeatherStationRepository { get; }
		IBimQueryGISRepository BimQueryGISRepository { get; }
		IBimQueryParameterLinkupGisRepository BimQueryParameterLinkupGisRepository { get; }
		IChangeLogAffectedSystemsRepository ChangeLogAffectedSystemsRepository { get; }
		IChangeLogRepository ChangeLogRepository { get; }
		ICityRepository CityRep
public class Inventory {
    private Dictionary<string, bool> obtained_instruments;
    private const int total_number_instruments = 3;
    private List<string> instruments_order;
    private int equipped_instrument;
    public Inventory() {
        obtained_instruments = new Dictionary<string, bool>();
        obtained_instruments.Add("guitar", false);
        obtained_instruments.Add("electric_guitar", false);
        obtained_instruments.Add("keyboard", false);
        instruments_order = new List<string>();
        instruments_order.Add("guitar");
        instruments_order.Add("electric_guitar");
        instruments_order.Add("keyboard");
        equipped_instrument = 1;
    }
    public void SetInstrument(string instrument) {
        obtained_instruments[instrument] = true;
    }
    public string GetEquippedInstrument() {
        return instruments_order[equipped_instrument];
    }
    public void ChangeInstrument(int direction) {
  
        if (equipped_instrument + direction < 
namespace LogBook.Business
    public class instrument_master_class
    {
        LogBookDataContext dt = new LogBookDataContext();
        public void SaveInstrument(tbl_logbook_instrument_master tblObj)
        {
            if (tblObj.id == 0)
                dt.tbl_logbook_instrument_masters.InsertOnSubmit(tblObj);
            
            dt.SubmitChanges();
        }
        public tbl_logbook_instrument_master GetInstrument(int InstrumentId)
        {
            return dt.tbl_logbook_instrument_masters.Where(e => e.id == InstrumentId).SingleOrDefault();
        }
        public List<tbl_logbook_instrument_master> GetInstruments(string strInstrument)
        {
            return dt.tbl_logbook_instrument_masters.ToList();
        }
        public object GetInstrumentList(string strInstrument, int deptid)
        {
            var temp = (from c in dt.tbl_logbook_instrument_masters
                        where
                        (strInstrument == string.Empty || c.name.Cont

                        (deptid == 0 || c.deptid == deptid)
                        select new
                        {
                            id = c.id,
                            name =c.name,
                            dept = c.tbl_logbook_department_master.name,
                            status = c.IsActive,
                            statusUrl = c.IsActive == true ? "~/Images/Icons/active.png" : "~/Images/Icons/inactive.png",
             
                        }).ToList();
            return temp;
        }
        public void DeleteInstrument(int InstrumentId)
        {
            tbl_logbook_instrument_master obj = dt.tbl_logbook_instrument_masters.Where(e => e.id == InstrumentId).SingleOrDefault();
            if (obj != null)
                dt.tbl_logbook_instrument_masters.DeleteOnSubmit(obj);
            dt.SubmitChanges();
        }
        public void ChangeStatus(int id)
        {
            tbl_logbook_instrument_master obj = dt.tbl_logbook_instrument_m
namespace SilverDaleSchools.DAL
    public class UnitOfWork : IDisposable
    {
        private sdContext context = new sdContext();
        private StaffRepository staffRepository;
        private StudentRepository studentRepository;
        private ResultRepository resultRepository;
        private PersonRepository personRepository;
        private LevelRepository levelRepository;
        private MyRoleRepository myRoleRepository;
        private NewsBoardRepository newsBoardRepository;
        public LevelRepository LevelRepository
        {
            get
            {
                if (this.levelRepository == null)
                {
                    this.levelRepository = new LevelRepository(context);
                }
                return levelRepository;
            }
        }
        public NewsBoardRepository NewsBoardRepository
        {
            get
            {
                if (this.newsBoardRepository == null)
                {
                    this.news

                }
                return newsBoardRepository;
            }
        }
        public MyRoleRepository MyRoleRepository
        {
            get
            {
                if (this.myRoleRepository == null)
                {
                    this.myRoleRepository = new MyRoleRepository(context);
                }
                return myRoleRepository;
            }
        }
        public PersonRepository PersonRepository
        {
            get
            {
                if (this.personRepository == null)
                {
                    this.personRepository = new PersonRepository(context);
                }
                return personRepository;
            }
        }
        public ResultRepository ResultRepository
        {
            get
            {
                if (this.resultRepository == null)
                {
                    this.resultRepository = new ResultRepository(context);
                }
                return resultR

            }
        }
        public StudentRepository StudentRepository
        {
            get
            {
                if (this.studentRepository == null)
                {
                    this.studentRepository = new StudentRepository(context);
                }
                return studentRepository;
            }
        }
        public StaffRepository StaffRepository
        {
            get
            {
                if (this.staffRepository == null)
                {
                    this.staffRepository = new StaffRepository(context);
                }
                return staffRepository;
            }
        }
      
        public void Save()
        {
            try
            {
                context.SaveChanges();
            }
            catch (Exception e)
            {
            }
        }
        private bool disposed = false;
        protected virtual void Dispose(bool disposing)
        {
            if (!this.disposed)
          
namespace DRMFSS.BLL.Services
    public interface IOtherDispatchAllocationService:IDisposable
    {
        bool AddOtherDispatchAllocation(OtherDispatchAllocation otherDispatchAllocation);
        bool DeleteOtherDispatchAllocation(OtherDispatchAllocation otherDispatchAllocation);
        bool DeleteById(int id);
        bool EditOtherDispatchAllocation(OtherDispatchAllocation otherDispatchAllocation);
        OtherDispatchAllocation FindById(int id);
        OtherDispatchAllocation FindById(Guid id);
       
        List<OtherDispatchAllocation> GetAllOtherDispatchAllocation();
        List<OtherDispatchAllocation> FindBy(Expression<Func<OtherDispatchAllocation, bool>> predicate);
        void Save(ViewModels.Dispatch.OtherDispatchAllocationViewModel model);
        OtherDispatchAllocationViewModel GetViewModelByID(Guid otherDispatchAllocationId);
        List<OtherDispatchAllocation> GetAllToCurrentOwnerHubs(UserProfile user);
        List<OtherDispatchAllocation> GetAllToOtherOwne
namespace DoorofSoul.Database.MySQL.DatabaseElements.Repositories
    class MySQLNatureRepositoryList : NatureRepositoryList
    {
        private MySQLWorldRepository worldRepository;
        private MySQLSceneRepository sceneRepository;
        private MySQLContainerRepository containerRepository;
        private MySQLEntityRepository entityRepository;
        private MySQLContainerElementsRepositoryList containerElementsRepositoryList;
        private MySQLEntityElementsRepositoryList entityElementsRepositoryList;
        private MySQLSceneElementsRepositoryList sceneElementsRepositoryList;
        public override WorldRepository WorldRepository { get { return worldRepository; } }
        public override SceneRepository SceneRepository { get { return sceneRepository; } }
        public override ContainerRepository ContainerRepository { get { return containerRepository; } }
        public override EntityRepository EntityRepository { get { return entityRepository; } }
        public o
namespace FinanceMvc.Repositories.Entity
    public class RepositoryFactory : IRepositoryFactory
    {
        protected readonly FinanceMvcContext Db;
        protected ICategoryRepository CategoryRepository;
        protected IPropertyRepository PropertyRepository;
        protected ITransactionRepository TransactionRepository;
        protected IAccountRepository AccountRepository;
        protected IUserRepository UserRepository;
        public RepositoryFactory()
        {
            Db = new FinanceMvcContext();
        }
        public ICategoryRepository GetCategoryRepository()
        {
            CategoryRepository = CategoryRepository ?? new CategoryRepository(Db);
            return CategoryRepository;
        }
        public IPropertyRepository GetPropertyRepository()
        {
            PropertyRepository = PropertyRepository ?? new PropertyRepository(Db);
            return PropertyRepository;
        }
        public ITransactionRepository GetTransactionRepository(
public class TileLayer : PoolBehaviour {
    public int centerTileX;
    public int centerTileY;
    public int centerChunkX;
    public int centerChunkY;
    
    public int chunkWidth;
    public int chunkHeight;
    public int widthInChunks;
    public int heightInChunks;
    public TileChunk[,] chunks;
    public delegate void ChunkCreatedHandler(TileChunk newChunk);
    public event ChunkCreatedHandler OnChunkCreated;
    
    public override void OnCreate() {
        chunkWidth = TileChunk.width;
        chunkHeight = TileChunk.height;
        widthInChunks = 16;
        heightInChunks = 16;
        chunks = new TileChunk[widthInChunks, heightInChunks];
        
        centerChunkX = widthInChunks/2;
        centerChunkY = heightInChunks/2;
        centerTileX = centerChunkX * chunkWidth;
        centerTileY = centerChunkY * chunkHeight;
    } 
    public IEnumerable<TileChunk> AllChunks {
        get {
            for (var i = 0; i < widthInChunks; i++) {
                for (v

                    var chunk = chunks[i, j];
                    if (chunk != null) yield return chunk;
                }
            }
        }
    }
    public void EnableRendering() {
        foreach (var chunk in AllChunks) {
            chunk.renderer.enabled = true;
        }
    }
    
    public void DisableRendering() {
        foreach (var chunk in AllChunks) {
            chunk.renderer.enabled = false;
        }
    }
    
    public Tile this[IntVector2 bp] {
        get {
            var trueX = centerTileX + bp.x;
            var trueY = centerTileY + bp.y;
            var chunkX = trueX/chunkWidth;
            var chunkY = trueY/chunkHeight;
            var localX = trueX%chunkWidth;
            var localY = trueY%chunkHeight;
            
            if (chunkX < 0 || chunkX >= chunkWidth || chunkY < 0 || chunkY >= chunkHeight)
                return null;
            
            var chunk = chunks[chunkX, chunkY];
            if (chunk == null) return null;
      

            return chunk[localX, localY];
        }
        set {
            var trueX = centerTileX + bp.x;
            var trueY = centerTileY + bp.y;
            var trueChunkX = trueX/chunkWidth;
            var trueChunkY = trueY/chunkHeight;
            var localX = trueX%chunkWidth;
            var localY = trueY%chunkHeight;
            
            var chunk = chunks[trueChunkX, trueChunkY];
            if (chunk == null && value != null) {
                chunk = Pool.For("TileChunk").Attach<TileChunk>(transform);
                chunk.transform.localPosition = new Vector2(
                    (trueChunkX - centerChunkX) * chunkWidth * Tile.worldSize, 
                    (trueChunkY - centerChunkY) * chunkHeight * Tile.worldSize
                 );    
                chunk.gameObject.SetActive(true);
                chunks[trueChunkX, trueChunkY] = chunk;
                if (OnChunkCreated != null)
                    OnChunkCreated(chunk);
            }
            if (c
namespace Kikwak.AutoFunctionCollection
	public class DebugginLog
	{
		public static DebugginLog Instance = new DebugginLog();
		private DebuggingWindow dw = new DebuggingWindow();
		[System.Diagnostics.Conditional("DEBUG")]	
		public void Show()
		{
			if (dw == null) {
				dw = new DebuggingWindow();
				if (dw.InvokeRequired) {
					dw.BeginInvoke(new InvokeDelegate(InvokeShow));
				}
				else {
					InvokeShow();
				}
			}
			else if (dw.IsDisposed) {
				dw = new DebuggingWindow();
				if (dw.InvokeRequired) {
					dw.BeginInvoke(new InvokeDelegate(InvokeShow));
				}
				else {
					InvokeShow();
				}
			}
			else if (!dw.Visible) {
				if (dw.InvokeRequired) {
					dw.BeginInvoke(new InvokeDelegate(InvokeShow));
				}
				else {
					InvokeShow();
				}
			}
		}
		private delegate void InvokeDelegate();
		private void InvokeShow()
		{
			dw.Show();
		}
		[System.Diagnostics.Conditional("DEBUG")]
		public void AddString(string msg, string catagory)
		{
			dw.AddString(msg, cat
namespace SchwabenCode.QuickIO.UnitTests
    public class QuickIOFileChunkTests
    {
        [Fact]
        public void QuickIOFileChunkEqualTests()
        {
            var position = 1;
            byte[ ] bytes = new byte[ 10 ];
            QuickIOFileChunk chunk = new QuickIOFileChunk( 1, bytes );
            chunk.Position.Should().Be( 1 );
            chunk.Bytes.Should().Equal( bytes );
            QuickIOFileChunk sameChunk = new QuickIOFileChunk( 1, bytes );
            sameChunk.Position.Should().Be( 1 );
            sameChunk.Bytes.Should().Equal( bytes );
            chunk.PositionEquals( sameChunk ).Should().Be( true );
            chunk.BytesEquals( sameChunk ).Should().Be( true );
            chunk.ChunkEquals( sameChunk ).Should().Be( true );
            chunk.Equals( sameChunk ).Should().Be( false );
            byte[ ] otherBytes = new byte[ 5 ];
            QuickIOFileChunk otherChunk = new QuickIOFileChunk( 2, otherBytes );
            otherChunk.Position.Should()
public class ChunkSpawner : MonoBehaviour {
    public int totalNumOfChunks;
    public GameObject wobble;
    float levelLength = 0;
    int numberOfChunks = 0;
    List<GameObject> chunks = new List<GameObject>();
	void Start () {
        /*
        GameObject chunk = (GameObject)Instantiate(Resources.Load("Chunk1"));
        levelLength = chunk.GetComponent<Chunk>().chunkLength;
        chunk.transform.position = new Vector3(0, 0, 0);
        numberOfChunks++;
        chunks.Add(chunk);
         * */
        SpawnChunk("1");
	}
	void Update () {
        /*
        if (wobble.transform.position.x > levelLength - 25)
        {
            int rand = Random.Range(1, totalNumOfChunks+1);
            GameObject chunk = (GameObject)Instantiate(Resources.Load("Chunk" + rand.ToString()));
            chunk.transform.position = new Vector3(levelLength, 0, 0);
            levelLength += chunk.GetComponent<Chunk>().chunkLength;
            numberOfChunks++;
            chunks.Add(chunk);
     
namespace NewLife.Queue.Storage
    public class ChunkReader
    {
        private readonly ChunkManager _chunkManager;
        private readonly ChunkWriter _chunkWriter;
        public ChunkReader(ChunkManager chunkManager, ChunkWriter chunkWriter)
        {
            Ensure.NotNull(chunkManager, "chunkManager");
            Ensure.NotNull(chunkWriter, "chunkWriter");
            _chunkManager = chunkManager;
            _chunkWriter = chunkWriter;
        }
        public T TryReadAt<T>(long position, Func<byte[], T> readRecordFunc, bool autoCache = true) where T : class, ILogRecord
        {
            var lastChunk = _chunkWriter.CurrentChunk;
            var maxPosition = lastChunk.GlobalDataPosition;
            if (position >= maxPosition)
            {
                return null;
            }
            var chunkNum = _chunkManager.GetChunkNum(position);
            var chunk = _chunkManager.GetChunk(chunkNum);
            if (chunk == null)
            {
                
namespace Assets.Scripts.Internal
    public struct ChunkVector
    {
        public byte x;
        public byte y;
        public byte z;
        public ChunkVector(byte x, byte y, byte z)
        {
            this.x = x;
            this.y = y;
            this.z = z;
        }
        public ChunkVector(int x, int y, int z)
        {
            this.x = (byte)x;
            this.y = (byte)y;
            this.z = (byte)z;
        }
        public ChunkVector Above
        {
            get
            {
                return new ChunkVector(x, y < 15 ? y + 1 : 15, z);
            }
        }
        public ChunkVector Below
        {
            get
            {
                return new ChunkVector(x, y == 0 ? 0 : y - 1, z);
            }
        }
        public ChunkVector Left
        {
            get
            {
                return new ChunkVector(x - 1, y, z);
            }
        }
        public ChunkVector Right
        {
            get
            {
           
namespace NAudio.SoundFont
    internal class InstrumentBuilder : StructureBuilder<Instrument>
    {
        private Instrument lastInstrument = null;
        public override Instrument Read(BinaryReader br)
        {
            Instrument i = new Instrument();
            string s = Encoding.UTF8.GetString(br.ReadBytes(20), 0, 20);
            if (s.IndexOf('\0') >= 0)
            {
                s = s.Substring(0, s.IndexOf('\0'));
            }
            i.Name = s;
            i.startInstrumentZoneIndex = br.ReadUInt16();
            if (lastInstrument != null)
            {
                lastInstrument.endInstrumentZoneIndex = (ushort)(i.startInstrumentZoneIndex - 1);
            }
            data.Add(i);
            lastInstrument = i;
            return i;
        }
        public override void Write(BinaryWriter bw, Instrument instrument)
        {
        }
        public override int Length
        {
            get
            {
                return 22;
           
public class TerrainChunk : Chunk {
	public SolidSubChunk groundChunk;
	public AlphaWaveSubChunk grassChunk;
	public override void Start () {
		updateChunk = true;
	}
	public override void poolStart() {
		blockWorld = new short[chunkWidth,chunkHeight,chunkDepth];
		for(int x = 0; x<chunkWidth; x++ )
			for(int y=0; y<chunkHeight; y++)
				for(int z=0; z<chunkDepth; z++)
					blockWorld[x,y,z] = 0;
		updateChunk = false;
		subChunk.Clear();
		StartCoroutine(Generate());
	}
	public override IEnumerator Generate() {
		
		SolidSubChunk Ground = groundChunk.GetPooledInstance<SolidSubChunk> ();	
		Ground.parentChunk = this;	
		Ground.chunkWidth = chunkWidth;
		Ground.chunkHeight = chunkHeight;
		Ground.chunkDepth = chunkDepth;
		Ground.index = 0;
		Ground.transform.position = position;
		subChunk.Add(Ground);
		
		AlphaWaveSubChunk Grass = grassChunk.GetPooledInstance<AlphaWaveSubChunk> ();	
		Grass.parentChunk = this;	
		Grass.chunkWidth = chunkWidth;
		Grass.chunkHeight = chunkHeight;
		Gr
namespace Cresce.Business.Tests
    public class TestableDataServices : IDataServices
    {
        public Mock<IPatientRepository> PatientRepositoryMock;
        public Mock<IServiceRepository> ServiceRepositoryMock;
        public Mock<IAppointmentRepository> AppointmentRepositoryMock;
        public Mock<IContractRepository> ContractRepositoryMock;
        public Mock<IUserRepository> UserRepositoryMock;
        public Mock<IInvoiceRepository> InvoiceRepositoryMock;
        public Mock<IDiscountRepository> DiscountRepositoryMock;
        public Mock<IPaymentRepository> PaymentRepositoryMock;
        public TestableDataServices()
        {
            CreateMocks();
        }
        private void SetMockInstances()
        {
            PatientRepository = PatientRepositoryMock.Object;
            ServiceRepository = ServiceRepositoryMock.Object;
            AppointmentRepository = AppointmentRepositoryMock.Object;
            ContractRepository = ContractRepositoryMock.Object;
     

            InvoiceRepository = InvoiceRepositoryMock.Object;
            DiscountRepository = DiscountRepositoryMock.Object;
            PaymentRepository = PaymentRepositoryMock.Object;
        }
        private void CreateMocks()
        {
            PatientRepositoryMock = new Mock<IPatientRepository>();
            ServiceRepositoryMock = new Mock<IServiceRepository>();
            AppointmentRepositoryMock = new Mock<IAppointmentRepository>();
            ContractRepositoryMock = new Mock<IContractRepository>();
            UserRepositoryMock = new Mock<IUserRepository>();
            InvoiceRepositoryMock = new Mock<IInvoiceRepository>();
            DiscountRepositoryMock = new Mock<IDiscountRepository>();
            PaymentRepositoryMock = new Mock<IPaymentRepository>();
            SetMockInstances();
        }
        public void Init() { }
        public IAppointmentRepository AppointmentRepository { get; set; }
        public IPatientRepository PatientRepository { get; 
namespace Devcat.Core.Threading
	public sealed class LoadFragmentManager
	{
		internal bool IsInThread
		{
			get
			{
				return this.threadLoad.IsInThread;
			}
		}
		public int TotalLoad
		{
			get
			{
				return this.totalLoad;
			}
		}
		public object Tag
		{
			get
			{
				return this.tag;
			}
			set
			{
				this.tag = value;
			}
		}
		public LoadFragmentManager()
		{
			this.jobList = new PriorityQueue<LoadFragment>();
			this.threadLoad = new ThreadLoad();
			this.threadLoad.Operationable += this.ThreadLoad_Operationable;
			this.newLoadFragmentList = new WriteFreeQueue2<LoadFragment>();
		}
		public void Startup(LoadBalancer loadBalancer)
		{
			if (this.loadBalancer != null)
			{
				throw new InvalidOperationException("Already registered to LoadBalancer");
			}
			this.loadBalancer = loadBalancer;
			loadBalancer.Add(this.threadLoad);
		}
		public void Cleanup()
		{
			this.loadBalancer.Remove(this.threadLoad);
		}
		internal void Add(LoadFragment loadFragment)
		{
			t

			this.threadLoad.Load = this.totalLoad + 1;
		}
		internal void Remove(LoadFragment loadFragment)
		{
			if (loadFragment.PriorityQueueElement.Valid)
			{
				this.jobList.Remove(loadFragment.PriorityQueueElement);
			}
			this.totalLoad -= loadFragment.PreviousLoad;
			loadFragment.PreviousLoad = 0;
			loadFragment.SetManagerInternal(null);
		}
		internal void Reserve(LoadFragment loadFragment)
		{
			this.Add(loadFragment);
		}
		private void DoReserve(LoadFragment loadFragment)
		{
			if (loadFragment.PriorityQueueElement.Valid)
			{
				return;
			}
			if (loadFragment.Manager == null)
			{
				loadFragment.SetManagerInternal(this);
				loadFragment.InvokeManagerAssign();
			}
			int previousLoad = loadFragment.PreviousLoad;
			int load = loadFragment.Load;
			loadFragment.PreviousLoad = load;
			this.totalLoad += load - previousLoad;
			if (load != 0)
			{
				loadFragment.PriorityQueueElement.Value = loadFragment;
				loadFragment.PriorityQueueElement.Priority = loadFragment.P
namespace DAL.Repository
    public class UnitOfWork : IUnitOfWork
    {
        public FloorballBaseCtx Ctx { get; set; }
        private IEventRepository eventRepository;
        [Inject]
        public IEventRepository EventRepository
        {
            get => eventRepository;
            set
            {
                eventRepository = value;
                eventRepository.Ctx = Ctx;
            }
        }
        private ILeagueRepository leagueRepository;
        [Inject]
        public ILeagueRepository LeagueRepository
        {
            get => leagueRepository; 
            set
            {
                leagueRepository = value;
                leagueRepository.Ctx = Ctx;
            }
        }
        private IMatchRepository matchRepository;
        [Inject]
        public IMatchRepository MatchRepository
        {
            get => matchRepository;
            set
            {
                matchRepository = value;
                matchRepository.Ctx = C

            }
        }
        private IPlayerRepository playerRepository;
        [Inject]
        public IPlayerRepository PlayerRepository
        {
            get => playerRepository; 
            set
            {
                playerRepository = value;
                playerRepository.Ctx = Ctx;
            }
        }
        private IRefereeRepository refereeRepository;
        [Inject]
        public IRefereeRepository RefereeRepository
        {
            get => refereeRepository;
            set
            {
                refereeRepository = value;
                refereeRepository.Ctx = Ctx;
            }
        }
        private ITeamRepository teamRepository;
        [Inject]
        public ITeamRepository TeamRepository
        {
            get => teamRepository;
            set
            {
                teamRepository = value;
                teamRepository.Ctx = Ctx;
            }
        }
        private IEventMessageRepository eventMessageRepository;

        [Inject]
        public IEventMessageRepository EventMessageRepository
        {
            get => eventMessageRepository;
            set
            {
                eventMessageRepository = value;
                eventMessageRepository.Ctx = Ctx;
            }
        }
        private IStatisticRepository statisticRepository;
        [Inject]
        public IStatisticRepository StatisticRepository
        {
            get => statisticRepository; 
            set
            {
                statisticRepository = value;
                statisticRepository.Ctx = Ctx;
            }
        }
        private IStadiumRepository stadiumRepository;
        [Inject]
        public IStadiumRepository StadiumRepository
        {
            get => stadiumRepository; 
            set
            {
                stadiumRepository = value;
                stadiumRepository.Ctx = Ctx;
            }
        }
        private IUserRepository userRepository;
        [Inject]
        
[Serializable]
public class World : MonoBehaviour {
	public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
	public GameObject chunkPrefab;
	public string worldName = "world";
	/*
	public int newChunkX;
	public int newChunkY;
	public int newChunkZ;
	public bool genChunk;
*/
	public void createChunk (int x, int y, int z)
	{
		WorldPos worldPos = new WorldPos (x, y, z);
		GameObject newChunkObject = Instantiate (chunkPrefab, new Vector3 (x, y, z), 
		                                         Quaternion.Euler (Vector3.zero)) as GameObject;
		Chunk newChunk = newChunkObject.GetComponent<Chunk> ();
		newChunk.pos = worldPos;
		newChunk.world = this;
		chunks.Add (worldPos, newChunk);
		TerrainGen terrainGen = new TerrainGen ();
		newChunk = terrainGen.ChunkGen (newChunk);
		newChunk.setBlocksUnmodified ();
		Serialization.loadChunk (newChunk);
	}
	public void destroyChunk (int x, int y, int z)
	{
		Chunk chunk = null;
		if (chunks.TryGetValue (new WorldPos (x, y, z), 

		{
			Serialization.saveChunk(chunk);
			UnityEngine.Object.Destroy (chunk.gameObject);
			chunks.Remove (new WorldPos (x, y, z));
		}
	}
	public Chunk getChunk (int x, int y, int z)
	{
		WorldPos pos = new WorldPos ();
		float multiple = Chunk.chunkSize;
		pos.x = Mathf.FloorToInt (x / multiple) * Chunk.chunkSize;
		pos.y = Mathf.FloorToInt	 (y / multiple) * Chunk.chunkSize;
		pos.z = Mathf.FloorToInt (z / multiple) * Chunk.chunkSize;
		Chunk containerChunk = null;
		chunks.TryGetValue (pos, out containerChunk);
		return containerChunk;
	}
	public Block getBlock (int x, int y, int z)
	{
		Chunk containerChunk = getChunk (x, y, z);
		if (containerChunk != null)
		{
			Block block = containerChunk.getBlock (x - containerChunk.pos.x,
			                                       y - containerChunk.pos.y,
			                                       z - containerChunk.pos.z);
			return block;
		}
		else
		{
			return new BlockAir();
		}
	}
	public void setBlock (int x, int y, int z, Block bloc

	{
		Chunk chunk = getChunk (x, y, z);
		if (chunk != null)
		{
			chunk.setBlock (x - chunk.pos.x, y - chunk.pos.y, z - chunk.pos.z, block);
			chunk.update = true;
			updateIfEqual(x - chunk.pos.x, 0, new WorldPos(x - 1, y, z));
			updateIfEqual(x - chunk.pos.x, Chunk.chunkSize - 1, new WorldPos(x + 1, y, z));
			updateIfEqual(y - chunk.pos.y, 0, new WorldPos(x, y - 1, z));
			updateIfEqual(y - chunk.pos.y, Chunk.chunkSize - 1, new WorldPos(x, y + 1, z));
			updateIfEqual(z - chunk.pos.z, 0, new WorldPos(x, y, z - 1));
			updateIfEqual(z - chunk.pos.z, Chunk.chunkSize - 1, new WorldPos(x, y, z + 1));
		}
	}
	void updateIfEqual (int value1, int value2, WorldPos pos)
	{
		if (value1 == value2)
		{
			Chunk chunk = getChunk (pos.x, pos.y, pos.z);
			if (chunk != null)
			{
				chunk.update = true;
			}
		}
	}
	void Start () {
		if (Application.loadedLevelName.Equals("Menu")) {
			for (int x = -4; x < 4; x++)
			{
				for (int y = -1; y < 3; y++)
				{
					for (int z = -4; z < 4; z++)

namespace KingsInno.ERP.Repository
    public class RepositoryInitializer : IRepositoryInitializer
    {
        public void Initialize(Runtime runtime)
        {
            runtime.RepositoryManager.AddRepository<IAccountBookRepository, AccountBookRepository>();
            runtime.RepositoryManager.AddRepository<IBankAccountRepository, BankAccountRepository>();
            runtime.RepositoryManager.AddRepository<IBankAccountOfEmpRepository, BankAccountOfEmpRepository>();
            runtime.RepositoryManager.AddRepository<IEmpCertificationRepository, EmpCertificationRepository>();
            runtime.RepositoryManager.AddRepository<IEmpContactInfoRepository, EmpContactInfoRepository>();
            runtime.RepositoryManager.AddRepository<IEmpEducationExperienceRepository, EmpEducationExperienceRepository>();
            runtime.RepositoryManager.AddRepository<IEmpFamilyMemberRepository, EmpFamilyMemberRepository>();
            runtime.RepositoryManager.AddRepository<IEmployeeReposi

            runtime.RepositoryManager.AddRepository<IEmpPositionRepository, EmpPositionRepository>();
            runtime.RepositoryManager.AddRepository<IEmpPositionChangeRepository, EmpPositionChangeRepository>();
            runtime.RepositoryManager.AddRepository<IEmpResumeRepository, EmpResumeRepository>();
            runtime.RepositoryManager.AddRepository<IEmpRewardPunishmentRepository, EmpRewardPunishmentRepository>();
            runtime.RepositoryManager.AddRepository<IEmpSalaryAdjustmentRepository, EmpSalaryAdjustmentRepository>();
            runtime.RepositoryManager.AddRepository<IEmpStatusChangeRepository, EmpStatusChangeRepository>();
            runtime.RepositoryManager.AddRepository<IEmpTrainRecordRepository, EmpTrainRecordRepository>();
            runtime.RepositoryManager.AddRepository<IPositionRepository, PositionRepository>();
            runtime.RepositoryManager.AddRepository<ISalaryLevelRepository, SalaryLevelRepository>();
            runtime.RepositoryMan

            runtime.RepositoryManager.AddRepository<IDepartmentRepository, DepartmentRepository>();
            runtime.RepositoryManager.AddRepository<IDeptManagerRepository, DeptManagerRepository>();
            runtime.RepositoryManager.AddRepository<IDeptPositionRepository, DeptPositionRepository>();
            runtime.RepositoryManager.AddRepository<IPurchasingOrderRepository, PurchasingOrderRepository>();
            runtime.RepositoryManager.AddRepository<IPurchasingOrderMaterialRepository, PurchasingOrderMaterialRepository>();
            runtime.RepositoryManager.AddRepository<ISalesContractRepository, SalesContractRepository>();
            runtime.RepositoryManager.AddRepository<ISalesContractProductReppository, SalesContractProductReppository>();
            runtime.RepositoryManager.AddRepository<IActionRepository, ActionRepository>();
            runtime.RepositoryManager.AddRepository<IAnnouncementRepository, AnnouncementRepository>();
            runtime.RepositoryMan
namespace EzClientLib
    public class DispatchData
    {
        public Action<DispatchData> action;
        public PacketHeader packetHeader;
        public Connection connection;
        public MessageData messageData;
        public DispatchData(Action<DispatchData> a, PacketHeader p, Connection c, MessageData m)
        {
            action = a;
            packetHeader = p;
            connection = c;
            messageData = m;
        }
    }
    public class DispatchQueue
    {
        private static DispatchQueue instance;
        public static DispatchQueue Instance
        {
            get { return instance; }
        }
        public Queue<DispatchData> dispatchQueue;
        public DispatchQueue()
        {
            instance = this;
            dispatchQueue = new Queue<DispatchData>();
        }
        public void Dispatch()
        {
            for (int i = 0; i < 30; i++) {
                if (dispatchQueue.Count > 0) {
                    DispatchData data = di
namespace System.Web.Services.Protocols {
    internal class ScatterGatherStream : Stream {
        private const int MemStreamMaxLength = Int32.MaxValue;        
        private MemoryChunk headChunk = null;
        private MemoryChunk currentChunk = null;  
        private long chunkSize = 0;
        private int currentOffset = 0;
        private int endOffset = 0;
        private long currentChunkStartPos = 0;
        internal ScatterGatherStream(int chunkSize) {
            this.chunkSize = chunkSize;
            currentChunk = headChunk = AllocateMemoryChunk(this.chunkSize);
            currentOffset = endOffset = 0;
            currentChunkStartPos = 0;
        }
        internal ScatterGatherStream() : this(1024) { }
        public override bool CanRead { get { return true; } }
        public override bool CanSeek { get { return true; } }
        public override bool CanWrite { get { return true; } }
        
        public override void Close() {            
            headChu

            currentChunk = null;
            endOffset = currentOffset = 0;
            currentChunkStartPos = 0;
        }
        public override void Flush() { }
        public override long Length { 
            get {
                MemoryChunk endChunk;
                return GetLengthInternal(out endChunk);
            }
        }
        private long GetLengthInternal(out MemoryChunk endChunk){
            long length = currentChunkStartPos;
            MemoryChunk chunk = currentChunk;
            while (chunk.Next != null) {
                length += chunk.Buffer.Length;
                chunk = chunk.Next;
            }
            length += endOffset;
            endChunk = chunk;
            return length;
        }
        public override long Position {
            get {
                return Seek(0, SeekOrigin.Current);
            }
             
            set {
                Seek(value, SeekOrigin.Begin);
            }
        }
        
        public override l

            MemoryChunk chunk  = null;;
            long relativeOffset = 0;
            long absoluteOffset = 0;
            
            if(loc == SeekOrigin.Begin){
                absoluteOffset = offset;
                if(offset >= currentChunkStartPos){
                    chunk = currentChunk;
                    relativeOffset = offset - currentChunkStartPos;
                }
                else{
                    chunk = headChunk;
                    relativeOffset = absoluteOffset;
                }
            }
            else if( loc == SeekOrigin.Current){
                absoluteOffset = offset + currentOffset + currentChunkStartPos;
                if( (offset + currentOffset) > 0){
                    chunk = currentChunk;
                    relativeOffset = offset + currentOffset;
                }
                else {
                    chunk = headChunk;
                    relativeOffset = absoluteOffset;
                }
            }
            else
namespace MTB
	public class BlockLightSpread
	{
		private World _world;
		private Queue<LightSpreadNode> _lightBfsQueue;
		private List<Chunk> _changedList;
		private bool _isSunLight;
		public BlockLightSpread (World world)
		{
			_world = world;
			_lightBfsQueue = new Queue<LightSpreadNode>();
			_changedList = new List<Chunk>();
		}
		
		
		public void AddSpreadNode(LightSpreadNode node)
		{
			_lightBfsQueue.Enqueue(node);
		}
		
		public void ClearNode()
		{
			_lightBfsQueue.Clear();
		}
		
		public List<Chunk> SpreadInChunk(Chunk chunk)
		{
			int nextX;
			int nextY;
			int nextZ;
			Chunk nextChunk;
			_changedList.Clear();
			while(_lightBfsQueue.Count > 0)
			{
				LightSpreadNode node = _lightBfsQueue.Dequeue();
				int y = node.index % Chunk.chunkHeight;
				int temp = node.index / Chunk.chunkHeight;
				int z = temp % Chunk.chunkDepth;
				int x = temp / Chunk.chunkDepth;
				
				Chunk nodeChunk = node.chunk;
				
				int curLightLevel = node.lightLevel;
				
				nextX 

				nextChunk = nodeChunk;
				if(nextX < 0)
				{
					nextChunk = _world.GetChunk(nextX + nodeChunk.worldPos.x,y + nodeChunk.worldPos.y,z + nodeChunk.worldPos.z);
					nextX = Chunk.chunkWidth - 1;
				}
				
				if(nextChunk != null && (nextChunk.isLightDataPrepared || nextChunk.worldPos.EqualOther(chunk.worldPos)))
				{
					SpreadInPos(nextX,y,z,nextChunk,curLightLevel);
				}
				
				nextX = x + 1;
				nextChunk = nodeChunk;
				if(nextX >= Chunk.chunkWidth)
				{
					nextChunk = _world.GetChunk(nextX + nodeChunk.worldPos.x,y + nodeChunk.worldPos.y,z + nodeChunk.worldPos.z);
					nextX = 0;
				}
				
				if(nextChunk != null && (nextChunk.isLightDataPrepared || nextChunk.worldPos.EqualOther(chunk.worldPos)))
				{
					SpreadInPos(nextX,y,z,nextChunk,curLightLevel);
				}
				
				nextZ = z - 1;
				nextChunk = nodeChunk;
				if(nextZ < 0)
				{
					nextChunk = _world.GetChunk(x + nodeChunk.worldPos.x,y + nodeChunk.worldPos.y,nextZ + nodeChunk.worldPos.z);
					nextZ = Chun

				}
				if(nextChunk != null && (nextChunk.isLightDataPrepared || nextChunk.worldPos.EqualOther(chunk.worldPos)))
				{
					SpreadInPos(x,y,nextZ,nextChunk,curLightLevel);
				}
				
				nextZ = z + 1;
				nextChunk = nodeChunk;
				if(nextZ >= Chunk.chunkDepth)
				{
					nextChunk = _world.GetChunk(x + nodeChunk.worldPos.x,y + nodeChunk.worldPos.y,nextZ + nodeChunk.worldPos.z);
					nextZ = 0;
				}
				if(nextChunk != null && (nextChunk.isLightDataPrepared || nextChunk.worldPos.EqualOther(chunk.worldPos)))
				{
					SpreadInPos(x,y,nextZ,nextChunk,curLightLevel);
				}
				
				nextY = y - 1;
				if(nextY >= 0)
				{
					SpreadInPos(x,nextY,z,nodeChunk,curLightLevel);
				}
				
				nextY = y + 1;
				if(nextY < Chunk.chunkHeight)
				{
					SpreadInPos(x,nextY,z,nodeChunk,curLightLevel);
				}
			}
			return _changedList;
		}
		private void SpreadInPos(int x,int y,int z,Chunk chunk,int curLightLevel)
		{
			if(curLightLevel < 2)return;
			Block b = chunk.GetBlock(x,y,z,true);
public class Chunk {
    public World w;
    private int chunkX, chunkY, chunkZ = 0;
    public const int chunkLogSize = 4;
    public const int chunkSize = 1 << chunkLogSize;
    public const int chunkMask = chunkSize - 1;
    private Block[,,] data = new Block[chunkSize, chunkSize, chunkSize];
    public Chunk(World w, int chunkX, int chunkY, int chunkZ) {
        this.w = w;
        this.chunkX = chunkX;
        this.chunkY = chunkY;
        this.chunkZ = chunkZ;
        for(int x = 0; x < chunkSize; x++) {
            for(int y = 0; y < chunkSize; y++) {
                for(int z = 0; z < chunkSize; z++) {
                    data[x, y, z] = Block.NewBlock(BlockType.STONE);
                }
            }
        }
    }
    public Block this[int x, int y, int z] {
        get {
            try {
                if(x < 0 || x > chunkSize - 1 || y < 0 || y > chunkSize - 1 || z < 0 || z > chunkSize - 1) {
                    return w[chunkX * chunkSize + x, chunkY * chunkSize + y, ch
namespace FxConnectProxy.Tests.Validators
    [TestClass]
    public class PermissionCheckerValidatorTests
    {
        [TestMethod]
        public void ValidateInstrumentBaseRequest()
        {
            {
                var v = new PermissionCheckerValidator();
                InstrumentBaseRequest r = null;
                AssertEx.Throws<ArgumentNullException>(() =>
                    {
                        v.Validate(r);
                    });
            }
            {
                var v = new PermissionCheckerValidator();
                InstrumentBaseRequest r = new InstrumentBaseRequest();
                r.Instrument = null;
                AssertEx.Throws<ArgumentNullException>(() =>
                {
                    v.Validate(r);
                });
            }
            {
                var v = new PermissionCheckerValidator();
                InstrumentBaseRequest r = new InstrumentBaseRequest();
                r.Instrument = "";
                As
namespace FastQuant
    public class Leg
    {
        private Framework framework;
        private Instrument instrument;
        public int InstrumentId { get; private set; }
        public double Weight { get; set; }
        internal Leg()
        {
        }
        internal Leg(Framework framework)
        {
            this.framework = framework;
        }
        public Leg(Instrument instrument, double weight = 1.0)
        {
            this.instrument = instrument;
            Weight = weight;
            InstrumentId = instrument.Id;
            this.framework = instrument.Framework;
        }
        internal void Init(Framework framework)
        {
            this.framework = framework;
            this.instrument = framework.InstrumentManager.GetById(InstrumentId);
            if (this.instrument == null)
                Console.WriteLine($"{nameof(Leg)}::{nameof(Init)} Can not find leg instrument in the framework instrument manager. Id = {InstrumentId}");
        }
    

        public Instrument Instrument
        {
            get
            {
                return this.instrument;
            }
            set
            {
                this.instrument = value;
                InstrumentId = this.instrument.Id;
            }
        }
        public string Symbol
        {
            get
            {
                return this.instrument?.Symbol;
            }
            set
            {
                var instrument = this.framework.InstrumentManager[value];
                if (instrument == null)
                    Console.WriteLine($"Leg::Symbol Can not find instrument with such symbol in the framework instrument manager. Symbol = {InstrumentId}");
                this.instrument = instrument;
                InstrumentId = instrument.Id;
            }
        }
        #region Extra
        public static Leg FromReader(BinaryReader reader)
        {
            return new Leg
            {
                InstrumentId = reader.ReadI
namespace MusicalTracker.DAL
    public class MusicalDataFactory
    {
        public List<IMusicInstrument> LoadBorrowedInstruments (
            string instrumentsFile, string borrowersFile)
        {
            List<MusicInstrumentSalesForce> instrumentList = null;
            List<MusicInstrumentBorrowerSalesForce> borrowerList = null;
            {
                CsvReader csv = new CsvReader(textReader);
                instrumentList = csv.GetRecords<MusicInstrumentSalesForce>().ToList();
            }
            {
                CsvReader csv = new CsvReader(textReader);
                borrowerList = csv.GetRecords<MusicInstrumentBorrowerSalesForce>().ToList();
            }
            List<IMusicInstrument> borrowedInstruments = new List<IMusicInstrument>();
            foreach (MusicInstrumentSalesForce instrument in instrumentList)
            {
                if (!string.IsNullOrEmpty(instrument.BORROWED_BY__C))
                {
                    var borrower = bo
namespace GuitarApp
    class Inventory
    {
        private List<Instrument> instruments;
        public Inventory()
        {
            instruments = new List<Instrument>();
        }
        public void AddInstrument(string serialNumber, double price, InstrumentSpec spec) 
        {
            instruments.Add(new Instrument(serialNumber, price, spec));
        }
        public Instrument GetInstrument(string serialNumber)
        {
            foreach (var instrument in instruments)
            {
                if (instrument.SerialNumber.Equals(serialNumber))
                    return instrument;
            }
            return null;
        }
        public List<Instrument> Search (InstrumentSpec searchSpec)
        {
            List<Instrument> matchingInstruments = new List<Instrument>();
            foreach (var instrument in instruments)
            {
                if (instrument.Spec.Matches(searchSpec))
                    matchingInstruments.Add(instrument);
     
namespace NAudio.SoundFont
    internal class InstrumentBuilder : StructureBuilder<Instrument>
    {
        private Instrument lastInstrument = null;
        public override Instrument Read(BinaryReader br)
        {
            Instrument i = new Instrument();
            string s = Encoding.UTF8.GetString(br.ReadBytes(20), 0, 20);
            if (s.IndexOf('\0') >= 0)
            {
                s = s.Substring(0, s.IndexOf('\0'));
            }
            i.Name = s;
            i.startInstrumentZoneIndex = br.ReadUInt16();
            if (lastInstrument != null)
            {
                lastInstrument.endInstrumentZoneIndex = (ushort)(i.startInstrumentZoneIndex - 1);
            }
            data.Add(i);
            lastInstrument = i;
            return i;
        }
        public override void Write(BinaryWriter bw, Instrument instrument)
        {
        }
        public override int Length
        {
            get
            {
                return 22;
           
namespace HelpOn.Persistencia.UnitOfWork
    public class UnitOfWork : IDisposable
    {
        private BancoContext _context = new BancoContext();
        public void Dispose()
        {
            if (_context != null)
            {
                _context.Dispose();
            }
            GC.SuppressFinalize(this);
        }
        private IGenericRepository<Funcionario> _FuncionarioRepository;
        public IGenericRepository<Funcionario> FuncionarioRepository
        {
            get
            {
                if (_FuncionarioRepository == null)
                {
                    _FuncionarioRepository = new GenericRepository<Funcionario>(_context);
                }
                return _FuncionarioRepository;
            }
        }
        private IGenericRepository<Laboratorio> _laboratorioRepository { get; set; }
        public IGenericRepository<Laboratorio> LaboratorioRepository
        {
            get
            {
                if (_laboratorioReposit

                {
                    _laboratorioRepository = new GenericRepository<Laboratorio>(_context);
                }
                return _laboratorioRepository;
            }
        }
        private IGenericRepository<Andar> _andarRepository { get; set; }
        public IGenericRepository<Andar> AndarRepository
        {
            get
            {
                if (_andarRepository == null)
                {
                    _andarRepository = new GenericRepository<Andar>(_context);
                }
                return _andarRepository;
            }
        }
        private IGenericRepository<Unidade> _unidadeRepository;
        public IGenericRepository<Unidade> UnidadeRepository
        {
            get
            {
                if (_unidadeRepository == null)
                {
                    _unidadeRepository = new GenericRepository<Unidade>(_context);
                }
                return _unidadeRepository;
            }
        }
      

        public IGenericRepository<Nivel> NivelRepository
        {
            get
            {
                if (_nivelRepository == null)
                {
                    _nivelRepository = new GenericRepository<Nivel>(_context);
                }
                return _nivelRepository;
            }
        }
        private IChamadoRepository _chamadoRepository;
        public IChamadoRepository ChamadoRepository
        {
            get
            {
                if (_chamadoRepository == null)
                {
                    _chamadoRepository = new ChamadoRepository(_context);
                }
                return _chamadoRepository;
            }
        }
        private IGenericRepository<Descricao> _descricaoRepository;
        public IGenericRepository<Descricao> DescricaoRepository
        {
            get
            {
                if (_descricaoRepository == null)
                {
                    _descricaoRepository = new GenericRepositor
﻿/*
 * Created by SharpDevelop.
 * User: Alexander Petrovskiy
 * Date: 30/11/2011
 * Time: 08:45 p.m.
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
namespace UIAutomation.Commands
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaExpandPattern")]
    
    public class InvokeUiaExpandPatternCommand : PatternCmdletBase
    { public InvokeUiaExpandPatternCommand() { WhatToDo = "Expand"; }
    }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaButtonExpand")]
    
    public class InvokeUiaButtonExpandCommand : InvokeUiaExpandPatternCommand
    { public InvokeUiaButtonExpandCommand() { } }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaComboBoxExpand")]
    
    public class InvokeUiaComboBoxExpandCommand : InvokeUiaExpandPatternCommand
    { public InvokeUiaComboBoxExpandCommand() { } }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaCustomExpand")]
    
    public class InvokeUiaCustomExpandCommand : InvokeUiaExpandPatternCommand
    { public InvokeUiaCustomExpan

    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaDataItemExpand")]
    
    public class InvokeUiaDataItemExpandCommand : InvokeUiaExpandPatternCommand
    { public InvokeUiaDataItemExpandCommand() { } }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaGroupExpand")]
    
    public class InvokeUiaGroupExpandCommand : InvokeUiaExpandPatternCommand
    { public InvokeUiaGroupExpandCommand() { } }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaGroupBoxExpand")]
    
    public class InvokeUiaGroupBoxExpandCommand : InvokeUiaGroupExpandCommand
    { public InvokeUiaGroupBoxExpandCommand() { } }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaListItemExpand")]
    
    public class InvokeUiaListItemExpandCommand : InvokeUiaExpandPatternCommand
    { public InvokeUiaListItemExpandCommand() { } }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaMenuBarExpand")]
    
    public class InvokeUiaMenuBarExpandCommand : InvokeUiaExpandPatternCommand
    { public InvokeUiaMenuBarExpandCommand() { } }
    
    [Cmdlet(V
namespace amis._DataLayer.GeneratedCode
    public partial class DcDispatchProviderDocumentState
    {
        public void Copy(DispatchProviderDocumentState objSource, ref DispatchProviderDocumentState objDestination)
        {
            objDestination.DispatchProviderDocumentStateId = objSource.DispatchProviderDocumentStateId;
            objDestination.DispatchProviderDocumentStateName = objSource.DispatchProviderDocumentStateName;
        }
        public DispatchProviderDocumentState Save(DispatchProviderDocumentState objSource, out string errorMessage)
        {
            errorMessage = "";
            try
            {
                {
                    {
                        DispatchProviderDocumentState service = context.DispatchProviderDocumentState.Where(r => r.DispatchProviderDocumentStateName.ToUpper() == objSource.DispatchProviderDocumentStateName.ToUpper() && r.DispatchProviderDocumentStateId != objSource.DispatchProviderDocumentStateId).FirstOrDefault();
     

                        DispatchProviderDocumentState row = context.DispatchProviderDocumentState.Where(r => r.DispatchProviderDocumentStateId == objSource.DispatchProviderDocumentStateId).FirstOrDefault();
                        if (row == null)
                        {
                            row = new DispatchProviderDocumentState();
                            Copy(objSource, ref row);
                            context.DispatchProviderDocumentState.Add(row);
                        }
                        else
                        {
                            Copy(objSource, ref row);
                        }
                        context.SaveChanges();
                        transaction.Complete();
                        return row;
                    }
                }
            }
            catch (Exception ex)
            {
                errorMessage = ErrorController.GetErrorMessage(ex);
                return null;
            }
        }
        pu

        {
            errorMessage = "";
            try
            {
                DispatchProviderDocumentState obj = null;
                {
                    obj = context.DispatchProviderDocumentState.Where(r => r.DispatchProviderDocumentStateId != DispatchProviderDocumentStateId).FirstOrDefault();
                    if (obj == null)
                    {
                        return false;
                    }
                    return true;
                }
            }
            catch (Exception ex)
            {
                errorMessage = ErrorController.GetErrorMessage(ex);
                return false;
            }
        }
        public List<DispatchProviderDocumentState> GetDispatchProviderDocumentStateList(out string errorMessage)
        {
            errorMessage = "";
            try
            {
                {
                    List<DispatchProviderDocumentState> list = context.DispatchProviderDocumentState.OrderBy(a => a.DispatchProviderDo
﻿namespace Grove.Gameplay.Modifiers
  public class ChangeController : Modifier, ICardModifier
  {
    private readonly Func<Modifier, Player> _getNewController;
    private ControllerCharacteristic _controller;
    private ControllerSetter _controllerSetter;
    private Player _newController;
    private ChangeController() {}
    public ChangeController(Player newController)
    {
      _newController = newController;
    }
    public ChangeController(Func<Modifier, Player> getNewController)
    {
      _getNewController = getNewController;
    }
    public override void Apply(ControllerCharacteristic controller)
    {
      _controller = controller;
      _controllerSetter = new ControllerSetter(_newController);
      _controllerSetter.Initialize(ChangeTracker);
      _controller.AddModifier(_controllerSetter);
    }
    protected override void Initialize()
    {
      if (_newController == null)
      {
        _newController = _getNewController(this);
      }
    }
    protected ove
namespace MO.Core.Window.Core {
   
   public class FShellView {
      internal IntPtr _handle;
      internal IShellView _face;
      protected IntPtr _menuHandle = IntPtr.Zero;
      public FShellView() {
      }
      /*public void Create() {
         if (_menuHandle == IntPtr.Zero) {
            _menuHandle = RUser32.CreatePopupMenu();
            _face.QueryContextMenu(_menuHandle, 0, RWinShell.CMD_FIRST, RWinShell.CMD_LAST, CMF.NORMAL | CMF.EXPLORE);
         }
      }
      public void Insert(string text, bool enable) {
         MFT extraFlag = enable ? 0 : MFT.GRAYED;
         RUser32.InsertMenu(_menuHandle, 0, MFT.BYPOSITION | extraFlag, (int)(RWinShell.CMD_LAST + 1), text);
         RUser32.InsertMenu(_menuHandle, 1, MFT.BYPOSITION | MFT.SEPARATOR, 0, "-");
         RUser32.SetMenuDefaultItem(_menuHandle, 0, true);
      }
      public int Popup(IntPtr handle, int x, int y) {
         Create();
         uint cmd = RUser32.TrackPopupMenuEx(_menuHandle, ETrackPopupMenu.RETURNCM

         _menuHandle = IntPtr.Zero;
         if (cmd >= RWinShell.CMD_FIRST) {
            SCmInvokeCommandInfoEX invoke = new SCmInvokeCommandInfoEX();
            invoke.cbSize = Marshal.SizeOf(typeof(SCmInvokeCommandInfoEX));
            invoke.lpVerb = (IntPtr)(cmd - 1);
            invoke.lpDirectory = string.Empty;
            invoke.fMask = 0;
            invoke.ptInvoke = new SPoint();
            invoke.ptInvoke.x = x;
            invoke.ptInvoke.y = y;
            invoke.nShow = 1;
            _face.InvokeCommand(ref invoke);
         }
         return (int)cmd;
      }
      public void InvokeDefault(int x, int y) {
         Create();
         int defaultCommand = RUser32.GetMenuDefaultItem(_menuHandle, false, 0);
         if (defaultCommand != -1) {
            SCmInvokeCommandInfoEX invoke = new SCmInvokeCommandInfoEX();
            invoke.cbSize = Marshal.SizeOf(typeof(SCmInvokeCommandInfoEX));
            invoke.lpVerb = (IntPtr)(defaultCommand - RWinShell.CMD_FIRST);
 
namespace Indico20.BusinessObjects.Base.Implementation
    public class UnitOfWork : IUnitOfWork
    {
        private readonly IDbContext _context;
        public ICompanyRepository CompanyRepository { get; }
        public IUserStatusRepository UserStatusRepository { get; }
        public IMenuItemRepository MenuItemRepository { get; }
        public IUserRepository UserRepository { get; }
        public IRoleRepository RoleRepository { get; }
        public IOrderRepository OrderRepository { get; }
        public IOrderDetailRepository OrderDetailRepository { get; }
        public IAgeGroupRepository AgeGroupRepository { get; }
        public IColourProfileRepository ColourProfileRepository { get; }
        public IGenderRepository GenderRepository { get; }
        public IPrinterRepository PrinterRepository { get; }
        public IPrinterTypeRepository PrinterTypeRepository { get; }
        public IProductionLineRepository ProductionLineRepository { get; }
        public UnitOfWor

        {
            _context = new IndicoContext();
            CompanyRepository = new CompanyRepository(_context);
            UserStatusRepository = new UserStatusRepository(_context);
            MenuItemRepository = new MenuItemRepository(_context);
            UserRepository = new UserRepository(_context);
            RoleRepository = new RoleRepository(_context);
            OrderRepository = new OrderRepository(_context);
            OrderDetailRepository = new OrderDetailRepository(_context);
            AgeGroupRepository = new AgeGroupRepository(_context);
            ColourProfileRepository = new ColourProfileRepository(_context);
            GenderRepository = new GenderRepository(_context);
            PrinterRepository = new PrinterRepository(_context);
            PrinterTypeRepository = new PrinterTypeRepository(_context);
            ProductionLineRepository = new ProductionLineRepository(_context);
        }
        public void Complete()
        {
            _co
namespace mcsharpbot.communication
    public class ChunkProvider
    {
        public Hashtable Chunks;
        public ChunkProvider()
        {
            Chunks = new Hashtable();
        }
        public Chunk AllocateChunk(int X, int Y)
        {
            ChunkCoordinates chunkCoords = new ChunkCoordinates(X, Y);
            byte[] blocks = new byte[32768];
            Chunk chunk = new Chunk(blocks, X, Y);
            for (int i = 0; i < chunk.SkylightMap.data.Length; i++)
            {
                chunk.SkylightMap.data[i] = 255;
            }
            Chunks.Add(chunkCoords, chunk);
            return chunk;
        }
        public Chunk GetFromCoordinates(int X, int Y)
        {
            Chunk c = (Chunk)Chunks[new ChunkCoordinates(X, Y)];
            if(c == null) 
            {
                return new Chunk(new byte[32768], 0, 0);
            } 
            else 
            {
                return c;
            }
        }
        public Blocks GetBlock(
namespace Contact.App.Base
    public class ThreadSTA
    {
        public OpenFileDialog InvokeOpenDialog;
        public SaveFileDialog InvokeSaveDialog;
        private Thread InvokeThread;
        private DialogResult InvokeResult;
        
        public ThreadSTA(OpenFileDialog openFileDialog)
        {
            InvokeOpenDialog = openFileDialog;
            InvokeThread = new Thread(new ThreadStart(InvokeOpenMethod));
            InvokeThread.SetApartmentState(ApartmentState.STA);
            InvokeResult = DialogResult.None;
        }
        public ThreadSTA(SaveFileDialog saveFileDialog)
        {
            InvokeSaveDialog = saveFileDialog;
            InvokeThread = new Thread(new ThreadStart(InvokeSaveMethod));
            InvokeThread.SetApartmentState(ApartmentState.STA);
            InvokeResult = DialogResult.None;
        }
        public DialogResult Invoke()
        {
            InvokeThread.Start();
            InvokeThread.Join();
            return InvokeRe
namespace NAudio.SoundFont 
	internal class InstrumentBuilder : StructureBuilder<Instrument>
	{
		private Instrument lastInstrument = null;
        public override Instrument Read(BinaryReader br) 
		{
			Instrument i = new Instrument();
			string s = Encoding.UTF8.GetString(br.ReadBytes(20), 0, 20);
			if(s.IndexOf('\0') >= 0) 
			{
				s = s.Substring(0,s.IndexOf('\0'));
			}
			i.Name = s;
			i.startInstrumentZoneIndex = br.ReadUInt16();
			if(lastInstrument != null)
			{
				lastInstrument.endInstrumentZoneIndex = (ushort) (i.startInstrumentZoneIndex - 1);
			}
			data.Add(i);
			lastInstrument = i;
			return i;
		}
        public override void Write(BinaryWriter bw, Instrument instrument) 
		{
		}
		public override int Length 
		{
			get 
			{
				return 22;
			}
		}
		public void LoadZones(Zone[] zones)
		{
			for(int instrument = 0; instrument < data.Count - 1; instrument++)
			{
				Instrument i = (Instrument) data[instrument];
				i.Zones = new Zone[i.endInstrumentZoneIndex - 
public class InstrumentController : MonoBehaviour
    private static InstrumentController m_instance;
    public static InstrumentController Instance { get { return m_instance; } }
    protected List<InstrumentHandle> m_instruments;
    protected List<InstrumentHandle> m_returns;
    protected InstrumentHandle m_selectedInstrument;
    protected GameObject m_lastSelectedGameInstrument = null;
    private Queue<InstrumentParameter> m_queuedParameters;
    void Awake()
    {
        m_instruments = new List<InstrumentHandle>();
        m_returns = new List<InstrumentHandle>();
        m_instance = this;
        m_queuedParameters = new Queue<InstrumentParameter>();
    }
    public void AddToQueue(InstrumentParameter param)
    {
        m_queuedParameters.Enqueue(param);
    }
    void Update()
    {
        if (m_queuedParameters.Count > 0)
        {
            m_queuedParameters.Dequeue().Send();
        }
    }
    public InstrumentHandle SelectedInstrument { get { return m_selected

    /*
     * Adds an instrument
     */
    public void AddInstrument(InstrumentHandle instrument)
    {
        m_instruments.Add(instrument);
    }
    public void AddReturn(InstrumentHandle instrument)
    {
        m_returns.Add(instrument);
    }
    /*
     * Gets instrument by name
     */
    public InstrumentHandle GetInstrumentByName(string targetInstrument)
    {
        foreach (InstrumentHandle instrument in m_instruments)
        {
            if (instrument.name == targetInstrument)
                return instrument;
        }
        return null;
    }
    public InstrumentHandle GetInstrumentByTrackindex(int trackindex)
    {
        foreach (InstrumentHandle instrument in m_instruments)
        {
            if (instrument.trackIndex == trackindex)
                return instrument;
        }
        return null;
    }
    /*
     * Finds a specific parameter by index
     */
    public DeviceParameter FindParameter(int trackindex, int deviceindex, int parameterinde

    {
        List<InstrumentHandle> instrumentList;
        if (category == 0)
            instrumentList = m_instruments;
        else
            instrumentList = m_returns;
        foreach (InstrumentHandle instrument in instrumentList)
        {
            if (instrument.trackIndex == trackindex)
            {
                foreach (DeviceParameter param in instrument.paramList)
                {
                    if (param.deviceIndex == deviceindex && param.parameterIndex == parameterindex)
                    {
                        return param;
                    }
                }
            }
        }
        return null;
    }
    public SendParameter FindSendParameter(int trackindex, int sendindex)
    {
        foreach (InstrumentHandle instrument in m_instruments)
        {
            if (instrument.trackIndex == trackindex)
            {
                foreach (SendParameter send in instrument.sendsList)
                {
                    if (send.send
namespace InstrumentApp
    class Inventory
    {
        private List<Instrument> _inventory;
        #region Initialization
        public Inventory()
        {
            _inventory = new List<Instrument>();
        }
        #endregion
        #region Methods: Internal
        public void addInstrument(string serialNumber,
                                  double price,
                                  InstrumentSpec spec)
        {
            Instrument instrument = new Instrument(serialNumber, price, spec);
            _inventory.Add(instrument);
        }
        public Instrument get(string serialNumber)
        {
            for (int i = 0; i < _inventory.Count; i++)
            {
                Instrument instrument = _inventory[i];
                if (instrument.serialNumber.Equals(serialNumber))
                {
                    return instrument;
                }
            }
            return null;
        }
        public List<Instrument> search(InstrumentSpec
public class ChunksMeshGenerator {
  static object chunksQueueLock = new object();
  class ChunkDone {
    public Chunk chunk;
    public List<Vector3> vertices;
    public List<Vector2> uvs;
    public List<Vector3> normals;
    public List<int> indicies;
  }
  static Stack<ChunkDone> chunksQueue = new Stack<ChunkDone>();
  public static void Update() {
    lock (chunksQueueLock) {
      if (chunksQueue.Count > 0) {
        ChunkDone chunkDone = chunksQueue.Pop();
        Mesh mesh = new Mesh();
        mesh.vertices = chunkDone.vertices.ToArray();
        mesh.uv = chunkDone.uvs.ToArray();
        mesh.normals = chunkDone.normals.ToArray();
        mesh.triangles = chunkDone.indicies.ToArray();
    
        chunkDone.chunk.meshFilter.mesh = mesh;
        chunkDone.chunk.meshCollider.sharedMesh = mesh;
        chunkDone.chunk.meshRenderer.sharedMaterial = chunkDone.chunk.world.material;
        chunkDone.chunk.status = Chunk.Status.Done;
      }
    }
  }
  public static void PushChun

    chunk.status = Chunk.Status.Creating;
    ThreadPool.QueueUserWorkItem(ChunkWorkerCallback, chunk);
  }
  public static void ChunkWorkerCallback(object threadContext) {
    int startTime = System.DateTime.Now.Millisecond;
    Chunk chunk = (Chunk)threadContext;
    List<Vector3> vertices = new List<Vector3>(Chunk.SIZE * Chunk.SIZE * Chunk.SIZE * 24);
    List<Vector2> uvs = new List<Vector2>(Chunk.SIZE * Chunk.SIZE * Chunk.SIZE * 24);
    List<Vector3> normals = new List<Vector3>(Chunk.SIZE * Chunk.SIZE * Chunk.SIZE * 24);
    List<int> indicies = new List<int>(Chunk.SIZE * Chunk.SIZE * Chunk.SIZE * 36);
    float tileSize = World.TextureTileSize;
    int currentIndex = 0;
    for (int x = 0; x < Chunk.SIZE; ++x) {
      for (int y = 0; y < Chunk.SIZE; ++y) {
        for (int z = 0; z < Chunk.SIZE; ++z) {
          if (chunk.blocks[x, y, z] == 0)
            continue;
          int worldBlockX = chunk.worldChunkPositionX * Chunk.SIZE + x;
          int worldBlockY = chunk.worldChu

          int worldBlockZ = chunk.worldChunkPositionZ * Chunk.SIZE + z;
          int blockID = chunk.blocks[x, y, z] - 1;
          float tilePosX = blockID;
          float tilePosY = 0;
          if (chunk.world.GetBlock(worldBlockX, worldBlockY, worldBlockZ - 1) == 0) {
            vertices.Add(new Vector3((x * Chunk.VOXEL_SIZE) - Chunk.VOXEL_SIZE_HALF, (y * Chunk.VOXEL_SIZE) - Chunk.VOXEL_SIZE_HALF, (z * Chunk.VOXEL_SIZE) - Chunk.VOXEL_SIZE_HALF));
            vertices.Add(new Vector3((x * Chunk.VOXEL_SIZE) - Chunk.VOXEL_SIZE_HALF, (y * Chunk.VOXEL_SIZE) + Chunk.VOXEL_SIZE_HALF, (z * Chunk.VOXEL_SIZE) - Chunk.VOXEL_SIZE_HALF));
            vertices.Add(new Vector3((x * Chunk.VOXEL_SIZE) + Chunk.VOXEL_SIZE_HALF, (y * Chunk.VOXEL_SIZE) + Chunk.VOXEL_SIZE_HALF, (z * Chunk.VOXEL_SIZE) - Chunk.VOXEL_SIZE_HALF));
            vertices.Add(new Vector3((x * Chunk.VOXEL_SIZE) + Chunk.VOXEL_SIZE_HALF, (y * Chunk.VOXEL_SIZE) - Chunk.VOXEL_SIZE_HALF, (z * Chunk.VOXEL_SIZE) - Chunk.VOXEL_SIZE_
namespace Microsoft.AspNet.Razor.CodeGenerators.Visitors
    public class CodeVisitor<TWriter> : ChunkVisitor<TWriter>
        where TWriter : CodeWriter
    {
        public CodeVisitor(TWriter writer, CodeGeneratorContext context)
            : base(writer, context)
        {
            if (writer == null)
            {
                throw new ArgumentNullException(nameof(writer));
            }
            if (context == null)
            {
                throw new ArgumentNullException(nameof(context));
            }
        }
        protected override void Visit(LiteralChunk chunk)
        {
        }
        protected override void Visit(ExpressionBlockChunk chunk)
        {
        }
        protected override void Visit(ExpressionChunk chunk)
        {
        }
        protected override void Visit(StatementChunk chunk)
        {
        }
        protected override void Visit(UsingChunk chunk)
        {
        }
        protected override void Visit(ParentChunk chunk)
 
namespace EQueue.Broker.Storage
    public class ChunkHeader
    {
        public const int Size = 128;
        public readonly int ChunkNumber;
        public readonly int ChunkDataTotalSize;
        public readonly long ChunkDataStartPosition;
        public readonly long ChunkDataEndPosition;
        public ChunkHeader(int chunkNumber, int chunkDataTotalSize)
        {
            Ensure.Nonnegative(chunkNumber, "chunkNumber");
            Ensure.Positive(chunkDataTotalSize, "chunkDataTotalSize");
            ChunkNumber = chunkNumber;
            ChunkDataTotalSize = chunkDataTotalSize;
            ChunkDataStartPosition = ChunkNumber * (long)ChunkDataTotalSize;
            ChunkDataEndPosition = (ChunkNumber + 1) * (long)ChunkDataTotalSize;
        }
        public byte[] AsByteArray()
        {
            var array = new byte[Size];
            {
                {
                    writer.Write(ChunkNumber);
                    writer.Write(ChunkDataTotalSize);
               

            }
            return array;
        }
        public static ChunkHeader FromStream(BinaryReader reader, Stream stream)
        {
            var chunkNumber = reader.ReadInt32();
            var chunkDataTotalSize = reader.ReadInt32();
            return new ChunkHeader(chunkNumber, chunkDataTotalSize);
        }
        public int GetLocalDataPosition(long globalDataPosition)
        {
            if (globalDataPosition < ChunkDataStartPosition || globalDataPosition > ChunkDataEndPosition)
            {
                throw new Exception(string.Format("globalDataPosition {0} is out of chunk data positions [{1}, {2}].", globalDataPosition, ChunkDataStartPosition, ChunkDataEndPosition));
            }
            return (int)(globalDataPosition - ChunkDataStartPosition);
        }
        public override string ToString()
        {
            return string.Format("[ChunkNumber:{0}, ChunkDataTotalSize:{1}, ChunkDataStartPosition:{2}, ChunkDataEndPosition:{3}]",
           
namespace SebWindowsClient.ProcessUtils
  internal class ProcessWatchDog
  {
    private List<ProcessInfo> _processesToWatch = new List<ProcessInfo>();
    public void StartWatchDog()
    {
      if (this._processesToWatch.Count != 0)
        return;
      foreach (string prohibitedExecutable in SEBProcessHandler.ProhibitedExecutables)
      {
        ProcessInfo processInfo = new ProcessInfo(prohibitedExecutable);
        processInfo.Started += new ProcessInfo.StartedEventHandler(this.ProcessStarted);
        this._processesToWatch.Add(processInfo);
      }
    }
    private void ProcessStarted(object sender, EventArgs e)
    {
      string processName = ((ProcessInfo) sender).ProcessName;
      foreach (Process processToClose in ((IEnumerable<Process>) Process.GetProcesses()).Where<Process>((Func<Process, bool>) (p => processName.Contains(p.ProcessName))))
        SEBNotAllowedProcessController.CloseProcess(processToClose);
    }
    public void StopWatchDog()
    {
      foreach (Pr
namespace BusinessLogic
    public class DataManager
    {
        private IUserRepository userRepository;
        private IFriendsRepository friendsRepository;
        private IFriendRequestsRepository friendsRequestRepository;
        private IMessagesRepository messagesRepository;
        private PrimaryMembershipProvider provider;
        public DataManager(IUserRepository userRepository, IFriendsRepository friendsRepository, IFriendRequestsRepository friendsRequestRepository, IMessagesRepository messagesRepository, PrimaryMembershipProvider provider)
        {
            this.userRepository = userRepository;
            this.friendsRepository = friendsRepository;
            this.friendsRequestRepository = friendsRequestRepository;
            this.messagesRepository = messagesRepository;
            this.provider = provider;
        }
        public IUserRepository Users { get { return userRepository; } }
        public IFriendsRepository Friends { get { return friendsRepository
namespace Core.Model.InvokeMethods.Base.Invoke.Service
	public abstract class InvokeServiceBase : IInvokeService
	{
		#region Fields
		private readonly QueueInvoker<DataInvoke> _queueInvoker;
		public Action<DataInvoke> OnAfterInvoke { get; set; }
		protected virtual InvokeType InvokeType
		{
			get
			{
				return InvokeType.Manual;
			}
		}
		#endregion
		#region Constructor
		protected InvokeServiceBase()
		{
			_queueInvoker = new QueueInvoker<DataInvoke>(OnDequeue);
		}
		#endregion
		#region Methods
		public void Invoke(DataInvoke invoked_data)
		{
			switch (InvokeType)
			{
				case InvokeType.Manual:
					break;
				case InvokeType.Local:
				case InvokeType.Remote:
					invoked_data.InvokeType = InvokeType;
					break;
				case InvokeType.Auto:
					invoked_data.InvokeType = GetAutoInvokeType();
					break;
			}
			_queueInvoker.Enqueue(invoked_data);
		}
		protected abstract void InvokeMethod(DataInvoke invoked_data, Action<DataInvoke> callback);
		
		private void OnDequeue(
namespace RockingMicrosoftBand.Common.Helpers
    public static class InvocationHelper
    {
        public static T ExecuteWithExceptionHandling<T>(this Func<T> codeToInvoke, string exceptionString = "", Func<T> codeToInvokeOnFail = null)
        {
            try
            {
                return codeToInvoke.Invoke();
            }
            catch (Exception e)
            {
                if (codeToInvokeOnFail != null)
                {
                    return codeToInvokeOnFail.Invoke();
                }
                throw;
            }
        }
        public static void ExecuteWithExceptionHandling(this Action codeToInvoke, string exceptionString = "", Action codeToInvokeOnFail = null)
        {
            try
            {
                codeToInvoke.Invoke();
            }
            catch (Exception e)
            {
                if (codeToInvokeOnFail != null)
                {
                    codeToInvokeOnFail.Invoke();
                }
          

            }
        }
        public static void WithClient<T>(this T proxy, Action<T> codeToExecute)
        {
            codeToExecute.Invoke(proxy);
            var disposableClient = proxy as IDisposable;
            if (disposableClient != null)
            {
                disposableClient.Dispose();
            }
        }
        public static void ExecuteWithIgnoreException(this Action codeToInvoke, Action codeToInvokeOnFail = null)
        {
            try
            {
                codeToInvoke.Invoke();
            }
            catch (Exception e)
            {
                if (codeToInvokeOnFail != null)
                {
                    codeToInvokeOnFail.Invoke();
                }
            }
        }
        public static T ExecuteWithIgnoreException<T>(this Func<T> codeToInvoke, Func<T> codeToInvokeOnFail = null)
        {
            try
            {
                return codeToInvoke.Invoke();
            }
            catch (Exception e)
     
namespace ControlPanel.Core
    public class CPServiceClient
    {
        public SystemProcess GetSystemProcessByName(string processName)
        {
            SystemProcessService systemProcessService = new SystemProcessService();
            DataTransfer<ControlPanel.Core.DataTransfer.SystemProcess.GetOutput> dt = systemProcessService.GetSystemProcessByName(processName);
            if (dt != null && dt.IsSuccess)
            {
                SystemProcess process=new SystemProcess();
                process.CopyFrom(dt.Data);
                return process;
            }
            return null;
        }
        public SystemProcessThread UpdateSystemProcessThread(SystemProcessThread processThread)
        {
            SystemProcessThreadService systemProcessThreadService = new SystemProcessThreadService();
            return systemProcessThreadService.UpdateSystemProcessThread(processThread);
        }
        public SystemProcessThread GetSystemProcessThreadByName(string threa

        {
            SystemProcessThreadService systemProcessThreadService = new SystemProcessThreadService();
            return systemProcessThreadService.GetSystemProcessThreadByName(threadName);
        }
        public List<SystemProcessThread> GetSystemProcessThreadsByProcessName(string processName)
        {
            SystemProcessService systemProcessService = new SystemProcessService();
            return systemProcessService.GetSystemProcessThreadsByProcessName(processName);
        }
        public List<SystemProcess> GetAllSystemProcess()
        {
            SystemProcessService systemProcessService = new SystemProcessService();
            DataTransfer<List<DataTransfer.SystemProcess.GetOutput>> result = systemProcessService.GetAll();
            List<SystemProcess> processes = new List<SystemProcess>();
            if (result.IsSuccess && result.Data != null && result.Data.Count > 0)
            {
                processes.CopyFrom(result.Data);
            }
      

        }
        public List<SystemProcessThread> GetSystemProcessThreadsByProcessID(int processID)
        {
            SystemProcessThreadService systemProcessThreadService = new SystemProcessThreadService();
            return systemProcessThreadService.GetSystemProcessThreadByProcessID(processID);
        }
        public bool ToggleSystemProcessThreadContinuous(int systemProcessThreadID)
        {
            SystemProcessThreadService systemProcessThreadService = new SystemProcessThreadService();
            return systemProcessThreadService.ToggleSystemProcessThreadContinuous(systemProcessThreadID);
        }
        public bool ToggleSystemProcessThreadEnabled(int systemProcessThreadID)
        {
            SystemProcessThreadService systemProcessThreadService = new SystemProcessThreadService();
            return systemProcessThreadService.ToggleSystemProcessThreadEnabled(systemProcessThreadID);
        }
        public DataTransfer<List<SystemProcessThread>> GetSystemProc
[System.Serializable]
public class ChunkManager
    bool redraw;
    public List<DirtyInfo> dirtyList;
    public List<WorldPos> chunkPointers;
    public List<MapChunk> mapChunks;
    public WorldPos pointer;
    public GameObject mapChunksGameObject;
    bool triggered;
    public sMap map;
    public ChunkManager()
    {
        chunkPointers = new List<WorldPos>();
        mapChunks = new List<MapChunk>();
        dirtyList = new List<DirtyInfo>();
        
    }
    public MapChunk CreateChunk(int x, int y)
    {
        MapChunk chunk = new MapChunk(x, y, map);
        chunkPointers.Add(chunk.pos);
        mapChunks.Add(chunk);
        chunk.gameobject.transform.parent = mapChunksGameObject.transform;
        chunk.gameobject.transform.localPosition = new Vector3(x * map.chunkSize, y * map.chunkSize, 0);
        return chunk;
    }
    public MapChunk GetChunkFromWorldPos(int x, int y)
    {
        pointer.X = x / map.chunkSize;
        pointer.Y = y / map.chunkSize;
        if 

            return mapChunks[chunkPointers.IndexOf(pointer)];
        return null;
    }
    public void SpawnChunks()
    {
        int widthInChunks = map.width / map.chunkSize;
        int heightInChunks = map.height / map.chunkSize;
        MapChunk cChunk;
        for (int y = 0; y < heightInChunks; y++)
        {
            for (int x = 0; x < widthInChunks; x++)
            {
                pointer.X = x;
                pointer.Y = y;
                if (chunkPointers.Contains(pointer))
                {
                    cChunk = mapChunks[chunkPointers.IndexOf(pointer)];
                }
                else
                {
                    cChunk = CreateChunk(x, y);
                }
            }
        }
    }
    public void Dirty(MapChunk chunk, string LayerName)
    {
        if (chunk == null)
            return;
        DirtyInfo dirty = new DirtyInfo(chunk, LayerName);
        if (!dirtyList.Contains(dirty))
        {
            dirtyList.Add(dirty);
  
public class World : MonoBehaviour
	public const int size = 4;
	GameObject worldGO;
	public Chunk[] Chunks;
	void Start()
	{
		Chunks = new Chunk[ size * size * size ];
		worldGO = new GameObject( "World" );
		GenerateWorld();
		FullWorldAOBake();
	}
	void GenerateWorld()
	{
		for( int x = 0; x < size; x++ )
		{
			for( int y = 0; y < size; y++ )
			{
				for( int z = 0; z < size; z++ )
				{
					var chunk = CreateChunk( x, y, z );
					chunk.transform.parent = worldGO.transform;
					
					Chunks[ GetChunkIndex( x, y, z ) ] = chunk;
				}
			}
		}
	}
	Chunk CreateChunk( int x, int y, int z )
	{
		var chunkGO = new GameObject( string.Format( "Chunk-{0},{1},{2}", x, y, z ) );
		var chunkMB = chunkGO.AddComponent< Chunk >();
		chunkMB.ConstructDummyChunk();
		chunkMB.WorldPosition = new WorldPosition( x * Chunk.size, y * Chunk.size, z * Chunk.size );
		
		chunkGO.transform.localPosition = new Vector3( x * Chunk.size, y * Chunk.size, z * Chunk.size );
		
		return chunkMB;
	}
	void FullWo

	{
		AOCalculation.Initialise( this );
		foreach( var chunk in Chunks )
		{
			AOCalculation.ExecuteOnChunk( chunk );
		}
	}
	int GetChunkIndex( int x, int y, int z )
	{
		return x + ( y * size ) + ( z * size * size );
	}
	public Chunk WorldCoordinatesToChunk( WorldPosition worldPosition )
	{
		if( worldPosition.WorldX < 0 || worldPosition.WorldY < 0 || worldPosition.WorldZ < 0 )
			return null;
		int chunkX = worldPosition.WorldX / Chunk.size;
		int chunkY = worldPosition.WorldY / Chunk.size;
		int chunkZ = worldPosition.WorldZ / Chunk.size;
		if( chunkX >= size || chunkY >= size || chunkZ >= size )
			return null;
		return Chunks[ GetChunkIndex( chunkX, chunkY, chunkZ ) ];
	}
	public Cube WorldCoordinatesToCube( WorldPosition worldPosition )
	{
		var chunk = WorldCoordinatesToChunk( worldPosition );
		if( chunk == null )
			return null;
		int chunkX = worldPosition.WorldX % Chunk.size;
		int chunkY = worldPosition.WorldY % Chunk.size;
		int chunkZ = worldPosition.WorldZ % Chunk.size
namespace Standartstyle.AppCode.DAL.Repository
    public class GeneralRepository : IDisposable
    {
        private Entities context = new Entities();
        private CBDCollectionRepository _CBDCollectionRepository;
        public CBDCollectionRepository CBDCollectionRepository
        {
            get
            {
                if (this._CBDCollectionRepository == null)
                    this._CBDCollectionRepository = new CBDCollectionRepository(context);
                return _CBDCollectionRepository;
            }
        }
        private CBDColorRepository _CBDColorRepository;
        public CBDColorRepository CBDColorRepository
        {
            get
            {
                if (this._CBDColorRepository == null)
                    this._CBDColorRepository = new CBDColorRepository(context);
                return _CBDColorRepository;
            }
        }
        private CBDManufacturerRepository _CBDManufacturerRepository;
        public CBDManufacturerRepos

        {
            get
            {
                if (this._CBDManufacturerRepository == null)
                    this._CBDManufacturerRepository = new CBDManufacturerRepository(context);
                return _CBDManufacturerRepository;
            }
        }
        private GoodColorRepository _GoodColorRepository;
        public GoodColorRepository GoodColorRepository
        {
            get
            {
                if (this._GoodColorRepository == null)
                    this._GoodColorRepository = new GoodColorRepository(context);
                return _GoodColorRepository;
            }
        }
        private GoodsCategoryRepository _GoodsCategoryRepository;
        public GoodsCategoryRepository GoodsCategoryRepository
        {
            get
            {
                if (this._GoodsCategoryRepository == null)
                    this._GoodsCategoryRepository = new GoodsCategoryRepository(context);
                return _GoodsCategoryRepository;
   

        }
        private GoodsRepository _GoodsRepository;
        public GoodsRepository GoodsRepository
        {
            get
            {
                if (this._GoodsRepository == null)
                    this._GoodsRepository = new GoodsRepository(context);
                return _GoodsRepository;
            }
        }
        private ImageRepository _ImageRepository;
        public ImageRepository ImageRepository
        {
            get
            {
                if (this._ImageRepository == null)
                    this._ImageRepository = new ImageRepository(context);
                return _ImageRepository;
            }
        }
        private ReplyRepository _ReplyRepository;
        public ReplyRepository ReplyRepository
        {
            get
            {
                if (this._ReplyRepository == null)
                    this._ReplyRepository = new ReplyRepository(context);
                return _ReplyRepository;
            }
        }
        
namespace CSharpUtils.Process
	abstract public class Process : ProcessBase
    {
        static protected Process currentExecutingProcess = null;
        protected int priority = 0;
        protected double x = 0, y = 0, z = 0;
        protected Process parent = null;
        protected LinkedList<Process> childs;
        static private LinkedList<Process> _allProcesses = new LinkedList<Process>();
        static public LinkedList<Process> allProcesses
        {
            get
            {
                return new LinkedList<Process>(_allProcesses);
            }
        }
        static public void _removeOld()
        {
            foreach (var process in allProcesses)
            {
                if (process.State == State.Ended) process._Remove();
            }
        }
        protected void _ExecuteProcessBefore()
        {
            foreach (var process in childs.Where(process => process.priority < 0).OrderBy(process => process.priority)) process._ExecuteProcess();
      

        protected void _ExecuteProcessAfter()
        {
            foreach (var process in childs.Where(process => process.priority >= 0).OrderBy(process => process.priority)) process._ExecuteProcess();
        }
        public void _ExecuteProcess()
        {
            if (State == State.Ended) return;
            currentExecutingProcess = this;
            this._ExecuteProcessBefore();
			this.SwitchTo();
			this._ExecuteProcessAfter();
        }
        protected void _DrawProcessBefore()
        {
            foreach (var process in childs.Where(process => process.z < 0).OrderBy(process => process.z)) process._DrawProcess();
        }
        protected void _DrawProcessAfter()
        {
            foreach (var process in childs.Where(process => process.z >= 0).OrderBy(process => process.z)) process._DrawProcess();
        }
        public void _DrawProcess()
        {
            this._DrawProcessBefore();
            this.Draw();
            this._DrawProcessAfter();
        
namespace Environment{
public class Lightmap {
	private Grid<SunLightChunk> sunChunks = new Grid<SunLightChunk>();
	private Grid<LightChunk> chunks = new Grid<LightChunk>();
	public void SetSunHeight(int height, int x, int z) {
		Vector3i chunkPos = Chunk.ToChunkPosition(x, 0, z);
		Vector3i localPos = Chunk.ToLocalPosition(x, 0, z);
		
		SunLightChunk chunk = GetSunChunkInstance(chunkPos.x, chunkPos.z);
		chunk.SetSunHeight( height, localPos.x, localPos.z );
	}
	public string GetStringBounds(){
		string stringBounds = "";
		stringBounds += "Sunchunk "+sunChunks.GetStringBounds ()+"\n";
		stringBounds += "LightChunk "+chunks.GetStringBounds ()+"\n";
		return stringBounds;
	}
	public int GetSunHeight(int x, int z) {
		Vector3i chunkPos = Chunk.ToChunkPosition(x, 0, z);
		Vector3i localPos = Chunk.ToLocalPosition(x, 0, z);
		SunLightChunk chunk = GetSunChunk(chunkPos.x, chunkPos.z);
		if(chunk != null) return chunk.GetSunHeight(localPos.x, localPos.z);
		return Map.maxChunkY;
	}
	public 

		Vector3i chunkPos = Chunk.ToChunkPosition(x, y, z);
		Vector3i localPos = Chunk.ToLocalPosition(x, y, z);
		SunLightChunk chunk = GetSunChunk(chunkPos.x, chunkPos.z);
		if(chunk != null) return chunk.IsLight(localPos.x, y, localPos.z);
		return false;
	}
	public bool SetMaxLight(byte light, int x, int y, int z) {
		Vector3i chunkPos = Chunk.ToChunkPosition(x, y, z);
		Vector3i localPos = Chunk.ToLocalPosition(x, y, z);
		
		SunLightChunk sunChunk = GetSunChunk(chunkPos.x, chunkPos.z);
		if(sunChunk != null && sunChunk.IsLight(localPos.x, y, localPos.z)) {
			return false;
		}
		
		LightChunk lightChunk = GetLightChunkInstance(chunkPos);
		return lightChunk.SetMaxLight(light, localPos);
	}
	public void SetLight(byte light, Vector3i pos) {
		SetLight(light, pos.x, pos.y, pos.z);
	}
	public void SetLight(byte light, int x, int y, int z) {
		Vector3i chunkPos = Chunk.ToChunkPosition(x, y, z);
		Vector3i localPos = Chunk.ToLocalPosition(x, y, z);
		SetLight(light, chunkPos, localPos);
	}

	public void SetLight(byte light, Vector3i chunkPos, Vector3i localPos) {
		LightChunk lightChunk = GetLightChunk(chunkPos);
		if(lightChunk == null) {
			if(light == LightComputer.MIN_LIGHT) return;
			lightChunk = GetLightChunkInstance(chunkPos);
		}
		lightChunk.SetLight(light, localPos);
	}
	public byte GetLight(Vector3i pos) {
		return GetLight(pos.x, pos.y, pos.z);
	}
	public byte GetLight(int x, int y, int z) {
		Vector3i chunkPos = Chunk.ToChunkPosition(x, y, z);
		Vector3i localPos = Chunk.ToLocalPosition(x, y, z);
		return GetLight(chunkPos, localPos);
	}
	public byte GetLight(Vector3i chunkPos, Vector3i localPos) {
		SunLightChunk sunChunk = GetSunChunk(chunkPos.x, chunkPos.z);
		int worldY = (chunkPos.y << Chunk.SIZE_Y_BITS) + localPos.y;
		if(sunChunk != null && sunChunk.IsLight(localPos.x, worldY, localPos.z)) return LightComputer.MAX_LIGHT;
		
		LightChunk lightChunk = GetLightChunk(chunkPos);
		if(lightChunk != null) return lightChunk.GetLight(localPos);
		return Light
﻿#region Copyright
#endregion
namespace Welt.Core.Forge
    public class ChunkManager
    {
        public World World { get; }
        public IChunkPersistence Persistence { get; }
        public IEnumerable<Chunk> Chunks => m_LoadedChunks.Values;
        private ConcurrentDictionary<Vector3I, Chunk> m_LoadedChunks;
        private object m_ChunkLock = new object();
        public ChunkManager(IChunkPersistence persistence, World world)
        {
            World = world;
            Persistence = persistence;
            m_LoadedChunks = new ConcurrentDictionary<Vector3I, Chunk>();
        }
        public Chunk GetChunk(uint x, uint y, uint z, bool generate = true)
        {
            return GetChunk(new Vector3I(x, y, z), generate);
        }
        public Chunk GetChunk(Vector3I index, bool generate = true)
        {
            if (m_LoadedChunks.ContainsKey(index)) return m_LoadedChunks[index];
            if (TryLoad(index, out var chunk)) return chunk;
            if (!gen
namespace Instrument.DataAccess
    public class InstrumentCertificationDaoImpl
    {
        public void DeleteByInstrumentId(int InstrumentId)
        {
            DBProvider.dbMapper.Delete("Instrument_Certification.DeleteByInstrumentId", InstrumentId);
        }
        public void Add(InstrumentCertificationModel model)
        {
            DBProvider.dbMapper.Insert("Instrument_Certification.Insert", model);
        }
        public void Update(InstrumentCertificationModel model)
        {
            DBProvider.dbMapper.Update("Instrument_Certification.Update", model);
        }
        public void UpdateFileIdByInstrumentIdAndOrderNo(int instrumentId, int fileId, string orderNo)
        {
            Hashtable ht = new Hashtable();
            ht["InstrumentId"] =instrumentId;
            ht["FileId"] =fileId;
            ht["OrderNo"] = orderNo;
            DBProvider.dbMapper.Update("Instrument_Certification.UpdateFileIdByInstrumentIdAndOrderNo", ht);
        }
        publ

        {
            DBProvider.dbMapper.Update("Instrument_Certification.UpdateCertInfo", model);
        }
        public void UpdateIsUseding(InstrumentCertificationModel model)
        {
            DBProvider.dbMapper.Update("Instrument_Certification.UpdateIsUseding", model);
        }
        
        public void DeleteById(int LogId)
        {
            DBProvider.dbMapper.Delete("Instrument_Certification.DeleteById", LogId);
        }
        public InstrumentCertificationModel GetById(int LogId)
        {
            return DBProvider.dbMapper.SelectObject<InstrumentCertificationModel>("Instrument_Certification.GetByID", LogId);
        }
        public InstrumentCertificationModel GetByCertificationCode(string certificationCode)
        {
            return DBProvider.dbMapper.SelectObject<InstrumentCertificationModel>("Instrument_Certification.GetByCertificationCode", certificationCode);
        }
        public IList<InstrumentCertificationModel> GetListByCertificationC

        {
            return DBProvider.dbMapper.SelectList<InstrumentCertificationModel>("Instrument_Certification.GetByCertificationCode", certificationCode);
        }
        public bool IsExistCertificationCode(int logId, string certificationCode)
        {
            InstrumentCertificationModel model = new InstrumentCertificationModel();
            model.LogId = logId;
            model.CertificationCode = certificationCode;
            int count = DBProvider.dbMapper.SelectObject<int>("Instrument_Certification.IsExistCertificationCode", model);
            return count > 0;
        }
        public virtual InstrumentCertificationModel GetMaxEndDateByInstrumentId(int instrumentId, string currentDate)
        {
            Hashtable ht = new Hashtable();
            ht["InstrumentId"] = instrumentId;
            ht["CurrentDate"] = currentDate;
            return DBProvider.dbMapper.SelectObject<InstrumentCertificationModel>("Instrument_Certification.GetMaxEndDateByInstrumentI
namespace AQRWebApp.DAL
    public class UnitOfWork: IDisposable
    {
        private AQRWebAppDbContext context = new AQRWebAppDbContext();
        private GenericRepository<AppInfo> appInfoRepository;
        private GenericRepository<Client> clientRepository;
        private GenericRepository<Colour> colourRepository;
        private GenericRepository<Delivery> deliveryRepository;
        private GenericRepository<FileInfo> fileInfoRepository;
        private GenericRepository<Partner> partnerRepository;
        private GenericRepository<PartnerStore> partnerStoreRepository;
        private GenericRepository<Product> productRepository;
        private GenericRepository<Receive> receiveRepository;
        private GenericRepository<ShipmentId> shipmentIdRepository;
        private GenericRepository<ShipmentRegister> shipmentRegisterRepository;
        private GenericRepository<Size> sizeRepository;
        private GenericRepository<SizeGroup> sizeGroupRepository;
        private Gene

        private GenericRepository<ClientPartner> clientPartnerRepository;
        private GenericRepository<Gender> genderRepository;
        private GenericRepository<Person> personRepository;
        private GenericRepository<PersonAccount> personAccountRepository;
        private GenericRepository<ChucDanh> chucDanhRepository;
        private GenericRepository<Department> departmentRepository;
        public AQRWebAppDbContext DataContext
        {
            get
            {
                return context;
            }
        }
        public GenericRepository<Department> DepartmentRepository
        {
            get
            {
                this.departmentRepository = new GenericRepository<Department>(context);
                return departmentRepository;
            }
        }
        public GenericRepository<ChucDanh> ChucDanhRepository
        {
            get
            {
                this.chucDanhRepository = new GenericRepository<ChucDanh>(context);
        

            }
        }
        public GenericRepository<PersonAccount> PersonAccountRepository
        {
            get
            {
                this.personAccountRepository = new GenericRepository<PersonAccount>(context);
                return personAccountRepository;
            }
        }
        public GenericRepository<Person> PersonRepository
        {
            get
            {
                this.personRepository = new GenericRepository<Person>(context);
                return personRepository;
            }
        }
        public GenericRepository<Gender> GenderRepository
        {
            get
            {
                this.genderRepository = new GenericRepository<Gender>(context);
                return genderRepository;
            }
        }
        public GenericRepository<AppInfo> AppInfoRepository
        {
            get
            {
                this.appInfoRepository = new GenericRepository<AppInfo>(context);
                return appInf
namespace Decorator
    public abstract class MusicInstrument 
    {
        public virtual void PlaySound()
        {
            Console.WriteLine("beep!");
        }
    } 
    public class Guitar:MusicInstrument
    {
        public override void PlaySound()
        {
            base.PlaySound();
            Console.WriteLine("Guitar sound!");
        }
    }
    public abstract  class Decorator:MusicInstrument
    {
        protected MusicInstrument _instrument;
        public Decorator(MusicInstrument instrument)
        {
            _instrument = instrument;
        }
        public MusicInstrument Instrument
        {
            get 
            {
                return _instrument;
            }
            set
            {
            if (value != null)
            {
                _instrument = value;
            }
        } }
        public bool SetInstrument(MusicInstrument instrument)
        {
             _instrument = instrument;
             return true;
        

        public override void PlaySound()
        {
            _instrument.PlaySound();
        }
    }
    public class ElectroInstrument : Decorator
    {
        public ElectroInstrument(MusicInstrument instrument):base(instrument)
        {
        }
        public double Voltage { get; set; }
        public override void PlaySound()
        {
            base.PlaySound();
            for (int i = 0; i < Math.Sqrt(this.Voltage); ++i)
            {
                Console.WriteLine("~");
            }
        }
    }
    public class AcousticInstrument : Decorator
    {
        public AcousticInstrument(MusicInstrument instrument)
            : base(instrument)
        {
        }
        public double Tembr { get; set; }
        public override void PlaySound()
        {
            base.PlaySound();
            for (int i = 0; i < Math.Sqrt(this.Tembr); ++i)
            {
                Console.WriteLine("#");
            }
        }
    }
    class Program
    {
        static 
namespace Fin.Data.Repository
    public class InstrumentRepository: IInstrumentRepository
    {
        private FinContext _context;
        private DbSet<Instrument> _set;
        public InstrumentRepository(FinContext context)
        {
            _context = context;
            _set = _context.Set<Instrument>();
        }
        public IQueryable<IInstrument> GetAll()
        {
            return _set.AsQueryable();
        }
        public IInstrument GetById(int id)
        {
            return (IInstrument)_set.Find(id);
        }
        public void Insert(IInstrument instrument)
        {
            _set.Add((Instrument)instrument);
        }
        public void Update(IInstrument instrument)
        {
            _set.Attach((Instrument)instrument);
            _context.Entry(instrument).State = EntityState.Modified;
        }
        public void Delete(IInstrument instrument)
        {
            if (_context.Entry(instrument).State == EntityState.Detached)
             
namespace UniFramework.Extension.Helper
	public class InvokeHelper : MonoBehaviour
	{
		class InvokeData
		{
			public string key = "default";
			public bool isRepeat = false;
			public float delay = 0;
			public float time;
			public float repeatTime = 0;
			public System.Action callback = null;
			public bool remove = false;
		}
		class ScriptData
		{
			public MonoBehaviour script;
			public List<InvokeData> invokeList;
		}
		private List<ScriptData> scriptDataList;
		private float currentInvokeTime;
		protected  virtual void OnEnable ()
		{
			scriptDataList = new List<ScriptData> ();
			currentInvokeTime = 0;
		}
		protected  virtual void OnDisable ()
		{
			
		}
		protected virtual void Update ()
		{
			if (scriptDataList == null)
				return;
			currentInvokeTime += Time.deltaTime;
			scriptDataList.RemoveAll (o => o.script.enabled == false);
			for (int i = 0; i < scriptDataList.Count; i++) {
				for (int j = 0; j < scriptDataList [i].invokeList.Count; j++) {
					InvokeData dat

					if (currentInvokeTime - data.time >= data.delay) {
						if (data.isRepeat) {
							data.delay += data.repeatTime;
						} else {
							data.remove = true;
						}
						if (data.callback != null) {
							data.callback ();
						}
					}
				}
				scriptDataList [i].invokeList.RemoveAll ((o) => {
					return o.remove;
				});
			}
			scriptDataList.RemoveAll (o => o.invokeList == null || o.invokeList.Count == 0);
			if (scriptDataList.Count == 0) {
				this.enabled = false;
			}
		}
		public void HelperInvokeRepeating (MonoBehaviour script, string methodKey, float delay, float repeatTime, System.Action callback)
		{
			AddHelperInvoke (script, methodKey, delay, repeatTime, callback);
		}
		private void AddHelperInvoke (MonoBehaviour script, string methodKey, float delay, float repeatTime, System.Action callback)
		{
			if (this.enabled == false)
				enabled = true;
		
			ScriptData data = scriptDataList.Find (o => o.script.Equals (script));
			if (data == null) {
				data = ne

				data.invokeList = new List<InvokeData> ();
				data.script = script;
				currentInvokeTime = 0;
				scriptDataList.Add (data);
			}
			InvokeData invoke = new InvokeData ();
			invoke.key = methodKey;
			invoke.delay = delay;
			if (repeatTime <= 0) {
				invoke.isRepeat = false;	
			} else {
				invoke.isRepeat = true;	
			}
			invoke.repeatTime = repeatTime;
			invoke.callback = callback;
			invoke.time = currentInvokeTime;
			data.invokeList.Add (invoke);
		}
		public bool IsHelperInvoking (MonoBehaviour script, string methodKey)
		{
			if (this.enabled == false || scriptDataList == null)
				return false;
			ScriptData data = scriptDataList.Find (o => o.script.Equals (script));
			if (data == null) {
				return false;
			}
			if (data.invokeList.Find (o => o.key.Equals (methodKey)) == null) {
				return false;
			}
			return true;
		}
		public void CancelHelperInvoke (MonoBehaviour script)
		{
			if (scriptDataList == null)
				return;
			scriptDataList.RemoveAll (o => o.scrip
namespace PostProcessor.Windows
	public partial class InputInstrumentWindow : Window
	{
		public enum InputInstrumentResults
		{
			Undefined,
			Apply,
			Ignore,
			IgnoreAll,
			Abort
		}
		public InputInstrumentResults InputInstrumentResult
		{
			get;
			private set;
		}
		public string InstrumentName
		{
			get { return txtInstrumentName.Text; }
		}
		public InputInstrumentWindow(int t, int lnum, string[] lines)
		{
			InitializeComponent();
			InputInstrumentResult = InputInstrumentResults.Undefined;
			txtLineNum.Text = (lnum + 1).ToString();
			txtInstrumentNum.Text = t.ToString();
			linesView.SetLines(lines, lnum);
		}
		private void InputInstrumentWindow_Closing(object sender, System.ComponentModel.CancelEventArgs e)
		{
			if (InputInstrumentResult != InputInstrumentResults.Undefined)
			{
				return;
			}
			if (MessageBox.Show("Прервать обработку?", "Внимание", MessageBoxButton.YesNoCancel) == MessageBoxResult.Yes)
			{
				InputInstrumentResult = InputInstrumentResults.
namespace ConservappiOsAndroid.iOS{
	public partial class MenuController : BaseController{
		UIAlertView alert = new UIAlertView();
		Rootobject sesion;
		public MenuController(IntPtr handle) : base(handle) {
		}
		public  override void ViewDidLoad() {
			base.ViewDidLoad();
			var estadoCuentaController = (EstadoDeCuentaTableViewController)Storyboard.InstantiateViewController("EstadoDeCuentaTableViewController");
			var historialEstadoCuenta = (HistorialEstadoCuentaTableViewController)Storyboard.InstantiateViewController("HistorialEstadoCuentaTableViewController");
			var payReference = (PayRefrenceTableViewController)Storyboard.InstantiateViewController("PayRefrenceTableViewController");
			var amortizacion = (AmortizacionTableViewController)Storyboard.InstantiateViewController("AmortizacionTableViewController");
			var movimientos = (MovimientosTableViewController)Storyboard.InstantiateViewController("MovimientosTableViewController");
			var notify= (SwiperTableViewController)Storyb

			var garantias = (GarantiasTableViewController)Storyboard.InstantiateViewController("GarantiasTableViewController");
			HistorialViewButton.TouchUpInside += (sender, e) => { 
				if (NavController.TopViewController != estadoCuentaController) {
					NavController.PopViewController(true);
				}
				Console.WriteLine(NavController.TopViewController.ToString());
					Console.WriteLine("Other Controller == null");
					Console.WriteLine(NavController.TopViewController.ToString());
					NavController.PushViewController(historialEstadoCuenta, true);
				} else {
					SidebarController.CloseMenu();
				}
				SidebarController.CloseMenu();
				
			};
			ReferenciaPagoViewButton.TouchUpInside += (sender, e) => {
				if (NavController.TopViewController != estadoCuentaController) {
					NavController.PopViewController(true);
				}
				Console.WriteLine(NavController.TopViewController.ToString());
					Console.WriteLine("Other Controller == null");
					Console.WriteLine(NavController.TopViewCon

					NavController.PushViewController(payReference, true);
				} else {
					SidebarController.CloseMenu();
				}
				SidebarController.CloseMenu();
				
			};
			AmortizacionViewButton.TouchUpInside += (sender, e) => { 
				if (NavController.TopViewController != estadoCuentaController) {
					NavController.PopViewController(true);
				}
				Console.WriteLine(NavController.TopViewController.ToString());
				if (NavController.TopViewController as AmortizacionTableViewController == null) {
					Console.WriteLine("Other Controller == null");
					Console.WriteLine(NavController.TopViewController.ToString());
					NavController.PushViewController(amortizacion, true);
				} else {
					SidebarController.CloseMenu();
				}
				SidebarController.CloseMenu();
				
			};
			estadoCuentaViewButton.TouchUpInside += (sender, e) => { 
				if (NavController.TopViewController != estadoCuentaController) {
					NavController.PopViewController(true);
				}
				Console.WriteLine(NavController.TopViewCon
namespace Proxii.Internal.Interceptors
	public class AfterInvokeInterceptor : IInterceptor
	{
		private readonly Action _afterInvoke;
        private readonly Action<MethodInfo> _afterInvokeMethodInfo;
        private readonly Action<MethodInfo, object[]> _afterInvokeMethodInfoArgs;
		public AfterInvokeInterceptor(Action afterInvoke)
		{
			_afterInvoke = afterInvoke;
		}
        public AfterInvokeInterceptor(Action<MethodInfo> afterInvoke)
        {
            _afterInvokeMethodInfo = afterInvoke;
        }
        public AfterInvokeInterceptor(Action<MethodInfo, object[]> afterInvoke)
        {
            _afterInvokeMethodInfoArgs = afterInvoke;
        }
		public void Intercept(IInvocation invocation)
		{
			invocation.Proceed();
            if (_afterInvoke != null)
                _afterInvoke();
            else if (_afterInvokeMethodInfo != null)
                _afterInvokeMethodInfo(invocation.Method);
            else
                _afterInvokeMethodInfoArgs(invocation.M
namespace Core.Model.InvokeMethods.Base.Invoke.Service
	public class InvokeServiceFactory : IInvokeServiceFactory
	{
		#region Fields
		private readonly IMethodService _methodService;
		private readonly IAssemblyService _assemblyService;
		private readonly ICoordinationService _coordinationService;
		private readonly IDataService<DataInvoke> _dataService;
		private readonly IWebServerService _webServerService;
		private readonly Dictionary<Type, IInvokeService> _serviceDictionary;
		private readonly RemoteInvokeService _remoteInvokeService;
		#endregion
		#region Constructor
		public InvokeServiceFactory(IMethodService method_service, IAssemblyService assembly_service, ICoordinationService coordination_service,
			IDataService<DataInvoke> data_service, IWebServerService web_server_service, RemoteInvokeService remote_invoke_service)
		{
			_methodService = method_service;
			_assemblyService = assembly_service;
			_coordinationService = coordination_service;
			_webServerService = web_s

			var invoke_c_sharp_method = new InvokeCSharpService(_assemblyService, _methodService, data_service);
			var invoke_executable_file = new InvokeExecutableFileService(new ExecutableFileMethodService(), data_service);
			
			_serviceDictionary = new Dictionary<Type, IInvokeService>
			{
				/*{typeof(RemoteInvokeService), remote_invoke_service},
				{typeof(InvokeCSharpService), invoke_c_sharp_method},*/
				{typeof(CSharpMethod), invoke_c_sharp_method},
				{typeof(ExecutableFileMethod), invoke_executable_file}
			};
		}
		#endregion
		#region Methods/Public
		public void AddOnDequeueEvent(Action<DataInvoke> action)
		{
			_remoteInvokeService.OnAfterInvoke += action;
			foreach (var service in _serviceDictionary)
			{
				service.Value.OnAfterInvoke += action;
			}
		}
		
		public IInvokeService GetInvokeService(DataInvoke invoked_data, InvokeType invoke_type = InvokeType.Manual)
		{
			switch (invoke_type)
			{
				case InvokeType.Manual:
					switch (invoked_data.InvokeType)
					
public class Chunk
		public bool generated;
		private Block[,,] blocks;
		private World world;
		private int chunkX, chunkZ;
		private ChunkObject chunkObject;
		public Chunk (World world, int chunkX, int chunkZ)
		{
				this.chunkX = chunkX;
				this.chunkZ = chunkZ;
				this.world = world;
				blocks = new Block[world.ChunkX, world.ChunkY, world.ChunkZ];
		}
		public void SetBlockWorldPos (Block block, int x, int y, int z)
		{
				SetBlock (block, WorldToLocateX (x), y, WorldToLocateZ (z));
		}
		public void SetBlock (Block block, int x, int y, int z)
		{				
				blocks [x, y, z] = block;
		}
		public void DelBlockWorldPos (int x, int y, int z)
		{
				DelBlock (WorldToLocateX (x), y, WorldToLocateZ (z));
		}
		public void DelBlock (int x, int y, int z)
		{				
				blocks [x, y, z] = null;
		}
		public Block GetBlockWorldPos (int x, int y, int z)
		{				
				return GetBlock (WorldToLocateX (x), y, WorldToLocateZ (z));
		}
		public Block GetBlock (int x, int y, int z)
		{
				return b

		}
		public int WorldToLocateZ (int z)
		{
				int iz = z % world.ChunkZ;
				if (iz < 0) 
						iz = world.ChunkZ + iz;
				return iz;
		}
		public int WorldToLocateX (int x)
		{
				int ix = x % world.ChunkX;
				if (ix < 0) 
						ix = world.ChunkX + ix;						
				return ix;
		}
		public int X {
				get{ return chunkX;}
		}
		public int Z {
				get{ return chunkZ;}
		}
		public int WorldX {
				get{ return chunkX * world.ChunkX;}
		}
		public int WorldZ {
				get{ return chunkZ * world.ChunkZ;}
		}
		public ChunkObject Object {
				get {
						if (chunkObject == null) {
								chunkObject = ChunkObject.Instance (world, this);
						}
						return chunkObject;
				}
		}
		public bool NeighboursReady ()
		{
				if (world.GetChunk (chunkX - 1, chunkZ).generated
						&& world.GetChunk (chunkX, chunkZ - 1).generated
						&& world.GetChunk (chunkX + 1, chunkZ).generated
						&& world.GetChunk (chunkX, chunkZ + 1).generated
						&& world.GetChunk (chunkX + 1, chunkZ + 1).generated
	
namespace WoodStore.Domain.Uow
    public interface IUnitOfWork : IDisposable
    {
         Repository<Organization_Legal_Entities> Organization_Legal_EntitiesRepository { get; }
        Repository<IndustryType> IndustryTypeRepository { get; }
        Repository<Bank> BankRepository { get; }
        Repository<Bank_Branches> BankBranchesRepository { get; }
        Repository<City> CityRepository { get; }
        Repository<Company_MainData> CompanyMainDataRepository { get; }
        Repository<Country> CountryRepository { get; }
        Repository<Currecny_Converter> CurrecnyConverterRepository { get; }
        Repository<Currency> CurrencyRepository { get; }
        Repository<Job> JobRepository { get; }
        Repository<Nationality> NationalityRepository { get; }
        Repository<District> DistrictRepository { get; }
        Repository<Unit> UnitRepository { get; }
        Repository<Unit_Converter> UnitConverterRepository { get; }
        Repository<Language> LanguageRepository

        Repository<Branch> BranchRepository { get; }
        Repository<SuppliersGroup> SuppliersGroupRepository { get; }
        Repository<Suppliers_SubGroup> Suppliers_SubGroupRepository { get; }
        Repository<Privilege> PrivilegesRepository { get; }
        Repository<RolePrivilege> RolePrivilegeRepository { get; }
        Repository<Role> RoleRepository { get; }
        Repository<User> UserRepository { get; }
        Repository<Gender> GenderRepository { get; }
        Repository<Job_Titles> JobTitlesRepository { get; }
        Repository<Career_Classes> CareerClassesRepository { get; }
        Repository<Allowance> AllowanceRepository { get; }
      
        Repository<User_Allowances> UserAllowancesRepository { get; }
      
        Repository<Setting> SettingRepository { get; }
        Repository<EmailConfig> EmailConfigRepository { get; }
        Repository<DryingType> DryingTypeRepository { get; }
        Repository<Grade> GradeRepository { get; }
        Repository<Pa

        Repository<Product> ProductRepository { get; }
        Repository<ProductDetail> ProductDetailRepository { get; }
        Repository<Store> StoreRepository { get; }
        Repository<StoreType> StoreTypeRepository { get; }
        Repository<Category> CategoryRepository { get; }
        Repository<Supplier> SupplierRepository { get; }
        Repository<SerialNoType> SerialNoTypeRepository { get; }
        Repository<StoreTransaction> StoreTransactionRepository { get; }
        Repository<IssuedProduct> IssuedProductRepository { get; }
        Repository<ReceivedProduct> ReceivedProductRepository { get; }
        Repository<AdditionType> AdditionTypeRepository { get; }
        Repository<IssueType> IssueTypeRepository { get; }
        Repository<StoreTransferenceRecord> StoreTransferenceRecordRepository { get; }
        Repository<TransactionDocument> TransactionDocumentRepository { get; }
        Repository<StoreInventory> StoreInventoryRepository { get; }
        Repository
public class Program
    private readonly static Random r = new Random();
    public static void Main(string[] args)
    {
        int N = 250;
        var work = Enumerable.Range(1,N).Select(x => r.Next(0, 6)).ToList();
        var chunks = work.Select((o,i) => new { Index=i, Obj=o })
            .GroupBy(e => e.Index / 10)
            .Select(group => group.Select(e => e.Obj).ToList())
            .ToList();
        foreach(var chunk in chunks)
            Console.WriteLine("Chunk: {0}", string.Join(", ", chunk.Select(i => i.ToString()).ToArray()));
    }
#endif
Chunk: 3, 0, 2, 0, 4, 2, 3, 3, 5, 0
Chunk: 2, 3, 4, 4, 0, 5, 4, 1, 3, 5
Chunk: 5, 0, 5, 2, 1, 4, 5, 1, 2, 4
Chunk: 2, 4, 1, 4, 5, 0, 5, 2, 1, 4
Chunk: 3, 4, 0, 5, 1, 3, 1, 3, 5, 2
Chunk: 2, 3, 2, 1, 3, 4, 5, 4, 1, 3
Chunk: 2, 0, 1, 1, 2, 4, 3, 5, 2, 2
Chunk: 4, 1, 2, 1, 3, 1, 4, 4, 4, 3
Chunk: 5, 0, 0, 5, 1, 2, 3, 0, 1, 0
Chunk: 3, 5, 5, 4, 5, 2, 2, 5, 1, 0
Chunk: 5, 2, 5, 2, 2, 1, 3, 3, 5, 1
Chunk: 1, 4, 2, 0, 5, 2, 0, 3, 1,
namespace Flubu.Tasks.Processes
    public class KillProcessTask : TaskBase
    {
        public override string TaskDescription
        {
            get
            {
                return String.Format (
                    System.Globalization.CultureInfo.InvariantCulture,
                    "Kill process '{0}'", 
                    processName);
            }
        }
        public KillProcessTask (string processName)
        {
            this.processName = processName;
        }
        public static void Execute (IScriptExecutionEnvironment environment, string processName)
        {
            KillProcessTask task = new KillProcessTask (processName);
            task.Execute (environment);
        }
        protected override void DoExecute (IScriptExecutionEnvironment environment)
        {
            Process[] processByName = Process.GetProcessesByName (processName);
            foreach (Process process in processByName)
            {
                environment.LogMes
namespace FutureArbitrage.BLL
    public class InstrumentCenter : BindableBase
    {
        private const string INSTRUMENT_CONFIG_KEY = "INSTRUMENT_CONFIG_KEY";
        private InstrumentCenter() { }
        private static readonly InstrumentCenter instance = new InstrumentCenter();
        public static InstrumentCenter Instance { get { return instance; } }
        public void Init()
        {
            this.InstrumentIDs = ConfigHelper.GetConfig<string[]>(INSTRUMENT_CONFIG_KEY);
            if (this.InstrumentIDs == null)
            {
                this.InstrumentIDs = new string[0];
            }
        }
        private string[] instrumentIDs;
        public string[] InstrumentIDs
        {
            get
            {
                return this.instrumentIDs;
            }
            set
            {
                this.instrumentIDs = value;
                this.NotifyPropertyChanged("InstrumentIDs");
            }
        }
        public void SetInstruments(Instrum
namespace Voxels
    public class World : MonoBehaviour
    {
        public GameObject chunkPrefab;
        Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
        [HideInInspector]
        public WorldData data;
        public Chunk CreateChunk(int x, int y, int z)
        {
            var chunkData = data.CreateChunk(x, y, z);
            var worldPos = chunkData.pos;
            var go = Instantiate(chunkPrefab, Vector3.zero, Quaternion.identity);
            go.transform.SetParent(transform);
            var chunk = go.GetComponent<Chunk>();
            chunk.pos = worldPos;
            chunk.world = this;
            chunk.data = chunkData;
            chunk.Render();
            chunks.Add(worldPos, chunk);
            return chunk;
        }
        public void DestroyChunk(int x, int y, int z)
        {
            var chunk = GetChunk(x, y, z);
            if (chunk == null) return;
            chunks.Remove(chunk.pos);
            GameObject.Destroy(

        }
        private Chunk GetChunk(int x, int y, int z)
        {
            var pos = data.GetChunkPos(x, y, z);
            Chunk chunk;
            chunks.TryGetValue(pos, out chunk);
            return chunk;
        }
        public void SetBlock(int x, int y, int z, BlockId block)
        {
            Chunk chunk = GetChunk(x, y, z);
            if (chunk == null)
            {
                chunk = CreateChunk(x, y, z);
            }
            data.SetBlock(x, y, z, block);
            chunk.Render();
            var xx = x - chunk.pos.x;
            var yy = y - chunk.pos.y;
            var zz = z - chunk.pos.z;
            var cs1 = MapConstants.ChunkSize - 1;
            UpdateIfEqual(xx, 0, new WorldPos(x - 1, y + 0, z + 0));
            UpdateIfEqual(xx, cs1, new WorldPos(x + 1, y + 0, z + 0));
            UpdateIfEqual(yy, 0, new WorldPos(x + 0, y - 1, z + 0));
            UpdateIfEqual(yy, cs1, new WorldPos(x + 0, y + 1, z + 0));
            UpdateIfEqual(zz,
namespace EIDService.Common.DataAccess
    public class UnitOfWork : IDisposable
    {
        private readonly DbContext _context;
        private GenericRepository<Emitent> emitentRepository;
        private GenericRepository<Security> securityRepository;
        private GenericRepository<Financial> financialRepository;
        private GenericRepository<TradeSession> tradeSessionRepository;
        private GenericRepository<Candle> candleRepository;
        private GenericRepository<Settings> settingsRepository;
        private GenericRepository<Order> orderRepository;
        private GenericRepository<Position> positionRepository;
        private GenericRepository<StopOrder> stopOrderRepository;
        private GenericRepository<Transaction> transactionRepository;
        private GenericRepository<TransactionResult> transactionResultRepository;
        private GenericRepository<Deal> dealRepository;
        private GenericRepository<MoneyLimit> moneylimitRepository;
        private 

        private GenericRepository<EIDProcess> eidProcessRepository;
        public UnitOfWork(DbContext context)
        {
            this._context = context;
        }
        public GenericRepository<Emitent> EmitentRepository
        {
            get
            {
                return this.emitentRepository ?? new GenericRepository<Emitent>(_context);
            }
        }
        public GenericRepository<Security> SecurityRepository
        {
            get
            {
                return this.securityRepository ?? new GenericRepository<Security>(_context);
            }
        }
        public GenericRepository<Financial> FinancialRepository
        {
            get
            {
                return this.financialRepository ?? new GenericRepository<Financial>(_context);
            }
        }
        public GenericRepository<TradeSession> TradeSessionRepository
        {
            get
            {
                return this.tradeSessionRepository ?? new Gene

            }
        }
        public GenericRepository<Candle> CandleRepository
        {
            get
            {
                return this.candleRepository ?? new GenericRepository<Candle>(_context);
            }
        }
        public GenericRepository<Settings> SettingsRepository
        {
            get
            {
                return this.settingsRepository ?? new GenericRepository<Settings>(_context);
            }
        }
        public GenericRepository<Order> OrderRepository
        {
            get
            {
                return this.orderRepository ?? new GenericRepository<Order>(_context);
            }
        }
        public GenericRepository<Position> PositionRepository
        {
            get
            {
                return this.positionRepository ?? new GenericRepository<Position>(_context);
            }
        }
        public GenericRepository<StopOrder> StopOrderRepository
        {
            get
            {
               
class LightComputerUtils {
	public static void SetLightDirty(Map map, Vector3i pos) {
		Vector3i chunkPos = Chunk.ToChunkPosition(pos);
		Vector3i localPos = Chunk.ToLocalPosition(pos);
		
		SetChunkLightDirty(map, chunkPos);
		
		if(localPos.x == 0) SetChunkLightDirty(map, chunkPos-Vector3i.right);
		if(localPos.y == 0) SetChunkLightDirty(map, chunkPos-Vector3i.up);
		if(localPos.z == 0) SetChunkLightDirty(map, chunkPos-Vector3i.forward);
		
		if(localPos.x == Chunk.SIZE_X-1) SetChunkLightDirty(map, chunkPos+Vector3i.right);
		if(localPos.y == Chunk.SIZE_Y-1) SetChunkLightDirty(map, chunkPos+Vector3i.up);
		if(localPos.z == Chunk.SIZE_Z-1) SetChunkLightDirty(map, chunkPos+Vector3i.forward);
	}
	private static void SetChunkLightDirty(Map map, Vector3i chunkPos) {
		Chunk chunkData = map.GetChunk(chunkPos);
		if(chunkData == null) return;
		ChunkRenderer chunk = chunkData.GetChunkRenderer();
		if(chunk == null) return;
		chunk.SetLightDirty();
	}
	public static int GetLightStep(BlockDat
public class World : MonoBehaviour
    public Dictionary<WorldPosition, Chunk> chunks;
    public GameObject chunkPrefab;
    public event Action OnGenerationComplete;
    void Start()
    {
        chunks = new Dictionary<WorldPosition, Chunk>();
        for (int x = 0; x < 10; x++)
        {
            for (int y = 0; y < 1; y++)
            {
                for (int z = 0; z < 10; z++)
                {
                    CreateChunk(x * 16, y * 16, z * 16);
                }
            }
        }
        if (OnGenerationComplete != null)
        {
            OnGenerationComplete.Invoke();
        }
    }
    private void CreateChunk(int x, int y, int z)
    {
        WorldPosition worldPos = new WorldPosition(x, y, z);
        GameObject newChunkObject = Instantiate(chunkPrefab, new Vector3(worldPos.x, worldPos.y, worldPos.z), Quaternion.Euler(Vector3.zero)) as GameObject;
        newChunkObject.transform.parent = transform;
        Chunk newChunk = newChunkObject.GetComponen

        newChunk.worldPosition = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        for (int ix = 0; ix < 16; ix++)
        {
            for (int iy = 0; iy < 16; iy++)
            {
                for (int iz = 0; iz < 16; iz++)
                {
                    if (worldPos.y + iy <= 2)
                    {
                        SetBlock(x + ix, y + iy, z + iz, new BlockGrass());
                    }
                    else
                    {
                        SetBlock(x + ix, y + iy, z + iz, new BlockAir());
                    }
                }
            }
        }
    }
    private Chunk GetChunk(int x, int y, int z)
    {
        float multiple = Chunk.chunkSize;
        WorldPosition pos = new WorldPosition(Mathf.FloorToInt(x / multiple) * Chunk.chunkSize,
                                              Mathf.FloorToInt(y / multiple) * Chunk.chunkSize,
                                              Mathf.FloorToInt(z /

        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Block GetBlock(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null)
        {
            return containerChunk.GetBlock(x - containerChunk.worldPosition.x,
                                           y - containerChunk.worldPosition.y,
                                           z - containerChunk.worldPosition.z);
        }
        return new BlockAir();
    }
    public void SetBlock(int x, int y, int z, Block block)
    {
        Chunk chunk = GetChunk(x, y, z);
        if (chunk != null)
        {
            chunk.SetBlock(x - chunk.worldPosition.x, y - chunk.worldPosition.y, z - chunk.worldPosition.z, block);
            chunk.update = true;
            UpdateIfEqual(x - chunk.worldPosition.x, 0, new WorldPosition(x - 1, y, z));
            UpdateIfEqual(x - chunk.worldPosition.x, Chun
namespace CreativeSpore.RpgMapEditor
	public class TileChunkPool : MonoBehaviour 
	{
		public const int k_TileChunkWidth = 62;
		public const int k_TileChunkHeight = 62;
		[System.Serializable]
		public class TileChunkLayer
		{
			public GameObject ObjNode;
			public TileChunk[] TileChunks;
		}
		public List<TileChunkLayer> TileChunkLayers = new List<TileChunkLayer>();
		private List<TileChunk> m_tileChunkToBeUpdated = new List<TileChunk>();
		[SerializeField]
		private AutoTileMap m_autoTileMap;
		public void Initialize (AutoTileMap autoTileMap)
		{
			hideFlags = HideFlags.NotEditable;
			m_autoTileMap = autoTileMap;
			foreach( TileChunkLayer tileChunkLayer in TileChunkLayers )
			{
				if( tileChunkLayer.ObjNode != null )
				{
				#if UNITY_EDITOR
					DestroyImmediate(tileChunkLayer.ObjNode);
				#else
					Destroy(tileChunkLayer.ObjNode);
				#endif
				}
			}
			TileChunkLayers.Clear();
			m_tileChunkToBeUpdated.Clear();
		}
		public void MarkUpdatedTile( int tileX, int tileY, 

		{
			TileChunk tileChunk = _GetTileChunk( tileX, tileY, layer );
			if( !m_tileChunkToBeUpdated.Contains(tileChunk) )
			{
				m_tileChunkToBeUpdated.Add( tileChunk );
			}
		}
		public void UpdateChunks()
		{
			while( m_tileChunkToBeUpdated.Count > 0 )
			{
				m_tileChunkToBeUpdated[0].RefreshTileData();
				m_tileChunkToBeUpdated.RemoveAt(0);
			}
		}
		public void UpdateLayerPositions ()
		{
			for( int i = 0; i < TileChunkLayers.Count; ++i )
			{
				TileChunkLayers[i].ObjNode.transform.position = m_autoTileMap.TileLayerPosition[i];
			}
		}
		private TileChunk _GetTileChunk( int tileX, int tileY, int layer )
		{
			TileChunkLayer chunkLayer = _GetTileChunkLayer( layer );
			int rowTotalChunks = 1 + ((m_autoTileMap.MapTileWidth - 1) / k_TileChunkWidth);
			int chunkIdx = (tileY / k_TileChunkHeight) * rowTotalChunks + (tileX / k_TileChunkWidth);
			TileChunk tileChunk = chunkLayer.TileChunks[chunkIdx];
			if( tileChunk == null )
			{
				int startTileX = tileX - tileX % k_TileC

				int startTileY = tileY - tileY % k_TileChunkHeight;
				GameObject chunkObj = new GameObject();
				chunkObj.name = "TileChunk"+startTileX+"_"+startTileY;
				chunkObj.transform.parent = chunkLayer.ObjNode.transform;
				chunkObj.hideFlags = HideFlags.NotEditable;
				tileChunk = chunkObj.AddComponent<TileChunk>();
				chunkLayer.TileChunks[chunkIdx] = tileChunk;
				tileChunk.Configure( m_autoTileMap, layer, startTileX, startTileY, k_TileChunkWidth, k_TileChunkHeight );
			}
			return tileChunk;
		}
		private TileChunkLayer _GetTileChunkLayer( int layer )
		{
			return TileChunkLayers.Count > layer? TileChunkLayers[layer] : _CreateTileChunkLayer( layer );
		}
		private TileChunkLayer _CreateTileChunkLayer( int layer )
		{
			int rowTotalChunks = 1 + ((m_autoTileMap.MapTileWidth - 1) / k_TileChunkWidth);
			int colTotalChunks = 1 + ((m_autoTileMap.MapTileHeight - 1) / k_TileChunkHeight);
			int totalChunks = rowTotalChunks * colTotalChunks;
			TileChunkLayer chunkLayer = null;
			
namespace TomiSoft_Style_Studio {
	public partial class InstrumentSelector : UserControl {
		private Instrument selectedInstr = Instrument.Drum;
		
		public Instrument SelectedInstrument {
			get {
				return this.selectedInstr;
			}
		}
		public event EventHandler<InstrumentEventArgs> InstrumentChanged;
		public InstrumentSelector() {
			InitializeComponent();
			Dictionary<RadioButton, Instrument> Mappings = new Dictionary<RadioButton, Instrument>() {
				{radioButton1, Instrument.Drum},
				{radioButton2, Instrument.Bass},
				{radioButton3, Instrument.Acc1},
				{radioButton4, Instrument.Acc2},
				{radioButton5, Instrument.Acc3},
				{radioButton6, Instrument.Acc4},
				{radioButton7, Instrument.Acc5},
				{radioButton8, Instrument.Acc6},
			};
			foreach (var item in Mappings) {
				item.Key.CheckedChanged += (o, e) => {
					if (item.Key.Checked)
						this.OnChanged(item.Value);
				};
			}
		}
		private void OnChanged(Instrument i) {
			this.selectedInstr = i;
			if (this.Inst
﻿namespace Frankfort.Threading.Internal
    public class ThreadDispatchAction<T> : DispatchAction
    {
        private T dispatchArgParam;
        private CallBackArg<T> dispatchCallArg;
        private CallBackArgRturn<T> dispatchCallArgReturn;
        private CallBack dispatchCallClean;
        private CallBackReturn dispatchCallReturn;
        private CallBackReturn<T> dispatchCallReturn2;
        public object dispatchExecutionResult;
        public T dispatchExecutionResult2;
        private bool executed;
        private bool safeMode;
        public ThreadDispatchAction()
        {
            this.executed = false;
            this.dispatchExecutionResult = null;
            this.dispatchExecutionResult2 = default(T);
        }
        public void ExecuteDispatch()
        {
            if (this.safeMode)
            {
                try
                {
                    if (this.dispatchCallClean != null)
                    {
                        this.dispatchCallCle

                    }
                    else if (this.dispatchCallArg != null)
                    {
                        this.dispatchCallArg(this.dispatchArgParam);
                    }
                    else if (this.dispatchCallArgReturn != null)
                    {
                        this.dispatchExecutionResult = this.dispatchCallArgReturn(this.dispatchArgParam);
                    }
                    else if (this.dispatchCallReturn != null)
                    {
                        this.dispatchExecutionResult = this.dispatchCallReturn();
                    }
                    else if (this.dispatchCallReturn2 != null)
                    {
                        this.dispatchExecutionResult2 = this.dispatchCallReturn2();
                    }
                }
                catch (Exception exception)
                {
                    Debug.Log(exception.Message + exception.StackTrace);
                }
            }
            else if (this.

            {
                this.dispatchCallClean();
            }
            else if (this.dispatchCallArg != null)
            {
                this.dispatchCallArg(this.dispatchArgParam);
            }
            else if (this.dispatchCallArgReturn != null)
            {
                this.dispatchExecutionResult = this.dispatchCallArgReturn(this.dispatchArgParam);
            }
            else if (this.dispatchCallReturn != null)
            {
                this.dispatchExecutionResult = this.dispatchCallReturn();
            }
            else if (this.dispatchCallReturn2 != null)
            {
                this.dispatchExecutionResult2 = this.dispatchCallReturn2();
            }
            this.executed = true;
        }
        public void Init(CallBackReturn dispatchCall, bool safeMode)
        {
            this.safeMode = safeMode;
            this.dispatchCallReturn = dispatchCall;
            this.ValidateExecutionOnInit(true);
        }
        public void 
public class World : MonoBehaviour {
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public GameObject chunkPrefab;
    public GameObject treePrefab;
    public GameObject bonePrefab;
    public GameObject horsePrefab;
    public GameObject huckPrefab;
    public GameObject waterPrefab;
    public string worldName = "world";
    public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(x, y, z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        var terrainGen = new TerrainGen();
        newChunk = terrainGen.ChunkGen(newChunk);
        if (newChunk.airCount == 6144) { newChunk.gameObject.SetActi

        newChunk.SetBlocksUnmodified();
        for (int i = 0; i < newChunk.treeList.Count; i++)
        {
            GameObject newTree = Instantiate(treePrefab);
            newTree.transform.position = newChunk.treeList[i];
        }
        for (int i = 0; i < newChunk.bushList.Count; i++)
        {
            GameObject newBush = Instantiate(huckPrefab);
            newBush.transform.position = newChunk.bushList[i];
        }
        if (newChunk.boneSpawn)
        {
            print("boneSpawn");
            GameObject newBone = Instantiate(bonePrefab);
            newBone.transform.position = newChunk.boneList[0];
        }
        if (newChunk.horseSpawn)
        {
            print("boneSpawn");
            GameObject newHorse = Instantiate(horsePrefab);
            newHorse.transform.position = newChunk.horseList[0];
        }
        Serialization.Load(newChunk);
        if (newChunk.hasWater)
        {
            GameObject newWater = Instantiate(waterPrefab);
       

            newChunk.water = newWater;
            newChunk.chunkWater = newWater.GetComponent<ChunkWater>();
        }
    }
    public void DestroyChunk(int x, int y, int z)
    {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
        {
            Serialization.SaveChunk(chunk);
            Object.Destroy(chunk.gameObject);
            chunks.Remove(new WorldPos(x, y, z));
        }
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        pos.x = Mathf.FloorToInt(x / 4f) * 4;
        pos.y = Mathf.FloorToInt(y / 4f) * 4;
        pos.z = Mathf.FloorToInt(z / 4f) * 4;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Block GetBlock(float x, float y, float z)
    {
        Chunk containerChunk = GetChunk(Mathf.FloorToInt(x), Mathf.FloorToInt(y), Mathf.FloorToInt(z));
        if (containerChunk != null)
 
namespace BRE.Tests.InstrumentMatrixTest
    public partial class InstrumentMatrixViewer : Form
    {
        private List<InstrumentName> m_InstrumentNames;
        private int m_CellHeight = 50;
        private int m_CellWidth = 130;
        public bool IsShutDown = false;
        public InstrumentMatrixViewer()
        {
            InitializeComponent();
            this.dataGridViewInstrumentMatrix.DataBindingComplete += new DataGridViewBindingCompleteEventHandler(DataGridViewInstrumentMatrix_DataBindingComplete);
        }
        private void DataGridViewInstrumentMatrix_DataBindingComplete(object sender, DataGridViewBindingCompleteEventArgs e)
        {
            int instrumentCount = m_InstrumentNames.Count;
            for (int index = 0; index < instrumentCount; ++index)
            {
                DataGridViewRow dataGridViewRow = this.dataGridViewInstrumentMatrix.Rows[index];
                dataGridViewRow.Height = m_CellHeight;
                string instrumentNameSt

                dataGridViewRow.HeaderCell.Value = instrumentNameString;
            }
        }
        public void ShowInstrumentMatrix(List<InstrumentName> instrumentNames, InstrumentMatrix instrumentMatrix)
        {
            this.m_InstrumentNames = instrumentNames;
            DataTable dataTable = new DataTable("InstrumentMatrix");
            int instrumentCount = instrumentNames.Count;
            for (int index = 0; index < instrumentCount; ++index)
            {
                string instrumentNameString = instrumentNames[index].FullName;
                dataTable.Columns.Add(instrumentNameString, typeof(string));
            }
            for (int index = 0; index < instrumentCount; ++index)
            {
                dataTable.Rows.Add(new object[instrumentCount]);
            }
            this.dataGridViewInstrumentMatrix.SuspendLayout();
            this.dataGridViewInstrumentMatrix.ColumnHeadersHeight = m_CellHeight;
            this.dataGridViewInstrumentMatri

            for (int xIndex = 0; xIndex < instrumentCount; ++xIndex)
            {
                for (int yIndex = 0; yIndex < instrumentCount; ++yIndex)
                {
                    InstrumentName quoteInstrument = instrumentNames[xIndex];
                    InstrumentName hedgeInstrument = instrumentNames[yIndex];
                    ResultingInstrument resultingInstrument;
                    if (instrumentMatrix.TryFindResultingInstrument(quoteInstrument, 0, hedgeInstrument, 0, out resultingInstrument))
                    {
                        dataTable.Rows[yIndex][xIndex] = resultingInstrument.ResultingInstrumentNameTT;
                    }
                }
            }
            foreach (DataGridViewColumn column in this.dataGridViewInstrumentMatrix.Columns)
            {
                column.Width = m_CellWidth;
                column.SortMode = DataGridViewColumnSortMode.NotSortable;
            }
            this.dataGridViewInstrumentMatrix.AutoResiz
namespace Curan.Common.FormalizedData.File.Riff.Wave
	public class RiffChunkListInfo : RiffChunkList
	{
		public const string TYPE = "INFO";
		public static readonly Dictionary<string,Type> bodyTypeDictionary;
		public static readonly Dictionary<string,Type> chunkTypeDictionary;
		public readonly RiffChunkIart iartBody;
		public readonly RiffChunkIcms icmsBody;
		public readonly RiffChunkIcmt icmtBody;
		public readonly RiffChunkIcop icopBody;
		public readonly RiffChunkIcrd icrdBody;
		public readonly RiffChunkIeng iengBody;
		public readonly RiffChunkIgnr ignrBody;
		public readonly RiffChunkIkey ikeyBody;
		public readonly RiffChunkInam inamBody;
		public readonly RiffChunkIprd iprdBody;
		public readonly RiffChunkIsbj isbjBody;
		public readonly RiffChunkIsft isftBody;
		public readonly RiffChunkIsrc isrcBody;
		public readonly RiffChunkItch itchBody;
		static RiffChunkListInfo()
		{
			chunkTypeDictionary = new Dictionary<string, Type>();
			chunkTypeDictionary.Add( RiffChunkIart.

			chunkTypeDictionary.Add( RiffChunkIcms.ID, typeof( RiffChunkIcms ) );
			chunkTypeDictionary.Add( RiffChunkIcmt.ID, typeof( RiffChunkIcmt ) );
			chunkTypeDictionary.Add( RiffChunkIcop.ID, typeof( RiffChunkIcop ) );
			chunkTypeDictionary.Add( RiffChunkIcrd.ID, typeof( RiffChunkIcrd ) );
			chunkTypeDictionary.Add( RiffChunkIeng.ID, typeof( RiffChunkIeng ) );
			chunkTypeDictionary.Add( RiffChunkIgnr.ID, typeof( RiffChunkIgnr ) );
			chunkTypeDictionary.Add( RiffChunkIkey.ID, typeof( RiffChunkIkey ) );
			chunkTypeDictionary.Add( RiffChunkInam.ID, typeof( RiffChunkInam ) );
			chunkTypeDictionary.Add( RiffChunkIprd.ID, typeof( RiffChunkIprd ) );
			chunkTypeDictionary.Add( RiffChunkIsbj.ID, typeof( RiffChunkIsbj ) );
			chunkTypeDictionary.Add( RiffChunkIsft.ID, typeof( RiffChunkIsft ) );
			chunkTypeDictionary.Add( RiffChunkIsrc.ID, typeof( RiffChunkIsrc ) );
			chunkTypeDictionary.Add( RiffChunkItch.ID, typeof( RiffChunkItch ) );
			bodyTypeDictionary = new Dictionary<string, Typ

		}
		public RiffChunkListInfo( string aId, UInt32 aSize, ByteArray aByteArray, RiffChunkList aParent )
			: base( chunkTypeDictionary, bodyTypeDictionary, aId, aSize, aByteArray, aParent )
		{
			type = TYPE;
			iartBody = ( RiffChunkIart )GetChunk( RiffChunkIart.ID );
			icmsBody = ( RiffChunkIcms )GetChunk( RiffChunkIcms.ID );
			icmtBody = ( RiffChunkIcmt )GetChunk( RiffChunkIcmt.ID );
			icopBody = ( RiffChunkIcop )GetChunk( RiffChunkIcop.ID );
			icrdBody = ( RiffChunkIcrd )GetChunk( RiffChunkIcrd.ID );
			iengBody = ( RiffChunkIeng )GetChunk( RiffChunkIeng.ID );
			ignrBody = ( RiffChunkIgnr )GetChunk( RiffChunkIgnr.ID );
			ikeyBody = ( RiffChunkIkey )GetChunk( RiffChunkIkey.ID );
			inamBody = ( RiffChunkInam )GetChunk( RiffChunkInam.ID );
			iprdBody = ( RiffChunkIprd )GetChunk( RiffChunkIprd.ID );
			isbjBody = ( RiffChunkIsbj )GetChunk( RiffChunkIsbj.ID );
			isftBody = ( RiffChunkIsft )GetChunk( RiffChunkIsft.ID );
			isrcBody = ( RiffChunkIsrc )GetChunk( RiffChunkIsrc.ID
﻿/* WorldManager.cs  
 * (c) 2017 Ritoban Roy-Chowdhury. All rights reserved 
 */
public class WorldManager : MonoBehaviour
    public GameObject ChunkPrefab;
    public Dictionary<WorldPos, Chunk> worldPosChunkMap = new Dictionary<WorldPos, Chunk>();
    public VoxelData StoneVoxel;
    public VoxelData AirVoxel;
    int numChunks = 8;
    #region Unity Methods
    private void Start()
    {
        for (int x = 0; x < numChunks; x++)
        {
            for (int y = 0; y < 1; y++)
            {
                for (int z = 0; z < numChunks; z++)
                {
                    CreateChunk(x * Chunk.CHUNK_SIZE, y * Chunk.CHUNK_SIZE, z * Chunk.CHUNK_SIZE);
                }
            }
        }
    }
    #endregion
    public void CreateChunk(int x, int y, int z)
    {
        GameObject chunkObj = Instantiate(
                ChunkPrefab,
                new Vector3(x, y, z),
                Quaternion.identity,
                this.transform
                )
             

        chunkObj.name = "Chunk " + x/Chunk.CHUNK_SIZE + " " + y/Chunk.CHUNK_SIZE + " " + z/Chunk.CHUNK_SIZE;
        Chunk chunk = new Chunk(
            this,
            chunkObj,
            new WorldPos(x, y, z)
            );
        worldPosChunkMap.Add(new WorldPos(x, y, z), chunk);
        for (int xi = 0; xi < Chunk.CHUNK_SIZE; xi++)
        {
            for (int yi = 0; yi < Chunk.CHUNK_SIZE; yi++)
            {
                for (int zi = 0; zi < Chunk.CHUNK_SIZE; zi++)
                {
                    if (yi <=
                        Mathf.PerlinNoise(
                            (float)(xi + x) / (Chunk.CHUNK_SIZE) * 0.3f + (float)Network.time / 4f,
                            (float)(zi + z) / (Chunk.CHUNK_SIZE) * 0.3f + (float)Network.time / 4f)
                        * Chunk.CHUNK_SIZE
                        )
                        SetVoxel(x + xi, y + yi, z + zi, new Voxel(xi, yi, zi, chunk, StoneVoxel));
                    else
                        S

                }
            }
        }
        chunk.CalculateMeshData();
        chunk.RenderChunk();
    }
    #region Utility Methods
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float chunkSize = Chunk.CHUNK_SIZE;
        pos.X = Mathf.FloorToInt(x / chunkSize) * Chunk.CHUNK_SIZE;
        pos.Y = Mathf.FloorToInt(y / chunkSize) * Chunk.CHUNK_SIZE;
        pos.Z = Mathf.FloorToInt(z / chunkSize) * Chunk.CHUNK_SIZE;
        Chunk containerChunk = null;
        worldPosChunkMap.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Voxel GetVoxel(int x, int y, int z)
    {
        Chunk chunk = GetChunk(x, y, z);
        if (chunk == null)  
            return new Voxel(x, y, z, null, AirVoxel);
        Voxel voxel = chunk.GetVoxel(x - chunk.WorldPos.X, y - chunk.WorldPos.Y, z - chunk.WorldPos.Z);
        return voxel;
    }
    public void SetVoxel(int x, int y, int z, Voxel voxel)
    {
       
namespace Devcat.Core.Memory
	public static class ChunkSegment<T>
	{
		internal static ChunkSegment<T>.ChunkSegmentContext Context
		{
			get
			{
				if (ChunkSegment<T>.context == null)
				{
					ChunkSegment<T>.context = new ChunkSegment<T>.ChunkSegmentContext();
				}
				return ChunkSegment<T>.context;
			}
		}
		public static int AllocationSize
		{
			get
			{
				return ChunkSegment<T>.allocationSize;
			}
			set
			{
				ChunkSegment<T>.allocationSize = value;
			}
		}
		public static ArraySegment<T> Get(int size)
		{
			return ChunkSegment<T>.Context.Get(size);
		}
		[ThreadStatic]
		private static ChunkSegment<T>.ChunkSegmentContext context;
		private static int allocationSize = 65512;
		internal class ChunkSegmentContext
		{
			public ChunkSegmentContext()
			{
				this.chunk = new T[ChunkSegment<T>.AllocationSize];
			}
			public ArraySegment<T> Get(int size)
			{
				if (size >= this.chunk.Length)
				{
					return new ArraySegment<T>(new T[size]);
				}
				if (this.inde
namespace midiKeyboarder
    public partial class instrumentPanel : UserControl
    {
        public instrumentPanel()
        {
            InitializeComponent();
        }
        public int instrumentID;
        public instrument myInstrument { get { return Form1.instruments[instrumentID]; } }
        public void setInstrument(int id)
        {
            instrumentID = id;
            tbIp.Text = Form1.instruments[instrumentID].ip;
            nudPort.Value = myInstrument.port;
            cbxType.SelectedIndex = (int)Form1.instruments[instrumentID].mytype;
        }
        private void cbPlay_CheckedChanged(object sender, EventArgs e)
        {
            if (cbPlay.Checked)
            {
                myInstrument.local = true;
                myInstrument.initKeyDriver();
                if (cbMboxServer.Checked)
                    myInstrument.setMultiboxDriver();
                    
            }
            else
            {
                myInstrument.stop();
      

        }
        private void cbRemote_CheckedChanged(object sender, EventArgs e)
        {
            if (cbRemote.Checked)
            {
                myInstrument.local = false;
                try
                {
                    Form1.instruments[instrumentID].connect();
                }
                catch (Exception exc)
                { cbRemote.Checked = false;
                System.Diagnostics.Trace.WriteLine(exc.ToString());
                }
            }
            else
                Form1.instruments[instrumentID].disconnect();
        }
        private void tbIp_TextChanged(object sender, EventArgs e)
        {
            Form1.instruments[instrumentID].ip = tbIp.Text;
        }
        private void nudPort_ValueChanged(object sender, EventArgs e)
        {
            Form1.instruments[instrumentID].port = (int)nudPort.Value;
        }
        private void cbxType_SelectedIndexChanged(object sender, EventArgs e)
        {
            Form1.instruments
namespace FactoryPattern
    class TypesOfVehicles
    {
        private readonly EFContext context;
        private Repository<Car> carRepository;
        private Repository<Motor> motorRepository;
        private Repository<Quad> quadRepository;
        public TypesOfVehicles()
        {
            context = new EFContext();
        }
        public Repository<Car> CarRepository
        {
            get
            {
                if (carRepository == null) carRepository = new Repository<Car>(context);
                return carRepository;
            }
        }
        public Repository<Motor> MotorRepository
        {
            get
            {
                if (motorRepository == null) motorRepository = new Repository<Motor>(context);
                return motorRepository;
            }
        }
        public Repository<Quad> QuadRepository
        {
            get
            {
                if (quadRepository == null) quadRepository = new Repository<Quad>(context
namespace Grabacr07.KanColleWrapper.Models.Raw
	public class kcsapi_battle
	{
		public int api_dock_id { get; set; }
		public api_opening_atack api_opening_atack;
		public api_hougeki1 api_hougeki1;
		public api_hougeki2 api_hougeki2;
		public api_hougeki3 api_hougeki3;
		public api_kouku api_kouku;
		public api_kouku2 api_kouku2;
		public api_raigeki api_raigeki;
		public int[] api_nowhps;
		public int[] api_nowhps_combined;
		public int[] api_maxhps_combined;
		public int[] api_escape_idx;
		public int[] api_escape_idx_combined;
		public int[] api_ship_ke;
		public int[] api_ship_lv;
		public int api_support_flag;
		public api_support_info api_support_info;
	}
	public class api_support_info
	{
		public api_support_hourai api_support_hourai;
		public api_support_airatack api_support_airatack;
	}
	public class api_support_hourai
	{
		public int api_deck_id;
		public int[] api_ship_id;
		public int[] api_undressing_flag;
		public int[] api_cl_list;
		public decimal[] api_damage;
	}
	pub

	{
		public int api_deck_id;
		public int[] api_ship_id;
		public int[] api_undressing_flag;
		public int[] api_stage_flag;
		public object[] api_plane_from;
		public api_stage3 api_stage3;
	}
	public class kcsapi_midnight_battle
	{
		public int api_deck_id { get; set; }
		public api_hougeki api_hougeki;
		public api_stage3 api_stage3;
		public int[] api_nowhps;
		public int[] api_nowhps_combined;
		public int[] api_maxhps_combined;
		public int[] api_ship_ke;
		public int[] api_ship_lv;
	}
	public class api_hougeki
	{
		public object[] api_damage;
		public object[] api_df_list;
	}
	public class api_hougeki1
	{
		public object[] api_damage;
		public object[] api_df_list;
	}
	public class api_hougeki2
	{
		public object[] api_damage;
		public object[] api_df_list;
	}
	public class api_hougeki3
	{
		public object[] api_damage;
		public object[] api_df_list;
	}
	public class api_raigeki
	{
		public decimal[] api_eydam;
		public int[] api_erai;
		public decimal[] api_fydam;
		public int[]
namespace UnityMesh
    public sealed class FileConfig
    {
        private readonly Dictionary<ushort, Chunk> _chunks = new Dictionary<ushort, Chunk>();
        public static FileConfig DefaultConfig()
        {
            var defConfig = new FileConfig();
            defConfig.RegisterChunk<VerticesChunk>();
            defConfig.RegisterChunk<UVsChunk>();
            defConfig.RegisterChunk<SubMeshChunk>();
            defConfig.RegisterChunk<NormalsChunk>();
            defConfig.RegisterChunk<TangentsChunk>();
            defConfig.RegisterChunk<BoneWeightsChunk>();
            defConfig.RegisterChunk<BindPosesChunk>();
            return defConfig;
        }
        internal IEnumerable<Chunk> Chunks
        {
            get { return _chunks.Values; }
        }
        public TChunk RegisterChunk<TChunk>() where TChunk : Chunk, new()
        {
            var nChunk = new TChunk();
            _chunks[nChunk.InternalChunkID] = nChunk;
            return nChunk;
        }
     
namespace OpenQuant.API.Engine
	public class InstrumentList : IEnumerable
	{
		private Dictionary<string, Instrument> instruments;
		public int Count
		{
			get
			{
				return this.instruments.Count;
			}
		}
		public Instrument this[string symbol]
		{
			get
			{
				return this.instruments[symbol];
			}
		}
		internal InstrumentList()
		{
			this.instruments = new Dictionary<string, Instrument>();
		}
		public IEnumerator GetEnumerator()
		{
			return this.instruments.Values.GetEnumerator();
		}
		public bool Contains(string name)
		{
			return this.instruments.ContainsKey(name);
		}
		public bool TryGetValue(string name, out Instrument instrument)
		{
			return this.instruments.TryGetValue(name, out instrument);
		}
		public void Add(Instrument instrument)
		{
			this.instruments.Add(instrument.Symbol, instrument);
		}
		public void Add(string symbol)
		{
			this.Add(InstrumentManager.Instruments[symbol]);
		}
		public void Clear()
		{
			this.instruments.Clear();
		}
		public void
namespace MvvmLight2.Model
    public partial class TeachingLoad 
    {
        partial void OnLectureChanged()
        {
            TeachingLoad load = this;
            if (load != null)
            {
                SetTotalDisciplineLoad(load);
                Messenger.Default.Send<TeachingLoad, LoadChairViewModel>(this);
            }
        }
        partial void OnLaboratoryWorkChanged()
        {
            TeachingLoad load = this;
            if (load != null)
            {
                SetTotalDisciplineLoad(load);
                Messenger.Default.Send<TeachingLoad, LoadChairViewModel>(this);
            }
        }
        partial void OnPracticalExercisesChanged()
        {
            TeachingLoad load = this;
            if (load != null)
            {
                SetTotalDisciplineLoad(load);
                Messenger.Default.Send<TeachingLoad, LoadChairViewModel>(this);
            }
        }
        partial void OnStreamChanged()
        {
            Mes

        }
       
        private static void SetTotalDisciplineLoad(TeachingLoad load)
        {
            load.SumLoad = 0;
            if (load.Lecture != null)
                load.SumLoad += load.Lecture;
            if (load.Consultation != null)
                load.SumLoad += load.Consultation;
            if (load.ControlWork != null)
                load.SumLoad += load.ControlWork;
            if (load.CourseProject != null) 
                load.SumLoad += load.CourseProject;
            if (load.CourseWorkt != null) 
                load.SumLoad += load.CourseWorkt;
            if (load.LaboratoryWork != null) 
                load.SumLoad += load.LaboratoryWork;
            if (load.PracticalExercises != null) 
                load.SumLoad += load.PracticalExercises;
            if (load.Examination != null) 
                load.SumLoad += load.Examination;
            if (load.SetOff != null) 
                load.SumLoad += load.SetOff;
            if (load.Gac != n
﻿namespace Allors.Web
    public class InvokeResponseBuilder
    {
        private readonly ISession session;
        private readonly InvokeRequest invokeRequest;
        private string @group;
        private User user;
        public InvokeResponseBuilder(ISession session, User user, InvokeRequest invokeRequest, string @group)
        {
            this.session = session;
            this.user = user;
            this.invokeRequest = invokeRequest;
            this.group = group;
        }
        public InvokeResponse Build()
        {
            if (this.invokeRequest.M == null || this.invokeRequest.I == null || this.invokeRequest.V == null)
            {
                throw new ArgumentException();
            }
            var obj = this.session.Instantiate(this.invokeRequest.I);
            var composite = (Composite)obj.Strategy.Class;
            var methodTypes = composite.MethodTypesByGroup[@group];
            var methodType = methodTypes.FirstOrDefault(x => x.Name.Equa

            if (methodType == null)
            {
                throw new Exception("Method " + this.invokeRequest.M + " not found.");   
            }
            
            var invokeResponse = new InvokeResponse();
            if (!this.invokeRequest.V.Equals(obj.Strategy.ObjectVersion.ToString()))
            {
                invokeResponse.AddVersionError(obj);
            }
            else
            {
                var acl = new AccessControlList(obj, this.user);
                if (acl.CanExecute(methodType))
                {
                    var method = obj.GetType().GetMethod(methodType.Name, new Type[] { });
                    try
                    {
                        method.Invoke(obj, null);
                    }
                    catch (Exception e)
                    {
                        var innerException = e;
                        while (innerException.InnerException != null)
                        {
                            innerE
namespace CodeAndPlay.Data
    public class UnitOfWork : IUnitOfWork
    {
        #region Attributes
        private bool disposed;
        private SymposiumContext context;
        private IEntityRepository<Attendance> attendanceRepository;
        private IEntityRepository<Event> eventRepository;
        private IEntityRepository<Organizer> organizerRepository;
        private IEntityRepository<Requirement> requirementRepository;
        private IEntityRepository<Role> roleRepository;
        private IEntityRepository<Rule> ruleRepository;
        private IEntityRepository<School> schoolRepository;
        private IEntityRepository<Sponsor> sponsorRepository;
        private IEntityRepository<Student> studentRepository;
        private IEntityRepository<Talk> talkRepository;
        private IEntityRepository<TeamMember> teamMemberRepository;
        private IEntityRepository<Team> teamRepository;
        private IEntityRepository<Ticket> ticketRepository;
        private IEntityRepo

        #endregion
        #region Repositories
        public IEntityRepository<Attendance> AttendanceRepository
        {
            get { return attendanceRepository ?? (attendanceRepository = new GenericRepository<SymposiumContext, Attendance>(context)); }
        }
        public IEntityRepository<Event> EventRepository
        {
            get { return eventRepository ?? (eventRepository = new GenericRepository<SymposiumContext, Event>(context)); }
        }
        public IEntityRepository<Organizer> OrganizerRepository
        {
            get { return organizerRepository ?? (organizerRepository = new GenericRepository<SymposiumContext, Organizer>(context)); }
        }
        public IEntityRepository<Requirement> RequirementRepository
        {
            get { return requirementRepository ?? (requirementRepository = new GenericRepository<SymposiumContext, Requirement>(context)); }
        }
        public IEntityRepository<Role> RoleRepository
        {
            get 

        }
        public IEntityRepository<Rule> RuleRepository
        {
            get { return ruleRepository ?? (ruleRepository = new GenericRepository<SymposiumContext, Rule>(context)); }
        }
        public IEntityRepository<School> SchoolRepository
        {
            get { return schoolRepository ?? (schoolRepository = new GenericRepository<SymposiumContext, School>(context)); }
        }
        public IEntityRepository<Sponsor> SponsorRepository
        {
            get { return sponsorRepository ?? (sponsorRepository = new GenericRepository<SymposiumContext, Sponsor>(context)); }
        }
        public IEntityRepository<Student> StudentRepository
        {
            get { return studentRepository ?? (studentRepository = new GenericRepository<SymposiumContext, Student>(context)); }
        }
        public IEntityRepository<Talk> TalkRepository
        {
            get { return talkRepository ?? (talkRepository = new GenericRepository<SymposiumContext, Talk>(co
namespace Sketcher.Core
    public class GraphPortChunkEncoder : GraphPortDelegate
    {
        public delegate void ChunkEncodedHandler(BufferChunk chunk);
        public event ChunkEncodedHandler ChunkEncodedEvent;
        void SendCommand(BufferChunk aCommand)
        {
            if (ChunkEncodedEvent != null)
                ChunkEncodedEvent(aCommand);
        }
        public override void SetTextColor(uint colorref)
        {
            BufferChunk chunk = new BufferChunk(128);
            chunk += GDI32.EMR_SETTEXTCOLOR;
            chunk += colorref;
            SendCommand(chunk);
        }
        public override void SaveState()
        {
            BufferChunk chunk = new BufferChunk(128);
            chunk += GDI32.EMR_SAVEDC;
            SendCommand(chunk);
        }
        public override void SetPixel(int x, int y, Color colorref)
        {
            BufferChunk chunk = new BufferChunk(128);
            chunk += GDI32.EMR_SETTEXTCOLOR;
            ChunkUtils.Pa

            chunk += colorref.ToArgb();
            SendCommand(chunk);
        }
        public override void SetPen(IPen aPen)
        {
            SelectUniqueObject(aPen.UniqueID);
        }
        public override void SelectUniqueObject(Guid objectID)
        {
            BufferChunk chunk = new BufferChunk(128);
            chunk += GDI32.EMR_SELECTUNIQUEOBJECT;
            chunk += objectID.ToByteArray();
            SendCommand(chunk);
        }
        public override void DrawRoundRect(IPen aPen, Rectangle rect, int xRadius, int yRadius)
        {
            BufferChunk chunk = new BufferChunk(128);
            chunk += GDI32.EMR_ROUNDRECT;
            ChunkUtils.Pack(chunk, rect.X, rect.Y, rect.Width, rect.Height);
            ChunkUtils.Pack(chunk, xRadius, yRadius);
            ChunkUtils.Pack(chunk, aPen);
            SendCommand(chunk);
        }
        public override void DrawRectangle(IPen aPen, Rectangle rect)
        {
            BufferChunk chunk = new Buffe

            chunk += GDI32.EMR_RECTANGLE;
            ChunkUtils.Pack(chunk, rect.X, rect.Y, rect.Width, rect.Height);
            ChunkUtils.Pack(chunk, aPen);
            SendCommand(chunk);
        }
        public override void DrawEllipse(IPen aPen, Rectangle rect)
        {
            BufferChunk chunk = new BufferChunk(128);
            chunk += GDI32.EMR_ELLIPSE;
            ChunkUtils.Pack(chunk, rect.X, rect.Y, rect.Width, rect.Height);
            SendCommand(chunk);
        }
        public override void DrawString(int x, int y, string aString)
        {
            BufferChunk chunk = new BufferChunk(128);
            chunk += GDI32.EMR_EXTTEXTOUTW;
            ChunkUtils.Pack(chunk, x, y);
            chunk += aString.Length;
            chunk += aString;
            SendCommand(chunk);
        }
        public override void DrawLine(IPen aPen, Point startPoint, Point endPoint)
        {
            BufferChunk chunk = new BufferChunk(1024);
            chunk += GDI32.E
namespace DataRepository
    public class Repository : IDataRepository
    {
        private LabnetCommunicationEntities myDb;
        public LabnetCommunicationEntities Context { get { return myDb; } }
        public Repository()
        {
            myDb = new LabnetCommunicationEntities();
        }
        public List<Instrument> GetInstruments()
        {
            List<Instrument> lstInstruments = new List<Instrument>();
            try
            {
                lstInstruments = (from _ins in myDb.Instruments where _ins.IsActive select _ins).ToList();
                
            }
            catch (Exception ex)
            {
                Console.WriteLine((ex.InnerException).Message);
            }
            return lstInstruments;
        }
        public int GetTestIdByInstrumentAndTestCode(int instrumentId, string testCode)
        {
            try
            {
                List<GetTestIdByInstrumentAndInstrumentTestCode_Result> lst = myDb.GetTestIdByInstrum

                if (lst.Count > 0)
                    return lst[0].TestId;
            }
            catch (Exception ex)
            {
                Console.WriteLine((ex.InnerException).Message);
            }
            return 0;
        }
        public bool InstrumentResult(string orderNumber, int testId, string value, string instrumentPatient, int instrumentId)
        {
            try
            {
                myDb.InstrumentResult(orderNumber, testId, value, instrumentPatient, instrumentId);
                return true;
            }
            catch (Exception ex)
            {
                Console.WriteLine((ex.InnerException).Message);
            }
            return false;
        }
        public List<InstrumentResult> GetAllValidInstrumentResultByCondition(DateTime? receivedDate, string orderNumber, int? instrumentId)
        {
            try
            {
                List<InstrumentResult> lstInstrumentResults = (from _insResult in myDb.InstrumentRes

                                                               where _insResult.Flag == false
                                                                 && _insResult.ReceivedDate == receivedDate
                                                                 && (orderNumber == null || _insResult.OrderNumber == orderNumber)
                                                                 && (instrumentId == null || _insResult.InstrumentId == instrumentId)
                                                               select _insResult).ToList();
                return lstInstrumentResults;
            }
            catch (Exception ex)
            {
                Console.WriteLine((ex.InnerException).Message);
            }
            return new List<InstrumentResult>();
        }
        public bool InsertToResult(int? orderNumber, DateTime? receivedDate, int? testId, string value, int? instrumentResultId)
        {
            try
            {
                myDb.Result(
namespace Observer.Rebuild
    internal sealed class InstrumentCollection : IList<Instrument>
    {
        private List<Instrument> instrumentCollection = new List<Instrument>();
        private List<int> pertinentContracts = new List<int>();
        private DateTime previousCallTime;
        public InstrumentCollection(string directoryPath)
        {
            PopulateCollection(directoryPath);
        }
        private void PopulateCollection(string directoryPath)
        {
            foreach (string file in Directory.GetFiles(directoryPath))
            {
                instrumentCollection.Add(new Instrument(file));
            }
        }
        public List<int> PertinentContracts(DateTime currentTime)
        {
            if (currentTime.IsWithinCacheRangeOf(previousCallTime))
                return pertinentContracts;
            pertinentContracts.Clear();
            foreach (Instrument instrument in instrumentCollection)
            {
                foreach (int contr

                {
                    pertinentContracts.Add(contract);
                }
            }
            previousCallTime = currentTime;
            return pertinentContracts;
        }
        public int IndexOf(Instrument item)
        {
            return instrumentCollection.IndexOf(item);
        }
        public void Insert(int index, Instrument item)
        {
            instrumentCollection.Insert(index, item);
        }
        public void RemoveAt(int index)
        {
            instrumentCollection.RemoveAt(index);
        }
        public Instrument this[int index]
        {
            get
            {
                return instrumentCollection[index];
            }
            set
            {
                instrumentCollection[index] = value;
            }
        }
        public void Add(Instrument item)
        {
            bool containsInstrument = false;
            foreach (Instrument instrument in instrumentCollection)
            {
           

                {
                    containsInstrument = true;
                    break;
                }
            }
            if (containsInstrument)
                throw new SystemException("EXCEPTION: InstrumentCollection already contains instrument \"" + item.Name + "\".");
            else
                instrumentCollection.Add(item);
        }
        public void Clear()
        {
            instrumentCollection.Clear();
        }
        public bool Contains(Instrument item)
        {
            return instrumentCollection.Contains(item);
        }
        public void CopyTo(Instrument[] array, int arrayIndex)
        {
            instrumentCollection.CopyTo(array, arrayIndex);
        }
        public int Count
        {
            get { return instrumentCollection.Count; }
        }
        public bool IsReadOnly
        {
            get { return ((IList<Instrument>)instrumentCollection).IsReadOnly; }
        }
        public bool Remove(Instrument item)
    
namespace SystemController.InstrumentBLL
    internal sealed class CheckPoint : IComparable<CheckPoint>
    {
        private Guid _instrumentId;
        private DateTime _checkTime;
        private InstrumentStatus _status;
        internal CheckPoint(Guid instrumentId, DateTime checkTime, InstrumentStatus status, DateTime tradeDay)
        {
            _instrumentId = instrumentId;
            _checkTime = checkTime;
            _status = status;
            this.TradeDay = tradeDay;
        }
        internal Guid InstrumentId
        {
            get { return _instrumentId; }
        }
        internal DateTime CheckTime
        {
            get { return _checkTime; }
        }
        internal InstrumentStatus Status
        {
            get { return _status; }
        }
        internal DateTime TradeDay
        {
            get;
            private set;
        }
        public int CompareTo(CheckPoint other)
        {
            return this.CheckTime.CompareTo(other.Check

        }
        public override string ToString()
        {
            return string.Format("instrumentId = {0}, checkTime = {1}, status = {2}, tradeDay = {3}", this.InstrumentId, this.CheckTime, this.Status, this.TradeDay);
        }
    }
    internal struct InstrumentCheckTimeKey : IEquatable<InstrumentCheckTimeKey>
    {
        private Guid _id;
        private DateTime _checkTime;
        internal InstrumentCheckTimeKey(Guid id, DateTime checkTime)
        {
            _id = id;
            _checkTime = checkTime;
        }
        internal Guid Id
        {
            get { return _id; }
        }
        internal DateTime CheckTime
        {
            get { return _checkTime; }
        }
        public bool Equals(InstrumentCheckTimeKey other)
        {
            return this.Id == other.Id && this.CheckTime == other.CheckTime;
        }
        public override bool Equals(object obj)
        {
            return this.Equals((InstrumentCheckTimeKey)obj);
        }
    

        {
            return this.Id.GetHashCode() ^ this.CheckTime.GetHashCode();
        }
    }
    public sealed class Manager
    {
        public static readonly Manager Default = new Manager();
        private static readonly TimeCheckPointComparer TimeCheckComparer = new TimeCheckPointComparer();
        private static readonly ILog Logger = LogManager.GetLogger(typeof(Manager));
        private Protocal.Common.Heap<CheckPoint> _checkPointHeap = new Protocal.Common.Heap<CheckPoint>();
        private HashSet<InstrumentCheckTimeKey> _loadedInstrumentCheckPoints = new HashSet<InstrumentCheckTimeKey>();
        private object _mutex = new object();
        static Manager() { }
        private Manager()
        {
            new Thread(this.TimePointCheckHandle)
            {
                IsBackground = true
            }.Start();
        }
        internal void LoadInstrumentTradingTimeFromDB()
        {
            lock (_mutex)
            {
                var tradingParams
namespace mtm.Store.Repository
   public class IStoreRepository
   {
       private DepartmentRepository _DepartmentRepository;
       public DepartmentRepository department
       {
           get
           {
               if (_DepartmentRepository == null)
                   _DepartmentRepository = new DepartmentRepository();
               return _DepartmentRepository;
           }
       }
       private ProductRepository _ProductRepository;
       public ProductRepository product
       {
           get
           {
               if (_ProductRepository == null)
                   _ProductRepository = new ProductRepository();
               return _ProductRepository;
           }
       }
       private ProducerRepository _ProducerRepository;
       public ProducerRepository producer
       {
           get
           {
               if (_ProducerRepository == null)
                   _ProducerRepository = new ProducerRepository();
               return _ProducerRepository;
   

       }
       private FileRepository _FileRepository;
       public FileRepository file
       {
           get
           {
               if (_FileRepository == null)
                   _FileRepository = new FileRepository();
               return _FileRepository;
           }
       }
       private OrderRepository _OrderRepository;
       public OrderRepository order
       {
           get
           {
               if (_OrderRepository == null)
                   _OrderRepository = new OrderRepository();
               return _OrderRepository;
           }
       }
       private ManagerOrderRepository _ManagerOrderRepository;
       public ManagerOrderRepository managerorder
       {
           get
           {
               if (_ManagerOrderRepository == null)
                   _ManagerOrderRepository = new ManagerOrderRepository();
               return _ManagerOrderRepository;
           }
       }
       private SellerRepository _SellerRepository;
       public SellerR
namespace Rental.Repository
    public class UnitOfWork
    {
        private RentalEntities _edm = null;
        private SliderRepository _sliderRepository = null;
        private RoomRepository _roomRepository = null;
        private AreaRepository _areaRepository = null;
        private ServiceRepository _serviceRepository = null;
        private FoodRepository _foodRepository = null;
        private PreferenceRepository _preferenceRepository = null;
        private AboutRepository _aboutRepository = null;
        private UserRepository _userRepository = null;
        private ArrivalRepository _arrivalRepository = null;
        public UnitOfWork()
        {
            _edm = new RentalEntities();
        }
        public ArrivalRepository ArrivalRepository
        {
            get
            {
                if (_arrivalRepository == null)
                {
                    _arrivalRepository = new ArrivalRepository(_edm);
                }
                return _arrivalRepo

            }
        }
        public UserRepository UserRepository
        {
            get
            {
                if (_userRepository == null)
                {
                    _userRepository = new UserRepository(_edm);
                }
                return _userRepository;
            }
        }
        public AboutRepository AboutRepository
        {
            get
            {
                if (_aboutRepository == null)
                {
                    _aboutRepository = new AboutRepository(_edm);
                }
                return _aboutRepository;
            }
        }
        public PreferenceRepository PreferenceRepository
        {
            get
            {
                if (_preferenceRepository == null)
                {
                    _preferenceRepository = new PreferenceRepository(_edm);
                }
                return _preferenceRepository;
            }
        }
        public ServiceRepository ServiceRepository


            get
            {
                if (_serviceRepository == null)
                {
                    _serviceRepository = new ServiceRepository(_edm);
                }
                return _serviceRepository;
            }
        }
        public FoodRepository FoodRepository
        {
            get
            {
                if (_foodRepository == null)
                {
                    _foodRepository = new FoodRepository(_edm);
                }
                return _foodRepository;
            }
        }
        public RoomRepository RoomRepository
        {
            get
            {
                if (_roomRepository == null)
                {
                    _roomRepository = new RoomRepository(_edm);
                }
                return _roomRepository;
            }
        }
        public AreaRepository AreaRepository
        {
            get
            {
                if (_areaRepository == null)
                {
            
public class SteamVR_ChangeControllerIndex : MonoBehaviour {
    public enum Controller_Type
    {
        RIGHT=0,
        LEFT=1,
        MAT=2,
        NONE=-1
    }
    private bool is_admit_change_device_index;
    public bool IsAdmitChangeDeviceIndex
    {
        set
        {
            foreach (SteamVR_TrackedObject c in controller)
                c.IsAdmitDevieIndexChange = value;
        }
    }
    public List<SteamVR_TrackedObject> controller;
    [SerializeField]
    private Controller_Type select_controller;
	void Start ()
    {
        select_controller = Controller_Type.NONE;
	}
	void Update ()
    {
		if(Input.GetKeyUp(KeyCode.F1))
        {
            if(select_controller != Controller_Type.NONE)
            {
                SteamVR_TrackedObject.EIndex index = controller[(int)select_controller].index;
                controller[(int)select_controller].index = controller[(int)Controller_Type.RIGHT].index;
                controller[(int)Controller_Type.RIGHT].ind

                select_controller = Controller_Type.NONE;
            }
            else select_controller = Controller_Type.RIGHT;
        }
        if (Input.GetKeyUp(KeyCode.F2))
        {
            if (select_controller != Controller_Type.NONE)
            {
                SteamVR_TrackedObject.EIndex index = controller[(int)select_controller].index;
                controller[(int)select_controller].index = controller[(int)Controller_Type.LEFT].index;
                controller[(int)Controller_Type.LEFT].index = index;
                select_controller = Controller_Type.NONE;
            }
            else select_controller = Controller_Type.LEFT;
        }
        if (Input.GetKeyUp(KeyCode.F3))
        {
            if (select_controller != Controller_Type.NONE)
            {
                SteamVR_TrackedObject.EIndex index = controller[(int)select_controller].index;
                controller[(int)select_controller].index = controller[(int)Controller_Type.MAT].index;
    
namespace Proxy
    internal class ChunkContentState : State
    {
        private Chunk chunk;
        private int size;
        public ChunkContentState(Chunk chunk)
        {
            this.chunk = chunk;
        }
        internal override void Handle(byte data, Action<State> state)
        {
            if (chunk.GetGetExpectedLength == 0)
            {
                chunk.ChangeState(new ChunkCompleteState(chunk));
            }
            else if (chunk.GetGetExpectedLength > size)
            {
                size++;
            }
            else if (chunk.GetGetExpectedLength == size)
            {
                if (data == '\r')
                {
                    return;
                }
                if (data == '\n')
                {
                    chunk.ResetLength();
                    chunk.ChangeState(new ChunkNumberOrCrState(chunk));
                }
                else
                {
                    throw new Exception("New line did not 
public class Map2D<I> {
	private List2D<Chunk2D<I>> chunks = new List2D<Chunk2D<I>>();
	private I defaultValue;
	public Map2D() {
		defaultValue = default(I);
	}
	public Map2D(I defaultValue) {
		this.defaultValue = defaultValue;
	}
	public void Set(I val, int x, int z) {
		Vector3i chunkPos = Chunk.ToChunkPosition(x, 0, z);
		Vector3i localPos = Chunk.ToLocalPosition(x, 0, z);
		Chunk2D<I> chunk = GetChunkInstance(chunkPos.x, chunkPos.z);
		chunk.Set(val, localPos.x, localPos.z);
	}
	public I Get(int x, int z) {
		Vector3i chunkPos = Chunk.ToChunkPosition(x, 0, z);
		Vector3i localPos = Chunk.ToLocalPosition(x, 0, z);
		Chunk2D<I> chunk = GetChunk(chunkPos.x, chunkPos.z);
		if(chunk != null) return chunk.Get(localPos.x, localPos.z);
		return defaultValue;
	}
	public Chunk2D<I> GetChunkInstance(int x, int z) {
		return chunks.GetInstance(x, z);
	}
	public Chunk2D<I> GetChunk(int x, int z) {
		return chunks.SafeGet(x, z);
	}
public class Chunk2D<I> {
	private I[,] chunk = new I[Chunk.SI
namespace JobSearchingSystem.DAL
    public class UnitOfWork : IDisposable
    {
        private JSSContext context = new JSSContext();
        /**
         * Single Table Repository
         */
        private GenericRepository<Administrator> administratorRepository;
        private GenericRepository<Advertise> advertiseRepository;
        private GenericRepository<AppliedJob> appliedJobRepository;
        private GenericRepository<AspNetRole> aspNetRoleRepository;
        private GenericRepository<AspNetUser> aspNetUserRepository;
        private GenericRepository<AspNetUserClaim> aspNetUserClaimRepository;
        private GenericRepository<AspNetUserLogin> aspNetUserLoginRepository;
        private GenericRepository<Benefit> benefitRepository;
        private GenericRepository<Category> categoryRepository;
        private GenericRepository<City> cityRepository;
        private GenericRepository<CompanyInfo> companyInfoRepository;
        private GenericRepository<CompanyInfoCity> co

        private GenericRepository<Contact> contactRepository;
        private GenericRepository<DesiredBenefit> desiredBenefitRepository;
        private GenericRepository<EducationHistory> educationHistoryRepository;
        private GenericRepository<EmploymentHistory> employmentHistoryRepository;
        private GenericRepository<ExpectedCategory> expectedCategoryRepository;
        private GenericRepository<ExpectedCity> expectedCityRepository;
        private GenericRepository<Job> jobRepository;
        private GenericRepository<JobBenefit> jobBenefitRepository;
        private GenericRepository<JobCategory> jobCategoryRepository;
        private GenericRepository<JobCity> jobCityRepository;
        private GenericRepository<JobLanguage> jobLanguageRepository;
        private GenericRepository<JobLevel> jobLevelRepository;
        private GenericRepository<JobPackage> jobPackageRepository;
        private GenericRepository<Jobseeker> jobseekerRepository;
        private GenericRe

        private GenericRepository<Language> languageRepository;
        private GenericRepository<Level> levelRepository;
        private GenericRepository<Manager> managerRepository;
        private GenericRepository<Message> messageRepository;
        private GenericRepository<MessageReceiver> messageReceiverRepository;
        private GenericRepository<OwnSkill> ownSkillRepository;
        private GenericRepository<Profile> profileRepository;
        private GenericRepository<PurchaseAdvertise> purchaseAdvertiseRepository;
        private GenericRepository<PurchaseJobPackage> purchaseJobPackageRepository;
        private GenericRepository<Recruiter> recruiterRepository;
        private GenericRepository<ReferencePerson> referencePersonRepository;
        private GenericRepository<Report> reportRepository;
        private GenericRepository<SchoolLevel> schoolLevelRepository;
        private GenericRepository<Skill> skillRepository;
        private GenericRepository<Staff> staffRepos
namespace Telerik.TeamPulse.Sdk.Common
    public static class ApiUrls
    {
        private static readonly string apiVersion = "v1";
        public static class Teams
        {
            public static string Post = "/api/" + apiVersion + "/teams";
            public static string Put = "/api/" + apiVersion + "/teams/{0}";
            public static string GetMany = "/api/" + apiVersion + "/projects/{0}/teams";
            public static string GetOne = "/api/" + apiVersion + "/teams/{0}";
            public static string Delete = "/api/" + apiVersion + "/teams/{0}";
        }
        public static class WorkItems
        {
            public static string Post = "/api/" + apiVersion + "/workitems";
            public static string Put = "/api/" + apiVersion + "/workitems/{0}";
            public static string GetMany = "/api/" + apiVersion + "/workitems";
            public static string GetOne = "/api/" + apiVersion + "/workitems/{0}";
            public static string Delete = "/api

        }
        public static class Links
        {
            public static string Post = "/api/" + apiVersion + "/links";
            public static string Put = "/api/" + apiVersion + "/links/{0}";
            public static string GetMany = "/api/" + apiVersion + "/links";
            public static string GetOne = "/api/" + apiVersion + "/links/{0}";
            public static string GetForWorkItem = "/api/" + apiVersion + "/workitems/{0}/links";
            public static string Delete = "/api/" + apiVersion + "/links/{0}";
        }
        public static class Comments
        {
            public static string Post = "/api/" + apiVersion + "/comments";
            public static string GetMany = "/api/" + apiVersion + "/comments";
            public static string GetOne = "/api/" + apiVersion + "/comments/{0}";
            public static string GetForWorkItem = "/api/" + apiVersion + "/workitems/{0}/comments";
            public static string Delete = "/api/" + apiVersion + "/comm

        }
        public static class Attachments
        {
            public static string Post = "/api/" + apiVersion + "/workitems/{0}/attachments";
            public static string Put = "/api/" + apiVersion + "/attachments/{0}";
            public static string GetMany = "/api/" + apiVersion + "/attachments";
            public static string GetOne = "/api/" + apiVersion + "/attachments/{0}";
            public static string GetForWorkItem = "/api/" + apiVersion + "/workitems/{0}/attachments";
            public static string GetForComment = "/api/" + apiVersion + "/comments/{0}/attachments";
            public static string Delete = "/api/" + apiVersion + "/attachments/{0}";
        }
        public static class Areas
        {
            public static string Post = "/api/" + apiVersion + "/areas";
            public static string Put = "/api/" + apiVersion + "/areas/{0}";
            public static string GetMany = "/api/" + apiVersion + "/areas";
            public static str
namespace Assets.components {
    [RequireComponent(typeof(VoxelGeometryDrawer))]
    public class VoxelWorld : MonoBehaviour {
        public int chunkSize;
        private SpatialHash _chunkBasket;
        void Awake() {
            this._chunkBasket = new SpatialHash(this);
        }
        public VoxelWorldChunk getChunkAt(int x, int y, int z){
            Vector3 chunkAABBOrigin = this.getGlobalAABBCoordinates(x, y, z);
            VoxelWorldChunk chunk = null ;
            if (this._chunkBasket.hasChunkAt(chunkAABBOrigin)) {
                chunk = this._chunkBasket.getChunkAt(chunkAABBOrigin);
            } else {
                GameObject chunkAnchor = new GameObject("WorldChunk");
                float semiChunkSize = ((float)this.chunkSize) / 2;
                chunkAnchor.transform.parent = this.transform;
                chunkAnchor.isStatic = true;
                chunk = chunkAnchor.AddComponent<VoxelWorldChunk>() as VoxelWorldChunk;
                chunk.size = this.ch

                chunk.originX = (int)chunkAABBOrigin.x;
                chunk.originY = (int)chunkAABBOrigin.y;
                chunk.originZ = (int)chunkAABBOrigin.z;
                chunk.transform.position = new Vector3(x, y, z);
                this._chunkBasket.addChunkAt(chunk, chunkAABBOrigin);
            }
            return chunk;
        }
        public void addVoxelAt(Voxel voxel, int x, int y, int z) {
            Vector3 chunkAABBOffset = this.getLocalAABBCoordinates(x, y, z);
            VoxelWorldChunk chunk = this.getChunkAt(x, y, z);
            
            int localX = (int)chunkAABBOffset.x;
            int localY = (int)chunkAABBOffset.y;
            int localZ = (int)chunkAABBOffset.z;
            if (!chunk.hasVoxelAt(localX, localY, localZ)) {
                chunk.addVoxelAt(voxel, localX, localY, localZ);
            }
        }
        public void removeVoxelAt(int x, int y, int z) {
            Vector3 chunkAABBOrigin = this.getGlobalAABBCoordinates(x, y,

            Vector3 chunkAABBOffset = this.getLocalAABBCoordinates(x, y, z);
            if (this._chunkBasket.hasChunkAt(chunkAABBOrigin)) {
                VoxelWorldChunk chunk = this._chunkBasket.getChunkAt(chunkAABBOrigin);
                chunk.removeVoxelAt((int)chunkAABBOffset.x, (int)chunkAABBOffset.y, (int)chunkAABBOffset.z);
                if (chunk.count == 0) {
                    chunk.transform.parent = null;
                    this._chunkBasket.removeChunkAt(chunkAABBOrigin);
                } else {
                    chunk.update();
                }
            }
        }
        public bool hasVoxelAt(int x, int y, int z) {
            bool retval = false;
            Vector3 chunkAABBOrigin = this.getGlobalAABBCoordinates(x, y, z);
            Vector3 chunkAABBOffset = this.getLocalAABBCoordinates(x, y, z);
            if (this._chunkBasket.hasChunkAt(chunkAABBOrigin)) {
                VoxelWorldChunk chunk = this._chunkBasket.getChunkAt(chunkAABBOrigin);
   
namespace Test
    class ProcessCreatHelper
    {
        public static List<ProcessProcessModel> createProcess(int pid, int bid, List<string> liuchengren)
        {
            List<ProcessProcessModel> lprocess = new List<ProcessProcessModel>();
            int order = 0;
            foreach (string renyuan in liuchengren)
            {
                ProcessProcessModel process = new ProcessProcessModel();
                process.Pid = pid;
                process.Bid = bid;
                process.Order = order;
                if (process.Order == 0)
                {
                    process.Handler = "发起人";
                    process.Nexthandler = renyuan;
                    process.Lasthandler = ProcessState.BEGIN.ToString();
                    process.State = ProcessState.FINISH;
                }
                else if (liuchengren.IndexOf(renyuan) == liuchengren.Count - 1)
                {
                    process.Handler = renyuan;
                    process.Ne
namespace Operations
    public class Operations : IOperations
    {
        private IBlobRepository _blobRepository;
        private IAzureCache _azureCache;
        public Operations(IBlobRepository BlobRepository, IAzureCache AzureCache)
        {
            _blobRepository = BlobRepository;
            _azureCache = AzureCache;
        }
        public void UploadChunk(FileChunk chunk)
        {
            {
                _blobRepository.UploadBlock(chunk.FileId, chunk.ChunkId, stream);
                SmallChunk smallChunk = new SmallChunk() { ChunkId = chunk.ChunkId, OriginalChunkId = chunk.OriginalChunkId };
                _azureCache.PutItem(new CacheItem() { FileId = chunk.FileId, Item = smallChunk });
            }
        }
        public void CommitChunks(FileChunk chunk)
        {
            List<CacheItem> cacheItems = _azureCache.GetItems(chunk.FileId);
            Dictionary<string, string> blockIds = cacheItems.Select(p => (SmallChunk)p.Item)
                    
public class ChunkStore
    public ChunkStore(IChunkGenerator generator, Material material, Transform parentTransform)
    {
        this.material = material;
        this.parentTransform = parentTransform;
        this.generator = generator;
    }
    
    public const int MaxChunks = 512;
    
    Transform parentTransform;
    Material material;
    Dictionary<int, Chunk> chunks = new Dictionary<int, Chunk>();
    IChunkGenerator generator;
    public int Mass { get { return chunks.Values.Sum(chunk => chunk.Mass); } }
    static int PositionHash(int x, int y, int z, out int cx, out int cy, out int cz)
    {
        cx = x >= 0 ? x / Chunk.BlockSize : (x - Chunk.BlockSize + 1) / Chunk.BlockSize; 
        cy = y >= 0 ? y / Chunk.BlockSize : (y - Chunk.BlockSize + 1) / Chunk.BlockSize; 
        cz = z >= 0 ? z / Chunk.BlockSize : (z - Chunk.BlockSize + 1) / Chunk.BlockSize;
        return ((cx - MaxChunks / 2) * MaxChunks * MaxChunks) + ((cy - MaxChunks / 2) * MaxChunks) + (cz - MaxChu

    }
    
    public Chunk Get(int x, int y, int z)
    {
        int cx, cy, cz;
        int hash = PositionHash(x, y, z, out cx, out cy, out cz);
        Chunk chunk;
        if (chunks.TryGetValue(hash, out chunk))
            return chunk;
        else
            return null;
    }
    
    public Chunk Add(int x, int y, int z)
    {
        if (Get(x, y, z) == null)
        {
            int cx, cy, cz;
            int hash = PositionHash(x, y, z, out cx, out cy, out cz);
            Chunk chunk = (Chunk)new GameObject("Chunk").AddComponent<Chunk>();
            chunk.transform.parent = parentTransform;
            chunk.transform.localPosition = Vector3.zero;
            chunk.transform.localRotation = Quaternion.identity;
            chunk.renderer.sharedMaterial = material;
            chunk.ChunkPos = new Point3D(cx, cy, cz);
            chunk.Generate(generator);
            chunks.Add(hash, chunk);
            return chunk;
        }
        else
        {
            ret
namespace Curan.Common.FormalizedData.File.Riff.Sfbk
	public class RiffChunkListPdta : RiffChunkList
	{
		public const string TYPE = "pdta";
		public static readonly Dictionary<string,Type> chunkTypeDictionary;
		public static readonly Dictionary<string,Type> bodyTypeDictionary;
		public RiffChunkPhdr phdrBody;
		public RiffChunkPbag pbagBody;
		public RiffChunkPmod pmodBody;
		public RiffChunkPgen pgenBody;
		public RiffChunkInst instBody;
		public RiffChunkIbag ibagBody;
		public RiffChunkImod imodBody;
		public RiffChunkIgen igenBody;
		public RiffChunkShdr shdrBody;
		static RiffChunkListPdta()
		{
			chunkTypeDictionary = new Dictionary<string, Type>();
			chunkTypeDictionary.Add( RiffChunkPhdr.ID, typeof( RiffChunkPhdr ) );
			chunkTypeDictionary.Add( RiffChunkPbag.ID, typeof( RiffChunkPbag ) );
			chunkTypeDictionary.Add( RiffChunkPmod.ID, typeof( RiffChunkPmod ) );
			chunkTypeDictionary.Add( RiffChunkPgen.ID, typeof( RiffChunkPgen ) );
			chunkTypeDictionary.Add( RiffChunkInst

			chunkTypeDictionary.Add( RiffChunkIbag.ID, typeof( RiffChunkIbag ) );
			chunkTypeDictionary.Add( RiffChunkImod.ID, typeof( RiffChunkImod ) );
			chunkTypeDictionary.Add( RiffChunkIgen.ID, typeof( RiffChunkIgen ) );
			chunkTypeDictionary.Add( RiffChunkShdr.ID, typeof( RiffChunkShdr ) );
			bodyTypeDictionary = new Dictionary<string, Type>();
		}
		public RiffChunkListPdta( string aId, UInt32 aSize, ByteArray aByteArray, RiffChunkList aParent )
			: base( chunkTypeDictionary, bodyTypeDictionary, aId, aSize, aByteArray, aParent )
		{
			type = TYPE;
			phdrBody = ( RiffChunkPhdr )GetChunk( RiffChunkPhdr.ID );
			pbagBody = ( RiffChunkPbag )GetChunk( RiffChunkPbag.ID );
			pmodBody = ( RiffChunkPmod )GetChunk( RiffChunkPmod.ID );
			pgenBody = ( RiffChunkPgen )GetChunk( RiffChunkPgen.ID );
			instBody = ( RiffChunkInst )GetChunk( RiffChunkInst.ID );
			ibagBody = ( RiffChunkIbag )GetChunk( RiffChunkIbag.ID );
			imodBody = ( RiffChunkImod )GetChunk( RiffChunkImod.ID );
			igenBody = 
namespace FarseerPhysics.Controllers
    [Flags]
    public enum ControllerType
    {
        GravityController = (1 << 0),
        VelocityLimitController = (1 << 1),
        AbstractForceController = (1 << 2)
    }
    public class FilterControllerData : FilterData
    {
        private ControllerType _type;
        public FilterControllerData(ControllerType type)
        {
            _type = type;
        }
        public override bool IsActiveOn(Body body)
        {
            if (body.ControllerFilter.IsControllerIgnored(_type))
                return false;
            return base.IsActiveOn(body);
        }
    }
    public class ControllerFilter
    {
        public ControllerType ControllerFlags;
        public void IgnoreController(ControllerType controller)
        {
            ControllerFlags |= controller;
        }
        public void RestoreController(ControllerType controller)
        {
            ControllerFlags &= ~controller;
        }
        public bool IsContr
public static class WorldSerializer {
	public static string defaultPath = Application.persistentDataPath + "/";
	public static string extension = ".chunk";
	public static void SerializeChunk(Chunk chunk, string worldName) {
		
		SerializedChunk serializedChunk = new SerializedChunk (chunk);
		WriteSerializedChunk(serializedChunk, worldName);
	} 
	public static void WriteSerializedChunk(SerializedChunk serializedChunk, string worldName) {
		System.IO.Directory.CreateDirectory (defaultPath + worldName);
		 
		BinaryFormatter binaryFormatter = new BinaryFormatter();
			binaryFormatter.Serialize (file, serializedChunk);
			file.Close (); 
		}
	}
	public static Chunk DeserializeChunk(Vector2 chunkPosition, string worldName) {
  
		GameObject chunkGameObject = (GameObject) GameObject.Instantiate (Resources.Load ("Prefabs/Chunk"), chunkPosition * PlayerPrefs.GetInt ("chunk_size"), Quaternion.identity);
		Chunk chunk = chunkGameObject.GetComponent<Chunk>();
		string path = defaultPath + worldN
namespace Proxii.Internal.Interceptors
    public class BeforeInvokeInterceptor : IInterceptor
    {
        private readonly Action _beforeInvoke;
        private readonly Action<MethodInfo> _beforeInvokeMethodInfo;
        private readonly Action<MethodInfo, object[]> _beforeInvokeMethodInfoArgs;
        public BeforeInvokeInterceptor(Action beforeInvoke)
        {
            _beforeInvoke = beforeInvoke;
        }
        public BeforeInvokeInterceptor(Action<MethodInfo> beforeInvoke)
        {
            _beforeInvokeMethodInfo = beforeInvoke;
        }
        public BeforeInvokeInterceptor(Action<MethodInfo, object[]> beforeInvoke)
        {
            _beforeInvokeMethodInfoArgs = beforeInvoke;
        }
        public void Intercept(IInvocation invocation)
        {
            if (_beforeInvoke != null)
                _beforeInvoke();
            else if (_beforeInvokeMethodInfo != null)
                _beforeInvokeMethodInfo(invocation.Method);
            else
         
namespace Surya.India.Service
    public interface IDispatchWaybillLineService : IDisposable
    {
        DispatchWaybillLine Create(DispatchWaybillLine s);
        void Delete(int id);
        void Delete(DispatchWaybillLine s);
        void Update(DispatchWaybillLine s);
        void DeleteForDispatchWaybillHeaderId(int DispatchWaybillHeaderid);
        IQueryable<DispatchWaybillLine> GetDispatchWaybillLineList();
        IQueryable<DispatchWaybillLine> GetDispatchWaybillLineForHeaderId(int DispatchWaybillHeaderId);
        DispatchWaybillLine GetDispatchWaybillLineForLineId(int DispatchWaybillLineId);
        DispatchWaybillLineViewModel GetDispatchWaybillLineViewModelForLineId(int DispatchWaybillLineId);
        IQueryable<DispatchWaybillLineViewModel> GetDispatchWaybillLineViewModelForHeaderId(int DispatchWaybillHeaderId);
    }
    public class DispatchWaybillLineService : IDispatchWaybillLineService
    {
        ApplicationDbContext db = new ApplicationDbContext();
        pri

        public DispatchWaybillLineService(IUnitOfWorkForService unitOfWork)
        {
            _unitOfWork = unitOfWork;
        }
        public void Dispose()
        {
        }
        public DispatchWaybillLine Create(DispatchWaybillLine S)
        {
            S.ObjectState = ObjectState.Added;
            _unitOfWork.Repository<DispatchWaybillLine>().Insert(S);
            return S;
        }
        public void Delete(int id)
        {
            _unitOfWork.Repository<DispatchWaybillLine>().Delete(id);
        }
        public void Delete(DispatchWaybillLine s)
        {
            _unitOfWork.Repository<DispatchWaybillLine>().Delete(s);
        }
        public void DeleteForDispatchWaybillHeaderId(int DispatchWaybillHeaderid)
        {
            var DispatchWaybillLine = from L in db.DispatchWaybillLine where L.DispatchWaybillHeaderId == DispatchWaybillHeaderid select new { DispatchWaybillLindId = L.DispatchWaybillLineId };
            foreach (var item in DispatchW

            {
                Delete(item.DispatchWaybillLindId);
            }
        }
        public void Update(DispatchWaybillLine s)
        {
            s.ObjectState = ObjectState.Modified;
            _unitOfWork.Repository<DispatchWaybillLine>().Update(s);
        }
        public IQueryable<DispatchWaybillLine> GetDispatchWaybillLineList()
        {
            return _unitOfWork.Repository<DispatchWaybillLine>().Query().Get();
        }
        public IQueryable<DispatchWaybillLine> GetDispatchWaybillLineForHeaderId(int DispatchWaybillHeaderId)
        {
            return _unitOfWork.Repository<DispatchWaybillLine>().Query().Get().Where(m => m.DispatchWaybillHeaderId == DispatchWaybillHeaderId);
        }
        public DispatchWaybillLine GetDispatchWaybillLineForLineId(int DispatchWaybillLineId)
        {
            return _unitOfWork.Repository<DispatchWaybillLine>().Query().Get().Where(m => m.DispatchWaybillLineId == DispatchWaybillLineId).FirstOrDefault();
       
namespace Infrastructure
    public class WindsorHttpControllerFactory : IHttpControllerFactory
    {
        private readonly IKernel _kernel;
        public WindsorHttpControllerFactory(IKernel kernel)
        {
            _kernel = kernel;
        }
        public IHttpController CreateController(HttpControllerContext controllerContext, string controllerName)
        {
            var controller =
                _kernel.Resolve<IHttpController>(String.Format("Web.Api.Controllers.{0}Controller", controllerName));
            controllerContext.Controller = controller;
            controllerContext.ControllerDescriptor = new HttpControllerDescriptor(GlobalConfiguration.Configuration,
                                                                                  controllerName, controller.GetType());
            return controllerContext.Controller;
        }
        public void ReleaseController(IHttpController controller)
        {
            _kernel.ReleaseComponent(controller);
namespace Substrate.Core
    public class ChunkCache
    {
        private LRUCache<ChunkKey, ChunkRef> _cache;
        private Dictionary<ChunkKey, ChunkRef> _dirty;
        public ChunkCache ()
        {
            _cache = new LRUCache<ChunkKey, ChunkRef>(256);
            _dirty = new Dictionary<ChunkKey, ChunkRef>();
            _cache.RemoveCacheValue += EvictionHandler;
        }
        #region IChunkCache Members
        public bool Insert (ChunkRef chunk)
        {
            ChunkKey key = new ChunkKey(chunk.X, chunk.Z);
            ChunkRef c;
            if (!_cache.TryGetValue(key, out c)) {
                _cache[key] = chunk;
                return true;
            }
            return false;
        }
        public bool Remove (ChunkKey key)
        {
            _dirty.Remove(key);
            return _cache.Remove(key);
        }
        public ChunkRef Fetch (ChunkKey key)
        {
            ChunkRef c;
            if (!_cache.TryGetValue(key, out c)) {
      

            }
            return c;
        }
        public IEnumerator<ChunkRef> GetDirtyEnumerator ()
        {
            return _dirty.Values.GetEnumerator();
        }
        public void ClearDirty ()
        {
            _dirty.Clear();
        }
        public void SyncDirty ()
        {
            foreach (KeyValuePair<ChunkKey, ChunkRef> e in _cache) {
                if (e.Value.IsDirty) {
                    _dirty[e.Key] = e.Value;
                }
            }
        }
        private void EvictionHandler (object sender, LRUCache<ChunkKey, ChunkRef>.CacheValueArgs e)
        {
            if (e.Value.IsDirty) {
                _dirty[e.Key] = e.Value;
            }
        }
        /*public bool MarkChunkDirty (ChunkRef chunk)
        {
            int cx = chunk.X;
            int cz = chunk.Z;
            ChunkKey k = new ChunkKey(cx, cz);
            if (!_dirty.ContainsKey(k)) {
                _dirty.Add(k, chunk);
                return true;
            }

﻿namespace Connecto.Repositories
    public static class ConnectoFactory
    {
        public static VendorRepository VendorRepository
        {
            get { return new VendorRepository(); }
        }
        public static ProductRepository ProductRepository
        {
            get { return new ProductRepository(); }
        }
        public static CompanyRepository CompanyRepository
        {
            get { return new CompanyRepository(); }
        }
        public static LocationRepository LocationRepository
        {
            get { return new LocationRepository(); }
        }
        public static SupplierRepository SupplierRepository
        {
            get { return new SupplierRepository(); }
        }
        public static EmployeeRepository EmployeeRepository
        {
            get { return new EmployeeRepository(); }
        }
        public static MeasureRepository MeasureRepository
        {
            get { return new MeasureRepository(); }
        }
     
namespace Intact.ParallelLib
    internal class UnconstantInvokeSynchronisationContainer : SynchronisationContainer
    {
        private ParallelQueue<InvokePart> parallelQueue;
        public ParallelQueue<InvokePart> ParallelQueue
        {
            get { return parallelQueue; }
            set { parallelQueue = value; }
        }
        private ParallelQueue<InvokePart>[] parallelQueues;
        public ParallelQueue<InvokePart>[] ParallelQueues
        {
            get { return parallelQueues; }
            set { parallelQueues = value; }
        }
        internal UnconstantInvokeSynchronisationContainer(ManualResetEvent manualResetEvent,
            ParallelQueue<InvokePart> parallelQueue, ParallelQueue<InvokePart>[] parallelQueues) 
            : base(manualResetEvent)
        {
            this.parallelQueue = parallelQueue;
            this.parallelQueues = parallelQueues;
        }
        internal UnconstantInvokeSynchronisationContainer(ManualResetEvent manualResetEven

            : base(manualResetEvent)
        {
        }
    }
    internal class UnconstantInvokeSynchronisationContainer<T> : UnconstantInvokeSynchronisationContainer
    {
        private ParallelQueue<InvokePart<T>> parallelQueue;
        public new ParallelQueue<InvokePart<T>> ParallelQueue
        {
            get { return parallelQueue; }
            set { parallelQueue = value; }
        }
        private ParallelQueue<InvokePart<T>>[] parallelQueues;
        public new ParallelQueue<InvokePart<T>>[] ParallelQueues
        {
            get { return parallelQueues; }
            set { parallelQueues = value; }
        }
        internal UnconstantInvokeSynchronisationContainer(ManualResetEvent manualResetEvent,
            ParallelQueue<InvokePart<T>> parallelQueue, ParallelQueue<InvokePart<T>>[] parallelQueues)
            : base(manualResetEvent)
        {
            this.parallelQueue = parallelQueue;
            this.parallelQueues = parallelQueues;
        }
    }
    i
namespace TChartFeatures
	public class SettingsDelegate : UITableViewDelegate
	{		
		private SettingsController _controller;
		private ChartViewController _chartController;
				
		public SettingsDelegate(SettingsController controller, ChartViewController chartController)
		{
			_controller = controller;	
			_chartController = chartController;
		}
		
		public override void RowSelected (UITableView tableView, NSIndexPath indexPath)
		{
			UITableViewController nextController = null;
			
			switch (indexPath.Row)
			{
/*				case 0:
					nextController = new SeriesTypesController(UITableViewStyle.Grouped);
					break;*/
				case 0:
					nextController = new AspectController(_controller.chart,_chartController,UITableViewStyle.Grouped);
					break;
				case 1:
					nextController = new ThemesController(_controller.chart,_chartController,UITableViewStyle.Grouped);
					break;
				case 2:
					nextController = new ColorPalettesController(_controller.chart,_chartController,UITableViewStyle.Grou
public class World : MonoBehaviour {
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public GameObject chunkPrefab;
    void Start()
    {
        for (int x = -2; x < 2; x++)
        {
            for (int y = -1; y < 1; y++)
            {
                for (int z = -1; z < 1; z++)
                {
                    CreateChunk(x * 16, y * 16, z * 16);
                }
            }
        }
    }
	void Update () {
	}
    public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(x, y, z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        for (int xi = 0; xi < 16; xi++)
        {
        

            {
                for (int zi = 0; zi < 16; zi++)
                {
                    if (yi <= 7)
                    {
                        SetBlock(x + xi, y + yi, z + zi, new BlockGrass());
                    }
                    else
                    {
                        SetBlock(x + xi, y + yi, z + zi, new BlockAir());
                    }
                }
            }
        }
    }
    public void DestroyChunk(int x, int y, int z)
    {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
        {
            Object.Destroy(chunk.gameObject);
            chunks.Remove(new WorldPos(x, y, z));
        }
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / 
namespace AllLifeDataCollector_EXE
    class Repository
    {
        private Int32 repositoryID;
        private string repositoryType;
        private string repositoryName;
        private string repositoryServerName;
        private string repositoryUsername;
        private string repositoryPassword;
        private string repositoryDBName;
        public Repository()
        {
        }
        public Repository(Int32 _RepositoryID, string _RepositoryType, string _RepositoryName, string _RepositoryServerName, string _RepositoryUsername, string _RepositoryPassword, string _RepositoryDBName)
        {
            this.repositoryID = _RepositoryID;
            this.repositoryType = _RepositoryType;
            this.repositoryName = _RepositoryDBName;
            this.repositoryServerName = _RepositoryServerName;
            this.repositoryUsername = _RepositoryUsername;
            this.repositoryPassword = _RepositoryPassword;
            this.repositoryDBName = _RepositoryDBName;


        public Int32 RepositoryID
        {
            get { return this.repositoryID; }
            set { this.repositoryID = value; }
        }
        public string RepositoryType
        {
            get { return this.repositoryType; }
            set { this.repositoryType = value; }
        }
        public string RepositoryName
        {
            get { return this.repositoryName; }
            set { this.repositoryName = value; }
        }
        public string RepositoryServerName
        {
            get { return this.repositoryServerName; }
            set { this.repositoryServerName = value; }
        }
        public string RepositoryUsername
        {
            get { return this.repositoryUsername; }
            set { this.repositoryUsername = value; }
        }
        public string RepositoryPassword
        {
            get { return this.repositoryPassword; }
            set { this.repositoryPassword = value; }
        }
        public string RepositoryDBName
 
namespace CLOSER_Repository_Ingester.ControllerSystem.Actions
    class AttachExternalInstrument : IAction
    {
        private string instrumentUserId;
        private string externalPath;
        public string scope { get; protected set; }
        public AttachExternalInstrument(string instrumentUserId, string externalPath)
        {
            this.instrumentUserId = instrumentUserId;
            this.externalPath = externalPath;
        }
        public void Validate()
        {
            if (!System.IO.File.Exists(this.externalPath))
            {
                throw new System.Exception("Missing file: " + this.externalPath);
            }
        }
        public IEnumerable<IVersionable> Build(IEnumerable<IVersionable> ws)
        {
            var instrument = ws.OfType<Instrument>()
                .Where(x => x.UserIds.Count > 0)
                .FirstOrDefault( x => x.UserIds.Any(y => y.Identifier == instrumentUserId));
            Attach(instrument, externalPath);
   
namespace SWRevealViewControllerTest
	public partial class ViewController : UIViewController
	{
		protected ViewController (IntPtr handle) : base (handle) { }
		partial void viewControllerExample (Foundation.NSObject sender)
		{
			var frontViewController = Storyboard.InstantiateViewController ("MainTestViewController") as MainTestViewController;
			var rearViewController = Storyboard.InstantiateViewController ("LeftTestViewController") as LeftTestViewController;
			var revealController = new SWRevealViewController (rearViewController, frontViewController);
			frontViewController.View.AddGestureRecognizer (revealController.PanGestureRecognizer);
			frontViewController.View.AddGestureRecognizer (revealController.TapGestureRecognizer);
			PresentViewController (revealController, true, null);
		}
		partial void navigationControllerExample (Foundation.NSObject sender)
		{
			var frontViewController = new UINavigationController (Storyboard.InstantiateViewController ("MainTestTableViewContro

			var rearViewController = Storyboard.InstantiateViewController ("LeftTestTableViewController") as LeftTestTableViewController;
			var revealController = new SWRevealViewController (rearViewController, frontViewController);
			frontViewController.View.AddGestureRecognizer (revealController.PanGestureRecognizer);
			frontViewController.View.AddGestureRecognizer (revealController.TapGestureRecognizer);
			PresentViewController (revealController, true, null);
		}
		partial void tableViewControllerExample (Foundation.NSObject sender)
		{
			var frontViewController = Storyboard.InstantiateViewController ("MainTestTableViewController") as MainTestTableViewController;
			var rearViewController = Storyboard.InstantiateViewController ("LeftTestTableViewController") as LeftTestTableViewController;
			var revealController = new SWRevealViewController (rearViewController, frontViewController);
			frontViewController.View.AddGestureRecognizer (revealController.PanGestureRecognizer);
			frontViewC
namespace Curan.Common.FormalizedData.File.Riff.Dls
	public class RiffChunkListWave : RiffChunkList
	{
		public const string TYPE = "wave";
		public static readonly Dictionary<string,Type> chunkTypeDictionary;
		public static readonly Dictionary<string,Type> bodyTypeDictionary;
		public readonly RiffChunkDlid dlidChunk;
		public readonly RiffChunkFmt_ fmt_Chunk;
		public readonly RiffChunkData dataChunk;
		public readonly RiffChunkWsmp wsmpChunk;
		static RiffChunkListWave()
		{
			chunkTypeDictionary = new Dictionary<string, Type>();
			chunkTypeDictionary.Add( RiffChunkDlid.ID, typeof( RiffChunkDlid ) );
			chunkTypeDictionary.Add( RiffChunkFmt_.ID, typeof( RiffChunkFmt_ ) );
			chunkTypeDictionary.Add( RiffChunkData.ID, typeof( RiffChunkData ) );
			chunkTypeDictionary.Add( RiffChunkWsmp.ID, typeof( RiffChunkWsmp ) );
			bodyTypeDictionary = new Dictionary<string, Type>();
			bodyTypeDictionary.Add( RiffChunkListLrgn.TYPE, typeof( RiffChunkListLrgn ) );
			bodyTypeDictionary.Add( Ri
namespace DRMFSS.BLL.Services
    public interface IOtherDispatchAllocationService:IDisposable
    {
        bool AddOtherDispatchAllocation(OtherDispatchAllocation otherDispatchAllocation);
        bool DeleteOtherDispatchAllocation(OtherDispatchAllocation otherDispatchAllocation);
        bool DeleteById(int id);
        bool EditOtherDispatchAllocation(OtherDispatchAllocation otherDispatchAllocation);
        OtherDispatchAllocation FindById(int id);
        OtherDispatchAllocation FindById(Guid id);
        List<OtherDispatchAllocation> GetAllOtherDispatchAllocation();
        List<OtherDispatchAllocation> FindBy(Expression<Func<OtherDispatchAllocation, bool>> predicate);
        void Save(ViewModels.Dispatch.OtherDispatchAllocationViewModel model);
        OtherDispatchAllocationViewModel GetViewModelByID(Guid otherDispatchAllocationId);
        List<OtherDispatchAllocation> GetAllToCurrentOwnerHubs(UserProfile user);
        List<OtherDispatchAllocation> GetAllToOtherOwnerHubs(Us
namespace T3ME.Business.StartUp
    public class StartBackgroundTasks : IBootstrapperTask
    {
        protected readonly IApplicationRepository ApplicationRepository = null;
        protected readonly ITweetRepository TweetRepository = null;
        protected readonly ITweeterRepository TweeterRepository = null;
        protected readonly ILanguageRepository LanguageRepository = null;
        public StartBackgroundTasks(IApplicationRepository applicationRepository, ITweetRepository tweetRepository,
            ITweeterRepository tweeterRepository, ILanguageRepository languageRepository)
        {
            this.ApplicationRepository = applicationRepository;
            this.TweetRepository = tweetRepository;
            this.TweeterRepository = tweeterRepository;
            this.LanguageRepository = languageRepository;
        }
        public void Execute()
        {
            TrawlTweets trawler = TrawlTweets.Instance();
            trawler.ApplicationRepository = ApplicationR
﻿namespace SDK.Lib
    /**
     * @brief 非引用计数资源加载结果通知
     */
    public class ResLoadResultNotify
    {
        public ResLoadResultNotify()
        {
            m_resLoadState = new ResLoadState();
            m_loadResEventDispatch = new ResEventDispatch();
        }
        public ResLoadState resLoadState
        {
            get
            {
                return m_resLoadState;
            }
            set
            {
                m_resLoadState = value;
            }
        }
        public ResEventDispatch loadResEventDispatch
        {
            get
            {
                return m_loadResEventDispatch;
            }
            set
            {
                m_loadResEventDispatch = value;
            }
        }
        public void onLoadEventHandle(IDispatchObject dispObj)
        {
            m_loadResEventDispatch.dispatchEvent(dispObj);
            m_loadResEventDispatch.clearEventHandle();
        }
        virtual public void copyFrom(ResLoadRe
namespace MemoScope.Modules.Process
    public class ProcessWrapper : IEquatable<ProcessWrapper>
    {
        public long VirtualMemory => Process.VirtualMemorySize64;
        public long PeakVirtualMemory => Process.PeakVirtualMemorySize64;
        public long PagedMemory => Process.PagedMemorySize64;
        public long PeakPagedMemory => Process.PeakPagedMemorySize64;
        public long PeakWorkingSet => Process.PeakWorkingSet64;
        public long WorkingSet => Process.WorkingSet64;
        public long PrivateMemory => Process.PrivateMemorySize64;
        public long HandleCount => Process.HandleCount;
        public TimeSpan TotalProcessorTime => Process.TotalProcessorTime;
        public DateTime StartTime => Process.StartTime;
        public TimeSpan UserProcessorTime => Process.UserProcessorTime;
        public System.Diagnostics.Process Process { get; }
        public ProcessWrapper(System.Diagnostics.Process process)
        {
            Process = process;
        }
     
namespace DataService.UnitOfWork
    public class UnitOfWork
    {
        private readonly object _db;
        private GenericRepository<Skill> _skillRepository;
        private GenericRepository<About> _aboutRepository;
        private GenericRepository<Resume> _resumeRepository;
        private GenericRepository<TimeStamp> _timeStampRepository;
        private GenericRepository<Project> _projectRepository;
        private GenericRepository<Reference> _referenceRepository;
        public UnitOfWork(object db)
        {
            _db = db;
        }
        public GenericRepository<Skill> SkillRepository => _skillRepository ?? (_skillRepository = new GenericRepository<Skill>(_db));
        public GenericRepository<About> AboutRepository => _aboutRepository ?? (_aboutRepository = new GenericRepository<About>(_db));
        public GenericRepository<Resume> ResumeRepository => _resumeRepository ?? (_resumeRepository = new GenericRepository<Resume>(_db));
        public GenericRepositor
namespace Crimenuts.App.Ajax.Game.Server.Managers
    public class ProcessManager : IProcessManager
    {
        #region Constructor
        public ProcessManager( IGameClient clients )
        {
            _clients = clients;
        }
        #endregion
        #region IProcessManager
        public IProcessManager IManager
        {
            get { return this; }
        }
        ProcessModel IProcessManager.GetModel( string processId )
        {
            var process = GetProcess( processId );
            var model = new ProcessModel( process );
            return model;
        }
        void IProcessManager.AutoAnswer( string processId )
        {
            var process = GetProcess( processId );
            process.ExecuteUserAction( Process.UserAction.ActionType.AutoAsk );
            _clients.ProcessUpdated( new ProcessModel( process ) );
        }
        void IProcessManager.Reset()
        {
            Schema.ResetProcesses();
            _clients.ProcessesReset();

        }
        void IProcessManager.Arrest( string processId, int memberId )
        {
            var process = GetProcess( processId );
            process.ExecuteUserAction( Process.UserAction.ActionType.Arrest, memberId );
            _clients.ProcessUpdated( new ProcessModel( process ) );
        }
        void IProcessManager.Annotate( string processId, int memberId, AnswerCode annotation )
        {
            var process = GetProcess( processId );
            process.Annotate( memberId, annotation );
            _clients.ProcessUpdated( new ProcessModel( process ) );
        }
        public void Continue( string processId )
        {
            var process = GetProcess( processId );
            process.ExecuteUserAction( Process.UserAction.ActionType.Continue );
            _clients.ProcessUpdated( new ProcessModel( process ) );
        }
        public void EarlyArrest( string processId, int memberId )
        {
            var process = GetProcess( processId );
       
namespace Core.TransactionServer.Agent.BLL.InstrumentBusiness
    internal abstract class InstrumentServiceFactory
    {
        internal abstract Instrument CreateInstrument(Account owner, Guid id, QuotationBulk initQuotation);
        internal abstract LotCalculator CreateLotCalculator(Instrument instrument);
        internal abstract OrderCollector CreateOrderCollector(Instrument instrument);
        internal abstract InstrumentCalculator CreateInstrumentCalculator(Instrument instrument);
    }
    internal sealed class GeneralInstrumentServiceFactory : InstrumentServiceFactory
    {
        internal override LotCalculator CreateLotCalculator(Instrument instrument)
        {
            return new GeneralLotCalculator(instrument);
        }
        internal override OrderCollector CreateOrderCollector(Instrument instrument)
        {
            return new GeneralOrderCollector(instrument);
        }
        internal override InstrumentCalculator CreateInstrumentCalculator(Instrumen

        {
            return new GeneralInstrumentCalculator(instrument);
        }
        internal override Instrument CreateInstrument(Account owner, Guid id, QuotationBulk initQuotation)
        {
            return new Instrument(owner, id, initQuotation,this);
        }
    }
    internal sealed class PhysicalInstrumentServiceFactory : InstrumentServiceFactory
    {
        internal override LotCalculator CreateLotCalculator(Instrument instrument)
        {
            return new PhysicalLotCalculator((PhysicalInstrument)instrument);
        }
        internal override OrderCollector CreateOrderCollector(Instrument instrument)
        {
            return new PhysicalInstrumentOrderCollector((PhysicalInstrument)instrument);
        }
        internal override InstrumentCalculator CreateInstrumentCalculator(Instrument instrument)
        {
            return new PhysicalInstrumentCalculator((PhysicalInstrument)instrument);
        }
        internal override Instrument CreateInst
public class InstrumentList : MonoBehaviour {
	private float vikingSpawnX;
	private GameObject[] viking_flute;
	private GameObject[] viking_harp;
	private GameObject[] viking_horn;
	private int index = 0;
	private List<Instrument> instrument_order;
	private List<GameObject> viking_order;
	private MusicManager music;
	public int viking_distance = 3;
	void Start () {
		viking_flute = Resources.LoadAll<GameObject>("Vikings/FlutePrefabs");
		viking_harp = Resources.LoadAll<GameObject>("Vikings/HarpPrefabs");
		viking_horn = Resources.LoadAll<GameObject>("Vikings/HornPrefabs");
		instrument_order = new List<Instrument>();
		viking_order = new List<GameObject>();
		music = FindObjectOfType<MusicManager>();
		SpawnGap();SpawnGap();SpawnGap();
		for (int i = 0; i < 40; i++) {
			SpawnViking();
		}
		MusicManager.OnBar += IncrementIndex;
	}
	private void SpawnGap(){
		instrument_order.Add(Instrument.None);
		viking_order.Add(null);
	}	
	GameObject FindPrefab(GameObject[] list){
		return list[Ra

	}
	private void SpawnViking(){
		instrument_order.Add(RandomInstrument());
		int i = instrument_order.Count - 1;
		if (instrument_order [i] == Instrument.Flute) {
			viking_order.Add(Instantiate (FindPrefab(viking_flute), new Vector2 (i * viking_distance, -1f), Quaternion.identity));
		} else if (instrument_order [i] == Instrument.Harp) {
			viking_order.Add(Instantiate (FindPrefab(viking_harp), new Vector2 (i * viking_distance, -1f), Quaternion.identity));
		} else if (instrument_order [i] == Instrument.Horn) {
			viking_order.Add(Instantiate (FindPrefab(viking_horn), new Vector2 (i * viking_distance, -1f), Quaternion.identity));
		} else {
			viking_order.Add(null);
		}
	}
	private void IncrementIndex(){
		index++;
		music.CheckInstrument();
		SpawnViking();
	}
	public Instrument GetCurrentInstrument(){
		return instrument_order[index];
	}
	public GameObject GetCurrentViking(){
		return viking_order[index];
	}
	Instrument RandomInstrument(){
		int instrument = Random.Range(0,4);
		
﻿#region copyright
#endregion
namespace Flux.Tests
    [TestClass]
    public class DispatcherTests
    {
        [TestMethod]
        public void Dispatcher_OnRegister_GivesValidToken()
        {
            Dispatcher dispatcher = new Dispatcher();
            DispatchToken dispatchToken = dispatcher.Register(p => { });
            
            Assert.IsTrue(dispatcher.HasRegistered(dispatchToken));
        }
        [TestMethod]
        public void Dispatch_CanTakeTwoArgs()
        {
            Dispatcher dispatcher = new Dispatcher();
            dispatcher.Dispatch("Whatup", true);
        }
        [TestMethod]
        public void Dispatcher_OnDispatch_DeliversPayload()
        {
            bool received = false;
            Dispatcher dispatcher = new Dispatcher();
            dispatcher.Register(p =>
            {
                received = true;
            });
            Payload payload = new Payload("", 3);
            dispatcher.Dispatch(payload);
            Assert.IsTr

        }
        [TestMethod]
        [ExpectedException(typeof(Flux.DispatcherExceptions.AlreadyDispatchingException))]
        public void Dispatcher_OnDispatch_DisablesDispatch()
        {
            Dispatcher dispatcher = new Dispatcher();
            DispatchToken dispatchToken = dispatcher.Register(p =>
            {
                dispatcher.Dispatch(new Payload("", 349));
            });
            dispatcher.Dispatch(new Payload("", 5));
        }
        [TestMethod]
        public void Dispatcher_OnDispatch_AcceptsWaitForRequests()
        {
            bool hasWaited = false;
            Dispatcher dispatcher = new Dispatcher();
            DispatchToken second = null;
            DispatchToken first = dispatcher.Register(p => {
                dispatcher.WaitFor(second);
                Assert.IsTrue(hasWaited);
            });
            second = dispatcher.Register(p => { hasWaited = true; });
            dispatcher.Dispatch(new Payload("", 4));
        }
        

        [ExpectedException(typeof(Flux.DispatcherExceptions.CircularDependecyException))]
        public void Dispatcher_OnDispatch_RejectsCircularWaitForRequests()
        {
            Dispatcher dispatcher = new Dispatcher();
            DispatchToken second = null;
            DispatchToken first = dispatcher.Register(p => {
                dispatcher.WaitFor(second);
            });
            second = dispatcher.Register(p => {
                dispatcher.WaitFor(first);
            });
            dispatcher.Dispatch(new Payload("", 4));
        }
        [TestMethod]
        public void Dispatcher_OnFinishDispatch_EnablesDispatch()
        {
            int dispatchCounter = 0;
            Dispatcher dispatcher = new Dispatcher();
            DispatchToken dispatchToken = dispatcher.Register(p => { dispatchCounter++; });
            dispatcher.Dispatch(new Payload("", 0));
            dispatcher.Dispatch(new Payload("", 1));
            Assert.AreEqual(dispatchCounter, 2);
   
namespace Warren.BlogDemo.EntityFrame
    public class UnitOfWork : IDisposable
    {
        private readonly BlogDbContext _context = null;
        private Repository<Blog> _blogRepository = null;
        private Repository<Category> _categoryRepository;
        private Repository<Comment> _commentRepository = null;
        private Repository<Role> _roleRepository = null;
        private Repository<User> _userRepository = null;
        public UnitOfWork(Repository<Blog> blogRepository, Repository<Category> categoryRepository, Repository<Comment> commentRepository, Repository<Role> roleRepository, Repository<User> userRepository)
        {
            _blogRepository = blogRepository;
            _categoryRepository = categoryRepository;
            _commentRepository = commentRepository;
            _roleRepository = roleRepository;
            _userRepository = userRepository;
            _context = new BlogDbContext();
        }
        public UnitOfWork()
        {
            _co

        }
        public Repository<Blog> BlogRepository
        {
            get { return _blogRepository ?? (_blogRepository = new Repository<Blog>(_context)); }
        }
        public Repository<Category> CategoryRepository
        {
            get { return _categoryRepository ?? (_categoryRepository = new Repository<Category>(_context)); }
        }
        public Repository<Comment> CommentRepository
        {
            get { return _commentRepository ?? (_commentRepository = new Repository<Comment>(_context)); }
        }
        public Repository<Role> RoleRepository
        {
            get { return _roleRepository ?? (_roleRepository = new Repository<Role>(_context)); }
        }
        public Repository<User> UserRepository
        {
            get { return _userRepository ?? (_userRepository = new Repository<User>(_context)); }
        }
        public void SaveChanges()
        {
            _context.SaveChanges();
        }
        public void Dispose()
        {
public class ChunkDictController : ChunkController {
    protected Dictionary<Pos, Chunk> chunks = new Dictionary<Pos, Chunk>();
    protected List<Chunk> chunkPool = new List<Chunk>();
    [Tooltip("If SetBlock's coordinates are within an unloaded chunk, load the chunk and apply the set block command.")]
    public bool SetBlockCreateMissingChunks;
    [Tooltip("If GetBlock's coordinates are within an unloaded chunk, load the chunk and return the block at the coordinates.")]
    public bool GetBlockCreateMissingChunks;
    public int minChunkY = -32;
    public int maxChunkY = 64;
    public override void Initialize(Voxelmetric vm)
    {
        base.Initialize(vm);
    }
    public override Chunk CreateChunk(Pos pos)
    {
        pos = GetChunkPos(pos);
        if (pos.y > maxChunkY || pos.y < minChunkY) return null;
        Chunk chunk;
        if (chunks.ContainsKey(pos))
        {
            return chunks[pos];
        }
        if (chunkPool.Count != 0)
        {
            ch

            chunkPool.RemoveAt(0);
        }
        else
        {
            GameObject chunkGO = new GameObject("Chunk at " + pos, new Type[] {
                vm.components.chunkType.GetType()
            });
            chunk = chunkGO.GetComponent<Chunk>();
            chunk.transform.rotation = transform.rotation;
        }
        Utils.ProfileCall(() => { chunk.VmStart(pos, this); }, "Chunk vmStart");
        chunks.Add(pos, chunk);
        return chunk;
    }
    public override void Destroy(Chunk chunk)
    {
        chunk.Clear();
        chunks.Remove(chunk.pos);
        chunkPool.Add(chunk);
    }
    public override Chunk GetChunk(Pos chunkPos)
    {
        Chunk chunk = null;
        chunks.TryGetValue(GetChunkPos(chunkPos), out chunk);
        return chunk;
    }
    public override Block GetBlock(Pos blockPos)
    {
        Chunk chunk = null;
        Pos chunkPos = GetChunkPos(blockPos);
        chunks.TryGetValue(chunkPos, out chunk);
        {
            if (Ge
namespace LogJoint
	public class InvokeSynchronization : IInvokeSynchronization
	{
		public InvokeSynchronization(ISynchronizeInvoke impl)
		{
			this.impl = impl;
		}
		public bool InvokeRequired 
		{
			get { return impl.InvokeRequired; } 
		}
		public IAsynchronousInvokeResult BeginInvoke(Delegate method, object[] args) 
		{
			return new AsynchronousInvokeResult(impl.BeginInvoke(method, args)); 
		}
		public object EndInvoke(IAsynchronousInvokeResult result) 
		{
			return impl.EndInvoke(((AsynchronousInvokeResult)result).impl); 
		}
		public object Invoke(Delegate method, object[] args)
		{
			return impl.Invoke(method, args);
		}
		async Task IInvokeSynchronization.Invoke(Action action)
		{
			await InvokeInternal((Func<int>)(() => { action(); return 0; }), null);
		}
		Task<T> IInvokeSynchronization.Invoke<T>(Func<T> func)
		{
			return InvokeInternal(func, null);
		}
		async Task IInvokeSynchronization.Invoke(Action action, CancellationToken cancellation)
		{
			await InvokeInt
namespace THOK.Wms.Bll.Service
    public class SortOrderDispatchService : ServiceBase<SortOrderDispatch>, ISortOrderDispatchService
    {
        [Dependency]
        public ISortOrderDispatchRepository SortOrderDispatchRepository { get; set; }
        [Dependency]
        public ISortOrderRepository SortOrderRepository { get; set; }
        protected override Type LogPrefix
        {
            get { return this.GetType(); }
        }
        #region ISortOrderDispatchService 成员
        public object GetDetails(int page, int rows, string OrderDate, string SortingLineCode)
        {
            IQueryable<SortOrderDispatch> sortDispatchQuery = SortOrderDispatchRepository.GetQueryable();
            var sortDispatch = sortDispatchQuery.Where(s => s.SortingLineCode == s.SortingLineCode);
            if (OrderDate != string.Empty && OrderDate != null)
            {
                OrderDate = Convert.ToDateTime(OrderDate).ToString("yyyyMMdd");
                sortDispatch = sortDispatch

            }
            if (SortingLineCode != string.Empty && SortingLineCode != null)
            {
                sortDispatch = sortDispatch.Where(s => s.SortingLineCode == SortingLineCode);
            }
            var temp = sortDispatch.OrderBy(b => b.SortingLineCode).AsEnumerable().Select(b => new
           {
               b.ID,
               b.SortingLineCode,
               b.SortingLine.SortingLineName,
               b.OrderDate,
               b.DeliverLineCode,
               WorkStatus = b.WorkStatus == "1" ? "未作业" : "已作业",
               b.DeliverLine.DeliverLineName,
               IsActive = b.IsActive == "1" ? "可用" : "不可用",
               UpdateTime = b.UpdateTime.ToString("yyyy-MM-dd HH:mm:ss")
           });
            int total = temp.Count();
            temp = temp.Skip((page - 1) * rows).Take(rows);
            return new { total, rows = temp.ToArray() };
        }
        public new bool Add(string SortingLineCode, string DeliverLineCodes)
        {
 

                                              .GroupBy(s => new { s.DeliverLineCode, s.OrderDate })
                                              .Select(s => new { DeliverLineCode = s.Key.DeliverLineCode, OrderDate = s.Key.OrderDate });
            foreach (var item in sortOder.ToArray())
            {
                var sortOrderDispatch = new SortOrderDispatch();
                sortOrderDispatch.SortingLineCode = SortingLineCode;
                sortOrderDispatch.DeliverLineCode = item.DeliverLineCode;
                sortOrderDispatch.WorkStatus = "1";
                sortOrderDispatch.OrderDate = item.OrderDate;
                sortOrderDispatch.IsActive = "1";
                sortOrderDispatch.UpdateTime = DateTime.Now;
                SortOrderDispatchRepository.Add(sortOrderDispatch);
            }
            SortOrderDispatchRepository.SaveChanges();
            return true;
        }
        public bool Delete(string id)
        {
            int ID = Convert.ToInt32(id);
namespace BodeAbp.Queue.Broker.Storage
    public class ChunkReader
    {
        private readonly ChunkManager _chunkManager;
        private readonly ChunkWriter _chunkWriter;
        public ChunkReader(ChunkManager chunkManager, ChunkWriter chunkWriter)
        {
            chunkManager.CheckNotNull("chunkManager");
            chunkWriter.CheckNotNull("chunkWriter");
            _chunkManager = chunkManager;
            _chunkWriter = chunkWriter;
        }
        public T TryReadAt<T>(long position, Func<byte[], T> readRecordFunc, bool autoCache = true) where T : class, ILogRecord
        {
            var lastChunk = _chunkWriter.CurrentChunk;
            var maxPosition = lastChunk.GlobalDataPosition;
            if (position >= maxPosition)
            {
                return null;
            }
            var chunkNum = _chunkManager.GetChunkNum(position);
            var chunk = _chunkManager.GetChunk(chunkNum);
            if (chunk == null)
            {
               
namespace SMTools.Deployment.Base
    public class ProcessBuilder
    {
        public event EventHandler OnProcessBegining;
        public event ProcessCompletedEventHandler OnProcessCompleted;
        public IDeployProcess DeploymentProcess
        {
            get;
            set;
        }
        public ProcessBuilder(IDeployProcess process)
        {
            this.DeploymentProcess = process;
        }
        public void Start()
        {
            this.DeploymentProcess.ApplyConfiguration();
            if (OnProcessBegining != null)
            {
                OnProcessBegining(this, null);
            }
            this.DeploymentProcess.Run();
            if (OnProcessCompleted != null)
            {
                OnProcessCompleted(this, new ProcessCompletedEventArgs(this.DeploymentProcess.GetOutput()));
            }
        }
        public async Task StartAsync()
        {
            this.DeploymentProcess.ApplyConfiguration();
            if (OnProcessBegini
namespace EventManagementSystem.Data.UnitOfWork.Interfaces
    public interface IAdminDataUnit : IDataUnitOfWork
    {
        IRoomsRepository RoomsRepository { get; }
        IFacilitiesRepository FacilitiesRepository { get; }
        IRoomFacilitiesRepository RoomFacilitiesRepository { get; }
        IGolfsRepository GolfsRepository { get; }
        IGolfFollowResourcesRepository GolfFollowResourceRepository { get; }
        IUsersRepository UsersRepository { get; }
        IUserGroupsRepository UserGroupsRepository { get; }
        IUserJobTypesRepository UserJobTypesRepository { get; }
        IUserDepartmentsRepository UserDepartmentsRepository { get; }
        IPermissionsRepository PermissionsRepository { get; }
        IUserPermissionsRepository UserPermissionsRepository { get; }
        IUserGroupPermissionsRepository UserGroupPermissionsRepository { get; }
        IPermissionGroupsRepository PermissionGroupsRepository { get; }
        IEventOptionsRepository EventOptionsRepo

        IEventTypeOptionsRepository EventTypeOptionsRepository { get; }
        IEventTypesRepository EventTypesRepository { get; }
        IEventStatusesRepository EventStatusesRepository { get; }
        IEventStatusOptionsRepository EventStatusOptionsRepository { get; }
        IProductsRepository ProductsRepository { get; }
        IProductTypesRepository ProductTypesRepository { get; }
        IProductGroupsRepository ProductGroupsRepository { get; }
        IProductDepartmentsRepository ProductDepartmentsRepository { get; }
        IProductEventTypesRepository ProductEventTypesRepository { get; }
        IProductVatRatesRepository ProductVatRatesRepository { get; }
        IProductOptionsRepository ProductOptionsRepository { get; }
        IMailTemplatesRepository MailTemplatesRepository { get; }
        IMailTemplateCategoriesRepository MailTemplateCategoriesRepository { get; }
        IMailTemplateTypesRepository MailTemplateTypesRepository { get; }
        IFollowUpStatusesRe

        IEnquiryStatusesRepository EnquiryStatusesRepository { get; }
        IEnquiryReceiveMethodsRepository EnquiryReceiveMethodsRepository { get; }
        IDefaultSettingsForEnquiriesRepository DefaultSettingsForEnquiriesRepository { get; }
        IDocumentsRepository DocumentsRepository { get; }
        IEventsRepository EventsRepository { get; }
        ITillDivisionsRepository TillDivisionsRepository { get; }
        ITillsRepository TillsRepository { get; }
        ISystemSettingsRepository SystemSettingsRepository { get; }
        IEventTypeTODOsRepository EventTypeTODOsRepository { get; }
        IMembershipGroupStylesRepository MembershipGroupStylesRepository { get; }
        IMembershipGroupAgesRepository MembershipGroupAgesRepository { get; }
        IMembershipGroupsRepository MembershipGroupsRepository { get; }
        IMembershipCategoriesRepository MembershipCategoriesRepository { get; }
        IMembershipCategoryGroupDefaultsRepository MembershipCategoryGroupDefau
namespace QuantBox.Helper.XSpeed
    public sealed class XSpeedAPI
    {
        private static readonly XSpeedAPI instance = new XSpeedAPI();
        private XSpeedAPI()
        {
        }
        public static XSpeedAPI GetInstance()
        {
            return instance;
        }
        public void __RegTdApi(IntPtr pTdApi)
        {
            m_pTdApi = pTdApi;
        }
        public void __RegMdApi(IntPtr pMdApi)
        {
            m_pMdApi = pMdApi;
        }
        #region 深度行情1
        #endregion
        #region 做市商
        public void ReqQuoteSubscribe()
        {
            if (null != m_pTdApi
                && IntPtr.Zero != m_pTdApi)
            {
                TraderApi.TD_ReqQuoteSubscribe(m_pTdApi);
            }
        }
        public delegate void RtnQuoteSubscribe(DFITCQuoteSubscribeRtnField pRtnQuoteSubscribeData);
        public event RtnQuoteSubscribe OnRtnQuoteSubscribe;
        public void FireOnRtnQuoteSubscribe(DFITCQuoteSubscribeRtnField pRtn
public class MapChunkHandler : MonoBehaviour {
    List<MapChunk> chunks = new List<MapChunk>();
	public void createChunks(List<WavesAndWeights> wavesAndWeights, Transform mapTransform, int chunkSize) {
        List<MapChunkPosition> positions = new List<MapChunkPosition>()
        {
            MapChunkPosition.MIDDLE,
            MapChunkPosition.LEFT,
            MapChunkPosition.RIGHT,
            MapChunkPosition.TOP,
            MapChunkPosition.BOTTOM,
            MapChunkPosition.TOP_RIGHT,
            MapChunkPosition.TOP_LEFT,
            MapChunkPosition.BOTTOM_RIGHT,
            MapChunkPosition.BOTTOM_LEFT,
        };
        foreach(var position in positions)
        {
            buildChunk(wavesAndWeights, mapTransform, chunkSize, position);
        }
    }
    void buildChunk(List<WavesAndWeights> wavesAndWeights, Transform mapTransform, int chunkSize, MapChunkPosition position)
    {
        IntVector2 offset = MapChunkDirection.getVectorDirection(position, chunkSize 

        GameObject chunkObject = new GameObject();
        buildChunkCollider(chunkObject, chunkSize, offset, position);
        MapChunk chunk = buildChunkScript(chunkObject, chunkSize, offset, position, wavesAndWeights, mapTransform);
        chunks.Add(chunk);
    }
    void buildChunkCollider(GameObject chunkObject, int chunkSize, IntVector2 offset, MapChunkPosition position)
    {
        if (position.Equals(MapChunkPosition.TOP) ||
           position.Equals(MapChunkPosition.BOTTOM) ||
           position.Equals(MapChunkPosition.LEFT) ||
           position.Equals(MapChunkPosition.RIGHT))
        {
            BoxCollider2D collider = chunkObject.AddComponent<BoxCollider2D>();
            collider.isTrigger = true;
            collider.size = new Vector3(chunkSize * 2, chunkSize * 2);
            collider.offset = new Vector3(offset.x, offset.y);
        }
    }
    MapChunk buildChunkScript(GameObject chunkObject, int chunkSize, IntVector2 offset, MapChunkPosition position, Lis
public static class DrumKit {
	public enum Instrument {HiHat, Snare, Bass, CymbalCrash, CymbalRide, TomHigh, TomMid, TomLow, Silence};
	public enum Mode {Beginner, Intermediate, Advanced};
	private static Dictionary<int, Instrument> midiCodeMap = new Dictionary<int, Instrument>();
	private static Mode currentMode = Mode.Intermediate;
	public static void setDifficulty(Mode newMode){
		currentMode = newMode;
		DrumKit.buildIntstrumentMap ();
	}
	public static Instrument getInstrumentFromMidiCode (int midiCode){
		if (midiCodeMap.ContainsKey (midiCode)) {
			return midiCodeMap [midiCode];
		} 
		return Instrument.Silence;
	}
	public static void buildIntstrumentMap() {
		midiCodeMap = new Dictionary<int, Instrument>();
		switch (currentMode)
		{
			
		case Mode.Beginner:
			midiCodeMap.Add(35, Instrument.Bass);
			midiCodeMap.Add(36, Instrument.Bass);
			midiCodeMap.Add(38, Instrument.Snare);
			midiCodeMap.Add(40, Instrument.Snare);
			break;
		case Mode.Intermediate:
			midiCodeMap.Add(3
namespace OvningsTenta4.Models.Tests
    [TestClass()]
    public class CalculateEnergyTests
    {
        [TestMethod()]
        public void CalculateMassTest()
        {
            Assert.Fail();
        }
        [TestMethod]
        public void CalculateEnergy_Default()
        {
            CalculateEnergy calculateEnergy = new CalculateEnergy();
            var actual = calculateEnergy.CalculateMass("1");
            var expected = 89875517873681764;
            Assert.AreEqual(expected, actual);
        }
        [TestMethod]
        public void CalculateEnergy_PositiveNumber()
        {
            CalculateEnergy calculateEnergy = new CalculateEnergy();
            var actual = calculateEnergy.CalculateMass("5");
            var expected = 449377589368408820;
            Assert.AreEqual(expected, actual);
        }
        [TestMethod]
        public void CalculateEnergy_NegativeNumber()
        {
            CalculateEnergy calculateEnergy = new CalculateEnergy();
          
namespace Microsoft.AspNetCore.Mvc.Razor.Directives
    public class UsingChunkMergerTest
    {
        [Fact]
        public void Merge_AddsNamespacesThatHaveNotBeenVisitedInChunkTree()
        {
            var expected = "MyApp.Models";
            var merger = new UsingChunkMerger();
            var chunkTree = new ChunkTree();
            var inheritedChunks = new Chunk[]
            {
                new UsingChunk { Namespace = expected },
            };
            merger.VisitChunk(new UsingChunk { Namespace = "Microsoft.AspNetCore.Mvc" });
            merger.MergeInheritedChunks(chunkTree, inheritedChunks);
            var chunk = Assert.Single(chunkTree.Children);
        }
        [Fact]
        public void Merge_IgnoresNamespacesThatHaveBeenVisitedInChunkTree()
        {
            var merger = new UsingChunkMerger();
            var chunkTree = new ChunkTree();
            var inheritedChunks = new Chunk[]
            {
                new UsingChunk { Namespace = "Micro

                new InjectChunk("Foo", "Bar")
            };
            merger.VisitChunk(new UsingChunk { Namespace = "Microsoft.AspNetCore.Mvc" });
            merger.MergeInheritedChunks(chunkTree, inheritedChunks);
            Assert.Empty(chunkTree.Children);
        }
        [Fact]
        public void Merge_DoesNotAddMoreThanOneInstanceOfTheSameInheritedNamespace()
        {
            var merger = new UsingChunkMerger();
            var chunkTree = new ChunkTree();
            var inheritedChunks = new Chunk[]
            {
                new LiteralChunk(),
                new UsingChunk { Namespace = "Microsoft.AspNetCore.Mvc" },
                new UsingChunk { Namespace = "Microsoft.AspNetCore.Mvc" },
                new UsingChunk { Namespace = "Microsoft.AspNetCore.Mvc.Razor" }
            };
            merger.MergeInheritedChunks(chunkTree, inheritedChunks);
            Assert.Equal(2, chunkTree.Children.Count);
            var chunk = Assert.IsType<UsingChunk>(chun

            Assert.Equal("Microsoft.AspNetCore.Mvc", chunk.Namespace);
            chunk = Assert.IsType<UsingChunk>(chunkTree.Children[1]);
            Assert.Equal("Microsoft.AspNetCore.Mvc.Razor", chunk.Namespace);
        }
        [Fact]
        public void Merge_MatchesNamespacesInCaseSensitiveManner()
        {
            var merger = new UsingChunkMerger();
            var chunkTree = new ChunkTree();
            var inheritedChunks = new[]
            {
                new UsingChunk { Namespace = "Microsoft.AspNetCore.Mvc" },
                new UsingChunk { Namespace = "Microsoft.AspNetCore.mvc" }
            };
            merger.MergeInheritedChunks(chunkTree, inheritedChunks);
            Assert.Equal(2, chunkTree.Children.Count);
            var chunk = Assert.IsType<UsingChunk>(chunkTree.Children[0]);
            Assert.Equal("Microsoft.AspNetCore.Mvc", chunk.Namespace);
            chunk = Assert.IsType<UsingChunk>(chunkTree.Children[1]);
            Assert.Equal("Mi
namespace ProjetPhoneDaveMuret.DataAccess
    class DetailsInstrumentDataAccess
    {
        public DetailsInstrumentDataAccess()
        {    
                   
        }
        private int idInstrument;
        public int IdInstrument
        {
            get { return idInstrument; }
            set { idInstrument = value; }
        }
        public async Task getAsyncIdInstrument (String nomInstrumentSansEspaces)
        {
            HttpClient client = new HttpClient();
            var json = await client.GetStringAsync(url);
            List<int> idInstrumentListString = JsonConvert.DeserializeObject<List<int>>(json);
            idInstrument = idInstrumentListString[0];
        }
        public async Task<String> getAsyncDescription()
        {
            HttpClient  client = new HttpClient();
            var json = await client.GetStringAsync(url);
            List<String> descriptionInstrumentListString = JsonConvert.DeserializeObject<List<String>>(json);
            ret
namespace Musicfy.Dal.Repositories
    public class InstrumentRepository : BaseRepository, IInstrumentRepository
    {
        public InstrumentRepository(IGraphClient graphClient) : base(graphClient)
        {
        }
        public IEnumerable<Instrument> GetAll()
        {
            return _graphClient.Cypher
                .Match("(instrument:Instrument)")
                .With("instrument")
                .OrderBy("instrument.name")
                .Return(instrument => instrument.As<Instrument>())
                .Results;
        }
        public Instrument GetById(string id)
        {
            return _graphClient.Cypher
                .Match("(instrument:Instrument)")
                .Where((Instrument instrument) => instrument.Id == id)
                .Return(instrument => instrument.As<Instrument>())
                .Results
                .FirstOrDefault();
        }
        public Instrument GetByName(string name)
        {
            return _graphClient.Cypher

                .Match("(instrument:Instrument)")
                .Where((Instrument instrument) => instrument.Name == name)
                .Return(instrument => instrument.As<Instrument>())
                .Results
                .FirstOrDefault();
        }
        public void Add(Instrument instrument)
        {
            _graphClient.Cypher
                .Create("(instrument:Instrument {newInstrument})")
                .WithParam("newInstrument", instrument)
                .ExecuteWithoutResults();
        }
        public void Update(Instrument updatedInstrument)
        {
            _graphClient.Cypher
                .Match("(instrument:Instrument)")
                .Where((Instrument instrument) => instrument.Id == updatedInstrument.Id)
                .Set("instrument.name = {newName}")
                .WithParam("newName", updatedInstrument.Name)
                .ExecuteWithoutResults();
        }
        public void Delete(string id)
        {
            var trans
public class World : MonoBehaviour {
	public NoiseGen noiseGen = new NoiseGen();
	public GameObject player;
	public Vector3 playerChunk, prevPlayerChunk = new Vector3(9, 9, 9);
	List<Chunk> chunks = new List<Chunk>();
	public GameObject chunk;
	private int chunkSize = 1;
	void Start () {
		
	}
	void Update () {
		handleChunks();
	}
	void handleChunks(){
		playerChunk = new Vector3((int) player.transform.position.x / chunkSize, (int) player.transform.position.y / chunkSize, (int) player.transform.position.z / chunkSize);
		if(playerChunk != prevPlayerChunk){
			for(int x = (int) playerChunk.x - 4; x <= playerChunk.x + 4; x ++){
				for(int z = (int) playerChunk.z - 4; z <= (int) playerChunk.z + 4; z ++){
					for(int y = 0; y < 160; y ++){
						Chunk searchResult = searchChunks(new Vector3(x, y, z));
						if(searchResult == null){
							Chunk newChunk = genChunk(new Vector3(x, y, z));
							chunks.Add(newChunk);
							newChunk.chunkPos = new Vector3(x, y, z);
							newChunk.worldG

							newChunk.chunkSize = chunkSize;
							newChunk.initChunk();
						}
						else searchResult.gameObject.SetActive(true);
					}
				}
			}
			prevPlayerChunk = playerChunk;
			for(int i = 0; i < chunks.Count; i ++){
				if(!(chunks[i].chunkPos.x > playerChunk.x - 2 && chunks[i].chunkPos.x < playerChunk.x + 2 && chunks[i].chunkPos.z > playerChunk.z - 2 && chunks[i].chunkPos.z < playerChunk.z + 2)){
					chunks[i].gameObject.SetActive(false);
				}
			}
		}
	}
	Chunk genChunk(Vector3 chunkPos){
		GameObject newChunk = Instantiate(chunk,new Vector3(chunkPos.x * chunkSize, chunkPos.y * chunkSize, chunkPos.z * chunkSize), new Quaternion(0,0,0,0)) as GameObject;
		return newChunk.GetComponent("Chunk") as Chunk;
	}
	public Chunk searchChunks(Vector3 chunkPos){
		for(int i = 0; i < chunks.Count; i ++){
			if(chunks[i].chunkPos.x == chunkPos.x && chunks[i].chunkPos.y == chunkPos.y && chunks[i].chunkPos.z == chunkPos.z){
				return chunks[i];
			}
		}
		return null;
	}
	int PerlinNoise(i
namespace SongStreamer
    public class AudioHub : IDisposable
    {
        private static Dictionary<Instrument, int> channels = new Dictionary<Instrument, int>
        {
            { Instrument.Choir, 1 },
            { Instrument.Flute, 2 },
            { Instrument.JazzGuitar, 3 },
            { Instrument.Organ, 4 },
            { Instrument.Piano, 5 },
            { Instrument.SlapBass, 6 },
            { Instrument.TenorSax, 7 },
            { Instrument.Trumpet, 8 },
            { Instrument.Vibes, 9 }
        };
        private MidiSynthesizer synth;
        public ActorSystem System { get; private set; }
        public AudioHub()
        {
            System = ActorSystem.Create("speakers");
            synth = new MidiSynthesizer();
            foreach (var channel in channels)
                synth.SetVoice(channel.Value, (int)channel.Key);
        }
        public void Play(Pitch pitch, Instrument instrument, int volume)
        {
            synth.Play(pitch, channels[i
namespace HSRP.Transaction
    public class Class1
    {
        string DispatchCode, StateName, ShippingAddresh, ReceiveCode, RTOlocation, Remarks, DispatchCode2;
        public string DispatchCode21
        {
            get { return DispatchCode2; }
            set { DispatchCode2 = value; }
        }
        public string Remarks1
        {
            get { return Remarks; }
            set { Remarks = value; }
        }
        public string RTOlocation1
        {
            get { return RTOlocation; }
            set { RTOlocation = value; }
        }
        public string ReceiveCode1
        {
            get { return ReceiveCode; }
            set { ReceiveCode = value; }
        }
        public string ShippingAddresh1
        {
            get { return ShippingAddresh; }
            set { ShippingAddresh = value; }
        }
        public string StateName1
        {
            get { return StateName; }
            set { StateName = value; }
        }
        public strin
namespace Fiap.RH.Sistema.Contratacao.Persistencia.UnitsOfWork
    public class UnitOfWork : IDisposable
    {
        private Entities _persistencia = new Entities();
        private IGenericRepository<Candidato> _candidatoRepository;
        private IGenericRepository<Fabrica> _fabricaRepository;
        private IGenericRepository<Aula> _aulaRepository;
        private IGenericRepository<CandidatoAula> _candidatoAulaRepository;
        private IGenericRepository<PerfilProfissional> _perfilProfissionalRepository;
        private IGenericRepository<Unidade> _unidadeRepository;
        private IGenericRepository<Curso> _cursoRepository;
        private IGenericRepository<AvaliacaoComportamental> _avaliacaoComportamentalRepository;
        private IGenericRepository<Relatorio> _relatorioRepository;
        private IGenericRepository<Habilidade> _habilidadeRepository;
        private IRelatorioHabilidadeRepository _relatorioHabilidadeRepository;
        private IGenericRepository<Login> _

        public IGenericRepository<Candidato> CandidatoRepository
        {
            get
            {
                if(_candidatoRepository == null)
                {
                    _candidatoRepository = new GenericRepository<Candidato>(_persistencia);
                }
                return _candidatoRepository;
            }
        }
        public IGenericRepository<Fabrica> FabricaRepository
        {
            get
            {
                if(_fabricaRepository == null)
                {
                    _fabricaRepository = new GenericRepository<Fabrica>(_persistencia);
                }
                return _fabricaRepository;
            }
        }
        public IGenericRepository<Aula> AulaRepository
        {
            get
            {
                if (_aulaRepository == null)
                {
                    _aulaRepository = new GenericRepository<Aula>(_persistencia);
                }
                return _aulaRepository;
           

        }
        public IGenericRepository<CandidatoAula> CandidatoAulaRepository
        {
            get
            {
                if (_candidatoAulaRepository == null)
                {
                    _candidatoAulaRepository = new GenericRepository<CandidatoAula>(_persistencia);
                }
                return _candidatoAulaRepository;
            }
        }
        public IGenericRepository<PerfilProfissional> PerfilProfissionalRepository
        {
            get
            {
                if (_perfilProfissionalRepository == null)
                {
                    _perfilProfissionalRepository = new GenericRepository<PerfilProfissional>(_persistencia);
                }
                return _perfilProfissionalRepository;
            }
        }
        public IGenericRepository<Unidade> UnidadeRepository
        {
            get
            {
                if (_unidadeRepository == null)
                {
                    _unidadeRepository =
namespace Merchant.DataAccess.Repository
    public class UnitOfWork : IDisposable
    {
        private MerchantDBEntities1 _context = new MerchantDBEntities1();
        private GenericRepository<Buyer> _buyerRepository;
        private GenericRepository<Insurance> _insuranceRepository;
        private GenericRepository<InsurancePolicy> _insurancePolicyRepository;
        private GenericRepository<Insurants> _insurantsRepository;
        private GenericRepository<Person> _personRepository;
        private GenericRepository<Pricelist> _pricelistRepository;
        private GenericRepository<PricelistItem> _pricelistItemRepository;
        private GenericRepository<PricelistItems> _pricelistItemsRepository;
        private GenericRepository<ResidentalBuilding> _residentialBuildingRepository;
        private GenericRepository<Risk> _riskRepository;
        private GenericRepository<RiskCategory> _riskCategoryRepository;
        private GenericRepository<RiskItem> _riskItemRepository;
    

        public GenericRepository<Buyer> BuyerRepository => _buyerRepository ?? (_buyerRepository = new GenericRepository<Buyer>(_context));
        public GenericRepository<Insurance> InsuranceRepository => _insuranceRepository ?? (_insuranceRepository = new GenericRepository<Insurance>(_context));
        public GenericRepository<InsurancePolicy> InsurancePolicyRepository => _insurancePolicyRepository ?? (_insurancePolicyRepository = new GenericRepository<InsurancePolicy>(_context));
        public GenericRepository<Insurants> InsurantsRepository => _insurantsRepository ?? (_insurantsRepository = new GenericRepository<Insurants>(_context));
        public GenericRepository<Person> PersonRepository => _personRepository ?? (_personRepository = new GenericRepository<Person>(_context));
        public GenericRepository<Pricelist> PricelistRepository => _pricelistRepository ?? (_pricelistRepository = new GenericRepository<Pricelist>(_context));
        public GenericRepository<PricelistIt

        public GenericRepository<PricelistItems> PricelistItemsRepository => _pricelistItemsRepository ?? (_pricelistItemsRepository = new GenericRepository<PricelistItems>(_context));
        public GenericRepository<ResidentalBuilding> ResidentialBuildingRepository => _residentialBuildingRepository ?? (_residentialBuildingRepository = new GenericRepository<ResidentalBuilding>(_context));
        public GenericRepository<Risk> RiskRepository => _riskRepository ?? (_riskRepository = new GenericRepository<Risk>(_context));
        public GenericRepository<RiskCategory> RiskCategoryRepository => _riskCategoryRepository ?? (_riskCategoryRepository = new GenericRepository<RiskCategory>(_context));
        public GenericRepository<RiskItem> RiskItemRepository => _riskItemRepository ?? (_riskItemRepository = new GenericRepository<RiskItem>(_context));
        public GenericRepository<Vehicle> VehicleRepository => _vehicleRepository ?? (_vehicleRepository = new GenericRepository<Vehicle>(_co
namespace Assets.Scripts.voxel
    public class World : MonoBehaviour
    {
        public GameObject ChunkPreFab;
        public Dictionary<WorldPos, Chunk> Chunks = new Dictionary<WorldPos, Chunk>();
        public string WorldName = "world";
        public void CreateChunk(int x, int y, int z)
        {
            var worldPos = new WorldPos(x, y, z);
            var newChunkObject =
                Instantiate(ChunkPreFab, new Vector3(x, y, z), Quaternion.Euler(Vector3.zero)) as GameObject;
            if (newChunkObject == null) return;
            var newChunk = newChunkObject.GetComponent<Chunk>();
            newChunk.WorldPos = worldPos;
            newChunk.World = this;
            Chunks.Add(worldPos, newChunk);
            var terrainGen = new TerrainGen();
            newChunk = terrainGen.ChunkGen(newChunk);
            newChunk.SetBlocksUnModified();
            var loaded = Serialization.LoadChunk(newChunk);
        }
        private void DestroyChunk(WorldPos pos)
  

            DestroyChunk(pos.X, pos.Y, pos.Z);
        }
        public int ChunksInMemory
        {
            get
            {
                return Chunks.Count;
            }
        }
        public void DestroyChunk(int x, int y, int z)
        {
            Chunk chunk;
            if (!Chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
                return;
            Serialization.SaveChunk(chunk);
            Destroy(chunk.gameObject);
            Chunks.Remove(new WorldPos(x, y, z));
        }
        public Chunk GetChunk(WorldPos pos)
        {
            return GetChunk(pos.X, pos.Y, pos.Z);
        }
        public Chunk GetChunk(int x, int y, int z)
        {
            float multiple = Chunk.ChunkSize;
            var pos = new WorldPos
            {
                X = Mathf.FloorToInt(x/multiple)*Chunk.ChunkSize,
                Y = Mathf.FloorToInt(y/multiple)*Chunk.ChunkSize,
                Z = Mathf.FloorToInt(z/multiple)*Chunk.ChunkSize
            }

            Chunk containerChunk;
            Chunks.TryGetValue(pos, out containerChunk);
            return containerChunk;
        }
        public Block GetBlock(int x, int y, int z)
        {
            var containerChunk = GetChunk(x, y, z);
            if (containerChunk == null)
                return new BlockAir();
            var block = containerChunk.GetBlock(
                x - containerChunk.WorldPos.X,
                y - containerChunk.WorldPos.Y,
                z - containerChunk.WorldPos.Z);
            return block;
        }
        public void SetBlock(int x, int y, int z, Block block)
        {
            var chunk = GetChunk(x, y, z);
            if (chunk == null)
                return;
            chunk.SetBlock(x - chunk.WorldPos.X, y - chunk.WorldPos.Y, z - chunk.WorldPos.Z, block);
            chunk.ShouldUpdate = true;
            UpdateIfEqual(x - chunk.WorldPos.X, 0, new WorldPos(x - 1, y, z));
            UpdateIfEqual(x - chunk.WorldPos.X, Chunk.
namespace Spark.Compiler.Javascript.ChunkVisitors
    public abstract class CodeProcessingChunkVisitor : ChunkVisitor
    {
        public abstract Snippets Process(Chunk chunk, Snippets code);
        
        protected override void Visit(GlobalVariableChunk chunk)
        {
            chunk.Value = Process(chunk, chunk.Value);
            base.Visit(chunk);
        }
        protected override void Visit(LocalVariableChunk chunk)
        {
            chunk.Value = Process(chunk, chunk.Value);
            base.Visit(chunk);
        }
        protected override void Visit(DefaultVariableChunk chunk)
        {
            chunk.Value = Process(chunk, chunk.Value);
            base.Visit(chunk);
        }
        protected override void Visit(AssignVariableChunk chunk)
        {
            chunk.Value = Process(chunk, chunk.Value);
            base.Visit(chunk);
        }
        protected override void Visit(SendExpressionChunk chunk)
        {
            chunk.Code = Process(chunk
namespace iBupro2Model.Repositories
    public interface IRepositoryService
    {
        IStudentPlanRepository StudentPlanRepositoryCreateInstance();
        IStudentFieldRepository StudentFieldRepositoryCreateInstance();
        ISubjectRepository SubjectRepositoryCreateInstace();
        IProjectRepository ProjectRepositoryCreateInstance();
        IDiplomProjectRepository DiplomProjectRepositoryCreateInstance();
        IUserRepository UserRepositoryCreateInstance();
        IRoleRepository RoleRepositoryCreateInstance();
        IDepartmentRepository DepartmentRepositoryCreateInstance();
        ITagRepository TagRepositoryCreateInstance();
        IHistoryRepository HistoryRepositoryCreateInstance();
        IOwnerRequestRepository OwnerRequestRepositoryCreateInstance();
        IProjectSourceRepository ProjectSourceRepositoryCreateInstance();
		ISemesterRepository SemesterRepositoryCreateInstance();
		IEnrollmentRepository EnrollmentRepositoryCreateInstance();
		ITagCategoryRep
namespace iExchange.StateServer.Adapter.AccountBLL
    internal sealed class AccountInstrument
    {
        internal AccountInstrument(Account owner, Instrument instrument)
        {
            this.Owner = owner;
            this.Instrument = instrument;
            this.InstrumentId = instrument.Id;
        }
        internal Account Owner { get; private set; }
        internal Instrument Instrument { get; private set; }
        internal Guid InstrumentId { get; private set; }
        internal decimal BuyLotBalanceSum { get; private set; }
        internal decimal SellLotBalanceSum { get; private set; }
        public override int GetHashCode()
        {
            return this.InstrumentId.GetHashCode();
        }
        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            AccountInstrument other = obj as AccountInstrument;
            if (other == null) return false;
            return this.InstrumentId == other.InstrumentId;
 
namespace B4F.TotalGiro.Stichting
    public class AssetManagerInstrumentCollection : TransientDomainCollection<IAssetManagerInstrument>, IAssetManagerInstrumentCollection
    {
        public AssetManagerInstrumentCollection()
            : base() { }
        public AssetManagerInstrumentCollection(IAssetManager parent)
            : base()
        {
            Parent = parent;
        }
        public IAssetManager Parent { get; set; }
        public void AddInstrument(ITradeableInstrument instrument)
        {
            if (instrument == null)
                throw new ApplicationException("It is not possible to map a null instrument to an assetmanager");
            
            if (this.Where(u => u.Instrument.Key == instrument.Key).Count() > 0)
                throw new ApplicationException(string.Format("The instrument {0} is already mapped to assetmanager {1}", instrument.DisplayNameWithIsin, Parent.CompanyName));
            this.Add(new AssetManagerInstrument(Parent, instr
namespace Bin.Helpers
    internal class FunctionHelpers
    {
        #region members
        private Repository.ArizaSetiRespository _arizaSetiRepositoryInsatnce;
        private Repository.FirmaRepository _firmaRepositoryInstance;
        private Repository.KullaniciRespository _kullaniciRepositoryInstance;
        private Repository.MailAdresiRepository _mailAdresRepositoryInstance;
        private Repository.MailGorevRepository _mailGorevRepositoryInstance;
        private Repository.MailSablonRepository _mailSablonRepositoryInstance;
        private Repository.MarkaRespository _markaRepositoryInstance;
        private Repository.MusteriRepository _musteriRepositoryInstance;
        private Repository.ServisDurumuRespository _servisDurumuRepositoryInstance;
        private Repository.ServisRepository _servisRepositoryInstance;
        private Repository.StokRepository _stokRepositoryInstance;
        private Repository.UcretRepository _ucretRepositoryInstance;
        private Repo

        private Repository.UrunTipiRepository _urunTipiRepositoryInstance;
        
        #endregion
        #region properties
        public Repository.ArizaSetiRespository ArizaSetiRespository 
        {
            get { return _arizaSetiRepositoryInsatnce; }
        }
        public Repository.FirmaRepository FirmaRepository
        {
            get { return _firmaRepositoryInstance; }
        }
        public Repository.KullaniciRespository KullaniciRespository
        {
            get { return _kullaniciRepositoryInstance; }
        }
        public Repository.MailAdresiRepository MailAdresiRepository
        {
            get { return _mailAdresRepositoryInstance; }
        }
        public Repository.MailGorevRepository MailGorevRepository
        {
            get { return _mailGorevRepositoryInstance; }
        }
        public Repository.MailSablonRepository MailSablonRepository
        {
            get { return _mailSablonRepositoryInstance; }
        }
        publi

        {
            get { return _markaRepositoryInstance; }
        }
        public Repository.MusteriRepository MusteriRepository
        {
            get { return _musteriRepositoryInstance; }
        }
        public Repository.ServisDurumuRespository ServisDurumuRespository
        {
            get { return _servisDurumuRepositoryInstance; }
        }
        public Repository.ServisRepository ServisRepository
        {
            get { return _servisRepositoryInstance; }
        }
        public Repository.StokRepository StokRepository
        {
            get { return _stokRepositoryInstance; }
        }
        public Repository.UcretRepository UcretRepository
        {
            get { return _ucretRepositoryInstance; }
        }
        public Repository.UrunRepository UrunRepository
        {
            get { return _urunRepositoryInstance; }
        }
        public Repository.UrunTipiRepository UrunTipiRepository
        {
            get { return _urunTipiReposi
namespace ePortafolioMVC.Models
    public static class RepositoryFactory
    {
        private static AlumnoRepository myAlumnoRepository = null;
        public static AlumnoRepository GetAlumnoRepository()
        {
            if (myAlumnoRepository == null)
            {
                myAlumnoRepository = new AlumnoRepository();
            }
            return myAlumnoRepository;
        }
        private static ArchivoRepository myArchivoRepository = null;
        public static ArchivoRepository GetArchivoRepository()
        {
            if (myArchivoRepository == null)
            {
                myArchivoRepository = new ArchivoRepository();
            }
            return myArchivoRepository;
        }
        private static CursoRepository myCursoRepository = null;
        public static CursoRepository GetCursoRepository()
        {
            if (myCursoRepository == null)
            {
                myCursoRepository = new CursoRepository();
            }
        

        }
        private static GrupoRepository myGrupoRepository = null;
        public static GrupoRepository GetGrupoRepository()
        {
            if (myGrupoRepository == null)
            {
                myGrupoRepository = new GrupoRepository();
            }
            return myGrupoRepository;
        }
        private static ProfesorRepository myProfesorRepository = null;
        public static ProfesorRepository GetProfesorRepository()
        {
            if (myProfesorRepository == null)
            {
                myProfesorRepository = new ProfesorRepository();
            }
            return myProfesorRepository;
        }
        private static ResultadoProgramaRepository myResultadoProgramaRepository = null;
        public static ResultadoProgramaRepository GetResultadoProgramaRepository()
        {
            if (myResultadoProgramaRepository == null)
            {
                myResultadoProgramaRepository = new ResultadoProgramaRepository();
       

            return myResultadoProgramaRepository;
        }
        private static ResultadoRubricaRepository myResultadoRubricaRepository = null;
        public static ResultadoRubricaRepository GetResultadoRubricaRepository()
        {
            if (myResultadoRubricaRepository == null)
            {
                myResultadoRubricaRepository = new ResultadoRubricaRepository();
            }
            return myResultadoRubricaRepository;
        }
        private static TrabajoRepository myTrabajoRepository = null;
        public static TrabajoRepository GetTrabajoRepository()
        {
            if (myTrabajoRepository == null)
            {
                myTrabajoRepository = new TrabajoRepository();
            }
            return myTrabajoRepository;
        }
        private static SeccionRepository mySeccionRepository = null;
        public static SeccionRepository GetSeccionRepository()
        {
            if (mySeccionRepository == null)
            {
          
namespace ManagerConsole.UI
    public partial class ChangePriceForFPLCalc : XamDialogWindow
    {
        private string _ExchangCode;
        private ObservableCollection<InstrumentForFloatingPLCalc> _InstrumentForFloatingPLCalcList;
        public ChangePriceForFPLCalc(string exchangeCode)
        {
            InitializeComponent();
            this.ExchangeCodeTextBlock.Text = exchangeCode;
            this._ExchangCode = exchangeCode;
            this._InstrumentForFloatingPLCalcList = new ObservableCollection<InstrumentForFloatingPLCalc>();
            this.GetInstrumentForFloatingPLCalc();
        }
        private void GetInstrumentForFloatingPLCalc()
        {
            ConsoleClient.Instance.GetInstrumentForFloatingPLCalc(this._ExchangCode, this.GetInstrumentForFloatingPLCalcCallback);
        }
        public void GetInstrumentForFloatingPLCalcCallback(List<CommonInstrumentForFloatingPLCalc> instrumentForFloatingPLCalcs)
        {
            this.Dispatcher.BeginInvoke((

            {
                foreach (CommonInstrumentForFloatingPLCalc commonEntity in result)
                {
                    this._InstrumentForFloatingPLCalcList.Add(new InstrumentForFloatingPLCalc(commonEntity));
                }
                this._ChangePriceGrid.ItemsSource = this._InstrumentForFloatingPLCalcList;
            }, instrumentForFloatingPLCalcs);
        }
        private void ChangePriceGrid_Click(object sender, Infragistics.Controls.Grids.CellClickedEventArgs e)
        {
            InstrumentForFloatingPLCalc instrumentForPL = e.Cell.Row.Data as InstrumentForFloatingPLCalc;
            this.InstrumentText.Text = instrumentForPL.InstrumentCode;
            this.BidText.Text = instrumentForPL.Bid;
            this.SpreadText.Text = instrumentForPL.SpreadPoint.ToString();
        }
        private void SaveButton_Click(object sender, RoutedEventArgs e)
        {
            if (!this.CheckData()) return;
            InstrumentForFloatingPLCalc instrumen

            int spreadPoint = int.Parse(this.SpreadText.Text);
            ConsoleClient.Instance.UpdateInstrumentForFloatingPLCalc(this._ExchangCode, instrumentForPL.InstrumentId, this.BidText.Text, spreadPoint, this.UpdateInstrumentForFloatingPLCalcCallback);
        }
        private bool CheckData()
        {
            if (!Toolkit.IsValidNumber(this.SpreadText.Text))
            {
                return false;
            }
            if (!Toolkit.IsNumber(this.BidText.Text))
            {
                return false;
            }
            return true;
        }
        private void SetInstrumentForFloatingPLCalc()
        {
            InstrumentForFloatingPLCalc instrumentForPL = this._ChangePriceGrid.ActiveCell.Row.Data as InstrumentForFloatingPLCalc;
            if (instrumentForPL == null) return;
            instrumentForPL.Bid = this.BidText.Text;
            ExchangeSettingManager settingManager= App.MainFrameWindow.ExchangeDataManager.GetExchangeSetting(this._Exc
namespace MusicSchoolClass.Models
    [Table("Instruments")]
    public class Instruments : EntityBase
    {
        #region Attributes
        private Int32 id;
        private String instrumentName;
        private String instrumentCategory;
        private String instrumentTallCat;
        private Boolean location;
        #endregion
        #region Properties
        [Key]
        [Column("id")]
        public int Id
        {
            get { return id; }
            set { id = value; OnPropertyChanged("Id"); }
        }
        [Column("instrumentName")]
        public String InstrumentName
        {
            get{return instrumentName;}
            set{instrumentName = value;this.OnPropertyChanged("InstrumentName");}
        }
        [Column("instrumentCategory")]
        public String InstrumentCategory
        {
            get{return instrumentCategory;}
            set{instrumentCategory = value;this.OnPropertyChanged("InstrumentCategory");}
        }
        [Column("in
namespace Patient_Transport_Migration.Controllers
    public class DispatchWerknemersController : Controller
    {
        private Context db = new Context();
        public ActionResult Index()
        {
            return View(db.tblDispatchWerknemers.ToList());
        }
        public ActionResult Details(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            DispatchWerknemer dispatchWerknemer = db.tblDispatchWerknemers.Find(id);
            if (dispatchWerknemer == null)
            {
                return HttpNotFound();
            }
            return View(dispatchWerknemer);
        }
        public ActionResult Create()
        {
            return View();
        }
        [HttpPost]
        [ValidateAntiForgeryToken]
        public ActionResult Create([Bind(Include = "Id,Gebruikersnaam")] DispatchWerknemer dispatchWerknemer)
        {
            if (ModelState.IsVa

            {
                db.tblDispatchWerknemers.Add(dispatchWerknemer);
                db.SaveChanges();
                return RedirectToAction("Index");
            }
            return View(dispatchWerknemer);
        }
        public ActionResult Edit(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            DispatchWerknemer dispatchWerknemer = db.tblDispatchWerknemers.Find(id);
            if (dispatchWerknemer == null)
            {
                return HttpNotFound();
            }
            return View(dispatchWerknemer);
        }
        [HttpPost]
        [ValidateAntiForgeryToken]
        public ActionResult Edit([Bind(Include = "Id,Gebruikersnaam")] DispatchWerknemer dispatchWerknemer)
        {
            if (ModelState.IsValid)
            {
                db.Entry(dispatchWerknemer).State = EntityState.Modified;
                db.SaveChanges();
     

            }
            return View(dispatchWerknemer);
        }
        public ActionResult Delete(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            DispatchWerknemer dispatchWerknemer = db.tblDispatchWerknemers.Find(id);
            if (dispatchWerknemer == null)
            {
                return HttpNotFound();
            }
            return View(dispatchWerknemer);
        }
        [HttpPost, ActionName("Delete")]
        [ValidateAntiForgeryToken]
        public ActionResult DeleteConfirmed(int id)
        {
            DispatchWerknemer dispatchWerknemer = db.tblDispatchWerknemers.Find(id);
            db.tblDispatchWerknemers.Remove(dispatchWerknemer);
            db.SaveChanges();
            return RedirectToAction("Index");
        }
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                
namespace Axiom.BusinessObjects
    public class DispatchMediaType
    {
        private static Logger logger = LogManager.GetCurrentClassLogger();
        private int             m_dispatchMediaTypeID;
        private string          m_mediaTypeName;
        #region GetSetVariables
        public int dispatchMediaTypeID
        {
            get { return m_dispatchMediaTypeID; }
        }
        public string mediaTypeName
        {
            get { return m_mediaTypeName; }
            set { m_mediaTypeName = value; }
        }
        #endregion
        public DispatchMediaType()
        {
            m_mediaTypeName = "";
        }
        public DispatchMediaType(int dispatchMediaTypeID)
        {
            m_dispatchMediaTypeID = dispatchMediaTypeID;
            ReadDispatchMediaTypeDetails();
        }
        public void ReadDispatchMediaTypeDetails()
        {
            DbConnection conn = new SqlConnection(GlobalSettings.connectionString);
            try
            {


                DbCommand cmdDispatchMediaTypeDetails = conn.CreateCommand();
                cmdDispatchMediaTypeDetails.CommandType = CommandType.StoredProcedure;
                cmdDispatchMediaTypeDetails.CommandText = "spSelectDispatchMediaTypeDetails";
                DbParameter param = cmdDispatchMediaTypeDetails.CreateParameter();
                param.ParameterName = "@DispatchMediaTypeID";
                param.Value = m_dispatchMediaTypeID;
                cmdDispatchMediaTypeDetails.Parameters.Add(param);
                DbDataReader rdrDispatchMediaTypeDetails = cmdDispatchMediaTypeDetails.ExecuteReader();
                rdrDispatchMediaTypeDetails.Read();
                if (!rdrDispatchMediaTypeDetails.IsDBNull(rdrDispatchMediaTypeDetails.GetOrdinal("MediaTypeName")))
                    m_mediaTypeName = (string)rdrDispatchMediaTypeDetails["MediaTypeName"];
                rdrDispatchMediaTypeDetails.Close();
            }
            catch (Exception ex)
           

                logger.Error(ex.Message); 
                throw ex;
            }
            finally
            {
                conn.Close();
            }
        }
        public void AddNew()
        {
            SqlConnection conn = new SqlConnection(GlobalSettings.connectionString);
            try
            {
                conn.Open();
                SqlCommand cmd = new SqlCommand("spAddDispatchMediaType", conn);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@MediaTypeName", SqlDbType.NVarChar, 200).Value = m_mediaTypeName;
                SqlParameter paramDispatchMediaTypeID = cmd.CreateParameter();
                paramDispatchMediaTypeID.ParameterName = "@DispatchMediaTypeID";
                paramDispatchMediaTypeID.SqlDbType = SqlDbType.Int;
                paramDispatchMediaTypeID.Direction = ParameterDirection.Output;
                cmd.Parameters.Add(paramDispatchMediaTypeID);
                cmd.ExecuteN
namespace Incubakery
    public class World
    {
        private readonly WorldFactory worldFactory;
        private Chunk[,,] chunks;
        private ConcurrentBag<ChunkPosition> renderQueue = new ConcurrentBag<ChunkPosition>();
        public bool IsLoading { get; set; }
        public ModuleBase Generator { get; private set; }
        public World(WorldFactory worldFactory, ModuleBase generator)
        {
            this.worldFactory = worldFactory;
            this.Generator = generator;
        }
        public void Initialize()
        {
            this.chunks = new Chunk[
                Constants.Context.MaxChunksInXDimension,
                Constants.Context.MaxChunksInYDimension,
                Constants.Context.MaxChunksInZDimension];
            for (int x = 0; x < Constants.Context.MaxChunksInXDimension; ++x)
            {
                for (int y = 0; y < Constants.Context.MaxChunksInYDimension; ++y)
                {
                    for (int z = 0; z < Constan

                    {
                        this.chunks[x, y, z] = this.CreateChunk(new ChunkPosition(x, y, z));
                    }
                }
            }
            WorldContext.Instance.EnqueueMessage(new GenerateWorldMessage(this));
        }
        public Chunk[,,] GetChunksCopy()
        {
            return (Chunk[,,])chunks.Clone();
        }
        public void Tick_UnityThread()
        {
            ChunkPosition chunkPosition;
            while (this.renderQueue.TryTake(out chunkPosition))
            {
                this.chunks[chunkPosition.X, chunkPosition.Y, chunkPosition.Z]
                    .RenderMeshIfRequired_UnityThread(this.worldFactory);
            }
        }
        public void AddToRenderQueue(ChunkPosition chunkPosition)
        {
            this.renderQueue.Add(chunkPosition);
        }
        public IEnumerable<Chunk> GetAllChunks()
        {
            return this.chunks.Cast<Chunk>().ToList();
        }
        public Chunk TryGet

        {
            if (!chunkPosition.InRange)
            {
                return null;
            }
            return this.chunks[chunkPosition.X, chunkPosition.Y, chunkPosition.Z];
        }
        public BlockInstance GetBlockOrDefault(WorldPosition worldPosition)
        {
            var chunkPosition = worldPosition.ToChunkPosition();
            var chunk = this.TryGetChunk(chunkPosition);
            if (chunk == null)
            {
                if (worldPosition.IsWorldContainer())
                {
                    return BlockInstance.WorldContainer;
                }
                return BlockInstance.Air;
            }
            var blockPosition = worldPosition.ToBlockPosition();
            return chunk.GetBlockOrDefault(blockPosition);
        }
        public bool IsChunkSideOpaqueOrHidden(ChunkPosition chunkPosition, Direction direction)
        {
            var chunk = this.TryGetChunk(chunkPosition);
            if (chunk == null)
            {
 
namespace MonkeyCancelTest
    public class Instrument_Update_Test
    {
        Instrument CreateInstrument(ITTInstrumentState instrumentState)
        {
            var orderbook = Substitute.For<ITTOrderBook>();
            instrumentState.Orderbook.Returns(orderbook);
            instrumentState.Alias.Returns("ZNU5");
            return new Instrument(instrumentState);
        }
        [Fact]
        public void EnableBidCxl_Test()
        {
            var instrumentState = Substitute.For<ITTInstrumentState>();
            var instrument = CreateInstrument(instrumentState);
            instrument.EnableBidCxl = false;
            Assert.Equal(instrument.EnableBidCxl, false);
            instrument.EnableBidCxl = true;
            Assert.Equal(instrument.EnableBidCxl, true);
            instrument.UpdateIfModified();
            instrumentState.Received(1).InvokeAction(Arg.Any<Action>());
            instrumentState.ClearReceivedCalls();
            instrument.EnableBidCxl = true;

            Assert.Equal(instrument.EnableBidCxl, true);
            instrument.UpdateIfModified();
            instrumentState.DidNotReceive().InvokeAction(Arg.Any<Action>());
            instrumentState.ClearReceivedCalls();
            instrument.EnableBidCxl = false;
            Assert.Equal(instrument.EnableBidCxl, false);
            instrument.UpdateIfModified();
            instrumentState.Received(1).InvokeAction(Arg.Any<Action>());
            instrumentState.ClearReceivedCalls();
            instrument.EnableBidCxl = false;
            Assert.Equal(instrument.EnableBidCxl, false);
            instrument.UpdateIfModified();
            instrumentState.DidNotReceive().InvokeAction(Arg.Any<Action>());
            instrumentState.ClearReceivedCalls();
        }
        [Fact]
        public void EnableAskCxl_Test()
        {
            var instrumentState = Substitute.For<ITTInstrumentState>();
            var instrument = CreateInstrument(instrumentState);
            instrum

            Assert.Equal(instrument.EnableAskCxl, false);
            instrument.EnableAskCxl = true;
            Assert.Equal(instrument.EnableAskCxl, true);
            instrument.UpdateIfModified();
            instrumentState.Received(1).InvokeAction(Arg.Any<Action>());
            instrumentState.ClearReceivedCalls();
            instrument.EnableAskCxl = true;
            Assert.Equal(instrument.EnableAskCxl, true);
            instrument.UpdateIfModified();
            instrumentState.DidNotReceive().InvokeAction(Arg.Any<Action>());
            instrumentState.ClearReceivedCalls();
            instrument.EnableAskCxl = false;
            Assert.Equal(instrument.EnableAskCxl, false);
            instrument.UpdateIfModified();
            instrumentState.Received(1).InvokeAction(Arg.Any<Action>());
            instrumentState.ClearReceivedCalls();
            instrument.EnableAskCxl = false;
            Assert.Equal(instrument.EnableAskCxl, false);
            instrument.UpdateIf
namespace Server.Core
    public static class ChunkDifferentiator
    {
        public static IEnumerable<DifferenceChunk> GetUpdatedChunks(List<Chunk> chunksFromCachedFile, List<Chunk> chunksFromCurrentFile)
        {
            List<DifferenceChunk> differenceChunks = new List<DifferenceChunk>(chunksFromCurrentFile.Count);
            foreach (Chunk currentChunk in chunksFromCurrentFile)
            {
                Chunk cachedChunk = chunksFromCachedFile.FirstOrDefault(x => x.ChunkHash.Equals(currentChunk.ChunkHash));
                DifferenceChunk differenceChunk;
                if (cachedChunk == null)
                    differenceChunk = new DifferenceChunk(currentChunk.ChunkInformation, currentChunk.FileChunkNumber, -1);
                else
                    differenceChunk = new DifferenceChunk(new byte[0], currentChunk.FileChunkNumber, cachedChunk.FileChunkNumber);
                differenceChunks.Add(differenceChunk);
            }
            return differenceChunks
namespace Zazz.Core.Interfaces
    public interface IUoW : IDisposable
    {
        ILinkedAccountRepository LinkedAccountRepository { get; }
        ICommentRepository CommentRepository { get; }
        IEventRepository EventRepository { get; }
        IFollowRepository FollowRepository { get; }
        IFollowRequestRepository FollowRequestRepository { get; }
        IAlbumRepository AlbumRepository { get; }
        IPhotoRepository PhotoRepository { get; }
        IUserRepository UserRepository { get; }
        IValidationTokenRepository ValidationTokenRepository { get; }
        IFacebookSyncRetryRepository FacebookSyncRetryRepository { get; }
        IFeedRepository FeedRepository { get; }
        IPostRepository PostRepository { get;}
        IFacebookPageRepository FacebookPageRepository { get; }
        IFeedPhotoRepository FeedPhotoRepository { get; }
        INotificationRepository NotificationRepository { get; }
        ICategoryStatRepository CategoryStatRepository { get; 
namespace Bacnet_Test_Final
    
         class TsmProcessor
    { 
    
       static node[] invoke_id_array;
       static byte pos;
  
         static TsmProcessor()
       {
           invoke_id_array = new node[255];
            for(int i=0;i<255;i++)
            {
                invoke_id_array[i].id=0;
            }
           pos = 0;
       }
        internal static byte next_free_id(UInt32 temp)
         {
             byte now = pos;
             pos++;
            while(pos!=now)
            {
                if (invoke_id_array[pos].id == 0)
                {
                    invoke_id_array[pos].id = 1;
                    invoke_id_array[pos].device_id = temp;
                    return pos;
                }
                else 
                    pos++;
                if(pos==100)
                {
                    pos = 0;
                }
            }
        }
        internal static void free_invoke_id(Byte id)
        {
            invoke_id_array[pos]
namespace Blarg.GameFramework.TileMap
	public class TileMap : TileContainer, IDisposable
	{
		#region Fields
		readonly Vector3 _position;
		readonly BoundingBox _bounds;
		#endregion
		#region Properties
		public readonly TileChunk[] Chunks;
		public readonly TileMeshCollection TileMeshes;
		public readonly ChunkVertexGenerator VertexGenerator;
		public readonly ITileMapLighter Lighter;
		public byte AmbientLightValue;
		public byte SkyLightValue;
		public readonly int ChunkWidth;
		public readonly int ChunkHeight;
		public readonly int ChunkDepth;
		public readonly int WidthInChunks;
		public readonly int HeightInChunks;
		public readonly int DepthInChunks;
		public override int Width
		{
			get { return ChunkWidth * WidthInChunks; }
		}
		public override int Height
		{
			get { return ChunkHeight * HeightInChunks; }
		}
		public override int Depth
		{
			get { return ChunkDepth * DepthInChunks; }
		}
		public override int MinX
		{
			get { return 0; }
		}
		public override int MinY


			get { return 0; }
		}
		public override int MinZ
		{
			get { return 0; }
		}
		public override int MaxX
		{
			get { return Width - 1; }
		}
		public override int MaxY
		{
			get { return Height - 1; }
		}
		public override int MaxZ
		{
			get { return Depth - 1; }
		}
		public override Vector3 Position
		{
			get { return _position; }
		}
		public override BoundingBox Bounds
		{
			get { return _bounds; }
		}
		#endregion
		public TileMap(int chunkWidth, int chunkHeight, int chunkDepth,
		               int widthInChunks, int heightInChunks, int depthInChunks,
		               TileMeshCollection tileMeshes,
		               ChunkVertexGenerator vertexGenerator,
		               ITileMapLighter lighter
		               )
		{
			if (tileMeshes == null)
				throw new ArgumentNullException("tileMeshes");
			if (vertexGenerator == null)
				throw new ArgumentNullException("vertexGenerator");
			TileMeshes = tileMeshes;
			VertexGenerator = vertexGenerator;
			Lighter = lighter;
			Chu

			ChunkHeight = chunkHeight;
			ChunkDepth = chunkDepth;
			WidthInChunks = widthInChunks;
			HeightInChunks = heightInChunks;
			DepthInChunks = depthInChunks;
			AmbientLightValue = 0;
			SkyLightValue = Tile.LIGHT_VALUE_SKY;
			int numChunks = widthInChunks * heightInChunks * depthInChunks;
			Chunks = new TileChunk[numChunks];
			for (int y = 0; y < heightInChunks; ++y)
			{
				for (int z = 0; z < depthInChunks; ++z)
				{
					for (int x = 0; x < widthInChunks; ++x)
					{
						TileChunk chunk = new TileChunk(
							x * chunkWidth,
							y * chunkHeight,
							z * chunkDepth,
							chunkWidth,
							chunkHeight,
							chunkDepth,
							this
							);
						int index = GetChunkIndex(x, y, z);
						Chunks[index] = chunk;
					}
				}
			}
			_position = Vector3.Zero;
			_bounds = new BoundingBox();
			_bounds.Min = Vector3.Zero;
			_bounds.Max.Set(Width, Height, Depth);
		}
		public void UpdateVertices()
		{
			for (int i = 0; i < Chunks.Length; ++i)
				UpdateChunkVerti
namespace POS.BLL.Security.IOC
    public partial class SecurityRepositoryModule : NinjectModule
    {
        public override void Load()
        {
            Bind<IAccessLogRepository>().To<AccessLogRepository>();
            Bind<IAdditionalOperationPermissionRepository>().To<AdditionalOperationPermissionRepository>();
            Bind<IAdditionalScreenPermissionRepository>().To<AdditionalScreenPermissionRepository>();
            Bind<IApplicationPolicyRepository>().To<ApplicationPolicyRepository>();
            Bind<IApplicationRepository>().To<ApplicationRepository>();
            Bind<IMenuRepository>().To<MenuRepository>();
            Bind<IModuleRepository>().To<ModuleRepository>();
            Bind<IRoleRepository>().To<RoleRepository>();
            Bind<IRoleWiseScreenPermissionRepository>().To<RoleWiseScreenPermissionRepository>();
            Bind<IRoleWiseOperationPermissionRepository>().To<RoleWiseOperationPermissionRepository>();
            Bind<IScreenRepository>()
namespace BRE.Lib.TermStructures
    public class HedgeOptionsReader
    {
        #region Members
        private Dictionary<InstrumentName, HedgeOptions> m_HedgeOptionsByInstrumentName;
        private LogHub m_Log;
        #region Constructors
        public HedgeOptionsReader(LogHub log)
        {
            m_Log = log;
            m_HedgeOptionsByInstrumentName = new Dictionary<InstrumentName, HedgeOptions>();
        }
        #region no Properties
        #region Public Methods
        public bool TryReadHedgeOptionsInformation(InstrumentInfoQuery queryResult)
        {
            bool isSuccess = false;
            InstrumentName quoteInstrument = queryResult.InstrumentName;
            List<InstrumentInfoItem> instrumentInfoItems = queryResult.Results;
            foreach (InstrumentInfoItem instrumentInfoItem in instrumentInfoItems)
            {
                if (m_HedgeOptionsByInstrumentName.ContainsKey(quoteInstrument))
                {
                    m_Log.New

                    continue;
                }
                else
                {
                    string instrumentNameTT = instrumentInfoItem.InstrumentNameTT;
                    string instrumentNameDatabase = instrumentInfoItem.InstrumentNameDatabase;
                    HedgeOptions hedgeOptions;
                    if (HedgeOptions.TryCreateHedgeOptions(quoteInstrument, instrumentNameTT, instrumentNameDatabase, m_Log, out hedgeOptions))
                    {
                        if (!TryGenerateHedgeOptions(quoteInstrument, instrumentInfoItem, hedgeOptions))
                            m_Log.NewEntry(LogLevel.Error, "Failed to generate hedge options for instrument {0}.", quoteInstrument);
                        else
                        {
                            m_HedgeOptionsByInstrumentName.Add(quoteInstrument, hedgeOptions);
                            isSuccess = true;
                        }
                    }
                    else
              

                }
            }
            return isSuccess;
        }
        public Dictionary<InstrumentName, HedgeOptions> GetHedgeOptionsByInstrumentName()
        {
            return m_HedgeOptionsByInstrumentName;
        }
        #region Private Methods
        public bool TryGenerateHedgeOptions(InstrumentName quoteInstrument, InstrumentInfoItem instrumentInfoItem, HedgeOptions hedgeOptions)
        {
            bool isSuccess = false;
            string hedgeOptionString = instrumentInfoItem.HedgeOptions;
            char seperator = '|';
            string[] hedgeOptionUnits = hedgeOptionString.Split(new char[] { seperator }, StringSplitOptions.RemoveEmptyEntries);
            if (hedgeOptionUnits.Length > 0)
            {
                string exchangeName = quoteInstrument.Product.Exchange;
                List<string> matchedResults = new List<string>();
                foreach (string hedgeOptionUnit in hedgeOptionUnits)
                {
                    sepera
namespace BusinessLogic
   public class DataManager
       private IPricesRepository pricesRepository;
       private IAdresRepository adresRepository;
       private IContaktnoeLicoRepository contaktnoeLicoRepository;
       private IClientsRepository clientsRepository;
       private IDogovorRepository dogovoraRepository;
       private IZakazyRepository zakazyRepository;
       private IZakazyAdresyRepository zakazyAdresyRepository;
       private IUsersRepository usersRepository;
       private IRazrabotkiRepository razrabotkiRepository;
       public DataManager(IPricesRepository pricesRepository, IAdresRepository adresRepository, IContaktnoeLicoRepository contaktnoeLicoRepository, IClientsRepository clientsRepository, IDogovorRepository dogovoraRepository, IZakazyRepository zakazyRepository, IZakazyAdresyRepository zakazyAdresyRepository, IUsersRepository usersRepository, IRazrabotkiRepository razrabotkiRepository)
       {
           this.pricesRepository = pricesRepository;
   

           this.clientsRepository = clientsRepository;
           this.contaktnoeLicoRepository = contaktnoeLicoRepository;
           this.dogovoraRepository = dogovoraRepository;
           this.zakazyRepository = zakazyRepository;
           this.zakazyAdresyRepository = zakazyAdresyRepository;
           this.usersRepository = usersRepository;
           this.razrabotkiRepository = razrabotkiRepository;
       }
      
       
       public IPricesRepository PricesRepository
       {
           get { return pricesRepository;}
       }
       public IAdresRepository AdresRepository
       {
           get { return adresRepository; }
       }
       public IContaktnoeLicoRepository ContaktnoeLicoRepository
       {
           get { return contaktnoeLicoRepository; }
       }
       public IClientsRepository ClientsRepository
       {
           get { return clientsRepository; }
       }
       public IDogovorRepository DogovorRepository
       {
           get { return dogovoraRepos
namespace Beer.World
    private class CacheKey
    {
        public int x;
        public int y;
    }
    public class ChunkCache: IChunkCache
    {
        public ChunkUpdated OnChunkUpdate;
        private IChunkLoader _chunkLoader;
        private Dictionary<CacheKey, Chunk> _cache;
        public ChunkCache(IChunkLoader loader)
        {
            _chunkLoader = loader;
        }
        private CacheKey GetKey(int x, int y)
        {
            CacheKey key = new CacheKey();
            key.x = x;
            key.y = y;
            return key;
        }
        public void GetChunk(int x, int y)
        {
            CacheKey key = GetKey(x, y);
            Chunk stored = _cache[key];
            if (stored == null)
                stored = _chunkLoader.LoadChunk(x, y);
            OnChunkUpdate(stored);
        }
        public void UpdateChunk(Chunk changedChunk)
        {
            _cache[GetKey(changedChunk.x, changedChunk.y)] = changedChunk;
            OnChunkUpdate(c
public class AIScript : ICommand
	private static Point _enemyPosition;
	private static readonly Random Entropy = new Random();
	private const double Dodge = 0.5;
	public void Think(IPlayerApi api)
    {
	    if (api.GetEnemySighted())
	    {
		    ShootAndRun(api);
			return;
	    }
	    RunForItem(api);
    }
	public static bool IsDodge()
	{
		return Entropy.NextDouble() < Dodge;
	}
	private static void ShootAndRun(IPlayerApi api)
	{
		if (IsDodge())
		{
			if ((api.GetHealth() < 40) && (api.GetNumberofVisibleMedkits() > 0))
			{
				api.GetNearestMedkit();
				return;
			}
			if (api.GetNumberOfVisibleBazookas() > 0)
			{
				api.GetNearestBazooka();	
			}
			else
			{
				api.MoveToRandomLocation();
			}
			
			return;
		}
		Shoot(api);
		_enemyPosition = api.GetEnemyPosition();
	}
	private static void Shoot(IPlayerApi api)
	{
		if (api.GetAmmo() == 0)
		{
			api.Stop();
			api.ShootBullet(AimPistol(api));
		}
		else
		{
			api.Stop();
			api.ShootRocket(AimRocket(api));
		}
	}
	pri
namespace SipperFile
	public class PortAssignment
	{
    private  Instrument  instrument;
    private  String      desc;
    public   const int   MaxNumOfPorts = 6;
    public  PortAssignment (Instrument _instrument,
                            string     _desc
                           )
    {
      instrument = _instrument;
      desc       = _desc;
    }
    public  PortAssignment (string  instrumentStr,
                            string  _desc
                           )
    {
      if  (instrumentStr.ToLower () == "none")
      {
        instrument = null;
        desc = "";
        return;
      }
      if  (instrumentStr == "")
      {
        instrument = SipperFile.Instrument.OtherInstrument ();
        desc = instrument.Description ();
      }
      instrument = SipperFile.Instrument.LookUpByShortName(instrumentStr);
      if  (instrument == null)
      {
        instrument = SipperFile.Instrument.OtherInstrument();
        desc = instrument.Description ();
      }
      e
public class ChunkManager : MonoBehaviour {
    public int totalChunks;
    public float lutFadeTime = 2;
    [Space]
    public List<Chunk> glitchChunkList = new List<Chunk>();
    public List<Chunk> airbnbChunkList = new List<Chunk>();
    public List<Chunk> squareChunkList = new List<Chunk>();
    public List<Chunk> awardsChunkList = new List<Chunk>();
    public List<Chunk> gdcChunkList = new List<Chunk>();
    [Space]
    public List<GameObject> glitchObjectList = new List<GameObject>();
    public List<GameObject> airbnbObjectList = new List<GameObject>();
    public List<GameObject> squareObjectList = new List<GameObject>();
    public List<GameObject> awardsObjectList = new List<GameObject>();
    public List<GameObject> gdcObjectList = new List<GameObject>();
    [Space]
    public Texture airbnbLUT;
    public Texture squareLUT;
    public Texture awardsLUT;
    public Texture gdcLUT;
    List<Chunk> currentChunkList;
    Chunk lastChunk;
    int currentSection = 1;
    int c

    List<GameObject> chunkList = new List<GameObject>();
    List<GameObject> specialObjectList = new List<GameObject>();
    void Awake() {
        Manager.chunkManager = this;
    }
    void Start() {
        currentChunkList = glitchChunkList;
        activateObjects(glitchObjectList, null);
        initialize();
    }
    void Update() {
        if (Input.GetKeyUp(KeyCode.Return)) {
            StartCoroutine(moveToNextSection());
        }
    }
    public void initialize() {
        Manager.cameraController.init();
        createChunk(new Vector3(0, 0, -360));
        createNextChunk();        
    }
    void createChunk(Vector3 pos) {
        activeChunk = currentChunkList[currentChunkInList];
        Chunk newChunk = Instantiate(activeChunk, pos, Quaternion.identity) as Chunk;
        newChunk.motherChunk = activeChunk;
        newChunk.gameObject.SetActive(true);
        newChunk.updatePositions();
        chunkList.Add(newChunk.gameObject);
        currentChunkInList++;
    

            currentChunkInList = 0;
    }
    void createNextChunk() {
                
        
        if (newestChunk != null) newChunkPosition = new Vector3(newestChunk.endPoint.transform.position.x, newestChunk.endPoint.transform.position.y, newestChunk.endPoint.transform.position.z);
        activeChunk = currentChunkList[currentChunkInList];
        Chunk newChunk = Instantiate(activeChunk, newChunkPosition, Quaternion.identity) as Chunk;
        newChunk.motherChunk = activeChunk;
        
        newChunk.gameObject.SetActive(true);
        newChunk.updatePositions();
        chunkList.Add(newChunk.gameObject);
        if (chunkList.Count >= totalChunks) {
            GameObject chunkToDestroy = chunkList[0];
            chunkList.Remove(chunkToDestroy);
            Destroy(chunkToDestroy, 1f);
        }
        lastChunk = newestChunk;
        newestChunk = newChunk;
        currentChunkInList++;
        if (currentChunkInList == currentChunkList.Count)
            currentCh
public class World : MonoBehaviour
	public string worldName = "world";
	public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
	public GameObject chunkPrefab;
	public void CreateChunk(int x, int y, int z)
	{
		WorldPos worldPos = new WorldPos(x, y, z);
		GameObject newChunkObject = Instantiate(chunkPrefab, new Vector3(x, y, z), Quaternion.Euler(Vector3.zero)) as GameObject;
		Chunk newChunk = newChunkObject.GetComponent<Chunk>();
		newChunk.pos = worldPos;
		newChunk.world = this;
		chunks.Add(worldPos, newChunk);
		TerrainGeneration terrainGen = new TerrainGeneration();
		newChunk = terrainGen.ChunkGen(newChunk);
		newChunk.SetBlocksUnmodified();
		Serialization.Load(newChunk);
	}
	public void DestroyChunk(int x, int y, int z)
	{
		Chunk chunk = null;
		if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
		{
			Serialization.SaveChunk(chunk);
			Object.Destroy(chunk.gameObject);
			chunks.Remove(new WorldPos(x, y, z));
		}
	}
	public Chunk GetChunk(int x,

	{
		WorldPos pos = new WorldPos();
		float multiple = Chunk.chunkSize;
		pos.x = Mathf.FloorToInt(x / multiple ) * Chunk.chunkSize;
		pos.y = Mathf.FloorToInt(y / multiple ) * Chunk.chunkSize;
		pos.z = Mathf.FloorToInt(z / multiple ) * Chunk.chunkSize;
		Chunk containerChunk = null;
		chunks.TryGetValue(pos, out containerChunk);
		return containerChunk;
	}
	public Block GetBlock(int x, int y, int z)
	{
		Chunk containerChunk = GetChunk(x, y, z);
		if (containerChunk != null)
		{
			Block block = containerChunk.GetBlock(x - containerChunk.pos.x, y -containerChunk.pos.y, z - containerChunk.pos.z);
			return block;
		}
		else
		{
			return new BlockAir();
		}
	}
	public void SetBlock(int x, int y, int z, Block block)
	{
		Chunk chunk = GetChunk(x, y, z);
		if (chunk != null)
		{
			int posX = x - chunk.pos.x;
			int posY = y - chunk.pos.y;
			int posZ = z - chunk.pos.z;
			chunk.SetBlock(posX, posY, posZ, block);
			chunk.update = true;
			UpdateIfEqual(posX, 0, new WorldPos(x - 1, y, 
namespace BusinessFlow.Controllers
    public class ClientsController : Controller
    {
        private readonly IEmployeeRepository employeeRepository;
        private readonly IEnquiryRepository enquiryRepository;
        private readonly IEnquiryDetailsRepository enquiryDetailsRepository;
        private readonly IProjectRepository projectRepository;
        private readonly ITaskRepository taskRepository;
        private readonly ITeamRepository teamRepository;
        private readonly IContactRepository contactRepository;
        private readonly ITeamProjectRepository temprojectRepository;
        private readonly IEmployeeTaskRepository empTaskRepository;
       
        public ClientsController(IEmployeeRepository employeeRepository, IProjectRepository projectRepository, ITaskRepository taskRepository,
            ITeamRepository teamRepository, IContactRepository contactRepository, IEnquiryDetailsRepository enquiryDetailsRepository,
            IEnquiryRepository enquiryRepos
﻿/**********************************************
 * 类作用：   车辆派车事务层处理
 * 建立人：   lysong
 * 建立时间： 2009/04/29
 ***********************************************/
namespace XBase.Business.Office.AdminManager
   public class CarDispatchBus
   {
       #region 获取请车单据号下拉列表(出去未归还的车辆)
       public static DataTable GetCarApplyNo(string CompanyCD, int EmployeeID)
        {
            return CarDispatchDBHelper.GetCarApplyNo(CompanyCD, EmployeeID);
        }
        #endregion
       #region 获取请车单据号下拉列表（出车和未出车的都包括）
       public static DataTable GetAllCarApplyNo(string CompanyCD)
       {
           return CarDispatchDBHelper.GetAllCarApplyNo(CompanyCD);
       }
       #endregion
       #region 添加车辆派送信息
       public static bool InsertCarDispatchInfoData(CarDispatchModel CarDispatchM, out int RetValID)
       {
           return CarDispatchDBHelper.InsertCarDispatchInfoData(CarDispatchM, out RetValID);
       }
       #endregion
       #region 获取车辆派送数据
       public static DataTable GetCarDispatch

       {
           try
           {
               return CarDispatchDBHelper.GetCarDispatchList(CompanyID, RecordNo, DispatchTitle, ApplyID, CarNo, CarMark, IfReturn, pageIndex, pageCount, ord, ref TotalCount);
           }
           catch (System.Exception ex)
           {
               throw ex;
           }
       }
       #endregion
       #region  根据派车ID获取派车信息
       public static DataTable GetCarDispatchByID(string DispatchID)
       {
           try
           {
               return CarDispatchDBHelper.GetCarDispatchByID(DispatchID);
           }
           catch (System.Exception ex)
           {
               throw ex;
           }
       }
       public static DataTable GetCarDispatchByIDPrint(string DispatchID)
       {
           try
           {
               return CarDispatchDBHelper.GetCarDispatchByIDPrint(DispatchID);
           }
           catch (System.Exception ex)
           {
               throw ex;
           }
       }
       #endregion
       #region 
namespace NAudio.SoundFont 
	internal class InstrumentBuilder : StructureBuilder 
	{
		private Instrument lastInstrument = null;
		public override object Read(BinaryReader br) 
		{
			Instrument i = new Instrument();
			string s = Encoding.ASCII.GetString(br.ReadBytes(20));
			if(s.IndexOf('\0') >= 0) 
			{
				s = s.Substring(0,s.IndexOf('\0'));
			}
			i.Name = s;
			i.startInstrumentZoneIndex = br.ReadUInt16();
			if(lastInstrument != null)
			{
				lastInstrument.endInstrumentZoneIndex = (ushort) (i.startInstrumentZoneIndex - 1);
			}
			data.Add(i);
			lastInstrument = i;
			return i;
		}
		public override void Write(BinaryWriter bw,object o) 
		{
			Instrument i = (Instrument) o;
		}
		public override int Length 
		{
			get 
			{
				return 22;
			}
		}
		public void LoadZones(Zone[] zones)
		{
			for(int instrument = 0; instrument < data.Count - 1; instrument++)
			{
				Instrument i = (Instrument) data[instrument];
				i.Zones = new Zone[i.endInstrumentZoneIndex - i.startInstru
namespace Uniframework
    [Serializable]
    public class NetworkInvokePackage
    {
        private NetworkInvokeType invokeType = NetworkInvokeType.Unknown;
        private string sessionId;
        private ClientType clientType = ClientType.SmartClient;
        private HybridDictionary context;
        public NetworkInvokePackage(NetworkInvokeType invokeType, string sessionId)
        {
            this.invokeType = invokeType;
            this.sessionId = sessionId;
            context = new HybridDictionary();
        }
        public NetworkInvokePackage(NetworkInvokeType invokeType, string sessionId, ClientType clientType)
            : this(invokeType, sessionId)
        {
            this.clientType = clientType;
        }
        public NetworkInvokeType InvokeType
        {
            get { return invokeType; }
        }
        public string SessionId
        {
            get { return sessionId; }
        }
        public ClientType ClientType
        {
            get {
namespace ClickWar2.Utility
    public class ChunkBoard<T>
        where T : new()
    {
        public ChunkBoard(int chunkSize = 8)
        {
            this.ChunkSize = chunkSize;
        }
        
        public readonly int ChunkSize;
        protected Dictionary<int, Dictionary<int, T[,]>> m_chunkMap = new Dictionary<int, Dictionary<int, T[,]>>();
        public int ChunkCount
        { get { return m_chunkMap.Count; } }
        public void Clear()
        {
            m_chunkMap.Clear();
        }
        public void GetChunkPosContainsItemAt(int itemX, int itemY, out int chunkX, out int chunkY)
        {
            if (itemX < 0)
            {
                chunkX = (itemX + 1) / ChunkSize;
                --chunkX;
            }
            else
            {
                chunkX = itemX / ChunkSize;
            }
            if (itemY < 0)
            {
                chunkY = (itemY + 1) / ChunkSize;
                --chunkY;
            }
            else
         

                chunkY = itemY / ChunkSize;
            }
        }
        protected void ItemPosToLocalPos(int itemX, int itemY, out int localX, out int localY)
        {
            if (itemX < 0)
            {
                localX = (ChunkSize - 1) - (-(itemX + 1) % ChunkSize);
            }
            else
            {
                localX = itemX % ChunkSize;
            }
            if (itemY < 0)
            {
                localY = (ChunkSize - 1) - (-(itemY + 1) % ChunkSize);
            }
            else
            {
                localY = itemY % ChunkSize;
            }
        }
        public bool SetChunkAt(int chunkX, int chunkY, T[,] chunk)
        {
            if (m_chunkMap.ContainsKey(chunkX) == false)
                m_chunkMap.Add(chunkX, new Dictionary<int, T[,]>());
            if (m_chunkMap[chunkX].ContainsKey(chunkY) == false)
            {
                m_chunkMap[chunkX].Add(chunkY, chunk);
                return true;
            }
      

        }
        public bool CreateChunkAt(int chunkX, int chunkY)
        {
            if (m_chunkMap.ContainsKey(chunkX) == false)
                m_chunkMap.Add(chunkX, new Dictionary<int, T[,]>());
            if (m_chunkMap[chunkX].ContainsKey(chunkY) == false)
            {
                var chunk = new T[ChunkSize, ChunkSize];
                for (int x = 0; x < ChunkSize; ++x)
                {
                    for (int y = 0; y < ChunkSize; ++y)
                    {
                        chunk[x, y] = new T();
                    }
                }
                m_chunkMap[chunkX].Add(chunkY, chunk);
                return true;
            }
            return false;
        }
        protected bool CreateChunkContainsItemAt(int itemX, int itemY)
        {
            int chunkX, chunkY;
            this.GetChunkPosContainsItemAt(itemX, itemY, out chunkX, out chunkY);
            return CreateChunkAt(chunkX, chunkY);
        }
        public T[,] GetChunkContain
public class OctreeWorldGeneration {
    float stoneBaseHeight = -3;
    float stoneBaseNoise = 0.05f;
    float stoneBaseNoiseHeight = 4;
    float stoneMountainHeight = 16;
    float stoneMountainFrequency = 0.008f;
    float stoneMinHeight = -12;
    private Chunk chunk;
    private World world;
    public void FetchChunk(out Chunk chunk)
    {
        chunk = this.chunk;
    }
    public void Generate(World world, Chunk chunk)
    {
        this.world = world;
        this.chunk = chunk;
        GenerateChunk();
    }
    void GenerateChunk()
    {
        for (int x = chunk.ChunkPosition.x; x < chunk.ChunkPosition.x + Chunk.ChunkSize; x++)
        {
            for (int z = chunk.ChunkPosition.z; z < chunk.ChunkPosition.z + Chunk.ChunkSize; z++)
            {
                int stoneHeight = Mathf.FloorToInt(stoneBaseHeight);
                stoneHeight += GetNoise(x, 0, z, stoneMountainFrequency, Mathf.FloorToInt(stoneMountainHeight));
                if (stoneHeight < stoneMinH
﻿namespace Game.Controllers
    public class Controller
    {
        public bool Right = false;
        public bool Left = false;
        public bool Up = false;
        public bool Down = false;
        public bool A = false;
        public bool B = false;
        public int Id;
        protected static int ControllerCount = 0;
        public Controller()
        {
            Id = ControllerCount;
            ControllerCount++;
        }
        public void DeepCopy(Controller controller)
        {
            Right = controller.Right;
            Left = controller.Left;
            Up = controller.Up;
            Down = controller.Down;
            A = controller.A;
            B = controller.B;
        }
        public bool Equals(Controller controller)
        {
            if (controller == null)
            {
                return false;
            }
            else
            {
                return (Right != controller.Right || Left != controller.Left || Up != controller
public class World : MonoBehaviour {
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public GameObject chunkPrefab;
    public string worldName = "world";
    public int newChunkX;
    public int newChunkY;
    public int newChunkZ;
    public bool genChunk;
    void Start()
    {
        for (int x = -4; x < 4; x++)
        {
            for (int y = -1; y < 3; y++)
            {
                for (int z = -4; z < 4; z++)
                {
                    CreateChunk(x * 16, y * 16, z * 16);
                }
            }
        }
    }
    void Update()
    {
        if (genChunk)
        {
            genChunk = false;
            WorldPos chunkPos = new WorldPos(newChunkX, newChunkY, newChunkZ);
            Chunk chunk = null;
            if (chunks.TryGetValue(chunkPos, out chunk))
            {
                DestroyChunk(chunkPos.x, chunkPos.y, chunkPos.z);
            }
            else
            {
                CreateChunk(ch

            }
        }
    }
    public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(x, y, z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.WorldPosition = worldPos;
        newChunk.World = this;
        chunks.Add(worldPos, newChunk);
        var terrainGen = new TerrainGen();
        newChunk = terrainGen.ChunkGen(newChunk);
        newChunk.SetBlocksUnmodified();
        bool loaded = Serialization.Load(newChunk);
    }
    public void DestroyChunk(int x, int y, int z)
    {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
        {
            UnityEngine.Object.Destroy(chunk.gameObject);
            chunks.Remove(new WorldPos(x, y, z));
        }
    }
    public 

    {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / multiple) * Chunk.chunkSize;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Block GetBlock(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null)
        {
            Block block = containerChunk.GetBlock(
            x - containerChunk.WorldPosition.x,
            y - containerChunk.WorldPosition.y,
            z - containerChunk.WorldPosition.z);
            return block;
        }
        else
        {
            return new BlockAir();
        }
    }
    public void SetBlock(int x, int y, int z, Block block)
    {
        Chunk chunk = GetChunk(x, y, z);
        if (chunk != null)
namespace Taskkill.Models
    public class Methods
    {
        public void GetProcessList(ObservableCollection<Process> processList)
        {
            Process[] processes = Process.GetProcesses();
            List<Process> guiProcesses = new List<Process>();
            foreach (Process process in processes)
            {
                if (process.MainWindowHandle.ToInt32() > 0)
                    guiProcesses.Add(process);
            }
            if (guiProcesses.Count != processList.Count)
            {
                processList.Clear();
                foreach (Process process in processes)
                {
                    if (process.MainWindowHandle.ToInt32() > 0)
                    {
                        processList.Add(process);
                    }
                }
            }
        }
        public void KillSelectedTask(Process process)
        {
            process.Kill();
        }
        public void KillAllTasks(ObservableCollection<Process> pro
namespace SCCM_Client_Repair
    class ProcessManager
    {
        public static void StartProcess(string filename, string args) {
            Process process = new Process();
            ProcessStartInfo processStartInfo = new ProcessStartInfo();
            processStartInfo.FileName = filename; 
            processStartInfo.Arguments = args;          
            processStartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            process.StartInfo = processStartInfo;
            process.Start();            
            process.WaitForExit(300000);
            process.Dispose();
            
             
        
        }
        public static string CheckProcess(Array processList) {
            foreach (string process in processList) {
                if (Process.GetProcessesByName(process).Length > 0) {
                    return process; 
                }
            
            }
            return ""; 
        }
        public static void KillProcess(string processName)
  
public class TerrainChunkLoader
    private TerrainChunkSerializer serializer;
    private TerrainChunkGenerator generator;
    public TerrainChunkLoader()
    {
        this.serializer = new TerrainChunkSerializer();
        this.generator = new TerrainChunkGenerator();
    }
    public Chunk LoadChunk(Terrain terrain, Vector2I chunkIndex)
    {
        Chunk chunk;
        if (!this.serializer.TryDeserializeChunk(chunkIndex, out chunk))
        {
            chunk = this.generator.GenerateChunk(terrain, chunkIndex);
            this.serializer.SerializeChunk(chunk, chunkIndex);
        }
        terrain.Blocks.ActiveChunks.Add(chunkIndex, chunk);
        return chunk;
    }
    public Chunk UnloadChunk(Terrain terrain, Vector2I chunkIndex)
    {
        Chunk chunk;
        if (!terrain.Blocks.TryGetChunk(chunkIndex, out chunk))
        {
            return null;
        }
        this.serializer.SerializeChunk(chunk, chunkIndex);
        terrain.Blocks.ActiveChunks.Remove(chunkIndex
namespace AllLifeDataCollector
    class Repository
    {
        private Int32 repositoryID;
        private string repositoryType;
        private string repositoryName;
        private string repositoryServerName;
        private string repositoryUsername;
        private string repositoryPassword;
        private string repositoryDBName;
        public Repository() 
        { 
        }
        public Repository(Int32 _RepositoryID, string _RepositoryType, string _RepositoryName, string _RepositoryServerName, string _RepositoryUsername, string _RepositoryPassword, string _RepositoryDBName)
        {
            this.repositoryID = _RepositoryID;
            this.repositoryType = _RepositoryType;
            this.repositoryName = _RepositoryDBName;
            this.repositoryServerName = _RepositoryServerName;
            this.repositoryUsername = _RepositoryUsername;
            this.repositoryPassword = _RepositoryPassword;
            this.repositoryDBName = _RepositoryDBName;
  

        public Int32 RepositoryID
        {
            get { return this.repositoryID; }
            set { this.repositoryID = value; }
        }
        public string RepositoryType
        {
            get { return this.repositoryType; }
            set { this.repositoryType = value; }
        }
        public string RepositoryName
        {
            get { return this.repositoryName; }
            set { this.repositoryName = value; }
        }
        public string RepositoryServerName
        {
            get { return this.repositoryServerName; }
            set { this.repositoryServerName = value; }
        }
        public string RepositoryUsername
        {
            get { return this.repositoryUsername; }
            set { this.repositoryUsername = value; }
        }
        public string RepositoryPassword
        {
            get { return this.repositoryPassword; }
            set { this.repositoryPassword = value; }
        }
        public string RepositoryDBName
 
namespace CCM.Business.Repositories
    public class UnitOfWork
    {
        private CCMContext _context;
        private CampRepository _campRepository;
        private SessionRepository _sessionRepository;
        private TagRepository _tagRepository;
        private SponsorRepository _sponsorRepository;
        private SponsorTypeRepository _sponsorTypeRepository;
        private AppSettingsRepository _appSettingsRepository;
        private UsersRepository _usersRepository;
        public UnitOfWork(CCMContext context)
        {
            _context = context;
        }
        public CampRepository CampRepository
        {
            get
            {
                if (_campRepository == null)
                {
                    _campRepository = new CampRepository(_context);
                }
                return _campRepository;
            }
        }
        public SessionRepository SessionRepository
        {
            get
            {
                if (_sessionRe

                {
                    _sessionRepository = new SessionRepository(_context);
                }
                return _sessionRepository;
            }
        }
        public TagRepository TagRepository
        {
            get
            {
                if (_tagRepository == null)
                {
                    _tagRepository = new TagRepository(_context);
                }
                return _tagRepository;
            }
        }
        public SponsorRepository SponsorRepository
        {
            get
            {
                if (_sponsorRepository == null)
                {
                    _sponsorRepository = new SponsorRepository(_context);
                }
                return _sponsorRepository;
            }
        }
        public SponsorTypeRepository SponsorTypeRepository
        {
            get
            {
                if (_sponsorTypeRepository == null)
                {
                    _sponsorTypeRepository = 
public class MapHandler : MonoBehaviour {
    private GameObject chunk;
    private GameHandler gameH;
    private PlayerHandler playerH;
    private float sizeChunk = 100f;
    private int nbSquare = 10;
    private int radiusVisibleChunk = 4;
    private Vector2 positionCenterChunk;
    private string[] listChunks;
    private float lowXLimit;
    private float highXLimit;
    private float lowZLimit;
    private float highZLimit;
    
    void FixedUpdate () {
        MajChunks();
    }
    public void InitMap(GameHandler gameHandler)
    {
        chunk = Resources.Load("Prefabs/Chunk") as GameObject;
        gameH = gameHandler;
        
        CreateInitialsChunks();
    }
    void CreateInitialsChunks()
    {
        Vector3 posPlayer;
        if (playerH) posPlayer = playerH.transform.position;
        else posPlayer = new Vector3(0f, 0f, 0f);
        positionCenterChunk = posPlayer;
        SetInitialCenter();
        for (int i = -radiusVisibleChunk; i <= radiusVisibleChunk;

        {
            for (int j = -radiusVisibleChunk; j <= radiusVisibleChunk; j++)
            {
                CreateChunk(posPlayer.x + i * sizeChunk, posPlayer.z + j * sizeChunk);
            }
        }
    }
    void CreateChunk(float positionX, float positionZ)
    {
        GameObject instance;
        instance = Instantiate(chunk, new Vector3(0, 0, 0), Quaternion.identity) as GameObject;
        instance.transform.SetParent(this.transform);
        ChunkHandler ch = instance.GetComponent<ChunkHandler>();
        ch.InitChunk(positionX, positionZ, sizeChunk, nbSquare);
    }
    void DestroyChunk(float positionX, float positionZ)
    {
        string chunkName = "Chunk" + positionX + "_" + positionZ;
        Destroy(GameObject.Find(chunkName));
    }
    void SetInitialCenter()
    {
        Vector3 posPlayer;
        if (playerH) posPlayer = playerH.transform.position;
        else posPlayer = new Vector3(0f, 0f, 0f);
        positionCenterChunk.x = (Mathf.Round(posPlayer.

        positionCenterChunk.y = (Mathf.Round(posPlayer.z / sizeChunk) * sizeChunk);
        lowXLimit = (Mathf.Round(posPlayer.x / sizeChunk) * sizeChunk) - sizeChunk / 2;
        highXLimit = (Mathf.Round(posPlayer.x / sizeChunk) * sizeChunk) + sizeChunk / 2;
        lowZLimit = (Mathf.Round(posPlayer.z / sizeChunk) * sizeChunk) - sizeChunk / 2;
        highZLimit = (Mathf.Round(posPlayer.z / sizeChunk) * sizeChunk) + sizeChunk / 2;
    }
    public void SetPlayer(PlayerHandler player)
    {
        playerH = player;
    }
    void MajChunks()
    {
        Vector3 posPlayer;
        if (playerH) posPlayer = playerH.transform.position;
        else posPlayer = new Vector3(0f, 0f, 0f);
        if (posPlayer.x < lowXLimit)
        {
            lowXLimit -= sizeChunk;
            highXLimit -= sizeChunk;            
            for(int i = 0; i < (radiusVisibleChunk*2+1); i++)
            {
                float newChunkX = positionCenterChunk.x - ((radiusVisibleChunk + 1) * sizeChunk)
public class CopyInstrument : MonoBehaviour, IDropHandler{
	private GameObject[] instruments;
	private int copiedInstrument;
	private int pastedInstrument;
	public GameObject item{
		
		get{
			
			if (transform.childCount > 0){
				
				return transform.GetChild(0).gameObject;
			return null;
	#region IDropHandler implementation
	public void OnDrop (PointerEventData eventData){
		if(!item){
			if(DragAndDrop.itemBeingDragged != null){
				if(DragAndDrop.itemBeingDragged.GetComponent<CopyInstrument>() != null){
					instruments = GameObject.FindGameObjectsWithTag("Instrument");
					copiedInstrument = DragAndDrop.itemBeingDragged.transform.parent.parent.GetComponentInParent<InstrumentScript>().instrumentNumber;
					pastedInstrument = this.transform.GetComponentInParent<InstrumentScript>().instrumentNumber;
					Destroy(instruments[pastedInstrument].GetComponent<InstrumentScript>().graphSuspended);
					instruments[pastedInstrument].GetComponent<InstrumentScript>().CreateBGGraph();
			
namespace MFDExtractor
    internal interface IInstrumentFormFactory
    {
        InstrumentForm Create
            (
            InstrumentType instrumentType,
            IInstrumentRenderer renderer,
            Image initialImage = null
            );
    }
    class InstrumentFormFactory : IInstrumentFormFactory
    {
        private readonly IInstrumentFormSettingsReader _instrumentFormSettingsReader;
        public InstrumentFormFactory(IInstrumentFormSettingsReader instrumentFormSettingsReader = null)
        {
            _instrumentFormSettingsReader = instrumentFormSettingsReader ?? new InstrumentFormSettingsReader();
        }
        public InstrumentForm Create
        (
            InstrumentType instrumentType,
            IInstrumentRenderer renderer,
            Image initialImage = null
        )
        {
            var currentSettings = _instrumentFormSettingsReader.Read(instrumentType.ToString());
            if (!currentSettings.Enabled) return null;
          

            Size size;
            var screen = Util.FindScreen(currentSettings.OutputDisplay);
            var instrumentForm = new InstrumentForm { Text = instrumentType.ToString(), ShowInTaskbar = false, ShowIcon = false, Settings = currentSettings};
            if (currentSettings.StretchToFit)
            {
                location = new Point(0, 0);
                size = screen.Bounds.Size;
                instrumentForm.StretchToFill = true;
            }
            else
            {
                location = new Point(currentSettings.ULX, currentSettings.ULY);
                size = new Size(currentSettings.LRX - currentSettings.ULX, currentSettings.LRY - currentSettings.ULY);
                instrumentForm.StretchToFill = false;
            }
            instrumentForm.AlwaysOnTop = currentSettings.AlwaysOnTop;
            instrumentForm.Monochrome = currentSettings.Monochrome;
            instrumentForm.Rotation = currentSettings.RotateFlipType;
            instrumentFor
        
namespace Noea.TogSim.Model
    public abstract class TrainEngineDispatch:ITrainEngineDispatch
    {
        #region ITrainEngineDispatch Members
        ArrayList _trains;
        public ArrayList Trains
        {
            get { return _trains; }
            set { _trains = value; }
        }
        public TrainEngineDispatch()
        {
        }
        public TrainEngineDispatch(ArrayList trains)
        {
            _trains = trains;
        }
        public abstract void Create();
        public void Create(System.Collections.ArrayList trains)
        {
            Trains = trains;
            Create();
        }
        public abstract void Dispose();
        #endregion
    }
  
    public class FixedTimeDispatch : TrainEngineDispatch
    {
        Thread _dispatchThread;
        bool _doRun;
        public FixedTimeDispatch() : base() { }
        public FixedTimeDispatch(ArrayList trains) : base(trains) { }
        public override void Create()
        {
         
﻿/*
 * Created by SharpDevelop.
 * User: Alexander Petrovskiy
 * Date: 12/5/2013
 * Time: 1:48 PM
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
namespace UIAutomation
    
    public class UiaInvokePattern : IInvokePattern
    {
        private classic.InvokePattern _invokePattern;
        private IUiElement _element;
        
        public UiaInvokePattern(IUiElement element, classic.InvokePattern invokePattern)
        {
            _invokePattern = invokePattern;
            _element = element;
        }
        
        public UiaInvokePattern(IUiElement element)
        {
            _element = element;
        }
        
        public UiaInvokePattern(classic.InvokePattern InvokePattern)
        {
            _invokePattern = InvokePattern;
        }
        
        public static readonly classic.AutomationPattern Pattern = classic.InvokePatternIdentifiers.Pattern;
        public static readonly classic.AutomationEvent InvokedEvent = 
namespace Amigula.Helpers
    public class AppHelper
    {
        private static bool EnsureSingleInstance()
        {
            Process currentProcess = Process.GetCurrentProcess();
            Process runningProcess = (from process in Process.GetProcesses()
                where
                    process.Id != currentProcess.Id &&
                    process.ProcessName.Equals(
                        currentProcess.ProcessName,
                        StringComparison.Ordinal)
                select process).FirstOrDefault();
            if (runningProcess == null) return true;
            ShowMainWindow(runningProcess);
            BringMainWindowToForeground(runningProcess);
            return false;
        }
        private static void ShowMainWindow(Process runningProcess)
        {
            const int swShowmaximized = 3;
            SafeNativeMethods.ShowWindow(runningProcess.MainWindowHandle, swShowmaximized);
        }
        private static void BringMainWindowToFor
namespace DAL
    public class Consignment
    {
        public DispatchList Load(string connectionString, string cDLCode, out string errMsg)
        {
            errMsg = string.Empty;
            DispatchList dispatchList = null;
            string strSql = string.Format(@" SELECT DISTINCT DispatchList.caddcode, (CASE WHEN isnull(DispatchList.cSBVCode, '') <> '' THEN salebillvouch.cVouchType  ELSE Dispatchlist.cVouchType END) AS cVouchType,  VouchType.cVouchName,
DispatchList.cDLCode,DispatchList.sbvid ,DispatchList.cSBVCode,DispatchList.ddate,DispatchList.cBusType, DispatchList.DLID as DLID,  DispatchList.cSTCode, 
SaleType.cSTName, DispatchList.cCusCode, Customer.cCusAbbName,Customer.cCusName, DispatchList.cDepCode, Department.cDepName,DispatchList.cPersonCode ,
 Person.cPersonName, DispatchList.cMaker,DispatchList.cVerifier,
DispatchList.cShipAddress,convert(char,convert(money,DispatchList.ufts),2) as ufts   ,
DispatchList.cDefine1 , DispatchList.cDefine2, DispatchList.cDefine3, 

 DispatchList.cDefine5, DispatchList.cDefine6, DispatchList.cDefine7, DispatchList.cDefine8, DispatchList.cDefine9, 
 DispatchList.cDefine10, DispatchList.cDefine11, DispatchList.cDefine12, DispatchList.cDefine13, DispatchList.cDefine14,
 DispatchList.cDefine15, DispatchList.cDefine16,DispatchList.cMemo,DispatchList.bReturnFlag 
 from DispatchList inner join   DispatchLists ON DispatchList.DLID = DispatchLists.DLID  
  INNER JOIN  Inventory ON DispatchLists.cInvCode = Inventory.cInvCode left join ComputationUnit on Inventory.ccomunitcode=ComputationUnit.ccomunitcode 
 inner join Warehouse on DispatchLists.cwhcode=warehouse.cwhcode
 LEFT OUTER JOIN SaleType ON DispatchList.cSTCode = SaleType.cSTCode 
 LEFT OUTER JOIN (select cpersoncode as cpersoncode2,cpersonname from Person) person ON DispatchList.cPersonCode = Person.cPersonCode2 
 LEFT OUTER JOIN  Customer ON DispatchList.cCusCode = Customer.cCusCode 
 LEFT OUTER JOIN Department ON DispatchList.cDepCode = Department.cDepCode
 left 

 left join VouchType on VouchType.cVouchType = case when  salebillvouch.SBVID is null then dispatchlist.cVouchType else salebillvouch.cVouchType end  
 WHERE  (DispatchList.cVouchType='05' OR DispatchList.cVouchType='06') 
AND  ((ISNULL(DispatchList.cSaleOut,'') = '' OR isnull(bqaneedcheck,0)=1) OR DispatchList.cSaleOut ='ST')    
AND NOT (isnull(DispatchList.bFirst,0) =1 And isnull(DispatchLists.bIsStQC,0) =0) 
AND (
	(ABS(ISNULL((case when (isnull(DispatchLists.bQANeedCheck,0)=1 and DispatchLists.iquantity>0) then DispatchLists.iqaquantity else DispatchLists.iquantity end ),0))-ABS(ISNULL(DispatchLists.fOutQuantity,0))    ) >=0.01 
	or ( igrouptype=2 and  (  ABS(ISNULL((case when (isnull(DispatchLists.bQANeedCheck,0)=1 and DispatchLists.iquantity>0) then DispatchLists.iqanum else DispatchLists.inum end ),0))-ABS(ISNULL(DispatchLists.fOutnum,0)) ) >=0.01)
	)
AND (ISNULL(DispatchLists.cWhCode,'')<>'') 
AND bInvType=0 
AND bService=0  
AND	((ISNULL(DispatchLists.bSettleAll,0)=0 and Dis
[RequireComponent(typeof(ControllerManager))]
public abstract class ControllerFunctionality : MonoBehaviour
    public ControllerManager controllerManager { get; private set; }
    public ControllerInformation nonActiveController { get; set; }
    private ControllerInformation _activeController;
    public ControllerInformation ActiveController
    {
        get
        {
            return _activeController;
        }
        set
        {
            _activeController = value;
        }
    }
    public ControllerFunctionalityInformation info { private get; set; }
    protected virtual void Awake()
    {
        controllerManager = GetComponent<ControllerManager>();
        StartCoroutine(WaitForControllerInitialized());
    }
    private void Update()
    {
        ControllerInformation[] trackedObjs = new ControllerInformation[] { };
        try
        {
            trackedObjs = controllerManager.controllerInfos;
        }
        catch (System.NullReferenceException)
        {
 

        }
        foreach (ControllerInformation controller in trackedObjs)
        {
            if (controllerManager.GetController(controller.trackedObj) == null)
            {
                Debug.LogWarning("The Controller: " + controller + " is not ready (yet).");
                continue;
            }
            if (ActiveController != null)
            {
                if (controller == ActiveController)
                {
                    ActiveControllerUpdate(controller);
                }
                else
                {
                    NonActiveControllerUpdate(controller);
                }
            }
            AnyControllerUpdate(controller);
        }
    }
    IEnumerator WaitForControllerInitialized()
    {
        while (controllerManager.controllerInfos == null)
        {
            yield return 0;
        }
        OnControllerInitialized();
    }
    protected abstract void ActiveControllerUpdate(ControllerInformation controller);
    protec
namespace PNGHandler
   class PNG_Chunk
   {
      public PNG_Chunk(byte[] chunk_data, ref int byte_index)
      {
         if (chunk_data == null)
         {
            throw new System.ArgumentNullException();
         }
         if (byte_index >= chunk_data.Length
            || chunk_data.Length - byte_index < 12)
         {
            throw new System.ArgumentException("PNG_Chunk: Passed invalid byte_index.");
         }
         else if (chunk_data.Length < 12)
         {
            throw new System.ArgumentException("PNG_Chunk: Invalid chunk data passed.");
         }
         chunk_length_p = (int)chunk_data[byte_index++];
         for (int i = 1; i < 4; i++)
         {
            chunk_length_p = chunk_length_p << 8;
            chunk_length_p += (int)chunk_data[byte_index++];
         }
          System.Text.StringBuilder sb = new System.Text.StringBuilder();
         for (int i = 0; i < 4; i++)
         {
            sb.Append((char)chunk_data[byte_index++]);
         }


         chunk_data_p = new byte[chunk_length_p];
         for (int i = 0; i < chunk_length_p; i++)
         {
            chunk_data_p[i] = chunk_data[byte_index++];
         }
         chunk_CRC_p = new byte[4];
         for (int i = 0; i < 4; i++)
         {
            chunk_CRC_p[i] = chunk_data[byte_index++];
         }
      }
      public PNG_Chunk(ref string chunk_data)
      {
         if (chunk_data.IndexOf("PNG") == 1)
         {
            chunk_data = chunk_data.Substring(8);
         }
         if (chunk_data.Length < 12)
         {
            throw new Exception("PNG chunk wasn't passed valid data.");
         }
         string chunk_length_str = chunk_data.Substring(0, 4);
         chunk_name_p = chunk_data.Substring(4, 4);
         chunk_length_p = interpret_chunk_length_string(chunk_length_str);
         string chunk_data_str = chunk_data.Substring(8, chunk_length);
         datastream_p = chunk_data_str;
         chunk_data_p = str_to_byte_arr(chunk_data_str);
  

         chunk_CRC_p = str_to_byte_arr(chunk_CRC_str);
         chunk_data = chunk_data.Substring(12 + chunk_length);
      }
      public PNG_Chunk(uint chunk_length, string chunk_name, byte[] chunk_data, byte[] chunk_CRC)
      {
         if(chunk_data.Equals(null)
            && chunk_length != 0)
         {
            throw new ArgumentException("PNG Chunk wasn't passed valid chunk data.");
         }
         else if(chunk_name.Length != 4
            || chunk_CRC.Length != 4)
         {
            throw new ArgumentException("PNG Chunk wasn't passed valid data.");
         }
         this.chunk_length_p = (int)chunk_length;
         this.chunk_name_p = chunk_name;
         this.chunk_data_p = chunk_data;
         this.chunk_CRC_p = chunk_CRC;
         this.is_ancillary_p = (1 << 5 & (byte)chunk_name[0]) > 0;
         this.is_private_p = (1 << 5 & (byte)chunk_name[1]) > 0;
         this.is_safe_to_copy_p = (1 << 5 & (byte)chunk_name[3]) > 0;
      }
      private byte[] str_to_
public class ProcessTools
	public static void StartProcess(string ApplicationPath)
    {
        UnityEngine.Debug.Log("打开本地应用");
        Process foo = new Process();
        foo.StartInfo.FileName = ApplicationPath;
        foo.Start();
    }
    public static bool CheckProcess(string processName)
    {
        bool isRunning = false;
        Process[] processes = Process.GetProcesses();
        int i = 0;
        foreach (Process process in processes)
        {
            try
            {
                i++;
                if (!process.HasExited)
                {
                    if (process.ProcessName.Contains(processName))
                    {
                        UnityEngine.Debug.Log(processName + "正在运行");
                        isRunning = true;
                        continue;
                    }
                    else if (!process.ProcessName.Contains(processName) && i > processes.Length)
                    {
                        UnityEngine.Debug.Log(pr

                        isRunning = false;
                    }
                }
            }
            catch (Exception ep)
            {
            }
        }
        return isRunning;
    }
    public static String[] ListAllAppliction()
    {
        Process[] processes = Process.GetProcesses();
        List<string> allProcess = new List<string>();
        foreach (Process process in processes)
        {
            try
            {
                if (!process.HasExited)
                {
                    allProcess.Add(process.ProcessName);
                }
            }
            catch (Exception ep)
            {
            }
        }
        return allProcess.ToArray();
    }
    public static void KillProcess(string processName)
    {
        Process[] processes = Process.GetProcesses();
        foreach (Process process in processes)
        {
            try
            {
                if (!process.HasExited)
                {
                    if (proces
namespace DesignPatterns.Facade
    public class VehicleFacade : IVehicleFacade
    {
        private readonly IEngineController _engineController;
        private readonly ITransmissionController _transmissionController;
        private readonly ITractionControlController _tractionControlController;
        private readonly ITachometerController _tachometerController;
        public VehicleFacade(IEngineController engineController, ITransmissionController transmissionController,
    ITractionControlController tractionControlController, ITachometerController tachometerController)
        {
            _engineController = engineController;
            _transmissionController = transmissionController;
            _tractionControlController = tractionControlController;
            _tachometerController = tachometerController;
        }
        public void Start()
        {
            _engineController.Start();
            _tractionControlController.Enable();
        }
        public void
﻿namespace SDK.Lib
    /**
     * @brief 非引用计数资源加载结果通知
     */
    public class ResLoadResultNotify
    {
        public ResLoadResultNotify()
        {
            this.mResLoadState = new ResLoadState();
            this.mLoadResEventDispatch = new ResEventDispatch();
        }
        public ResLoadState resLoadState
        {
            get
            {
                return this.mResLoadState;
            }
            set
            {
                this.mResLoadState = value;
            }
        }
        public ResEventDispatch loadResEventDispatch
        {
            get
            {
                return this.mLoadResEventDispatch;
            }
            set
            {
                this.mLoadResEventDispatch = value;
            }
        }
        public void onLoadEventHandle(IDispatchObject dispObj)
        {
            this.mLoadResEventDispatch.dispatchEvent(dispObj);
            this.mLoadResEventDispatch.clearEventHandle();
        }
        virtua
namespace musicians_practice_log_api.Controllers
    [Route("api/[controller]")]
    public class InstrumentController : Controller
    {
        private PracticeLogContext _context;
        public InstrumentController(PracticeLogContext context)
        {
            _context = context;
        }
        [HttpPost]
        [Route("deleteById")]
        public ResultViewModel DeleteById([FromBody]int instrumentId)
        {
            var instrument = _context.Instruments.SingleOrDefault(s => s.Id == instrumentId);
            if (instrument != null)
            {
                try
                {
                    if (instrument != null)
                    {
                        _context.Remove(instrument);
                        _context.SaveChanges();
                    }
                    return new ResultViewModel(Result.Success, instrument.Name + " was successfully deleted.");
                }
                catch (Exception ex)
                {
                

                }
            }
            else
            {
                return new ResultViewModel(Result.Error, "Could not find " + instrument.Name + ". Try again later.");
            }
        }
        [HttpPost]
        [Route("insert")]
        public ResultViewModel Insert([FromBody]Instrument instrument)
        {
            try
            {
                _context.Add(instrument);
                _context.SaveChanges();
                return new ResultViewModel(Result.Success, instrument.Name + " was successfully created.");
            }
            catch (Exception ex)
            {
                return new ResultViewModel(Result.Error, "Could not create " + instrument.Name + ". Try again later.", ex);
            }
        }
        [HttpGet]
        [Route("selectAll")]
        public string SelectAll()
        {
            return Helper.ParseToJsonString(_context.Instruments.Include(s => s.Categories));
        }
        [HttpPost]
        [Route("selectByI

        public ResultViewModel SelectById([FromBody]int instrumentId)
        {
            var instrument = _context.Instruments.SingleOrDefault(s => s.Id == instrumentId);
            if (instrument != null)
            {
                return new ResultViewModel(Result.Success, instrument);
            }
            else
            {
                return new ResultViewModel(Result.Error, "Could not find " + instrument.Name + ". Try again later.");
            }
        }
        [HttpPost]
        [Route("update")]
        public ResultViewModel Update([FromBody]Instrument newInstrument)
        {
            var oldInstrument = _context.Instruments.SingleOrDefault(s => s.Id == newInstrument.Id);
            if (oldInstrument != null)
            {
                try
                {
                    oldInstrument.Name = newInstrument.Name;
                    oldInstrument.UserId = newInstrument.UserId;
                    _context.SaveChanges();
                    retur
public partial class jobs_editJobDispatch : AxiomPage
    protected void Page_Load(object sender, EventArgs e)
    {
        int jobID = int.Parse(Request.QueryString["JID"]);
        int jobDispatchID = int.Parse(Request.QueryString["JDID"]);
        Job job = new Job(jobID);
        if (!IsPostBack)
        {
            Master.FindControl("jobNoPanel").Visible = true;
            jobDetailsPanel.job = job;
            jobDetailsTabs.job = job;
            jobDetailsTabs.selectedTab = "JobDispatch";
            PopulatePage(jobID, jobDispatchID);
        }
    }
    private void PopulatePage(int jobID, int jobDispatchID)
    {
        JobDispatch jobDispatch = new JobDispatch(jobID, jobDispatchID);
        DispatchMediaType dmt = new DispatchMediaType(jobDispatch.jobDispatchStatusID);
        deliverToNameLabel.Text = jobDispatch.deliveryToName;
        jobDispatchStatusLabel.Text = jobDispatch.statusName;
        deliveryAddressLabel.Text = jobDispatch.deliveryAddress.Replace("\n", 

        dispatchReferenceLabel.Text = jobDispatch.dispatchReference;
        dispatchMediaTypeLabel.Text = dmt.mediaTypeName;
        filenameLabel.Text = jobDispatch.filename;
        deliveryInstructionsLabel.Text = jobDispatch.deliveryInstructions;
        deliveryMethodLabel.Text = jobDispatch.deliveryMethod;
        receivedByLabel.Text = jobDispatch.receivedBy;
        if (jobDispatch.scheduledDate > DateTime.MinValue)
        {
            scheduledDateLabel.Text = jobDispatch.scheduledDate.ToString("dd/MM/yyyy");
        }
        else
        {
            scheduledDateLabel.Text = "";
        }
        if (jobDispatch.actualDispatchDate > DateTime.MinValue)
        {
            actualDispatchDateLabel.Text = jobDispatch.actualDispatchDate.ToString("dd/MM/yyyy");
        }
        else
        {
            actualDispatchDateLabel.Text = "";
        }
        if (jobDispatch.deliveryRequiredDate > DateTime.MinValue)
        {
            deliverOnDateLabel.Text = jobDispatch

        }
        else
        {
            deliverOnDateLabel.Text = "";
        }
        if (jobDispatch.receivedDate > DateTime.MinValue)
        {
            receivedDateLabel.Text = jobDispatch.receivedDate.ToString("dd/MM/yyyy");
        }
        else
        {
            receivedDateLabel.Text = "";
        }
        if (jobDispatch.jobDispatchDocument1 != "")
        {
            fileLink1.NavigateUrl = "~/assets/jobFiles/" + jobDispatch.jobDispatchDocument1;
            fileLink1.Text = "Download file: " + jobDispatch.jobDispatchDocument1;
            fileRow1.Visible = true;
        }
        else
        {
            fileRow1.Visible = false;
        }
        if (jobDispatch.jobDispatchDocument2 != "")
        {
            fileLink2.NavigateUrl = "~/assets/jobFiles/" + jobDispatch.jobDispatchDocument2;
            fileLink2.Text = "Download file: " + jobDispatch.jobDispatchDocument2;
            fileRow2.Visible = true;
        }
        else
        {
            
namespace Famoser.SyncApi.Helpers
    public class SyncApiHelper : IDisposable
    {
        private readonly IStorageService _storageService;
        private readonly string _applicationName;
        private readonly string _uri;
        {
            _storageService = storageService;
            _applicationName = applicationName;
            _uri = uri;
        }
        private IApiConfigurationService _apiConfigurationService;
        public IApiConfigurationService ApiConfigurationService
        {
            get { return _apiConfigurationService ?? (_apiConfigurationService = new ApiConfigurationService(_applicationName, _uri)); }
            set { _apiConfigurationService = value; }
        }
        private IApiStorageService _apiStorageService;
        public IApiStorageService ApiStorageService
        {
            get { return _apiStorageService ?? (_apiStorageService = new ApiStorageService(_storageService, ApiConfigurationService)); }
            set { _apiStorageServic

        }
        private IApiTraceService _apiTraceService;
        public IApiTraceService ApiTraceService
        {
            get { return _apiTraceService ?? (_apiTraceService = new ApiTraceService()); }
            set { _apiTraceService = value; }
        }
        private IApiAuthenticationService _apiAuthenticationService;
        public IApiAuthenticationService ApiAuthenticationService
        {
            get { return _apiAuthenticationService ?? (_apiAuthenticationService = new ApiAuthenticationService(ApiConfigurationService, ApiUserRepository, ApiDeviceRepository)); }
            set { _apiAuthenticationService = value; }
        }
        private IApiUserRepository<UserModel> _apiUserRepository;
        public IApiUserRepository<UserModel> ApiUserRepository
        {
            get { return _apiUserRepository ?? (_apiUserRepository = new ApiUserRepository<UserModel>(ApiConfigurationService, ApiStorageService, ApiTraceService)); }
            set { _apiUserRepository

        }
        private IApiDeviceRepository<DeviceModel> _apiDeviceRepository;
        public IApiDeviceRepository<DeviceModel> ApiDeviceRepository
        {
            get { return _apiDeviceRepository ?? (_apiDeviceRepository = new ApiDeviceRepository<DeviceModel>(ApiConfigurationService, ApiStorageService, ApiTraceService)); }
            set { _apiDeviceRepository = value; }
        }
        private IApiCollectionRepository<CollectionModel> _apiCollectionRepository;
        public IApiCollectionRepository<CollectionModel> ApiCollectionRepository
        {
            get { return _apiCollectionRepository ?? (_apiCollectionRepository = new ApiCollectionRepository<CollectionModel>(ApiAuthenticationService, ApiStorageService, ApiConfigurationService, ApiTraceService)); }
            set { _apiCollectionRepository = value; }
        }
        public ApiRepository<T, CollectionModel> ResolveRepository<T>()
            where T : ISyncModel
        {
            return new ApiReposi
namespace DAL.Generic.UnitofWork
    public interface IGenericUnitofWork :IDisposable
    {
     IGenericRepository<AddressType> AddressTypeRepository {get;}
    IGenericRepository<Client> ClientRepository {get;}
    IGenericRepository<ClientAddress> ClientAddressRepository {get;}
    IGenericRepository<ClientFeedBack> ClientFeedBackRepository {get;}
    IGenericRepository<ClientOrderReviewReceived> ClientOrderReviewReceivedRepository {get;}
    IGenericRepository<ClientOrderReviewSent> ClientOrderReviewSentRepository {get;}
    IGenericRepository<ClientOrderToReview> ClientOrderToReviewRepository {get;}
    IGenericRepository<ClientReviewScore> ClientReviewScoreRepository {get;}
    IGenericRepository<ClientSubscription> ClientSubscriptionRepository {get;}
    IGenericRepository<Cooker> CookerRepository {get;}
    IGenericRepository<CookerCoupon> CookerCouponRepository {get;}
    IGenericRepository<CookerCuisine> CookerCuisineRepository {get;}
    IGenericRepository<CookerDeliveryZone

    IGenericRepository<CookerFeedBack> CookerFeedBackRepository {get;}
    IGenericRepository<CookerGeoIP> CookerGeoIPRepository {get;}
    IGenericRepository<CookerHoursofOperation> CookerHoursofOperationRepository {get;}
    IGenericRepository<CookerMenu> CookerMenuRepository {get;}
    IGenericRepository<CookerOrderReviewReceived> CookerOrderReviewReceivedRepository {get;}
    IGenericRepository<CookerOrderReviewSent> CookerOrderReviewSentRepository {get;}
    IGenericRepository<CookerOrderToReview> CookerOrderToReviewRepository {get;}
    IGenericRepository<CookerPaymentMethod> CookerPaymentMethodRepository {get;}
    IGenericRepository<CookerPlan> CookerPlanRepository {get;}
    IGenericRepository<CookerPromotion> CookerPromotionRepository {get;}
    IGenericRepository<CookerReviewScore> CookerReviewScoreRepository {get;}
    IGenericRepository<CookerReviewServiceDetail> CookerReviewServiceDetailRepository {get;}
    IGenericRepository<CookerSpokenLanguage> CookerSpokenLanguageRe

    IGenericRepository<CookerSubscription> CookerSubscriptionRepository {get;}
    IGenericRepository<Coupon> CouponRepository {get;}
    IGenericRepository<CouponType> CouponTypeRepository {get;}
    IGenericRepository<CuisineType> CuisineTypeRepository {get;}
    IGenericRepository<Currency> CurrencyRepository {get;}
    IGenericRepository<DeliveryZone> DeliveryZoneRepository {get;}
    IGenericRepository<Dish> DishRepository {get;}
    IGenericRepository<DishOption> DishOptionRepository {get;}
    IGenericRepository<DishOptionsChoice> DishOptionsChoiceRepository {get;}
    IGenericRepository<Dispute> DisputeRepository {get;}
    IGenericRepository<DisputeReason> DisputeReasonRepository {get;}
    IGenericRepository<DisputeStatu> DisputeStatuRepository {get;}
    IGenericRepository<IndustryAverageRating> IndustryAverageRatingRepository {get;}
    IGenericRepository<Invoice> InvoiceRepository {get;}
    IGenericRepository<Language> LanguageRepository {get;}
    IGenericRepository<Men
﻿namespace PravoAdder.Api
	public class ApiRouter
	{
		public static ProjectsApi Projects;
		public static ProjectFoldersApi ProjectFolders;
		public static ProjectGroupsApi ProjectGroups;
		public static ProjectTypesApi ProjectTypes;
		public static ParticipantsApi Participants;
		public static DictionaryApi Dictionary;
		public static CasebookApi Casebook;
		public static ProjectCustomValuesApi ProjectCustomValues;
		public static CalculationFormulasApi CalculationFormulas;
		public static ResponsiblesApi Responsibles;
		public static CurrenciesApi Currencies;
		public static int PageSize = 50;
		static ApiRouter()
		{
			Projects = new ProjectsApi();
			ProjectFolders = new ProjectFoldersApi();
			ProjectGroups = new ProjectGroupsApi();
			ProjectTypes = new ProjectTypesApi();
			Participants = new ParticipantsApi();
			Dictionary = new DictionaryApi();
			Casebook = new CasebookApi();
			ProjectCustomValues = new ProjectCustomValuesApi();
			CalculationFormulas = new CalculationFor
namespace AmarokGames.Grids {
    public class Grid2D : MonoBehaviour {
        public enum GridType { Static = 0, Dynamic = 1 }
        public int GridId { get { return gridId; } }
        public int ChunkWidth { get { return chunkWidth; } }
        public int ChunkHeight { get { return chunkHeight; } }
        public GridType Type { get { return gridType; } }
        public IEnumerable<Int2> RecentlyCreated { get { return recentlyCreatedChunks; } }
        public IEnumerable<Int2> RecentlyRemoved { get { return recentlyRemovedChunks; } }
        private List<Int2> recentlyCreatedChunks = new List<Int2>();
        private List<Int2> recentlyRemovedChunks = new List<Int2>();
        private int gridId;
        private int chunkWidth;
        private int chunkHeight;
        private GridType gridType;
        private LayerConfig layers;
        private Dictionary<Int2, Grid2DChunk> chunkObjects = new Dictionary<Int2, Grid2DChunk>();
        public Int2 GetGridCoord(Vector2 worldPos) {
 

            return new Int2(Mathf.FloorToInt(localPos.x), Mathf.FloorToInt(localPos.y));
        }
        [SerializeField]
        private bool drawChunkBoundsGizmo = false;
        [SerializeField]
        private bool drawChunkAABBGizmo = false;
        public void Setup(int gridId, int chunkWidth, int chunkHeight, LayerConfig layers, GridType type) {
            this.gridId = gridId;
            this.chunkWidth = chunkWidth;
            this.chunkHeight = chunkHeight;
            this.layers = layers;
            this.gridType = type;
            
            switch(gridType) {
                case GridType.Static:
                    break;
                case GridType.Dynamic:
                    Rigidbody2D rigidbody = gameObject.AddComponent<Rigidbody2D>();
                    rigidbody.isKinematic = false;
                    rigidbody.simulated = true;
                    break;
            }
        }
        public ChunkData CreateChunk(Int2 chunkCoord) {
            if (

                throw new System.Exception(string.Format("Chunk with offset {0} already exists in this grid.", chunkCoord));
            }
            ChunkData chunk = new ChunkData(chunkWidth * chunkHeight, layers);
            string name = string.Format("chunk {0}", chunkCoord);
            GameObject obj = new GameObject(name);
            obj.transform.SetParent(this.transform, false);
            Grid2DChunk chunkBehaviour = obj.AddComponent<Grid2DChunk>();
            Vector2 pos = new Vector2(chunkCoord.x * ChunkWidth, chunkCoord.y * ChunkHeight);
            chunkBehaviour.transform.localPosition = pos;
            chunkBehaviour.Setup(chunkCoord, this, chunk);
            chunkObjects.Add(chunkCoord, chunkBehaviour);
            recentlyCreatedChunks.Add(chunkCoord);
            return chunk;
        }
        #region indexing
        public static Int2 GetChunkCoord(Int2 gridCoord, int chunkWidth, int chunkHeight) {
            int x = gridCoord.x / chunkWidth;
           
namespace N3DSCmbViewer.Cmb
    [System.Diagnostics.DebuggerDisplay("{GetType()}")]
    class SklmChunk : BaseCTRChunk
    {
        public override string ChunkTag { get { return "sklm"; } }
        public const int MshsChunkPointer = 0x08;
        public const int ShpChunkPointer = 0x0C;
        public MshsChunk MshsChunk { get; private set; }
        public ShpChunk ShpChunk { get; private set; }
        public SklmChunk(byte[] data, int offset, BaseCTRChunk parent)
            : base(data, offset, parent)
        {
            MshsChunk = new MshsChunk(ChunkData, (int)BitConverter.ToUInt32(ChunkData, MshsChunkPointer), this);
            ShpChunk = new ShpChunk(ChunkData, (int)BitConverter.ToUInt32(ChunkData, ShpChunkPointer), this);
        }
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendFormat("-- {0} --\n", this.GetType().Name);
            sb.AppendLine();
            sb.Append(MshsChunk.ToString());
namespace uGaMa.Manager
    public class Dispatcher
    {
        public Dictionary<object, Dictionary<Action<NotifyParam>, uGaMaBehaviour>> dispatchList;
        public Dispatcher()
        {
            dispatchList = new Dictionary<object, Dictionary<Action<NotifyParam>, uGaMaBehaviour>>();
        }
        CommandBinder commandMap
        {
            get
            {
                return BaseGameManager.GetInstance().commandMap;        
            }
        }
        
        MediatorBinder mediatorMap
        {
            get
            {
                return BaseGameManager.GetInstance().mediatorMap;
            }
        }
        public void AddListener(uGaMaBehaviour obj, object dispatchKey, Action<NotifyParam> callback)
        {
            if(!dispatchList.ContainsKey(dispatchKey))
            {
                Dictionary<Action<NotifyParam>, uGaMaBehaviour> actions = new Dictionary<Action<NotifyParam>, uGaMaBehaviour>();
                actions.Add(callback, obj

                dispatchList.Add(dispatchKey, actions);
            }
            else
            {
                Dictionary<Action<NotifyParam>, uGaMaBehaviour> actions = dispatchList[dispatchKey];
                actions.Add(callback, obj);
            }
        }
        public void RemoveListener(uGaMaBehaviour obj, object dispatchKey, Action<NotifyParam> callback)
        {
            if(dispatchList.ContainsKey(dispatchKey))
            {
                Dictionary<Action<NotifyParam>, uGaMaBehaviour> actions = dispatchList[dispatchKey];
                for (int i = 0; i < actions.Count; i++)
                {
                    if(actions.Keys.ElementAt(i) == callback && actions.Values.ElementAt(i) == obj)
                    {
                        actions.Remove(actions.Keys.ElementAt(i));
                    }
                }
            }
        }
        public void RemoveAllListeners(uGaMaBehaviour obj)
        {
            foreach (KeyValuePair<object, Diction

            {
                Dictionary<Action<NotifyParam>, uGaMaBehaviour> actions = item.Value;
                if(actions.ContainsValue(obj))
                {
                    for (int i = 0; i < actions.Count; i++)
                    {
                        if(actions.Values.ElementAt(i) == obj)
                        {
                            actions.Remove(actions.Keys.ElementAt(i));
                        }
                    }
                }
            }
        }
        
        public void Dispatch(object dispatchKey, object dispatchParam, object dispatchMsg)
        {
            NotifyParam notify = new NotifyParam(dispatchKey, dispatchParam, dispatchMsg);
            commandMap.ExecuteCommand(notify);
            SendNotifyToObject(notify);
        }
        public void Dispatch(object dispatchKey, object dispatchParam)
        {
            NotifyParam notify = new NotifyParam(dispatchKey, dispatchParam, null);
            commandMap.ExecuteCommand(n
namespace NinjaTrader.Strategy
    class Portfolio
    {
        private readonly Dictionary<Instrument, TradingPosition> positionPerInstrument = new Dictionary<Instrument, TradingPosition>();
        public IEnumerable<TradingPosition> Positions
        {
            get
            {
                return positionPerInstrument.Values;
            }
        }
        public void RemovePosition(TradingPosition position)
        {
            positionPerInstrument.Remove(position.Instrument);
        }
        public void AddPosition(TradingPosition position)
        {
            positionPerInstrument.Add(position.Instrument, position);
        }
        internal TradingPosition GetPosition(Instrument instrument)
        {
            return positionPerInstrument[instrument];
        }
        internal bool TryGetPosition(Instrument instrument, out TradingPosition position)
        {
            return positionPerInstrument.TryGetValue(instrument, out position);
        }
        publ
#if NET
namespace Catel
    public static class ProcessExtensions
    {
        #region Methods
        private static string FindIndexedProcessName(int pid)
        {
            var processName = Process.GetProcessById(pid).ProcessName;
            var processesByName = Process.GetProcessesByName(processName);
            string processIndexdName = null;
            for (var index = 0; index < processesByName.Length; index++)
            {
                processIndexdName = index == 0 ? processName : processName + "#" + index;
                var processId = new PerformanceCounter("Process", "ID Process", processIndexdName);
                if ((int) processId.NextValue() == pid)
                {
                    return processIndexdName;
                }
            }
            return processIndexdName;
        }
        private static Process FindPidFromIndexedProcessName(string indexedProcessName)
        {
            var parentId = new PerformanceCounter("Process", "Crea
namespace Falcon.Data.Infrastructure
    public class UnitOfWork : IUnitOfWork
    {
        IDatabaseFactory dbFactory;
        public UnitOfWork(IDatabaseFactory dbFactory)
        {
            this.dbFactory = dbFactory;
        }
        private FalconDbContext datContext;
        protected FalconDbContext DataContext
        {
            get
            {
                return datContext = dbFactory.DataContext;
            }
        }
        public void Dispose()
        {
            DataContext.Dispose();
        }
        public void Commit()
        {
            DataContext.SaveChanges();
        }
        private IAdminRepository adminRepository;
        public IAdminRepository AdminRepository
        {
            get { return adminRepository = new AdminRepository(dbFactory); }
        }
        private IBankAccountRepository bankAccountRepository;
        public IBankAccountRepository BankAccountRepository
        {
            get { return bankAccountRepository = new

        }
        private ICategoryRepository categoryRepository;
        public ICategoryRepository CategoryRepository
        {
            get { return categoryRepository = new CategoryRepository(dbFactory); }
        }
        private ICircleRepository circleRepository;
        public ICircleRepository CircleRepository
        {
            get { return circleRepository = new CircleRepository(dbFactory); }
        }
        private IComplaintRepository complaintRepository;
        public IComplaintRepository ComplaintRepository
        {
            get { return complaintRepository = new ComplaintRepository(dbFactory); }
        }
        private ICvRepository cvRepository;
        public ICvRepository CvRepository
        {
            get { return cvRepository = new CvRepository(dbFactory); }
        }
        private IDocumentRepository documentRepository;
        public IDocumentRepository DocumentRepository
        {
            get { return documentRepository = new DocumentR

        }
        private IEvaluationRepository evaluationRepository;
        public IEvaluationRepository EvaluationRepository
        {
            get { return evaluationRepository = new EvaluationRepository(dbFactory); }
        }
        private IEventRepository eventRepository;
        public IEventRepository EventRepository
        {
            get { return eventRepository = new EventRepository(dbFactory); }
        }
        private IFreelancerRepository freelancerRepository;
        public IFreelancerRepository FreelancerRepository
        {
            get { return freelancerRepository = new FreelancerRepository(dbFactory); }
        }
        private IMemberRepository memberRepository;
        public IMemberRepository MemberRepository
        {
            get { return memberRepository = new MemberRepository(dbFactory); }
        }
        private IMissionRepository missionRepository;
        public IMissionRepository MissionRepository
        {
            get { return mi
namespace osc.net.unittests.Message
    [TestClass]
    public class MessageDispatchTests
    {
        [TestMethod]
        public void MessageDispatch_Test_Dispatch()
        {
            MessageDispatch dispatch = new MessageDispatch();
            MessageBuilder builder1 = new MessageBuilder();
            builder1.SetAddress("/test1");
            builder1.PushAtom(1);
            MessageBuilder builder2 = new MessageBuilder();
            builder2.SetAddress("/test2");
            builder2.PushAtom("TEST");
            MessageBuilder builder3 = new MessageBuilder();
            builder3.SetAddress("/test3");
            builder3.PushAtom("TEST2");
            String address = "";
            Atom value = new Atom();
            Action<osc.net.Message> callback = m => {
                address = m.Address;
                value = m.Atoms[0];
            };
            dispatch.RegisterMethod("/test1", callback);
            dispatch.RegisterMethod("/test2", callback);
           
namespace ImobiliariaModel.DAL
    public class UnitOfWork : IDisposable
    {
        private ApplicationDbContext context = new ApplicationDbContext();
        private IAnuncioRepository anuncioRepository;
        private ITipoImovelRepository tipoImovelRepository;
        private IAlertaRepository alertaRepository;
        private IUserRepository userRepository;
        private IImovelRepository imovelRepository;
        private ITipoAnuncioRepository tipoAnuncioRepository;
        private ILocalRepository localRepository;
        private IImagemRepository imagemRepository;
        private IConfigurationRepository configurationRepository;
        private ISugestaoRepository sugestaoRepository;
        private INotificacaoRepository notificacaoRepository;
        private IAgendaRepository agendaRepository;
        private IPreferenciasRepository preferenciasRepository;
        private Auth auth;
        public IAnuncioRepository AnuncioRepository
        {
            get
           

                if (this.anuncioRepository == null)
                {
                    this.anuncioRepository = new AnuncioRepository(context);
                }
                return anuncioRepository;
            }
        }
        public IAlertaRepository AlertaRepository
        {
            get
            {
                if (this.alertaRepository == null)
                {
                    this.alertaRepository = new AlertaRepository(context);
                }
                return alertaRepository;
            }
        }
        public ITipoImovelRepository TipoImovelRepository
        {
            get
            {
                if (this.tipoImovelRepository == null)
                {
                    this.tipoImovelRepository = new TipoImovelRepository(context);
                }
                return tipoImovelRepository;
            }
        }
        public IUserRepository UserRepository
        {
            get
            {
                if (this

                {
                    this.userRepository = new UserRepository(context);
                }
                return userRepository;
            }
        }
        public IImovelRepository ImovelRepository
        {
            get
            {
                if (this.imovelRepository == null)
                {
                    this.imovelRepository = new ImovelRepository(context);
                }
                return imovelRepository;
            }
        }
        public ITipoAnuncioRepository TipoAnuncioRepository
        {
            get
            {
                if (this.tipoAnuncioRepository == null)
                {
                    this.tipoAnuncioRepository = new TipoAnuncioRepository(context);
                }
                return tipoAnuncioRepository;
            }
        }
        public ILocalRepository LocalRepository
        {
            get
            {
                if (this.localRepository == null)
                {
         
namespace Global.DataAccess
    public class InstrumentUsingPlanDaoImpl
    {
        public void Add(InstrumentUsingPlanModel model)
        {
            DBProvider.dbMapper.Insert("BaseData_InstrumentUsingPlan.Insert", model);
        }
        public void Update(InstrumentUsingPlanModel model)
        {
            DBProvider.dbMapper.Update("BaseData_InstrumentUsingPlan.Update", model);
        }
        public void DeleteById(int PlanId)
        {
            DBProvider.dbMapper.Delete("BaseData_InstrumentUsingPlan.DeleteById", PlanId);
        }
        public InstrumentUsingPlanModel GetById(int PlanId)
        {
            return DBProvider.dbMapper.SelectObject<InstrumentUsingPlanModel>("BaseData_InstrumentUsingPlan.GetByID", PlanId);
        }
        public IList<InstrumentUsingPlanModel> GetAll()
        {
            return DBProvider.dbMapper.SelectList<InstrumentUsingPlanModel>("BaseData_InstrumentUsingPlan.GetAll");
        }
        public IList<InstrumentUsingPlanMo
namespace NewAssigment
	public partial class ViewController : UIViewController
	{
		protected ViewController(IntPtr handle) : base(handle)
		{
		}
		public override void ViewDidLoad()
		{
			base.ViewDidLoad();
			genji.TouchUpInside += (object sender, EventArgs e) =>
			{
				secondViewController controller = this.Storyboard.InstantiateViewController("here") as secondViewController;
				controller.NameTitle = "Genji";
				controller.Image = "Genji_portrait.png";
				controller.Attack1 = "Shuriken:";
				controller.Info11 = "- 28 damage per round";
				controller.Info12 = " ";
				controller.Attack2 = "Swift Strike:";
				controller.Info21 = "- 50 damage";
				controller.Info22 = "- 15m range";
				controller.Attack3 = "Deflect:";
				controller.Info31 = "- 2 second duration";
				controller.Info32 = "- 8 second cooldown";
				controller.Attack4 = "Cyber Agility:";
				controller.Info41 = " ";
				controller.Info42 = " ";
				controller.Attack5 = "Dragonblades:";
				controller.Info51 

				controller.Info52 = "- 5m range";
				this.NavigationController.PushViewController(controller, true);
			};
			mccree.TouchUpInside += (object sender, EventArgs e) =>
			{
				secondViewController controller = this.Storyboard.InstantiateViewController("here") as secondViewController;
				controller.NameTitle = "McCree";
				controller.Image = "Mccree_portrait.png";
				controller.Attack1 = "Peacekeeper:";
				controller.Info11 = "- 2-6 rounds per second";
				controller.Info12 = "- 35-70 damage";
				controller.Attack2 = "Combat Roll:";
				controller.Info21 = "- 6m range";
				controller.Info22 = "- 8 second cooldown";
				controller.Attack3 = "Flashbang:";
				controller.Info31 = "- 25 damage";
				controller.Info32 = "- 5m range";
				controller.Attack4 = "Deadeye:";
				controller.Info41 = "- 6 sec duration";
				controller.Info42 = "- \"its high noon\"";
				controller.Attack5 = "";
				controller.Info51 = "";
				controller.Info52 = "";
				this.NavigationController.PushView

			};
			pharah.TouchUpInside += (object sender, EventArgs e) =>
			{
				secondViewController controller = this.Storyboard.InstantiateViewController("here") as secondViewController;
				controller.NameTitle = "Pharah";
				controller.Image = "Pharah_portrait.png";
				controller.Attack1 = "Rocket Launcher:";
				controller.Info11 = "- 120 damage";
				controller.Info12 = "- 3m radius";
				controller.Attack2 = "Concussive Blast:";
				controller.Info21 = "- 8m radius";
				controller.Info22 = "- 12 second cooldown";
				controller.Attack3 = "Jump Jet:";
				controller.Info31 = "- 10 second cooldown";
				controller.Info32 = "";
				controller.Attack4 = "Hover Jet:";
				controller.Info41 = "- 2 second cooldown";
				controller.Info42 = "";
				controller.Attack5 = "Barrage:";
				controller.Info51 = "- 50 damage";
				controller.Info52 = "- 30 rounds per second";
				this.NavigationController.PushViewController(controller, true);
			};
			reaper.TouchUpInside += (object sender, Event
public class World : MonoBehaviour
    public string worldName = "world";
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public GameObject chunkPrefab;
    public int newChunkX;
    public int newChunkY;
    public bool genChunk;
    void Start()
    {
        for (int x = -4; x < 4; x++)
        {
            for (int y = -1; y < 3; y++)
            {
                CreateChunk(x * 16, y * 16);
            }
        }
    }
    void Update()
    {
        if (genChunk)
        {
            genChunk = false;
            WorldPos chunkPos = new WorldPos(newChunkX, newChunkY);
            Chunk chunk = null;
            if (chunks.TryGetValue(chunkPos, out chunk))
            {
                DestroyChunk(chunkPos.x, chunkPos.y);
            }
            else
            {
                CreateChunk(chunkPos.x, chunkPos.y);
            }
        }
    }
    public Chunk GetChunk(int x, int y)
    {
        WorldPos pos = new WorldPos();
      

        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Block GetBlock(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y);
        if (containerChunk != null)
        {
            Block block = containerChunk.GetBlock(x - containerChunk.pos.x, y - containerChunk.pos.y, z);
            return block;
        }
        else
        {
            return new BlockAir();
        }
    }
    public void SetBlock(int x, int y, int z, Block block)
    {
        Chunk chunk = GetChunk(x, y);
        if (chunk != null)
        {
            chunk.SetBlock(x - chunk.pos.x, y - chunk.pos.y, z, block);
            chunk.update = true;
            UpdateIfEqual(x - chunk.pos.x, 0, new WorldPos(x - 1, y));
            UpdateIfEqual(x - chunk.pos.x, Chunk.chunkSize - 1

            UpdateIfEqual(y - chunk.pos.y, 0, new WorldPos(x, y - 1));
            UpdateIfEqual(y - chunk.pos.y, Chunk.chunkSize - 1, new WorldPos(x, y + 1));
        }
    }
    public void CreateChunk(int x, int y)
    {
        WorldPos worldPos = new WorldPos(x, y);
        GameObject newChunkObject = Instantiate(chunkPrefab, new Vector3(x, y), Quaternion.Euler(Vector3.zero)) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        var terrainGen = new TerrainGen();
        newChunk = terrainGen.ChunkGen(newChunk);
        newChunk.SetBlocksUnmodified();
        bool loaded = Serialization.Load(newChunk);
    }
    public void DestroyChunk(int x, int y)
    {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldPos(x, y), out chunk))
        {
            Object.Destroy(chunk.gameObject);
            chunks.Remove(new WorldPos(x, y));
namespace musicTherapy1
    public partial class Legend : Form
    {
        public MainForm parentForm;
        public Legend()
        {
            InitializeComponent();
        }
        private void Legend_Load(object sender, EventArgs e)
        {
            instrumentListView.LargeImageList = new ImageList();
            instrumentListView.LargeImageList.ImageSize = new Size(32, 32);
            instrumentListView.SmallImageList = new ImageList();
            instrumentListView.SmallImageList.ImageSize = new Size(16, 16);
            
            instrumentListView.View = View.List;
            
            instrumentListView.Columns.Add("Name", 120, HorizontalAlignment.Left);
            instrumentListView.Columns.Add("Category", 120, HorizontalAlignment.Left);
            instrumentListView.Columns.Add("Sub-category", 120, HorizontalAlignment.Left);
            instrumentListView.Columns.Add("Description", 120, HorizontalAlignment.Right);
          
            ArrayList ins

            instCategList = ((MainForm)(this.parentForm)).instrumentCategorylist;
            int numOfCategories = instCategList.Count;
            int imageIndexCounter = 0;
            for (int CategoryCount = 0; CategoryCount < instCategList.Count; CategoryCount++)
            {
                Category category = (Category)instCategList[CategoryCount];
           
                if (category.SubCategoryList.Count == 0)
                {
                    ArrayList imageList = (ArrayList)category.ImageList;
                    for (int imageCounter = 0; imageCounter < imageList.Count; imageCounter++)
                    {
                        myImage my_image = (myImage)imageList[imageCounter];
                        Bitmap image = new Bitmap(my_image.instrumentImage,new Size(32,32));
                        instrumentListView.LargeImageList.Images.Add( image);
                        ListViewItem instrumentListItem = instrumentListView.Items.Add(my_image.instrumentName, im

                        image = new Bitmap(my_image.instrumentImage, new Size(16, 16));
                        instrumentListView.SmallImageList.Images.Add(image);
                     
                        instrumentListItem.SubItems.Add(my_image.instrumentInfo.Category);
                        instrumentListItem.SubItems.Add(my_image.instrumentInfo.SubCategory);
                        imageIndexCounter++;
                  
                    }
                  
                }
                {
                    ArrayList subCategoryList = (ArrayList)category.SubCategoryList;
                    for (int subCategoryCounter = 0; subCategoryCounter < subCategoryList.Count; subCategoryCounter++)
                    {
                        SubCategory subCategory = (SubCategory)subCategoryList[subCategoryCounter];
                   
                        ArrayList imageList = (ArrayList)subCategory.ImageList;
                        for (int imageCounter = 0; imageCoun
namespace GrSU.ProcessExplorer.Core
    public class ProcessManager : IProcessManager
    {
        public event ProcessStart ProcessStart;
        public event ProcessStop ProcessStop;
        internal readonly ProcessHandler ProcessHandler;
        internal readonly ProcessEventManager ProcessEventManager;
        public ProcessManager()
        {
            this.ProcessEventManager = new ProcessEventManager();
            this.ProcessEventManager.ProcessStart += processEventManagerProcessStart;
            this.ProcessEventManager.ProcessStop += processEventManagerProcessStop;
            this.ProcessHandler = new ProcessHandler();
        }
        private void processEventManagerProcessStop(object sender, ProcessChangeStateEventArgs e)
        {
            this.OnProcessStop(e.ProcessId);
        }
        private void processEventManagerProcessStart(object sender, ProcessChangeStateEventArgs e)
        {
            var process = this.GetProcess(e.ProcessId);
            this.O

        }
        public IEnumerable<Process> GetProcesses()
        {
            return this.ProcessHandler.GetProcesses()
                .Select(item => item.Map<Process>());
        }
        public Process GetProcess(uint id)
        {
            var processEntry = this.ProcessHandler.GetProcess(id);
            return processEntry.HasValue ? processEntry.Value.Map<Process>() : null;
        }
        public void KillProcess(uint id)
        {
            this.ProcessHandler.KillProcess(id);
        }
        private void OnProcessStart(Process process)
        {
            if (ProcessStart == null)
            {
                return;
            }
            ProcessStart(this, new ProcessStartEventArgs
            {
                Process = process
            });
        }
        private void OnProcessStop(uint processId)
        {
            if (ProcessStop == null)
            {
                return;
            }
            ProcessStop(this, new ProcessStopEventA
namespace WcfRestContrib.ServiceModel.Description
    public class WebDispatchFormatterAttribute : Attribute, IOperationBehavior
    {
        private readonly WebDispatchFormatterBehavior _behavior;
        public WebDispatchFormatterAttribute() : this(WebDispatchFormatter.FormatterDirection.Both)
        {
        }
        public WebDispatchFormatterAttribute(WebDispatchFormatter.FormatterDirection direction)
        {
            _behavior = new WebDispatchFormatterBehavior(direction);
        }
        public void ApplyDispatchBehavior(OperationDescription operationDescription, DispatchOperation dispatchOperation)
        {
            _behavior.ApplyDispatchBehavior(operationDescription, dispatchOperation);
        }
        public void ApplyClientBehavior(OperationDescription operationDescription, ClientOperation clientOperation)
        {
            _behavior.ApplyClientBehavior(operationDescription, clientOperation);
        }
        public void AddBindingParameters(Operatio
/*
 * Chunk Manager creates and destroys chunks and the player 
 * moves around
 */
public class ChunkManager{
	private const int CHUNK_RADIUS = 5;
	private Dictionary<int, Chunk> chunks = new Dictionary<int, Chunk>();
	private Chunk AddChunk(int x, int z){
		Debug.Log ("ADDING CHUNK!");
		int idx = (x << 16) ^ z;
		if(!chunks.ContainsKey(idx)){
			Chunk chunk = new Chunk(x, z);	
			chunks[idx] = chunk;
			return chunk;
		}
		return null;
	}
	private void RemoveChunk(int x, int z){
		int idx = (x << 16) ^ z;
		if (chunks.ContainsKey(idx)){
			Debug.Log ("DESTROYING CHUNK!");
			Chunk chunk = chunks[idx];
			chunks.Remove(idx);
			GameObject.Destroy(chunk.go);
		}
	}
	public ChunkManager () {		
		BuildAndDestroyChunks();
	}	
	public void UpdateResolutions(){
		GameObject player = GameObject.Find("Player");
		foreach(Chunk chunk in chunks.Values){
			float distance = (chunk.GetPosition() + new Vector3(Chunk.SIZE_RX/2, 0, Chunk.SIZE_RX/2) - player.transform.position).magnitude;
			float x

			if((chunk.GetSize() < 64) && (x  > 0.00002*chunk.GetSize())){
				while((chunk.GetSize() < 64) && (x  > 0.00002*chunk.GetSize())){
					chunk.DoubleResolution();	
				}
			} 
		}
	}
	public void BuildAndDestroyChunks(){
		GameObject player = GameObject.Find("Player");
		
		
		int player_world_x = (int)Mathf.Round(player.transform.position.x / Chunk.SIZE_RX + 0.5f);
		int player_world_z = (int)Mathf.Round ((player.transform.position.z - (player_world_x-0.5f)*0.577350269189626f*Chunk.SIZE_RX)/Chunk.SIZE_RZ + 0.5f);
		
		AddChunk(player_world_x,player_world_z);
		
		/* create chunk around
		 */
		for(int x = 1; x < CHUNK_RADIUS; x++){
			for	(int z = 1; z < CHUNK_RADIUS; z++){
				if(x + z < CHUNK_RADIUS){
					AddChunk(player_world_x+x,player_world_z+z);
					AddChunk(player_world_x-x,player_world_z-z);
					AddChunk(player_world_x-x,player_world_z+z);
					AddChunk(player_world_x+x,player_world_z-z);
				}
			}
			AddChunk(player_world_x,player_world_z+x);
			AddChunk(player_world_x
namespace AudioSynthesis.Sf2.Chunks
    public class InstrumentChunk : Chunk
    {
        private class RawInstrument
        {
            public string name;
            public ushort startInstrumentZoneIndex;
            public ushort endInstrumentZoneIndex;
        }
        private RawInstrument[] rawInstruments;
        public InstrumentChunk(string id, int size, BinaryReader reader)
            : base(id, size)
        {
            if (size % 22 != 0)
                throw new Exception("Invalid SoundFont. The preset chunk was invalid.");
            rawInstruments = new RawInstrument[size / 22];
            RawInstrument lastInstrument = null;
            for (int x = 0; x < rawInstruments.Length; x++)
            {
                RawInstrument i = new RawInstrument();
                i.name = IOHelper.Read8BitString(reader, 20);
                i.startInstrumentZoneIndex = reader.ReadUInt16();
                if (lastInstrument != null)
                    lastInstrument.en
public class Chunk : MonoBehaviour {
	public int chunkId;
	public int width;
	public int height;
	public int entreanceY;
	public int rightExitY = -1;
	public int upExitX = -1;
	public int downExitX = -1;
	public float orientation;
	[Disable] public ChunkFlow flow = null;
	[Disable] public bool chunkFlowPresent = false;
	[Disable] public Chunk nextChunk;
	[Disable] public Chunk lastChunk;
	[Disable] public bool playerPassedThrought;
	[Disable] public bool isStraight = true;
	[Disable] public bool startingChunk = false;
	[Disable] public Vector2 checkPointLocation;
	public Color32 backgroundColor;
	public int randomToGenerate = -1;
	public ProceduralGeneratorOfChunk proceduralGenerator;
	void OnTriggerEnter2D(Collider2D other) {
		if (other.tag == "Player" && chunkId > proceduralGenerator.currentChunkId) {
			proceduralGenerator.setCurrentChunk(this);
			Camera cam = References.RunnerCamera.camera;
			CameraEffet ce = new CameraEffet(cam.backgroundColor, backgroundColor, cam, 2, Referenc

			References.EffectManager.addEffect(ce);
			playerPassedThrought = true;
			if(randomToGenerate != -1){
				GameData.seed = randomToGenerate;
				GameData.chunkId = chunkId;
			}
		}
	}
	public void copyTo(Chunk chunk){
		chunk.chunkId = this.chunkId;
		chunk.width = this.width;
		chunk.height = this.height;
		chunk.entreanceY = this.entreanceY;
		
		chunk.rightExitY = this.rightExitY;
		chunk.upExitX = this.upExitX;
		chunk.downExitX = this.downExitX;
		
		chunk.orientation = this.orientation;
		
		chunk.flow = this.flow;
		chunk.chunkFlowPresent = this.chunkFlowPresent;
		chunk.nextChunk = this.nextChunk;
		chunk.lastChunk = this.lastChunk;
		chunk.playerPassedThrought = this.playerPassedThrought;
		
		chunk.isStraight = this.isStraight;
		
		chunk.startingChunk = this.startingChunk;
		chunk.checkPointLocation = this.checkPointLocation;
		chunk.backgroundColor = this.backgroundColor;
		
		chunk.randomToGenerate = this.randomToGenerate;
		chunk.proceduralGenerator = this.procedural
namespace Radvill.DataFactory.Public
    public class DataFactory : IDataFactory
    {
        private readonly IRadvillContext _context;
        public DataFactory(
            IRadvillContext context, 
            IUserRepository userRepository, 
            ICategoryRepository categoryRepository, 
            IQuestionRepository questionRepository, 
            IAnswerRepository answerRepository, 
            IPendingQuestionRepository pendingQuestionRepository,
            IAdvisorProfileRepository advisorProfileRepository)
        {
            _context = context;
            UserRepository = userRepository;
            CategoryRepository = categoryRepository;
            QuestionRepository = questionRepository;
            AnswerRepository = answerRepository;
            PendingQuestionRepository = pendingQuestionRepository;
            AdvisorProfileRepository = advisorProfileRepository;
        }
        
        public IUserRepository UserRepository { get; set; }
        publi
namespace TheGrid.Model
    [Serializable]
    public class Cell
    {
        [XmlIgnore]
        public Map Map { get; set; }
        public Point Coord { get; set; }
        public Vector2 Location { get; set; }
        public Vector2 InitialLocation { get; set; }
        [XmlIgnore]
        public Cell[] Neighbourghs { get; set; }
        public Clip Clip { get; set; }
        public Channel Channel { get; set; }
        public float[] Life { get; set; }
        [XmlIgnore]
        public List<TimeValue<Vector2>> ListWave { get; set; }
        [XmlIgnore]
        public float Size { get; set; }
        public Cell() 
        {
            this.ListWave = new List<TimeValue<Vector2>>();
            this.Size = 1f;
        }
        public Cell(Map map, int x, int y, float left, float top)
        {
            this.Map = map;
            this.Coord = new Point(x, y);
            this.Location = new Vector2(left, top);
            this.InitialLocation = new Vector2(left, top);
      

            this.Size = 1f;
            this.Neighbourghs = new Cell[6];
        }
        public int IndexPosition
        {
            get
            {
                return (this.Coord.Y - 1) * this.Map.Width + this.Coord.X - 1;
            }
        }
        public override string ToString()
        {
            return String.Format("{0} : {1},{2}", IndexPosition, Coord.X, Coord.Y);
        }
        public void InitClip()
        {
            if (Clip == null)
                Clip = new Clip();
        }
        public Cell GetDirection(int direction, int iteration)
        {
            Cell cell = this;
            for (int i = 0; i < iteration && cell != null; i++)
            {
                cell = cell.Neighbourghs[direction];
            }
            return cell;
        }
        public void Clone(Cell cellOrigin)
        {
            cellOrigin.Clip = null;
            
            cellOrigin.Channel = this.Channel;
            if (this.Clip != null)
           

                cellOrigin.Clip = new Clip();
                for (int i = 0; i < 6; i++)
                {
                    cellOrigin.Clip.Directions[i] = this.Clip.Directions[i];
                }
                cellOrigin.Clip.Repeater = this.Clip.Repeater;
                cellOrigin.Clip.Speed = this.Clip.Speed;
                cellOrigin.Clip.Duration = this.Clip.Duration;
                if (this.Clip.Instrument != null)
                {
                    if (this.Clip.Instrument is InstrumentSample)
                    {
                        cellOrigin.Clip.Instrument = new InstrumentSample(((InstrumentSample)this.Clip.Instrument).Sample);
                    }
                    else if (this.Clip.Instrument is InstrumentEffect)
                    {
                        cellOrigin.Clip.Instrument = new InstrumentEffect(((InstrumentEffect)this.Clip.Instrument).ChannelEffect);
                    }
                    else if (this.Clip.Instrument is InstrumentSt
namespace Controller
    public class ControllerSupervitec
    {
        private TestController controllerTest;
        private Supervitec supervitec;
        private ModuleController controllerModule;
        
        public ControllerSupervitec() {
            supervitec = Supervitec.GetSupervitec;
        }
        public TestController Test_Controller
        {
            get
            {
                if (controllerTest==null)
                {
                    controllerTest = new TestController();
                }
                return controllerTest;           
            }
        }
        public static SerialController Serial_Controller
        {
            get
            {
                return SerialController.Serial_Controller;
            }
        }
        public ModuleController Module_Controller
        {
            get
            {
                if (controllerModule == null)
                {
                    controllerModule = new ModuleControll
namespace MissionPlanner.Controls
    public static class ControlHelpers
    {
        public static void InvokeIfRequired<T>(this T control, Action<T> action) where T : ISynchronizeInvoke
        {
            if (control.InvokeRequired)
            {
                control.Invoke(new Action(() => action(control)), null);
            }
            else
            {
                action(control);
            }
        }
        public static void InvokeIfRequired(this ISynchronizeInvoke control, MethodInvoker action)
        {
            if (control.InvokeRequired)
            {
                control.Invoke(action, null);
            }
            else
            {
                action();
            }
        }
        public static void BeginInvokeIfRequired<T>(this T control, Action<T> action) where T : ISynchronizeInvoke
        {
            if (control.InvokeRequired)
            {
                control.BeginInvoke(new Action(() => action(control)), null);
           
public class ChunkGenerator : MonoBehaviour {
	public int seed = 0;
	public int chunkSize = 10;
	public int chunkLoadRadius = 5;
	public GameObject[] chunks;
	public GameObject follow;
	Vector2 lastchunk,currentchunk;
	void Start () {
		Vector2 chunk_position = new Vector2(Mathf.FloorToInt(follow.transform.position.x/chunkSize),Mathf.FloorToInt(follow.transform.position.y/chunkSize));
		GameObject g;
		for(int x = -chunkLoadRadius; x<chunkLoadRadius; x++)
		{ 
			for(int y = -chunkLoadRadius; y<chunkLoadRadius; y++)
			{
				
				Random.seed = (int)((chunk_position.x+x)+(chunk_position.y+y))+seed;
				g = (GameObject)GameObject.Instantiate(chunks[Random.Range(0,chunks.GetLength(0))],new Vector3((chunk_position.x+x)*chunkSize,(chunk_position.y+y)*chunkSize,0),Quaternion.identity);
				g.GetComponent<ChunkBehavior>().radius = chunkSize * chunkLoadRadius;
				g.GetComponent<ChunkBehavior>().follow = follow;
			
			}
		}
	}
	void Update () {
		Vector2 chunk_position = new Vector2(Mathf.Flo

		currentchunk = chunk_position;
		if(currentchunk != lastchunk)
		{
			if(currentchunk.x > lastchunk.x)
			{
				GameObject g;
				for(int y = -chunkLoadRadius; y<chunkLoadRadius; y++)
				{
					Random.seed = (int)((chunk_position.x+1)+(chunk_position.y+y))+seed;
					g = (GameObject)GameObject.Instantiate(chunks[Random.Range(0,chunks.GetLength(0))],new Vector3((chunk_position.x+(chunkLoadRadius-1))*chunkSize,(chunk_position.y+y)*chunkSize,0),Quaternion.identity);
					g.GetComponent<ChunkBehavior>().radius = chunkSize * chunkLoadRadius;
					g.GetComponent<ChunkBehavior>().follow = follow;
				}
			}
			if(currentchunk.x < lastchunk.x)
			{
				GameObject g;
				for(int y = -chunkLoadRadius; y<chunkLoadRadius; y++)
				{
					Random.seed = (int)((chunk_position.x+1)+(chunk_position.y+y))+seed;
					g = (GameObject)GameObject.Instantiate(chunks[Random.Range(0,chunks.GetLength(0))],new Vector3((chunk_position.x-(chunkLoadRadius-1))*chunkSize,(chunk_position.y+y)*chunkSize,0),Quaterni

					g.GetComponent<ChunkBehavior>().radius = chunkSize * chunkLoadRadius;
					g.GetComponent<ChunkBehavior>().follow = follow;
				}
			}
			if(currentchunk.y > lastchunk.y)
			{
				GameObject g;
				for(int y = -chunkLoadRadius; y<chunkLoadRadius; y++)
				{
					Random.seed = (int)((chunk_position.x+1)+(chunk_position.y+y))+seed;
					g = (GameObject)GameObject.Instantiate(chunks[Random.Range(0,chunks.GetLength(0))],new Vector3((chunk_position.x+y)*chunkSize,(chunk_position.y+(chunkLoadRadius-1))*chunkSize,0),Quaternion.identity);
					g.GetComponent<ChunkBehavior>().radius = chunkSize * chunkLoadRadius;
					g.GetComponent<ChunkBehavior>().follow = follow;
				}
			}
			if(currentchunk.y < lastchunk.y)
			{
				GameObject g;
				for(int y = -chunkLoadRadius; y<chunkLoadRadius; y++)
				{
					Random.seed = (int)((chunk_position.x-1)+(chunk_position.y+y))+seed;
					g = (GameObject)GameObject.Instantiate(chunks[Random.Range(0,chunks.GetLength(0))],new Vector3((chunk_position.x-y)
[CreateAssetMenu(menuName = "Prototype/CharactersActions/StartClimbingAction")]
public class StartClimbingAction : _Action
    public override void Execute(CharacterStateController controller)
    {
        StartClimb(controller);
    }
    private void StartClimb(CharacterStateController controller)
    {
        if (controller.m_CharacterController.climbingTop)
        {
            controller.m_CharacterController.climbAnchorTop = controller.m_CharacterController.climbCollider.transform.parent.transform.GetChild(2);
            Debug.Log("Scendo");
            controller.m_CharacterController.startClimbAnimationTop = true;
        }
        else
        {
            controller.m_CharacterController.climbAnchorBottom = controller.m_CharacterController.climbCollider.transform.parent.transform.GetChild(3);
            Debug.Log("Salgo");
            controller.m_CharacterController.CharacterTansform.DOMove(controller.m_CharacterController.climbAnchorBottom.position, 1f);
        }
   
namespace MiNETDevToolsPlugin.Models
    [Serializable]
    public class ChunkData
    {
        public int X { get; set; }
        public int Z { get; set; }
        public ChunkColumnInfo[] ColumnInfo { get; set; }
        internal static ChunkData FromChunk(ChunkColumn chunk)
        {
            var columnInfo = new ChunkColumnInfo[16*16];
            for (int z = 0; z < 16; z++)
            {
                for (int x = 0; x < 16; x++)
                {
                    var info = new ChunkColumnInfo
                    {
                        X = x,
                        Z = z,
                        BiomeId = chunk.GetBiome(x, z),
                        Height = GetHeightFix(chunk, x, z)
                    };
                    columnInfo[z * 16 + x] = info;
                }
            }
            return new ChunkData()
            {
                X = chunk.x,
                Z = chunk.z,
                ColumnInfo = columnInfo
            };
        }
       
namespace Debugger
	public partial class NDebugger
	{
		List<Process> processCollection = new List<Process>();
		
		public event EventHandler<ProcessEventArgs> ProcessStarted;
		public event EventHandler<ProcessEventArgs> ProcessExited;
		
		public IList<Process> Processes {
			get {
				return processCollection.AsReadOnly();
			}
		}
		internal Process GetProcess(ICorDebugProcess corProcess)
		{
			foreach (Process process in Processes) {
				if (process.CorProcess == corProcess) {
					return process;
				}
			}
			return null;
		}
		internal void AddProcess(Process process)
		{
			processCollection.Add(process);
			OnProcessStarted(process);
		}
		internal void RemoveProcess(Process process)
		{
			processCollection.Remove(process);
			OnProcessExited(process);
			if (processCollection.Count == 0) {
				this.MTA2STA.AsyncCall( delegate { this.TerminateDebugger(); } );
			}
		}
		protected virtual void OnProcessStarted(Process process)
		{
			if (ProcessStarted != null) {
				Process
namespace MiNET.Worlds
	public class FlatlandWorldProvider : IWorldProvider
	{
		private readonly ConcurrentDictionary<ChunkCoordinates, ChunkColumn> _chunkCache = new ConcurrentDictionary<ChunkCoordinates, ChunkColumn>();
		public bool IsCaching { get; private set; }
		public FlatlandWorldProvider()
		{
			IsCaching = true;
		}
		public void Initialize()
		{
		}
		Random rand = new Random();
		public ChunkColumn GenerateChunkColumn(ChunkCoordinates chunkCoordinates)
		{
			lock (_chunkCache)
			{
				ChunkColumn cachedChunk;
				if (_chunkCache.TryGetValue(chunkCoordinates, out cachedChunk))
				{
					return cachedChunk;
				}
				ChunkColumn chunk = new ChunkColumn();
				chunk.x = chunkCoordinates.X;
				chunk.z = chunkCoordinates.Z;
				int h = PopulateChunk(chunk);
				chunk.SetBlock(0, h + 1, 0, 7);
				chunk.SetBlock(1, h + 1, 0, 41);
				chunk.SetBlock(2, h + 1, 0, 41);
				chunk.SetBlock(3, h + 1, 0, 41);
				chunk.SetBlock(3, h + 1, 0, 41);
				chunk.SetBlock(0, h, 0, 31);
	

				chunk.SetBlock(0, h, 2, 18);
				chunk.SetBlock(0, h, 15, 31);
				chunk.SetBlock(0, h, 14, 161);
				chunk.SetBlock(0, h, 13, 18);
				chunk.SetBlock(6, h, 9, 63);
				chunk.SetMetadata(6, h, 9, 12);
				var blockEntity = GetBlockEntity((chunkCoordinates.X*16) + 6, h, (chunkCoordinates.Z*16) + 9);
				chunk.SetBlockEntity(blockEntity.Coordinates, blockEntity.GetCompound());
				if (chunkCoordinates.X == 1 && chunkCoordinates.Z == 1)
				{
					for (int x = 0; x < 10; x++)
					{
						for (int z = 0; z < 10; z++)
						{
							for (int y = h - 2; y < h; y++)
							{
								chunk.SetBlock(x, y, z, 8);
							}
						}
					}
				}
				if (chunkCoordinates.X == 3 && chunkCoordinates.Z == 1)
				{
					for (int x = 0; x < 10; x++)
					{
						for (int z = 0; z < 10; z++)
						{
							for (int y = h - 1; y < h; y++)
							{
								chunk.SetBlock(x, y, z, 10);
							}
						}
					}
				}
				for (int x = 0; x < 16; x++)
				{
					for (int z = 0; z < 16; z++)
					{
						fo

						{
							if (chunk.GetBlock(x, y, z) == 0x00)
							{
								chunk.SetSkylight(x, y, z, 0xff);
							}
							else
							{
								chunk.SetSkylight(x, y, z, 0x00);
							}
						}
					}
				}
				chunk.GetBatch();
				_chunkCache[chunkCoordinates] = chunk;
				return chunk;
			}
		}
		public Vector3 GetSpawnPoint()
		{
			return new Vector3(0, 12, 0);
		}
		public long GetTime()
		{
			return 0;
		}
		public int PopulateChunk(ChunkColumn chunk)
		{
			int h = 0;
			var random = new CryptoRandom();
			var stones = new byte[16*16*128];
			for (int i = 0; i < stones.Length; i = i + 128)
			{
				h = 1;
				switch (random.Next(0, 20))
				{
					case 0:
						stones[i + h++] = 3;
						break;
					case 1:
						break;
					case 2:
						break;
					case 3:
						break;
					case 4:
						break;
					case 5:
						break;
					default:
						break;
				}
			}
			chunk.blocks = stones;
			return h;
		}
		public void SaveChunks()
		{
		}
		private Sign GetBlockEntity(int x, int y
namespace Lab1.Library.DataAccess
	public class ObjectRepositoryFactory : IRepositoryFactory
	{
		public ReaderRepository CreateReaderRepository()
		{
			return new ReaderObjectRepository();
		}
		public BookRepository CreateBookRepository(LibraryDepartmentRepository libraryDepartmentRepository)
		{
			return new BookObjectRepository(libraryDepartmentRepository);
		}
		public LibrarianRepository CreateLibrarianRepository(LibraryDepartmentRepository libraryDepartmentRepository)
		{
			return new LibrarianObjectRepository(libraryDepartmentRepository);
		}
		public LibraryDepartmentRepository CreateLibraryDepartmentRepository()
		{
			return new LibraryDepartmentObjectRepository();
		}
		public OrderRepository CreateOrderRepository(ReaderRepository readerRepository, BookRepository bookRepository, 
			LibraryDepartmentRepository libraryDepartmentRepository, LibrarianRepository librarianRepository)
		{
			return new OrderObjectRepository(readerRepository, bookRepository, libraryDepartmentRe
public class MyController : MonoBehaviour {
    public enum Side
    {
        side1,
        side2
    }
	public static GameController gc
	{
		get {return GetGameController (); }
	}
	public static ClickController cc
	{
		get {return GetClickController (); }
	}
    public static GameController GetGameController()
    {
        GameController gameController = null;
        GameObject gameControllerObject = GameObject.FindWithTag("GameController");
        if (gameControllerObject != null)
        {
            gameController = gameControllerObject.GetComponent<GameController>();
        }
        if (gameController == null)
        {
            Debug.Log("Cant find gameController script");
        }
        return gameController;
    }
	public static ClickController GetClickController()
	{
		ClickController clickController = null;
		GameObject gameControllerObject = GameObject.FindWithTag("GameController");
		if (gameControllerObject != null)
		{
			clickController = gameControllerObje
/* Copyright 2013-2015 MongoDB Inc.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
namespace MongoDB.Bson.IO
    public sealed class OutputBufferChunkSource : IBsonChunkSource
    {
        const int DefaultInitialUnpooledChunkSize = 1024;
        const int DefaultMaxChunkSize = 1 * 1024 * 1024;
        const int DefaultMinChunkSize = 16 * 1024;
        private readonly IBsonChunkSource _baseSource;
        private bool _disposed;
        private int _initialUnpooledChunkSize;
        private readonly int _maxChunkSize;
        private readonly in

        private int _previousChunkSize;
        public OutputBufferChunkSource(
            IBsonChunkSource baseSource,
            int initialUnpooledChunkSize = DefaultInitialUnpooledChunkSize,
            int minChunkSize = DefaultMinChunkSize,
            int maxChunkSize = DefaultMaxChunkSize)
        {
            if (baseSource == null)
            {
                throw new ArgumentNullException("baseSource");
            }
            if (initialUnpooledChunkSize < 0)
            {
                throw new ArgumentOutOfRangeException("initialUnpooledChunkSize");
            }
            if (minChunkSize <= 0)
            {
                throw new ArgumentOutOfRangeException("minChunkSize");
            }
            if (maxChunkSize <= 0)
            {
                throw new ArgumentOutOfRangeException("maxChunkSize");
            }
            if (!PowerOf2.IsPowerOf2(minChunkSize))
            {
                throw new ArgumentException("minChunkSize is not a pow

            }
            if (!PowerOf2.IsPowerOf2(maxChunkSize))
            {
                throw new ArgumentException("maxChunkSize is not a power of 2.", "maxChunkSize");
            }
            if (maxChunkSize < minChunkSize)
            {
                throw new ArgumentException("maxChunkSize is less than minChunkSize", "maxChunkSize");
            }
            _baseSource = baseSource;
            _initialUnpooledChunkSize = initialUnpooledChunkSize;
            _minChunkSize = minChunkSize;
            _maxChunkSize = maxChunkSize;
        }
        public IBsonChunkSource BaseSource
        {
            get
            {
                ThrowIfDisposed();
                return _baseSource;
            }
        }
        public int InitialUnpooledChunkSize
        {
            get { return _initialUnpooledChunkSize; }
        }
        public int MaxChunkSize
        {
            get { return _maxChunkSize; }
        }
        public int MinChunkSize
        {
 
namespace ISharpConvertor.DAL.Abstract
    public interface IRepositoryHolder:IDisposable
    
    {
        Entity.ISharpConvertorEntities Context { get; }
        IAdressRepository AdressRepository { get; }
        IBankRepository BankRepository { get; }
        ICominsRepository CominsRepository { get; }
        ICurrencyRepository CurrencyRepository { get; }
        ICurrencyRateRepository CurrencyRateRepository { get; }
        IExpodentureRepository ExpodentureRepository { get; }
        IIncomeRepository IncomeRepository { get; }
        INewsRepository NewsRepository { get; }
        IOperationCominsRepository OperationCominsRepository { get; }
        IOperationDetailsRepository OperationDetailsRepository { get; }
        IOperationRepository OperationRepository { get; }
        IRateRepository RateRepository { get; }
        IRssUserNewsRepository RssUserNewsRepository { get; }
        IRssUserRepository RssUserRepository { get; }
        ISystemCominRepository SystemCominRep
namespace DistributedDesktop
    public static class ChunkUtils
    {
        #region Packing Methods
        public static void Pack(BufferChunk aChunk, int x, int y)
        {
            aChunk += x;
            aChunk += y;
        }
        public static void Pack(BufferChunk aChunk, int left, int top, int right, int bottom)
        {
            aChunk += left;
            aChunk += top;
            aChunk += right;
            aChunk += bottom;
        }
        public static void Pack(BufferChunk chunk, Point aPoint)
        {
            chunk += aPoint.X;
            chunk += aPoint.Y;
        }
        public static void Pack(BufferChunk chunk, Point[] points)
        {
            chunk += points.Length;
            for (int i = 0; i < points.Length; i++)
            {
                Pack(chunk, points[i].X, points[i].Y);
            }
        }
        public static void Pack(BufferChunk chunk, Guid uniqueID)
        {
            chunk += uniqueID.ToByteArray();
        
namespace MinecraftClone.Domain.Renderer {
	class TerrainRenderer {
		private World world;
		private GameObject chunkPrefab;
		private GameObject target;
		public TerrainRenderer(World world, GameObject target) {
			this.world = world;
			this.target = target;
			this.chunkPrefab = Resources.Load("Prefabs/Chunk") as GameObject;
		}
		public void Init() {
			Unload ();
		}
		public void Unload() {
			foreach (var chunk in world.Chunks.Values) {
				foreach (var obj in chunk.GameObjects.Values) {
					GameObject.Destroy (obj);
				}
				chunk.GameObjects.Clear ();
			}
		}
		public bool IsDrawed(Vector3 position) {
			return IsDrawed (ChunkAddress.FromPosition (position));
		}
		public bool IsDrawed(ChunkAddress address) {
			return world.IsGenerated (address) && world [address].GameObjects.Count > 0;
		}
		public void Redraw(Vector3 position) {
			Redraw (ChunkAddress.FromPosition (position));
		}
		public void Redraw(ChunkAddress address) {
			var chunk = world [address];
			SetMesh (c
namespace RealtimeInstrumentDataApp.Tests
    [TestFixture]
    public class GuiInstrumentTests
    {
        private GuiInstrument _guiInstrument;
        private List<double> _prices;
        [SetUp]
        public void InitialSetup()
        {
            _guiInstrument = new GuiInstrument();
            _guiInstrument.Prices = new List<double>();
            _prices = new List<double>()
            {
                15.0,
                16.3,
                17.8,
                25.2,
                14.5
            };
            foreach (var price in _prices)
            {
                _guiInstrument.AddPrice(price);
            }
        }
        [Test]
        public void SetInstrumentName_RetrieveNameFromGuiInstrument()
        {
            var expected = "VOD.L";
            _guiInstrument.Name = "VOD.L";
            Assert.AreEqual(expected, _guiInstrument.Name);
        }
        [Test]
        public void SetInstrumentPrices_RetrievePricesFromGuiIntrument_TestAddPr
namespace LinFu.AOP.Interfaces
    internal class CompositeAroundInvoke : IAroundInvoke
    {
        private readonly IList<IAroundInvoke> _aroundInvokeList = new List<IAroundInvoke>();
        public CompositeAroundInvoke(IEnumerable<IAroundInvoke> aroundInvokeList)
        {
            if (aroundInvokeList == null)
                throw new ArgumentNullException("aroundInvokeList");
            foreach (var current in aroundInvokeList)
            {
                if (current == null)
                    continue;
                _aroundInvokeList.Add(current);
            }
        }
        public void AfterInvoke(IInvocationInfo context, object returnValue)
        {
            foreach (var invoke in _aroundInvokeList)
            {
                invoke.AfterInvoke(context, returnValue);
            }
        }
        public void BeforeInvoke(IInvocationInfo context)
        {
            foreach (var invoke in _aroundInvokeList)
            {
                invoke.BeforeI
namespace Utility
   public  class ProcessHelper
    {
       public static void CloseProcess(string processName)
       {
           Process[] processes = Process.GetProcessesByName(processName);
           foreach (Process p in processes)
           {
               p.CloseMainWindow();
               p.Kill();
           }
       }
       public static  void CloseProcess(int processId)
       {
            try
            {
                Process processes = Process.GetProcessById(processId);
                if (processes != null)
                {
                    processes.CloseMainWindow();
                    processes.Kill();
                }
            }
            catch(ArgumentException)
            {
            }
       }
       public static List<int> GetRunningProcessIds(string processName)
       {
           var processId = new List<int>();
           var processes = Process.GetProcessesByName(processName);
           foreach (Process p in processes)
           
namespace Service
    public interface IDispatchWaybillLineService : IDisposable
    {
        DispatchWaybillLine Create(DispatchWaybillLine s);
        void Delete(int id);
        void Delete(DispatchWaybillLine s);
        void Update(DispatchWaybillLine s);
        void DeleteForDispatchWaybillHeaderId(int DispatchWaybillHeaderid);
        IQueryable<DispatchWaybillLine> GetDispatchWaybillLineList();
        IQueryable<DispatchWaybillLine> GetDispatchWaybillLineForHeaderId(int DispatchWaybillHeaderId);
        DispatchWaybillLine GetDispatchWaybillLineForLineId(int DispatchWaybillLineId);
        DispatchWaybillLineViewModel GetDispatchWaybillLineViewModelForLineId(int DispatchWaybillLineId);
        IQueryable<DispatchWaybillLineViewModel> GetDispatchWaybillLineViewModelForHeaderId(int DispatchWaybillHeaderId);
    }
    public class DispatchWaybillLineService : IDispatchWaybillLineService
    {
        ApplicationDbContext db = new ApplicationDbContext();
        private readonl

        public DispatchWaybillLineService(IUnitOfWorkForService unitOfWork)
        {
            _unitOfWork = unitOfWork;
        }
        public void Dispose()
        {
        }
        public DispatchWaybillLine Create(DispatchWaybillLine S)
        {
            S.ObjectState = ObjectState.Added;
            _unitOfWork.Repository<DispatchWaybillLine>().Insert(S);
            return S;
        }
        public void Delete(int id)
        {
            _unitOfWork.Repository<DispatchWaybillLine>().Delete(id);
        }
        public void Delete(DispatchWaybillLine s)
        {
            _unitOfWork.Repository<DispatchWaybillLine>().Delete(s);
        }
        public void DeleteForDispatchWaybillHeaderId(int DispatchWaybillHeaderid)
        {
            var DispatchWaybillLine = from L in db.DispatchWaybillLine where L.DispatchWaybillHeaderId == DispatchWaybillHeaderid select new { DispatchWaybillLindId = L.DispatchWaybillLineId };
            foreach (var item in DispatchW

            {
                Delete(item.DispatchWaybillLindId);
            }
        }
        public void Update(DispatchWaybillLine s)
        {
            s.ObjectState = ObjectState.Modified;
            _unitOfWork.Repository<DispatchWaybillLine>().Update(s);
        }
        public IQueryable<DispatchWaybillLine> GetDispatchWaybillLineList()
        {
            return _unitOfWork.Repository<DispatchWaybillLine>().Query().Get();
        }
        public IQueryable<DispatchWaybillLine> GetDispatchWaybillLineForHeaderId(int DispatchWaybillHeaderId)
        {
            return _unitOfWork.Repository<DispatchWaybillLine>().Query().Get().Where(m => m.DispatchWaybillHeaderId == DispatchWaybillHeaderId);
        }
        public DispatchWaybillLine GetDispatchWaybillLineForLineId(int DispatchWaybillLineId)
        {
            return _unitOfWork.Repository<DispatchWaybillLine>().Query().Get().Where(m => m.DispatchWaybillLineId == DispatchWaybillLineId).FirstOrDefault();
       
namespace Vienna.Processes
    public class ProcessManager
    {
        protected List<Process> ProcessList;
        public ProcessManager()
        {
            ProcessList = new List<Process>();
        }
        public ProcessCounter UpdateProcesses(long delta)
	    {
            var counter = new ProcessCounter();
            for (var i = 0; i < ProcessList.Count; i++)
            {
                var process = ProcessList[i];
                if (process.State == ProcessState.Uninitialized)
                    process.OnInit();
                if (process.State == ProcessState.Running)
                    process.OnUpdate(delta);
                if (process.IsDead)
                {
                    HandleDeadProcess(process, ref counter);
                }          
            }
	        return counter;
	    }
	    public void AttachProcess(Process process)
        {
            ProcessList.Add(process);
        }
        public void AbortAllProcesses(bool immediate)
      

            for (var i = 0; i < ProcessList.Count; i++)
            {
                var process = ProcessList[i];
                if (!process.IsAlive) continue;
                process.State = ProcessState.Aborted;
                
                if (!immediate) continue;
                process.OnAbort();
                ProcessList.Remove(process);
            }
        }
        public int Count
        {
            get { return ProcessList.Count; }
        }
        public void Clear()
        {
            ProcessList.Clear();
        }
        private void HandleDeadProcess(Process process, ref ProcessCounter counter)
        {
            var successCount = 0;
            var failCount = 0;
            switch (process.State)
            {
                case ProcessState.Succeeded:
                    process.OnSuccess();
                    var child = process.RemoveChild();
                    if (child != null)
                        AttachProcess(child);
            
namespace InstrumentApp
    class Instrument
    {
        #region Properties
        internal string serialNumber { get; }
        internal double price { get; set; }
        internal InstrumentSpec spec { get; }
        internal InstrumentType instrumentType { get; }
        #endregion
        private InstrumentType getInstrumentType(InstrumentSpec spec)
        {
            if (spec is GuitarSpec)
            {
                return InstrumentType.Guitar;
            }
            else if (spec is MandolinSpec)
            {
                return InstrumentType.Mandolin; 
            }
            return InstrumentType.Unknown;
        }
        #region Initialization
        public Instrument(string serialNumber,
                          double price,
                          InstrumentSpec spec)
        {
            this.serialNumber = serialNumber;
            this.price = price;
            this.spec = spec;
            this.instrumentType = getInstrumentType(spec);
      
public class ActualPlayerChunk : MonoBehaviour 
	public ChunkLength m_chunkLength;
	public GameObject m_player;
	private Vector3 m_playerPosition;	
	private int[] chunkLength = new int[3];
	private bool[] chunkFound = new bool[3];
	private int[] chunkAnzahl = new int[3];	
	private Vector3 actualChunk;	
	void Start () 
	{
		allValuesToStart();		
	}
	/*void Update()
	{
		calculateActualPlayerPosition();		
		calculateActualChunk();
		calculateChunkPosition();
		allValuesToStart();	
	}*/
	public Vector3 GetActualPlayerChunk()
	{
		calculateActualPlayerPosition();		
		calculateActualChunk();
		calculateChunkPosition();
		allValuesToStart();	
		return actualChunk;
	}
	void allValuesToStart()
	{
		chunkLength[0] = m_chunkLength.GetChunkLength(0);
		chunkLength[1] = m_chunkLength.GetChunkLength(1);
		chunkLength[2] = m_chunkLength.GetChunkLength(2);
		for(int i = 0; i < 3; i++)
		{
			chunkFound[i] = false;
			chunkAnzahl[i] = 0;
		}
	}	
	void calculateActualPlayerPosition()
	{		
		m_playerPos

	}	
	void calculateActualChunk()
	{		
		while( chunkFound[0] == false || chunkFound[1] == false || chunkFound[2] == false )
		{	
			calculateActualChunkAxis(0, m_playerPosition.x);
			calculateActualChunkAxis(1, m_playerPosition.y);
			calculateActualChunkAxis(2, m_playerPosition.z);
		}		
	}
	void calculateActualChunkAxis(int axis, float playerPositionAxis)
	{		
		if(chunkFound[axis] == false)
		{				
			if((playerPositionAxis < (chunkLength[axis] * chunkAnzahl[axis]) + chunkLength[axis]) && playerPositionAxis > 0)
			{
				chunkFound[axis] = true;					
			}
			if((playerPositionAxis > (-chunkLength[axis] * chunkAnzahl[axis]) - chunkLength[axis]) && playerPositionAxis < 0)
			{						
				chunkFound[axis] = true;
				chunkAnzahl[axis]++;
				chunkLength[axis] = -chunkLength[axis];
			}
			if(chunkFound[axis] == false)
			{
				chunkAnzahl[axis]++;					
			}
		}
		
	}
	void calculateChunkPosition()
	{
		actualChunk = new Vector3(chunkAnzahl[0] * chunkLength[0], chunkAnzahl[1] * chunkLe
namespace Dargon.Processes.Watching
   public class ProcessWatcherServiceImpl : ProcessWatcherService
   {
      private static readonly Logger logger = LogManager.GetCurrentClassLogger();
      private readonly IProcessProxy processProxy;
      private readonly IProcessWatcher processWatcher;
      private readonly MultiValueDictionary<string, Action<CreatedProcessDescriptor>> processSpawnedHandlersByProcessName = new MultiValueDictionary<string, Action<CreatedProcessDescriptor>>();
      public ProcessWatcherServiceImpl(IProcessProxy processProxy, IProcessWatcher processWatcher)
      {
         logger.Info("Constructing Process Watching Service");
         this.processProxy = processProxy;
         this.processWatcher = processWatcher;
      }
      public void Initialize()
      {
         logger.Info("Initializing Process Watching Service");
         this.processWatcher.NewProcessFound += HandleProcessWatcherNewProcessFound;
         this.processWatcher.Start();
      }
      inte

      {
         var lowerProcessName = e.ProcessName.ToLower();
         HashSet<Action<CreatedProcessDescriptor>> handlers;
         if (processSpawnedHandlersByProcessName.TryGetValue(lowerProcessName, out handlers)) {
            foreach (var handler in handlers) {
               try {
                  handler(new CreatedProcessDescriptor(e.ProcessName, e.ProcessID, e.ParentProcessID));
               } catch (Exception ex) {
                  logger.Error("Process watcher handler threw", ex);
               }
            }
         }
      }
      public void Subscribe(Action<CreatedProcessDescriptor> handler, SCG.IEnumerable<string> names, bool retroactive)
      {
         var lowerCaseNames = new ItzWarty.Collections.HashSet<string>(names.Select(FormatProcessName));
         foreach (var lowerCaseName in lowerCaseNames) {
            processSpawnedHandlersByProcessName.Add(lowerCaseName, handler);
         }
         if (retroactive) {
            var processes = processWatch
namespace MFDExtractor.UI
	class InstrumentForms
	{
		public InstrumentForm AccelerometerForm { get; set; }
		public InstrumentForm ADIForm { get; set; }
		public InstrumentForm AltimeterForm { get; set; }
		public InstrumentForm AOAIndexerForm { get; set; }
		public InstrumentForm AOAIndicatorForm { get; set; }
		public InstrumentForm ASIForm { get; set; }
		public InstrumentForm BackupAdiForm { get; set; }
		public InstrumentForm CabinPressForm { get; set; }
		public InstrumentForm CautionPanelForm { get; set; }
		public InstrumentForm CMDSPanelForm { get; set; }
		public InstrumentForm CompassForm { get; set; }
		public InstrumentForm DEDForm { get; set; }
		public InstrumentForm EHSIForm { get; set; }
		public InstrumentForm EPUFuelForm { get; set; }
		public InstrumentForm FTIT1Form { get; set; }
		public InstrumentForm FTIT2Form { get; set; }
		public InstrumentForm FuelFlowForm { get; set; }
		public InstrumentForm FuelQuantityForm { get; set; }
		public InstrumentForm HSIForm {

		public InstrumentForm HUDForm { get; set; }
		public InstrumentForm HydAForm { get; set; }
		public InstrumentForm HydBForm { get; set; }
		public InstrumentForm ISISForm { get; set; }
		public InstrumentForm LandingGearLightsForm { get; set; }
		public InstrumentForm LeftMFDForm { get; set; }
		public InstrumentForm MFD3Form { get; set; }
		public InstrumentForm MFD4Form { get; set; }
		public InstrumentForm NOZPos1Form { get; set; }
		public InstrumentForm NOZPos2Form { get; set; }
		public InstrumentForm NWSIndexerForm { get; set; }
		public InstrumentForm OILGauge1Form { get; set; }
		public InstrumentForm OILGauge2Form { get; set; }
		public InstrumentForm PFLForm { get; set; }
		public InstrumentForm PitchTrimForm { get; set; }
		public InstrumentForm RightMfdForm { get; set; }
		public InstrumentForm RollTrimForm { get; set; }
		public InstrumentForm RPM1Form { get; set; }
		public InstrumentForm RPM2Form { get; set; }
		public InstrumentForm RWRForm { get; set; }
		public In
namespace OSCConnect.Controllers
    class ProcessController
    {
        public static bool IsProcessRunning(String processName)
        {
            Process[] pname = Process.GetProcessesByName(processName);
            return ((pname.Length != 0) ? true : false);
        }
        public static bool IsProcessRunning(int processID)
        {
            try
            {
                Process pname = Process.GetProcessById(processID);
                return (pname != null);
            }
            catch (Exception)
            {
                return (false);
            }
        }
        public static bool IsProcessRunning(Process process)
        {
            return IsProcessRunning(process.Id);
        }
        public static bool KillProcess(Process process)
        {
            if (process != null)
            {
                int processId = process.Id;
                
                if (!process.HasExited)
                {
                    process.Close();
  
namespace BlogApp.DLL.UoW
    public class UnitOfWork : IDisposable
    {
        private readonly BlogAppContext _context = null;
        private Repository<Blog> _blogRepository = null;
        private Repository<Category> _categoryRepository;
        private Repository<Comment> _commentRepository = null;
        private Repository<Role> _roleRepository = null;
        private Repository<User> _userRepository = null;
        public UnitOfWork(Repository<Blog> blogRepository, Repository<Category> categoryRepository, Repository<Comment> commentRepository, Repository<Role> roleRepository, Repository<User> userRepository)
        {
            _blogRepository = blogRepository;
            _categoryRepository = categoryRepository;
            _commentRepository = commentRepository;
            _roleRepository = roleRepository;
            _userRepository = userRepository;
            _context = new BlogAppContext();
        }
        public Repository<Blog> BlogRepository
        {
      
namespace Lte.WebApp.Controllers.Topic
    public class QueryCollegeRegionController : ApiController
    {
        private readonly ICollegeRepository _repository;
        public QueryCollegeRegionController(ICollegeRepository repository)
        {
            _repository = repository;
        }
        public CollegeRegion Get(int id)
        {
            return _repository.GetRegion(id);
        }
    }
    public class CollegeQueryController : ApiController
    {
        private readonly ICollegeRepository _repository;
        public CollegeQueryController(ICollegeRepository repository)
        {
            _repository = repository;
        }
        [HttpGet]
        public IHttpActionResult Get(int id)
        {
            CollegeInfo info = _repository.Get(id);
            return info == null ? (IHttpActionResult)BadRequest("College Id Not Found!") : Ok(info);
        }
        [HttpGet]
        public IHttpActionResult Get(string name)
        {
            CollegeInfo info =

            return info == null ? (IHttpActionResult) BadRequest("College Name Not Found!") : Ok(info);
        }
        [HttpGet]
        public IEnumerable<CollegeInfo> Get()
        {
            return _repository.GetAll();
        }
    }
    public class CollegeENodebController : ApiController
    {
        private readonly IInfrastructureRepository _repository;
        private readonly IENodebRepository _eNodebRepository;
        public CollegeENodebController(IInfrastructureRepository repository, IENodebRepository eNodebRepository)
        {
            _repository = repository;
            _eNodebRepository = eNodebRepository;
        }
        [HttpGet]
        public IEnumerable<string> Get(string collegeName)
        {
            return _repository.QueryCollegeENodebNames(_eNodebRepository, collegeName);
        }
    }
    public class CollegeENodebsController : ApiController
    {
        private readonly IInfrastructureRepository _repository;
        private readonly 

        private readonly IAlarmRepository _alarmRepository;
        public CollegeENodebsController(IInfrastructureRepository repository, IENodebRepository eNodebRepository,
            IAlarmRepository alarmRepository)
        {
            _repository = repository;
            _eNodebRepository = eNodebRepository;
            _alarmRepository = alarmRepository;
        }
        [HttpGet]
        public IEnumerable<ENodebView> Get(string collegeName)
        {
            return _repository.QueryCollegeENodebs(_eNodebRepository, _alarmRepository, collegeName);
        }
    }
    public class CollegeBtssController : ApiController
    {
        private readonly IInfrastructureRepository _repository;
        private readonly IBtsRepository _btsRepository;
        public CollegeBtssController(IInfrastructureRepository repository, IBtsRepository btsRepository)
        {
            _repository = repository;
            _btsRepository = btsRepository;
        }
        [HttpGet]
        
public class WorldManager : MonoBehaviour {
	public Vector2 worldChunkSize = new Vector2(15.0f, 10.0f);
	public uint    chunkBlockSize = 3u;
	private WorldChunkTable _chunkCache  = null;
	private Vector2 		_spawnPoint  = Vector2.zero;
	private WorldChunkIndex _currentIndx = WorldChunkIndex.Origin;
	public Vector2 SpawnPoint
	{
		get { return _spawnPoint; }
	}
	public string RootChunk
	{
		set
		{
			 DebugUtils.Assert(_chunkCache != null);
			_chunkCache.LoadWorldChunk(value, WorldChunkIndex.Origin);
		}
	}
	void Start () {
		
		 DebugUtils.Assert(_chunkCache == null);
		_chunkCache = new WorldChunkTable(worldChunkSize);
        SetFocusedChunk("area_01-01", _currentIndx);
	}
    public void TransitionToChunk(WorldDirection chunkDir, string sceneName)
    {
        WorldChunkIndex newChunkIndex = _currentIndx + WorldDirectionUtils.GetWorldChunkOffset(chunkDir);
        WorldChunk newChunk = _chunkCache[newChunkIndex];
        DebugUtils.Assert(newChunk != null, "WorldManager::Transitio

            sceneName, newChunkIndex.x, newChunkIndex.y);
        newChunk.AddLoadCompleteDelegate(delegate(string loadedSceneName) {
            DebugUtils.Assert(loadedSceneName == sceneName, "WorldManager::Transition() - '{0}' was not the chunk we found at ({1},{2}), '{3}' was",
                sceneName, newChunkIndex.x, newChunkIndex.y, loadedSceneName);
            SetFocusedChunk(sceneName, newChunkIndex);
        });
    }
	private WorldChunk LoadChunkBlock(int    chunkX,
								      int    chunkY,
							          string chunkName,
								      int    leftPadding,
		 						      int    rightPadding,
                                      int    upperPadding,
                                      int    lowerPadding)
	{
		if (chunkName == null)
			return null;
		WorldChunk chunk = _chunkCache.LoadWorldChunk(chunkName, new WorldChunkIndex(chunkX, chunkY));
        Action<string> loadDelegate = delegate(string sceneName) {
            DebugUtils.Assert(chunk.isValid);
        

                LoadChunkBlock(chunkX - 1, chunkY, chunk[WorldDirection.Left], leftPadding - 1, 0, upperPadding, lowerPadding);
            if (rightPadding > 0)
                LoadChunkBlock(chunkX + 1, chunkY, chunk[WorldDirection.Right], 0, rightPadding - 1, upperPadding, lowerPadding);
            if (upperPadding > 0)
                LoadChunkBlock(chunkX, chunkY - 1, chunk[WorldDirection.Up], leftPadding, rightPadding, upperPadding - 1, 0);
            if (lowerPadding > 0)
                LoadChunkBlock(chunkX, chunkY + 1, chunk[WorldDirection.Down], leftPadding, rightPadding, 0, lowerPadding - 1);
        };
        chunk.AddLoadCompleteDelegate(loadDelegate);
        return chunk;
	}
    private void SetFocusedChunk(string chunkName, WorldChunkIndex atIndex)
    {
        WorldChunk oldChunk = _chunkCache[_currentIndx];
        if (oldChunk != null)
        {
            oldChunk.AddLoadCompleteDelegate(delegate(string sceneName) {
                oldChunk.focused = false;
 
﻿namespace DrBeshoyClinic.DAL.Repositories.Infrastructure
    public interface IUnitOfWork
    {
        ChronicDiseaseRepository ChronicDiseaseRepository { get; }
        DrugHxRepository DrugHxRepository { get; }
        EmgNcvRepository EmgNcvRepository { get; }
        ExaminationChronicDiseaseRepository ExaminationChronicDiseaseRepository { get; }
        ExaminationRepository ExaminationRepository { get; }
        FamilyHxRepository FamilyHxRepository { get; }
        LabTestRepository LabTestRepository { get; }
        MedicineDetailsRepository MedicineDetailsRepository { get; }
        MedicineRepository MedicineRepository { get; }
        OperationRepository OperationRepository { get; }
        PatientRepository PatientRepository { get; }
        PhotoRepository PhotoRepository { get; }
        RadiologyRepository RadiologyRepository { get; }
        SurgicalHxRepository SurgicalHxRepository { get; }
        TreatmentDescriptionRepository TreatmentDescriptionRepository { get; 
namespace osc.net
    public class MessageDispatch
    {
        private Dictionary<string, List<Action<Message>>> dispatchTable = new Dictionary<string, List<Action<Message>>>();
        public void RegisterMethod(string oscMethod, Action<Message> callback) {
            if (dispatchTable.ContainsKey(oscMethod)) {
                dispatchTable[oscMethod].Add(callback);
            }
            else {
                dispatchTable[oscMethod] = new List<Action<Message>>() {
                    callback
                };
            }
        }
        public void UnregisterMethod(string oscMethod) {
            dispatchTable.Remove(oscMethod);
        }
        public void UnregisterCallback(string oscMethod, Action<Message> callback) {
            if (dispatchTable.ContainsKey(oscMethod)) {
                dispatchTable[oscMethod].Remove(callback);
            }
        }
        public void UnregisterCallback(Action<Message> callback) {
            foreach (var callbackList in dispa
namespace GVFS.UnitTests.Common
    [TestFixture]
    public class ProcessHelperTests
    {
        [TestCase]
        public void GetCommandLineTest()
        {
            Process internalProcess = null;
            StreamWriter stdin = null;
            try
            {
                ProcessStartInfo processInfo = new ProcessStartInfo("git.exe");
                processInfo.UseShellExecute = false;
                processInfo.RedirectStandardOutput = false;
                processInfo.RedirectStandardError = false;
                processInfo.RedirectStandardInput = true;
                processInfo.Arguments = "hash-object --stdin";
                internalProcess = Process.Start(processInfo);
                stdin = internalProcess.StandardInput;
                string commandLine = ProcessHelper.GetCommandLine(Process.GetProcessById(internalProcess.Id));
                commandLine.EndsWith("\"git.exe\" hash-object --stdin").ShouldEqual(true);
            }
            finally
namespace QuantBox.Helper.CTPZQ
    public sealed class CTPZQAPI
    {
        private static readonly CTPZQAPI instance = new CTPZQAPI();
        private CTPZQAPI()
        {
        }
        public static CTPZQAPI GetInstance()
        {
            return instance;
        }
        public void __RegTdApi(IntPtr pTdApi)
        {
            m_pTdApi = pTdApi;
        }
        public void __RegMdApi(IntPtr pMdApi)
        {
            m_pMdApi = pMdApi;
        }
        #region 合列列表
        private Dictionary<string, CZQThostFtdcInstrumentField> _dictInstruments = null;
        public void __RegInstrumentDictionary(Dictionary<string, CZQThostFtdcInstrumentField> dict)
        {
            _dictInstruments = dict;
        }
        public delegate void RspQryInstrument(CZQThostFtdcInstrumentField pInstrument);
        public event RspQryInstrument OnRspQryInstrument;
        public void FireOnRspQryInstrument(CZQThostFtdcInstrumentField pInstrument)
        {
            if (nul

            {
                OnRspQryInstrument(pInstrument);
            }
        }
        public void ReqQryInstrument(string instrument)
        {
            if (null != _dictInstruments)
            {
                CZQThostFtdcInstrumentField value;
                if (_dictInstruments.TryGetValue(instrument, out value))
                {
                    FireOnRspQryInstrument(value);
                    return;
                }
            }
            if (!string.IsNullOrEmpty(instrument)
                    && null != m_pTdApi
                    && IntPtr.Zero != m_pTdApi)
            {
                TraderApi.TD_ReqQryInstrument(m_pTdApi, instrument);
            }
        }
        #endregion
        #region 保证金率
        #endregion
        #region 手续费率
        private Dictionary<string, CZQThostFtdcInstrumentCommissionRateField> _dictCommissionRate = null;
        public void __RegInstrumentCommissionRateDictionary(Dictionary<string, CZQThostFtdcInstrumentCommi

        {
            _dictCommissionRate = dict;
        }
        public void ReqQryInstrumentCommissionRate(string instrument)
        {
            if (null != _dictCommissionRate)
            {
                CZQThostFtdcInstrumentCommissionRateField value;
                if (_dictCommissionRate.TryGetValue(instrument, out value))
                {
                    FireOnRspQryInstrumentCommissionRate(value);
                    return;
                }
            }
            if (!string.IsNullOrEmpty(instrument)
                && null != m_pTdApi
                && IntPtr.Zero != m_pTdApi)
            {
                TraderApi.TD_ReqQryInstrumentCommissionRate(m_pTdApi, instrument);
            }
        }
        public delegate void RspQryInstrumentCommissionRate(CZQThostFtdcInstrumentCommissionRateField pInstrumentCommissionRate);
        public event RspQryInstrumentCommissionRate OnRspQryInstrumentCommissionRate;
        public void FireOnRspQryInstrumentCommiss
namespace Omnipresence.Processing
    public class ApiServices:IDisposable
    {
        #region [FIELDS]
        private OmnipresenceEntities db;
        private static ApiServices instance;
        #endregion
        #region [CONSTRUCTOR]
        private ApiServices()
        {
            db = new OmnipresenceEntities();
            db.Connection.Open();
        }
        public static ApiServices GetInstance()
        {
            if (instance == null)
            {
                instance = new ApiServices();
            }
            return instance;
        }
        #endregion
        #region [CRUD]
        public bool CreateApiUser(CreateApiUserModel caum)
        {
            ApiUser apiUser = new ApiUser();
            apiUser.ApiKey = caum.ApiKey;
            apiUser.Email = caum.Email;
            apiUser.AppName = caum.AppName;
            apiUser.LastCallDate = DateTime.Now;
            apiUser.ApiCallCount = 0;
            db.AddToApiUsers(apiUser);
            db.Sa

            return true;
        }
        public bool UpdateApiUser(ApiUserModel aum)
        {
            ApiUser apiUser = db.ApiUsers.Where(u => u.ApiUserId == aum.ApiUserId).FirstOrDefault();
            if (apiUser != null)
            {
                apiUser.ApiKey = aum.ApiKey;
                apiUser.ApiCallCount = aum.ApiCallCount;
                apiUser.LastCallDate = aum.LastCallDate;
                apiUser.AppName = aum.AppName;
                apiUser.Email = aum.Email;
                db.SaveChanges();
                return true;
            }
            else
            {
                return false;
            }
        }
        public bool DeleteApiUser(DeleteApiUserModel daum)
        {
            ApiUser apiUser = db.ApiUsers.Where(u => u.ApiUserId == daum.ApiUserId).FirstOrDefault();
            if (apiUser != null)
            {
                db.DeleteObject(apiUser);
                db.SaveChanges();
                return true;
            }
      

            {
                return false;
            }
        }
        #endregion
        #region [SEARCH]
        public ApiUserModel GetApiUserById(int id)
        {
            ApiUser apiUser = db.ApiUsers.Where(account => account.ApiUserId == id).FirstOrDefault();
            ApiUserModel apiUserModel = Utilities.ApiUserToApiUserModel(apiUser);
            return apiUserModel;
        }
        public ApiUserModel GetApiUserByEmail(string email)
        {
            ApiUser apiUser = db.ApiUsers.Where(account => account.Email == email).FirstOrDefault();
            ApiUserModel apiUserModel = Utilities.ApiUserToApiUserModel(apiUser);
            return apiUserModel;
        }
        public ApiUserModel GetApiUserByApiKey(string apiKey)
        {
            ApiUser apiUser = db.ApiUsers.Where(account => account.ApiKey == apiKey).FirstOrDefault();
            ApiUserModel apiUserModel = Utilities.ApiUserToApiUserModel(apiUser);
            return apiUserModel;
        }
   
public static class ChunkManager {
    static bool dirtyChunks = false;
    static Dictionary<IntPoint, MapChunk> chunks = new Dictionary<IntPoint, MapChunk>();
    static List<MapChunk> dirtyList = new List<MapChunk>();
    static IntPoint pointer = new IntPoint(-1, -1);
    public static GameObject MapChunks;
    public static MapChunk CreateChunk (int x, int y)
    {
        MapChunk chunk = new MapChunk(x, y);
        chunks.Add(chunk.pos, chunk);
        chunk.gameobject.transform.parent = MapChunks.transform;
        chunk.gameobject.transform.position = new Vector3(x * MapChunk.chunkSize, y * MapChunk.chunkSize, 0);
        return chunk;
    }
    public static MapChunk GetChunk(int x, int y)
    {
        pointer.X = x;
        pointer.Y = y;
        if (chunks.ContainsKey(pointer))
            return chunks[pointer];
        return null;
    }
    public static void SpawnChunks ()
    {
        int widthInChunks = MapGenerator.instance.Map.width / MapChunk.chunkSize;
        i
[System.Serializable]
public class ComplexityBranch{
	public int branchFrom = -1;
	public int id;
	public bool inBranch = false;
	public List<ComplexityChunk> complexities = new List<ComplexityChunk>();
	public bool AddBranch(ComplexityBranch branch){
		bool branchAdded = false;
		ComplexityChunk chunk = FindComplexityChunk (branch.branchFrom);
		if (chunk.zoneChunkId != -1) {
			chunk.branches.Add (branch);
			branchAdded = true;
		}
		return branchAdded;
	}
	public ComplexityChunk FindComplexityChunk(int number){
		ComplexityChunk foundChunk = new ComplexityChunk();
		foundChunk.zoneChunkId = -1;
		foreach(ComplexityChunk chunk in complexities){
			if (chunk.zoneChunkId == number) {
				foundChunk = chunk;
				/*if(foundChunk.zoneChunkId != -1){
					break;
				}*/
			} else {
				foreach (ComplexityBranch branch in chunk.branches) {
					foundChunk = branch.FindComplexityChunk (number);
					/*if(foundChunk.zoneChunkId != -1){
						break;
					}*/
				}
			}
		}
		return foundChunk
namespace Umbra.Implementations
    public class SetupThread
    {
        ChunkQueue LoadQueue;
        ChunkQueue GenerationQueue;
        ChunkQueue VegetationQueue;
        ChunkQueue BuildQueue;
        ChunkQueue SetupQueue;
        ChunkQueue UnloadQueue;
        public void AddToLoad(Chunk chunk)
        {
            LoadQueue.Enqueue(chunk);
        }
        public void AddToGeneration(Chunk chunk)
        {
            GenerationQueue.Enqueue(chunk);
        }
        public void AddToVegetation(Chunk chunk)
        {
            VegetationQueue.Enqueue(chunk);
        }
        public void AddToBuild(Chunk chunk)
        {
            BuildQueue.Enqueue(chunk);
        }
        public void AddToSetup(Chunk chunk)
        {
            SetupQueue.AddSorted(chunk);
        }
        public void AddToUnload(Chunk chunk)
        {
            if (!LoadQueue.Contains(chunk))
            {
                UnloadQueue.Enqueue(chunk);
            }
            LoadQueue.Remove(ch

            GenerationQueue.Remove(chunk);
            VegetationQueue.Remove(chunk);
            BuildQueue.Remove(chunk);
            SetupQueue.Remove(chunk);
            chunk.WillBeUnloaded = true;
        }
        public void Run()
        {
            LoadQueue = new ChunkQueue();
            GenerationQueue = new ChunkQueue();
            VegetationQueue = new ChunkQueue();
            BuildQueue = new ChunkQueue();
            SetupQueue = new ChunkQueue();
            UnloadQueue = new ChunkQueue();
            Chunk currentChunk;
            while (true)
            {
                if (!Variables.Game.IsInitialized)
                {
                    continue;
                }
                if (UnloadQueue.Count > 0)
                {
                    currentChunk = UnloadQueue.Dequeue();
                    if (currentChunk == null)
                    {
                        continue;
                    }
                    if (Constants.World.SaveDynamic

                    {
                        ChunkManager.StoreChunkImmediate(currentChunk);
                    }
                    else
                    {
                        currentChunk = null;
                    }
                    Console.Write("UnloadQueue: " + GenerationQueue.Count);
                    LoadQueue.Remove(currentChunk);
                    GenerationQueue.Remove(currentChunk);
                    SetupQueue.Remove(currentChunk);
                }
                else if (LoadQueue.Count > 0)
                {
                    currentChunk = LoadQueue.Dequeue();
                    if (currentChunk == null)
                    {
                        continue;
                    }
                    ChunkManager.LoadChunkImmediate(currentChunk);
                    currentChunk.BuildOctree();
                    currentChunk.HasData = true;
                    Console.Write("LoadQueue: " + GenerationQueue.Count);
                    if (SetupQ
namespace DispatchRider.AspNetCore
    public static class DispatchRiderExtension
    {
        static public IApplicationBuilder UseDispatchRider(this IApplicationBuilder app)
        {
            EnableRewind(app);
            return app.UseMiddleware<DispatchRiderMiddleware>();
        }
        static private void EnableRewind(IApplicationBuilder app)
        {
            app.Use(next => async context => {
                var initialBody = context.Request.Body;
                context.Request.EnableRewind();
                await next(context);
                return;
            });
        }
        public static DispatchRiderServicesBuilder AddDispatchRider(this IServiceCollection services)
        {
            return services.AddDispatchRider(configureOptions: null);
        }
        static public DispatchRiderServicesBuilder AddDispatchRider(this IServiceCollection services, Action<DispatchRiderOptions> configureOptions)
        {
            services.TryAddTransient<IDisp
namespace ECommon.Storage
    public class ChunkHeader
    {
        public const int Size = 128;
        public readonly int ChunkNumber;
        public readonly int ChunkDataTotalSize;
        public readonly long ChunkDataStartPosition;
        public readonly long ChunkDataEndPosition;
        public ChunkHeader(int chunkNumber, int chunkDataTotalSize)
        {
            Ensure.Nonnegative(chunkNumber, "chunkNumber");
            Ensure.Positive(chunkDataTotalSize, "chunkDataTotalSize");
            ChunkNumber = chunkNumber;
            ChunkDataTotalSize = chunkDataTotalSize;
            ChunkDataStartPosition = ChunkNumber * (long)ChunkDataTotalSize;
            ChunkDataEndPosition = (ChunkNumber + 1) * (long)ChunkDataTotalSize;
        }
        public byte[] AsByteArray()
        {
            var array = new byte[Size];
            {
                {
                    writer.Write(ChunkNumber);
                    writer.Write(ChunkDataTotalSize);
                }
   

            return array;
        }
        public static ChunkHeader FromStream(BinaryReader reader, Stream stream)
        {
            var chunkNumber = reader.ReadInt32();
            var chunkDataTotalSize = reader.ReadInt32();
            return new ChunkHeader(chunkNumber, chunkDataTotalSize);
        }
        public int GetLocalDataPosition(long globalDataPosition)
        {
            if (globalDataPosition < ChunkDataStartPosition || globalDataPosition > ChunkDataEndPosition)
            {
                throw new Exception(string.Format("globalDataPosition {0} is out of chunk data positions [{1}, {2}].", globalDataPosition, ChunkDataStartPosition, ChunkDataEndPosition));
            }
            return (int)(globalDataPosition - ChunkDataStartPosition);
        }
        public override string ToString()
        {
            return string.Format("[ChunkNumber:{0}, ChunkDataTotalSize:{1}, ChunkDataStartPosition:{2}, ChunkDataEndPosition:{3}]",
                         
namespace WIMARTS.DB.BLL
	public partial class DispatchMasterBLL
	{
       
		private DispatchMasterDAO _DispatchMasterDAO;
		public DispatchMasterDAO DispatchMasterDAO
		{
			get { return _DispatchMasterDAO; }
			set { _DispatchMasterDAO = value; }
		}
		public DispatchMasterBLL()
		{
			DispatchMasterDAO = new DispatchMasterDAO();
		}
        public List<DispatchMaster> GetDispatchMasters(BLLManager.MasterStatus Flag)
		{
			try
			{
				return DispatchMasterDAO.GetDispatchMasters((int)Flag);
			}
			catch(Exception ex)
			{
				throw ex;
			}
		}
		public DispatchMaster GetDispatchMaster(int DispMasterID)
		{
			try
			{
				return DispatchMasterDAO.GetDispatchMaster(DispMasterID);
			}
			catch(Exception ex)
			{
				throw ex;
			}
		}
		public int AddDispatchMaster(DispatchMaster oDispatchMaster)
		{
			try
			{
				return DispatchMasterDAO.AddDispatchMaster(oDispatchMaster);
			}
			catch (Exception ex)
			{
				throw ex;
			}
		}
		public int UpdateDispatchMaster(DispatchMaster 

		{
			try
			{
				return DispatchMasterDAO.UpdateDispatchMaster(oDispatchMaster);
			}
			catch (Exception ex)
			{
				throw ex;
			}
		}
		public int RemoveDispatchMaster(DispatchMaster oDispatchMaster)
		{
			try
			{
				return DispatchMasterDAO.RemoveDispatchMaster(oDispatchMaster);
			}
			catch (Exception ex)
			{
				throw ex;
			}
		}
		public int RemoveDispatchMaster(int DispMasterID)
		{
			try
			{
				return DispatchMasterDAO.RemoveDispatchMaster(DispMasterID);
			}
			catch (Exception ex)
			{
				throw ex;
			}
		}
		public List<DispatchMaster> DeserializeDispatchMasters(string Path)
		{
			try
			{
				return GenericXmlSerializer<List<DispatchMaster>>.Deserialize(Path);
			}
			catch (Exception ex)
			{
				throw ex;
			}
		}
		public void SerializeDispatchMasters(string Path, List<DispatchMaster> DispatchMasters)
		{
			try
			{
				GenericXmlSerializer<List<DispatchMaster>>.Serialize(DispatchMasters, Path);
			}
			catch (Exception ex)
			{
				throw ex;
			}
		}
	
namespace VehicleGPS.Views.Control.DispatchCentre.VehicleDispatch
    public partial class DispatchTaskUserControl : UserControl
    {
        public DispatchTaskUserControl()
        {
            InitializeComponent();
        }
        public static readonly DependencyProperty DispatchTaskProperty = DependencyProperty.Register("DispatchTask", typeof(VehicleDispatchItemViewModel), typeof(DispatchTaskUserControl));
        public VehicleDispatchItemViewModel DispatchTask
        {
            get
            {
                return (VehicleDispatchItemViewModel)GetValue(DispatchTaskProperty);
            }
            set
            {
                SetValue(DispatchTaskProperty, value);
            }
        }
        private void Image_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        {
            DispatchVehicle infoWin = new DispatchVehicle(this.DataContext);
            infoWin.Owner = Window.GetWindow(this);
            infoWin.ShowDialog();
        }
        
namespace CourseServer.Repositories.Advance
    public class DispatchManageRepository : Repository
    {
        public List<Dictionary<string, object>> GetAll()
        {
            List<Dictionary<string, object>> Ret = null;
            {
                DbSet<Dispatch> dispatches = context.Set<Dispatch>();
                if (dispatches.Count() <= 0)
                {
                    return Ret;
                }
                Dictionary<string, object> dispatchInfo;
                Ret = new List<Dictionary<string, object>>(dispatches.Count());
                var result = dispatches.ToList();
                foreach (var dispatch in result)
                {
                    dispatchInfo = new Dictionary<string, object>();
                    dispatchInfo.Add("Id", dispatch.Id);
                    dispatchInfo.Add("Name", dispatch.Course.Name);
                    dispatchInfo.Add("ClassroomId", dispatch.ClassroomId);
                    dispatchInfo.Add("Location", di

                    dispatchInfo.Add("TeacherId", dispatch.TeacherId);
                    dispatchInfo.Add("TeacherName", dispatch.Teacher.Name);
                    dispatchInfo.Add("Weekday", dispatch.Weekday);
                    dispatchInfo.Add("At", dispatch.At);
                    dispatchInfo.Add("Limit", dispatch.Limit);
                    Ret.Add(dispatchInfo);
                }
            }
            return Ret;
        }
        public bool Create(string weekday, DateTime at,
            int limit,
            int teacherId, int courseId, int roomId)
        {
            bool bRet = false;
            {
                DbSet<Course> courses = context.Set<Course>();
                DbSet<Teacher> teachers = context.Set<Teacher>();
                DbSet<Classroom> classrooms = context.Set<Classroom>();
                var course = courses.Where(c => c.Id == courseId).FirstOrDefault();
                var teacher = teachers.Where(t => t.Id == teacherId).FirstOrDefault(

                var classroom = classrooms.Where(c => c.Id == roomId).FirstOrDefault();
                if (course == null || teacher == null || classroom == null)
                {
                    return bRet;
                }
                DbSet<Dispatch> dispatches = context.Set<Dispatch>();
                Dispatch dispatch = new Dispatch() { Course = course, Teacher = teacher,
                    Weekday = weekday, At = at, Limit = limit, Enable = true,
                    Classroom = classroom};
                dispatches.Add(dispatch);
                context.SaveChanges();
                bRet = true;
            }
            return bRet;
        }
        public bool Destroy(int id)
        {
            bool bRet = false;
            {
                DbSet<Dispatch> dispatches = context.Set<Dispatch>();
                Dispatch dispatch = dispatches.Where(d => d.Id == id).FirstOrDefault();
                if (dispatch != null)
                {
                    d
[assembly: guitarlib.RegisterEvent(typeof(guitarlib.InvokeEventMaker))]
namespace guitarlib {
    public class InvokeEventMaker : EventMaker
    {
        private static InvokeEventMaker instance = new InvokeEventMaker();
        public static InvokeEventMaker Instance
        {
            get
            {
                return instance;
            }
        }
        public override bool isSupportedBy(WidgetI component)
        {
            AutomationElement element = component.Element;
            return (bool) element.GetCurrentPropertyValue(
                AutomationElement.IsInvokePatternAvailableProperty);
        }
        public override Ice.Object makeObject(WidgetI component)
        {
            return new InvokeEvent(component);
        }
    }
    public class InvokeEvent : ActionDisp_
    {
        public static readonly string Name = "Invoke";
        private WidgetI component;
        public InvokeEvent(WidgetI component) {
            this.component = component;
namespace Curan.Common.FormalizedData.File.Riff.Avi
	public class RiffChunkListInfo : RiffChunkList
	{
		public const string TYPE = "INFO";
		public static readonly Dictionary<string,Type> chunkTypeDictionary;
		public static readonly Dictionary<string,Type> bodyTypeDictionary;
		public readonly RiffChunkIart chunkIart;
		public readonly RiffChunkIcms chunkIcms;
		public readonly RiffChunkIcmt chunkIcmt;
		public readonly RiffChunkIcop chunkIcop;
		public readonly RiffChunkIcrd chunkIcrd;
		public readonly RiffChunkIeng chunkIeng;
		public readonly RiffChunkIgnr chunkIgnr;
		public readonly RiffChunkIkey chunkIkey;
		public readonly RiffChunkInam chunkInam;
		public readonly RiffChunkIprd chunkIprd;
		public readonly RiffChunkIsbj chunkIsbj;
		public readonly RiffChunkIsft chunkIsft;
		public readonly RiffChunkIsrc chunkIsrc;
		public readonly RiffChunkItch chunkItch;
		static RiffChunkListInfo()
		{
			chunkTypeDictionary = new Dictionary<string, Type>();
			chunkTypeDictionary.Add( R

			chunkTypeDictionary.Add( RiffChunkIcms.ID, typeof( RiffChunkIcms ) );
			chunkTypeDictionary.Add( RiffChunkIcmt.ID, typeof( RiffChunkIcmt ) );
			chunkTypeDictionary.Add( RiffChunkIcop.ID, typeof( RiffChunkIcop ) );
			chunkTypeDictionary.Add( RiffChunkIcrd.ID, typeof( RiffChunkIcrd ) );
			chunkTypeDictionary.Add( RiffChunkIeng.ID, typeof( RiffChunkIeng ) );
			chunkTypeDictionary.Add( RiffChunkIgnr.ID, typeof( RiffChunkIgnr ) );
			chunkTypeDictionary.Add( RiffChunkIkey.ID, typeof( RiffChunkIkey ) );
			chunkTypeDictionary.Add( RiffChunkInam.ID, typeof( RiffChunkInam ) );
			chunkTypeDictionary.Add( RiffChunkIprd.ID, typeof( RiffChunkIprd ) );
			chunkTypeDictionary.Add( RiffChunkIsbj.ID, typeof( RiffChunkIsbj ) );
			chunkTypeDictionary.Add( RiffChunkIsft.ID, typeof( RiffChunkIsft ) );
			chunkTypeDictionary.Add( RiffChunkIsrc.ID, typeof( RiffChunkIsrc ) );
			chunkTypeDictionary.Add( RiffChunkItch.ID, typeof( RiffChunkItch ) );
			bodyTypeDictionary = new Dictionary<string, Typ

		}
		public RiffChunkListInfo( string aId, UInt32 aSize, ByteArray aByteArray, RiffChunkList aParent )
			: base( chunkTypeDictionary, bodyTypeDictionary, aId, aSize, aByteArray, aParent )
		{
			type = TYPE;
			chunkIart = ( RiffChunkIart )GetChunk( RiffChunkIart.ID );
			chunkIcms = ( RiffChunkIcms )GetChunk( RiffChunkIcms.ID );
			chunkIcmt = ( RiffChunkIcmt )GetChunk( RiffChunkIcmt.ID );
			chunkIcop = ( RiffChunkIcop )GetChunk( RiffChunkIcop.ID );
			chunkIcrd = ( RiffChunkIcrd )GetChunk( RiffChunkIcrd.ID );
			chunkIeng = ( RiffChunkIeng )GetChunk( RiffChunkIeng.ID );
			chunkIgnr = ( RiffChunkIgnr )GetChunk( RiffChunkIgnr.ID );
			chunkIkey = ( RiffChunkIkey )GetChunk( RiffChunkIkey.ID );
			chunkInam = ( RiffChunkInam )GetChunk( RiffChunkInam.ID );
			chunkIprd = ( RiffChunkIprd )GetChunk( RiffChunkIprd.ID );
			chunkIsbj = ( RiffChunkIsbj )GetChunk( RiffChunkIsbj.ID );
			chunkIsft = ( RiffChunkIsft )GetChunk( RiffChunkIsft.ID );
			chunkIsrc = ( RiffChunkIsrc )GetChunk( Rif
namespace Assets
    public class World : MonoBehaviour
    {
        readonly IDictionary<WorldPos, Chunk> _chunks = new Dictionary<WorldPos, Chunk>();
        public void Start()
        {
            for (var x = 0; x < 16; x++)
            {
                for (var z = 0; z < 16; z++)
                {
                    CreateChunk(x * 16, 0, z * 16);
                }
            }
        }
        public void Update()
        {
        }
        public Chunk GetChunk(WorldPos worldPos)
        {
            float multiple = Chunk.ChunkSize;
            var chunkWorldPos = new WorldPos(
                Mathf.FloorToInt(worldPos.X / multiple) * Chunk.ChunkSize,
                Mathf.FloorToInt(worldPos.Y / multiple) * Chunk.ChunkSize,
                Mathf.FloorToInt(worldPos.Z / multiple) * Chunk.ChunkSize);
            Chunk chunk;
            _chunks.TryGetValue(chunkWorldPos, out chunk);
            return chunk;
        }
        public Block GetBlock(WorldPos worldPos)
  

            if (worldPos.X < 0 || worldPos.Y < 0 || worldPos.Z < 0)
                return new BlockAir();
            var chunk = GetChunk(worldPos);
            if (chunk != null)
            {
                return chunk.GetBlock(worldPos.X - chunk.WorldPos.X, worldPos.Y - chunk.WorldPos.Y,
                    worldPos.Z - chunk.WorldPos.Z);
            }
            return new BlockAir();
        }
        public Block this[int x, int y, int z]
        {
            get { return GetBlock(new WorldPos(x, y, z)); }
        }
        public void CreateChunk(int x, int y, int z)
        {
            var worldPos = new WorldPos(x, y, z);
            var chunkObject = new GameObject(string.Format("Chunk[{0}, {1}, {2}]", x, y, z));
            chunkObject.transform.position = new Vector3(x, y, z);
            chunkObject.AddComponent<Chunk>();
            var chunk = chunkObject.GetComponent<Chunk>();
            chunk.WorldPos = worldPos;
            chunk.World = this;
            va
namespace FpmlSerializedCSharp
    public class IdentifiedAsset
    {
        public IdentifiedAsset(XmlNode xmlNode)
        : base(xmlNode)
        {
            XmlNodeList instrumentIdNodeList = xmlNode.SelectNodes("instrumentId");
            
            foreach (XmlNode item in instrumentIdNodeList)
            {
                if (item.Attributes["href"] != null || item.Attributes["id"] == null) 
                {
                    if (item.Attributes["id"] != null) 
                    {
                        instrumentIdIDRef = item.Attributes["id"].Name;
                        List<InstrumentId> ob = new List<InstrumentId>();
                        ob.Add(new InstrumentId(item));
                        IDManager.SetID(instrumentIdIDRef, ob);
                    }
                    else if (item.Attributes.ToString() == "href")
                    {
                        instrumentIdIDRef = item.Attributes["href"].Name;
                    }
                    el

                    {
                    instrumentId.Add(new InstrumentId(item));
                    }
                }
            }
            
        
            XmlNodeList descriptionNodeList = xmlNode.SelectNodes("description");
            if (descriptionNodeList.Count > 1 )
            {
                    throw new Exception();
            }
            
            foreach (XmlNode item in descriptionNodeList)
            {
                if (item.Attributes["href"] != null || item.Attributes["id"] == null) 
                {
                    if (item.Attributes["id"] != null) 
                    {
                        descriptionIDRef = item.Attributes["id"].Name;
                        XsdTypeString ob = XsdTypeString();
                        IDManager.SetID(descriptionIDRef, ob);
                    }
                    else if (item.Attributes.ToString() == "href")
                    {
                        descriptionIDRef = item.Attributes["href"

                    }
                    else
                    {
                        description = new XsdTypeString(item);
                    }
                }
            }
            
        
        }
        
    
        #region InstrumentId
        private List<InstrumentId> instrumentId;
        public List<InstrumentId> InstrumentId
        {
            get
            {
                if (this.instrumentId != null)
                {
                    return this.instrumentId; 
                }
                else if (this.instrumentIdIDRef != null)
                {
                    instrumentId = IDManager.getID(instrumentIdIDRef) as List<InstrumentId>;
                    return this.instrumentId; 
                }
                else
                {
                    throw new NotImplementedException();
                }
            }
            set
            {
                if (this.instrumentId != value)
                {
               
namespace GuitarApp1
	public enum Type
	{
		ACOUSITC,
		ELECTRIC
	}
	public enum Builder
	{
		FENDER,
		MARTIN,
		GIBSON,
		COLLINGS,
		OLSON,
		RYAN,
		PRS,
		ANY
	}
	public enum Wood
	{
		INDIAN_ROSEWOOD,
		BRAZILIAN_ROSEWOOD,
		MAHOGANY,
		MAPLE,
		COCOBOLO,
		CEDAR,
		ADIRONDACK,
		ALDER,
		SITKA
	}
	public enum InstrumentType
	{
		GUITAR, 
		BANJO, MANDOLIN, 
		DOBRO,
		FIDDLE,
		BASS
	}
	public class Inventory
	{
		private List<Instrument> instruments;
		public Inventory()
		{
			instruments = new List<Instrument>();
		}
		public void addInstrument(string serialNumber, double price, InstrumentSpec spec)
		{
			Instrument instrument = new Instrument(serialNumber, price, spec);
			instruments.Add(instrument);
		}
		public Instrument getInstrument(string serialNumber)
		{
			foreach (Instrument g in this.instruments)
			{
				if (g.getSerialNumber() == serialNumber)
				{
					return g;
				}
			}
			return null;
		}
		public List<Instrument> search(InstrumentSpec searchSpec)
		{
		
namespace ProcessMonitorWpf
    public class ProcessManagerTester
    {
        private const int DelayBetweenTestStepsInMilliseconds = 3000;
        private ProcessManager _processManager;
        private LogControl _logControl;
        private string _processNamePrefix;
        private bool _wasRestarted;
        public ProcessManagerTester(string processNamePrefix, LogControl logControl)
        {
            _processManager = new ProcessManager();
            _processNamePrefix = processNamePrefix;
            _logControl = logControl;
        }
        public void RunTest(Process process)
        {
            if (process != null
                && !string.IsNullOrEmpty(process.ProcessName)
                && process.ProcessName.StartsWith(_processNamePrefix))
            {
                string processDetails = "[" + process.Id + " " + process.ProcessName + "]";
                bool runSuspendAndResumeTest = false;
                if (!_wasRestarted)
                {
          

                    LogMessage(ProcessUtils.ProcessDetailsToString(process));
                    if (process.StartInfo != null && !string.IsNullOrEmpty(process.StartInfo.FileName))
                    {
                        LogMessage("RunTest: Killing process " + processDetails);
                        try
                        {
                            _processManager.KillProcess(process);
                            LogMessage("RunTest: Process " + processDetails + " killed");
                            Thread.Sleep(DelayBetweenTestStepsInMilliseconds);
                            LogMessage("RunTest: Restarting process " + processDetails);
                            _processManager.RestartProcess(process);
                            LogMessage("RunTest: Process " + processDetails + " restarted");
                        }
                        catch (Exception e)
                        {
                            LogMessage("RunTest: Failed to kill/restart proce

                                + processDetails + ": " + e.Message);
                        }
                    }
                    else
                    {
                        LogMessage("RunTest: Cannot test killing/restarting process "
                            + processDetails + " - the process could not be restarted since the file name is missing from the start info");
                        runSuspendAndResumeTest = true;
                    }
                }
                else
                {
                    _wasRestarted = false;
                    runSuspendAndResumeTest = true;
                }
                if (runSuspendAndResumeTest)
                {
                    RunSuspendAndResumeTest(process, processDetails);
                    Thread.Sleep(DelayBetweenTestStepsInMilliseconds);
                    LogMessage("RunTest: Done testing with process " + processDetails);
                }
            }
        }
        private void RunSu
namespace UnityOps.UnityAsync
    [Serializable]
    public class InvokeAfterDelay : AsyncOperationScript<OperationOutputs, AsyncOperationErrors, OperationProgress>
    {
        #region properties
        protected Action delayInvokeCallback;
        float delay;
        float startTime;
        #endregion
        #region public methods
        public static InvokeAfterDelay Call(Action callback)
        {
            InvokeAfterDelay asyncOps = new InvokeAfterDelay(callback);
            asyncOps.Execute();
            return asyncOps;
        }
        public static InvokeAfterDelay Call(Action callback, float delay)
        {
            InvokeAfterDelay asyncOps = new InvokeAfterDelay(callback, delay);
            asyncOps.Execute();
            return asyncOps;
        }
        public static InvokeAfterDelay Call(float delay, Action callback)
        {
            InvokeAfterDelay asyncOps = new InvokeAfterDelay(delay, callback);
            asyncOps.Execute();
            retur

        }
        public static InvokeAfterDelay Call(string name, Action callback, float delay)
        {
            InvokeAfterDelay asyncOps = new InvokeAfterDelay(name, callback, delay);
            asyncOps.Execute();
            return asyncOps;
        }
        public static InvokeAfterDelay Call(string name, float delay, Action callback)
        {
            InvokeAfterDelay asyncOps = new InvokeAfterDelay(name, delay, callback);
            asyncOps.Execute();
            return asyncOps;
        }
        public InvokeAfterDelay(Action callback) : this(callback, 0.0f)
        {
        }
        public InvokeAfterDelay(float delay, Action callback) : this(callback, delay)
        {
        }
        public InvokeAfterDelay(Action callback, float delay) : this("InvokeAfterDelay", callback, delay)
        {
        }
        public InvokeAfterDelay(string name, float delay, Action callback) : this(name, callback, delay)
        {
        }
        public InvokeAfterDelay(st
namespace Musicfy.Bll.Services
    public class InstrumentService : IInstrumentService
    {
        private readonly IInstrumentRepository _instrumentRepository;
        public InstrumentService(IInstrumentRepository instrumentRepository)
        {
            _instrumentRepository = instrumentRepository;
        }
        public IEnumerable<InstrumentModel> GetAll()
        {
            var instruments = _instrumentRepository.GetAll();
            return instruments.Select(InstrumentMapper.ToInstrumentModel);
        }
        public InstrumentModel GetById(string id)
        {
            var instrument = _instrumentRepository.GetById(id);
            if (instrument == null)
            {
                throw new NotFoundException(Messages.InvalidInstrumentId);
            }
            return InstrumentMapper.ToInstrumentModel(instrument);
        }
        public void Add(InstrumentModel instrumentModel)
        {
            if (string.IsNullOrEmpty(instrumentModel.Name))
     

                throw new ValidationException(Messages.InstrumentNameRequired);
            }
            var instrumentByName = _instrumentRepository.GetByName(instrumentModel.Name);
            if (instrumentByName != null)
            {
                throw new ConflictException(Messages.InstrumentNameAlreadyExists);
            }
            var instrument = InstrumentMapper.ToInstrument(instrumentModel);
            instrument.Id = SecurityUtils.GenerateEntityId();
            _instrumentRepository.Add(instrument);
        }
        public void Update(string id, InstrumentModel instrumentModel)
        {
            if (string.IsNullOrEmpty(instrumentModel.Name))
            {
                throw new ValidationException(Messages.InstrumentNameRequired);
            }
            var instrument = _instrumentRepository.GetById(id);
            if (instrument == null)
            {
                throw new NotFoundException(Messages.InvalidInstrumentId);
            }
          
public class HairBufferUpdater : MonoBehaviour {
	public hBuffUpdater updater;
			
	public void Live() {
		if( updater == null){
			updater = GetComponent<hBuffUpdater>();
		}
	 	ExtraEnable();
		updater.OnBeforeCollisionDispatch += BeforeCollisionDispatch;
		updater.OnAfterCollisionDispatch += AfterCollisionDispatch;
		updater.OnBeforeConstraintDispatch += BeforeConstraintDispatch;
		updater.OnAfterConstraintDispatch += AfterConstraintDispatch;
	}
	public void Die(){
		updater.OnBeforeCollisionDispatch -= BeforeCollisionDispatch;
		updater.OnAfterCollisionDispatch -= AfterCollisionDispatch;
		updater.OnBeforeConstraintDispatch -= BeforeConstraintDispatch;
		updater.OnAfterConstraintDispatch -= AfterConstraintDispatch;
	}
	public virtual void ExtraEnable(){}
	public virtual void BeforeCollisionDispatch(ComputeShader computeShader , int _kernel){}
	public virtual void AfterCollisionDispatch(ComputeShader computeShader , int _kernel){}
	public virtual void BeforeConstraintDispatch(Comput
namespace QuanLyDonHang.Data.MongoDb
    public class UnitOfWork : IDisposable
    {
        private UserRepository _userRepository;
        private CustomerGroupRepository _customerGroupRepository;
        private CustomerRepository _customerRepository;
        private ProductGroupRepository _productGroupRepository;
        private ProductUnitRepository _productUnitRepository;
        private ProductRepository _productRepository;
        private OrderRepository _orderRepository;
        public UnitOfWork(MongoHelper helper)
        {
            DataHelper = helper;
        }
        public MongoHelper DataHelper { get; set; }
        public UserRepository UserRepository => _userRepository ?? (_userRepository = new UserRepository(DataHelper,
                                                                                                         User.COLLECTIONNAME));
        public CustomerGroupRepository CustomerGroupRepository => _customerGroupRepository ?? (_customerGroupRepository

                                                                                                                                                      CustomerGroup.COLLECTIONNAME));
        public CustomerRepository CustomerRepository => _customerRepository ?? (_customerRepository = new CustomerRepository(DataHelper,
                                                                                                                             Customer.COLLECTIONNAME));
        public ProductGroupRepository ProductGroupRepository => _productGroupRepository ?? (_productGroupRepository = new ProductGroupRepository(DataHelper,
                                                                                                                                                 ProductGroup.COLLECTIONNAME));
        public ProductUnitRepository ProductUnitRepository => _productUnitRepository ?? (_productUnitRepository = new ProductUnitRepository(DataHelper,
                                           
namespace Facade
    public class VehicleFacade : IVehicleFacade
    {
        private readonly IEngineController _engineController;
        private readonly ITransmissionController _transmissionController;
        private readonly ITractionControlController _tractionControlController;
        private readonly ITachometerController _tachometerController;
        private const int RpmValue = 500;
        private const int RpmThreshold = 1500;
        public VehicleFacade(IEngineController engineController, ITransmissionController transmissionController,
            ITractionControlController tractionControlController, ITachometerController tachometerController)
        {
            _engineController = engineController;
            _transmissionController = transmissionController;
            _tractionControlController = tractionControlController;
            _tachometerController = tachometerController;
        }
        public void Start()
        {
            _engineController.Start

            if (_engineController.Running)
            {
                _tractionControlController.Enable();
            }
        }
        public void Accelerate()
        {
            if (_transmissionController.Gear == 0)
            {
                _transmissionController.ShiftUp();
                _tachometerController.Rpm += RpmValue;
            }
            else if (_tachometerController.Rpm >= _tachometerController.Limit && _transmissionController.Gear < _transmissionController.MaxGear)
            {
                _transmissionController.ShiftUp();
                _tachometerController.Rpm = RpmThreshold;
            }
            else if (_tachometerController.Rpm >= _tachometerController.Limit && _transmissionController.Gear == _transmissionController.MaxGear)
            {
                Console.WriteLine("Imminent overheating - you need to brake !!!");
            }
            else
            {
                _tachometerController.Rpm += RpmValue;
            
namespace GuitarStore.Models
    public class ShoppingCartItem
    {
        #region Data
        public string ItemId { get; set; }
        public int Quantity { get; set; }
        public int InstrumentId { get; set; }
        public virtual Instrument Instrument { get; set; }
        #endregion
        #region ToStringForWebPage
        public string ToStringForWebPage()
        {
            return "Item ID: " + Instrument.InstrumentId + "<br />" +
                   "Brand: " + Instrument.Brand + "<br />" +
                   "Instrument name: " + Instrument.InstrumentModel + "<br />" +
                   "Price: " + Instrument.Price + "$" + "<br />" +
                   "Quantity: " + Quantity + "<br />" +
                   "Total: " + Instrument.Price * Quantity + "$";
        }
        #endregion
        #region ToStringForEmail
        public string ToStringForEmail()
        {
            return "Item ID: " + Instrument.InstrumentId +
               "\nBrand: " + Instrument.
namespace System.Runtime.ExceptionServices
    public static class __ExceptionDispatchInfo
    {
        public static IObservable<System.Runtime.ExceptionServices.ExceptionDispatchInfo> Capture(
            IObservable<System.Exception> source)
        {
            return Observable.Select(source,
                (sourceLambda) => System.Runtime.ExceptionServices.ExceptionDispatchInfo.Capture(sourceLambda));
        }
        public static IObservable<System.Reactive.Unit> Throw(
            this IObservable<System.Runtime.ExceptionServices.ExceptionDispatchInfo> ExceptionDispatchInfoValue)
        {
            return
                Observable.Do(ExceptionDispatchInfoValue,
                    (ExceptionDispatchInfoValueLambda) => ExceptionDispatchInfoValueLambda.Throw()).ToUnit();
        }
        public static IObservable<System.Exception> get_SourceException(
            this IObservable<System.Runtime.ExceptionServices.ExceptionDispatchInfo> ExceptionDispatchInfoValue)
       
namespace ManagerBusiness.Logics.Builds
    public class BuildViewModels
    {
        public static IList<ApiKeyViewModel> ApiKeys(IList<ApiKey> apiKeysDb)
        {
            var apiKeysViewModel = new List<ApiKeyViewModel>();
            foreach (var apiKey in apiKeysDb)
            {
                var apiKeyUrls = ApiKeyUrls(apiKey.Urls.ToList());
                var apiKeyViewModel = new ApiKeyViewModel(apiKey.Id, apiKey.Name, apiKey.Base64Secret, apiKey.UserId, 
                    apiKeyUrls);
                apiKeysViewModel.Add(apiKeyViewModel);
            }
            return apiKeysViewModel;
        }
        public static IList<ApiKeyUrlViewModel> ApiKeyUrls(IList<ApiKeyUrl> apiKeyUrls)
        {
            var result = new List<ApiKeyUrlViewModel>();
            foreach (var apiKeyUrl in apiKeyUrls)
            {
                var apiKeyViewModel = new ApiKeyUrlViewModel(apiKeyUrl.Url);
                result.Add(apiKeyViewModel);
            }
            return 
namespace StorageControl.Web.Controllers
    public class InstrumentTypesController : BaseController
    {
        public IInstrumentTypesRepository InstrumentTypesRepository { get; set; }
        public InstrumentTypesController(IInstrumentTypesRepository instrumentTypesRepository)
        {
            this.InstrumentTypesRepository = instrumentTypesRepository;
        }
        public ViewResult Index()
        {
            InstrumentTypesListModel model = new InstrumentTypesListModel();
            model.InstrumentTypes = InstrumentTypesRepository.List().ToList();
            return View(model);
        }
        public ViewResult Create()
        {
            InstrumentTypesCreateModel model = new InstrumentTypesCreateModel();
            return View(model);
        }
        [HttpPost]
        public ActionResult Create(InstrumentTypesCreateModel model)
        {
            ValidateModel(model);
            if (ModelState.IsValid)
            {
                try
            

                    int result = InstrumentTypesRepository.Create(model.InstrumentType);
                    Success(string.Format("Tipo '{0}' criado. :)", model.InstrumentType.Name));
                    return RedirectToAction("Index");
                }
                catch
                {
                    Error("Ocorreu um erro ao processar sua requisição. :(");
                    return View("Error");
                }
            }
            else
            {
                Warning(BuildErrorMessage(GetErrors()));
                return View(model);
            }
        }
        public ActionResult Edit(int id)
        {
            if (id > 0)
            {
                InstrumentTypesEditModel model = new InstrumentTypesEditModel();
                model.InstrumentType = InstrumentTypesRepository.Get(id);
                return View(model);
            }
            else
            {
                return View("Error");
            }
        }
        [HttpPo

        public ActionResult Edit(int id, InstrumentTypesEditModel model)
        {
            ValidateModel(model);
            if (ModelState.IsValid)
            {
                try
                {
                    model.InstrumentType.Id = id;
                    int result = InstrumentTypesRepository.Update(model.InstrumentType);
                    Success("Tipo atualizado.");
                    return RedirectToAction("Index");
                }
                catch
                {
                    return View("Error");
                }
            }
            else
            {
                Warning(BuildErrorMessage(GetErrors()));
                return RedirectToAction("Edit");
            }
        }
        public ActionResult Delete(int id)
        {
            if (id > 0)
            {
                InstrumentTypesDeleteModel model = new InstrumentTypesDeleteModel();
                model.InstrumentType = InstrumentTypesRepository.Get(id);
         
namespace Pattern.Node
    public class InvokeNodeSet : InvokeNode
    {
        protected HashSet<InvokeNode> m_ChildNodes;
        public override int ChildCount
        {
            get { return m_ChildNodes.Count; }
        }
        public InvokeNodeSet()
        {
            m_ChildNodes = new HashSet<InvokeNode>();
            m_Name = string.Empty;
        }
        protected override void DetachChild(InvokeNode childNode)
        {
            m_ChildNodes.Remove(childNode);
        }
        protected override void AttachChild(InvokeNode childNode)
        {
            m_ChildNodes.Add(childNode);
        }
        public override IEnumerator<InvokeNode> GetEnumerator()
        {
            return m_ChildNodes.GetEnumerator();
        }
        public override void DetachChildren()
        {
            List<InvokeNode> tempNodes = new List<InvokeNode>(ChildCount);
            var enumerator = m_ChildNodes.GetEnumerator();
            while (enumerator.MoveNext())
       

                tempNodes.Add(enumerator.Current);
            }
            for (var i = 0; i < tempNodes.Count; i++)
            {
                tempNodes[i].ParentNode = null;
            }
        }
        public override bool IsChildOf(InvokeNode parent)
        {
            InvokeNode tempNode = this;
            while (tempNode != null)
            {
                if (tempNode == parent)
                {
                    return true;
                }
                tempNode = tempNode.ParentNode;
            }
            return false;
        }
        public override InvokeNode Find(string name)
        {
            if (name == null)
            {
                return null;
            }
            string[] names = name.Split('/');
            return FindNode(names, 0);
        }
        public override InvokeNode FindNode(string[] names, int layerIndex)
        {
            var enumerator = m_ChildNodes.GetEnumerator();
            while (enumerator.MoveNext

            {
                if (enumerator.Current.Name != names[layerIndex])
                    continue;
                if (layerIndex == names.Length - 1)
                {
                    return enumerator.Current;
                }
                var targetNode = enumerator.Current.FindNode(names, layerIndex + 1);
                if (targetNode != null)
                {
                    return targetNode;
                }
            }
            return null;
        }
        public override void Invoke()
        {
            if (m_ChildNodes.Count == 0)
            {
                InvokeEvent.Invoke();
                return;
            }
            switch (NodeInvokeMode)
            {
                case InvokeMode.TreeDownToTop:
                case InvokeMode.TreeTopToDown:
                case InvokeMode.TreeReverseTopToDown:
                case InvokeMode.TreeReverseDownToTop:
                    InvokeTreeMode();
                    break;
         
namespace Processes.Services
    public class ProcessDetailService : IProcessDetailService
    {
        private readonly IProcessesInfosUtility _processesInfosUtility;
        private ProcessDetails[] _processDetails;
        public ProcessDetailService()
        {
            _processesInfosUtility = new ProcessesInfosUtility();
        }
        ProcessDetails[] IProcessDetailService.GetNewProcesses()
        {
            ProcessDetails[] newProcess = LoadProcesses();
            if (_processDetails == null)
            {
                _processDetails = newProcess;
                return newProcess;
            }
            var addedProcess = ExceptProcess(newProcess, _processDetails);
            if (addedProcess.Length > 0)
            {
                _processDetails = newProcess;
            }
            return addedProcess;
        }
        ProcessDetails[] IProcessDetailService.GetRemoveProcess()
        {
            ProcessDetails[] newProcess = LoadProcesses();
     

            {
                return null;
            }
            var removeProcess = ExceptProcess(_processDetails, newProcess);
            if (removeProcess.Length > 0)
            {
                _processDetails = newProcess;
            }
            return removeProcess;
        }
        private ProcessDetails[] ExceptProcess(ProcessDetails[] from, ProcessDetails[] except)
        {
            var fromLength = from.Length;
            var exceptLength = except.Length;
            var result = new List<ProcessDetails>(Math.Max(fromLength, exceptLength));
            for (int i = 0; i < fromLength; i++)
            {
                var isNotContains = true;
                for (int j = 0; j < exceptLength; j++)
                {
                    if (from[i].ID == except[j].ID
                        && from[i].ProcessName == except[j].ProcessName)
                    {
                        isNotContains = false;
                        break;
                    }
  
﻿namespace PVT.Q1._2017.Shop.Tests.Moq
    public class RepositoryFactoryMoq : IRepositoryFactory
    {
        private readonly AlbumRepositoryMoq _albumRepositoryMoq = new AlbumRepositoryMoq();
        private readonly ArtistRepositoryMoq _artistRepositoryMoq = new ArtistRepositoryMoq();
        private readonly TrackRepositoryMoq _trackRepositoryMoq = new TrackRepositoryMoq();
        private readonly CurrencyRepositoryMoq _currencyRepositoryMoq = new CurrencyRepositoryMoq();
        private readonly AlbumPriceRepositoryMoq _albumPriceRepositoryMoq = new AlbumPriceRepositoryMoq();
        private readonly CurrencyRateRepositorMoq _currencyRateRepositorMoq = new CurrencyRateRepositorMoq();
        private readonly FeedbackRepositoryMoq _feedbackRepositoryMoq = new FeedbackRepositoryMoq();
        private readonly GenreRepositoryMoq _genreRepositoryMoq = new GenreRepositoryMoq();
        private readonly PriceLevelRepositoryMoq _priceLevelRepositoryMoq = new PriceLevelRepositoryMoq();

        private readonly TrackPriceRepositoryMoq _trackPriceRepositoryMoq = new TrackPriceRepositoryMoq();
        private readonly UserDataRepositoryMoq _userDataRepositoryMoq = new UserDataRepositoryMoq();
        private readonly VoteRepositoryMoq _voteRepositoryMoq = new VoteRepositoryMoq();
        private readonly AlbumTrackRelationRepositoryMoq _albumTrackRelationRepositoryMoq = new AlbumTrackRelationRepositoryMoq();
        private readonly UserRepositoryMoq _userRepositoryMoq = new UserRepositoryMoq();
        private readonly SettingRepositoryMoq _settingRepositoryMoq = new SettingRepositoryMoq();
        private readonly OrderTrackRepositoryMoq _orderTrackRepositoryMoq = new OrderTrackRepositoryMoq();
        private readonly OrderAlbumRepositoryMoq _orderAlbumRepositoryMoq = new OrderAlbumRepositoryMoq();
        private readonly PurchasedTrackRepositoryMoq _purchasedTrackRepositoryMoq = new PurchasedTrackRepositoryMoq();
        private readonly PurchasedAlbumRepositoryMo

        private readonly PaymentTransactionRepositoryMoq _paymentTransactionRepositoryMoq = new PaymentTransactionRepositoryMoq();
        private readonly UserPaymentMethodRepositoryMoq _userPaymentMethodRepositoryMoq = new UserPaymentMethodRepositoryMoq();
        public IAlbumRepository GetAlbumRepository()
        {
            return _albumRepositoryMoq.Repository;
        }
        public IArtistRepository GetArtistRepository()
        {
            return _artistRepositoryMoq.Repository;
        }
        public ITrackRepository GetTrackRepository()
        {
            return _trackRepositoryMoq.Repository;
        }
        public ICurrencyRepository GetCurrencyRepository()
        {
            return _currencyRepositoryMoq.Repository;
        }
        public IAlbumPriceRepository GetAlbumPriceRepository()
        {
            return _albumPriceRepositoryMoq.Repository;
        }
        public ICurrencyRateRepository GetCurrencyRateRepository()
        {
            retu
namespace Core.Model.Data.DataModel
	public class DataInvoke : DataBase
	{
		#region Properties
		public bool IsRequestData { get; set; }
		
		public InvokeType? InvokeType { get; set; }
		#endregion
		#region Constructor
		public DataInvoke(Guid id, object value)
			: base(id, value)
		{
			InvokeType = InvokeMethods.Base.Invoke.DataModel.InvokeType.Auto;
		}
		public DataInvoke(Guid id)
			: base(id)
		{
			InvokeType = InvokeMethods.Base.Invoke.DataModel.InvokeType.Auto;
		}
		public DataInvoke() 
			: this(Guid.NewGuid())
		{
			InvokeType = InvokeMethods.Base.Invoke.DataModel.InvokeType.Auto;
		}
		public DataInvoke(object value)
			: this(Guid.NewGuid(), value)
		{
			InvokeType = InvokeMethods.Base.Invoke.DataModel.InvokeType.Auto;
		}
		#endregion
		public static implicit operator DataInvoke(double data)
		{
			return new DataInvoke(data);
		}
		public static implicit operator DataInvoke(int data)
		{
			return new DataInvoke(data);
		}
		public static implicit operator DataInv

		{
			return new DataInvoke(data);
		}
		public DataInvoke<T> SetType<T>()
		{
			DataInvoke<T> result;
			if (HasValue)
			{
				result = new DataInvoke<T>(Id, (T)Value);
			}
			else
			{
				result = new DataInvoke<T>(Id);
			}
			result.InvokeType = InvokeType;
			result.IsRequestData = IsRequestData;
			result.InputIds = InputIds;
			return result;
		}
	}
	public class DataInvoke<T> : DataInvoke
	{
		#region Properties
		public bool IsRequestData { get; set; }
		public InvokeType? InvokeType { get; set; }
		public new T Value
		{
			get { return (T)base.Value; }
			set { _value = value; }
		}
		#endregion
		#region Constructor
		public DataInvoke(Guid id, T value)
			: base(id, value)
		{
			InvokeType = InvokeMethods.Base.Invoke.DataModel.InvokeType.Auto;
		}
		public DataInvoke(Guid id)
			: base(id)
		{
			InvokeType = InvokeMethods.Base.Invoke.DataModel.InvokeType.Auto;
		}
		public DataInvoke()
			: this(Guid.NewGuid())
		{
			InvokeType = InvokeMethods.Base.Invoke.DataMode
namespace DrxApi.Controllers
    [Route("api/[controller]")]
    public class InstrumentsController : Controller
    {
        private readonly IInstrumentService _instrumentService;
        private readonly IMapper _mapper;
        public InstrumentsController(IInstrumentService instrumentService, IMapper mapper)
        {
            _instrumentService = instrumentService;
            _mapper = mapper;
        }  
        [HttpGet]
        public IActionResult GetAll()
        {
            var instruments = _instrumentService.ListAll();
            var instrumentsDTO = _mapper.Map<IEnumerable<InstrumentDTO>>(instruments);
            return new OkObjectResult(instrumentsDTO);
        }
        [HttpGet("{id}", Name = "GetInstrument")]
        public IActionResult GetById(long id)
        {
            var item = _instrumentService.GetById(id);
            if (item == null)
            {
                return NotFound();
            }
            var instrument = _mapper.Map<Instrum

            return new OkObjectResult(instrument);
        }
        [HttpPost]
        public IActionResult Create([FromBody] InstrumentDTO item)
        {
            if (item == null)
            {
                return BadRequest();
            }
            var instrument = _mapper.Map<Instrument>(item);
            if (instrument == null)
            {
                return BadRequest();
            }
            _instrumentService.Add(instrument);
            return CreatedAtRoute("GetInstrument", new { id = instrument.Id }, item);
        }
        [HttpPut("{id}")]
        public IActionResult Update(long id, [FromBody] InstrumentDTO item)
        {
            if (item == null || item.Id != id)
            {
                return BadRequest();
            }
            var i = _instrumentService.GetById(id);
            if (i == null)
            {
                return NotFound();
            }
            var instrument = _mapper.Map<Instrument>(item);
            _ins
namespace AISTek.XRage.Graphics
    public class RenderChunkManager : XComponent
    {
        public RenderChunkManager(XGame game)
            : base(game)
        { }
        #region Public properties
        public IList<GeometryRenderChunk> GeometryRenderChunks { get { return geometryChunkList; } }
        public IList<LightRenderChunk> LightRenderChunks { get { return lightChunkList; } }
        public IList<ParticleChunk> ParticleChunks { get { return particleChunkList; } }
        
        #endregion
        #region Public methods
        #region Render chunks allocation and releasing
        public GeometryRenderChunk AllocateGeometryChunk()
        {
            return AllocateChunk(geometryChunkList, deadGeometryChunkList);
        }
        public void ReleaseGeometryChunk(GeometryRenderChunk chunk)
        {
            ReleaseChunk(chunk, deadGeometryChunkList);
        }
        public LightRenderChunk AllocateLightChunk()
        {
            return AllocateChunk(light

        }
        public void ReleaseLightChunk(LightRenderChunk chunk)
        {
            ReleaseChunk(chunk, deadLightChunkList);
        }
        public ParticleChunk AllocateParticleChunk()
        {
            return AllocateChunk(particleChunkList, deadParticleChunkList);
        }
        public void ReleaseParticleChunk(ParticleChunk chunk)
        {
            ReleaseChunk(chunk, deadParticleChunkList);
        }
        #endregion
        public void PreallocateChunks(int geometryRenderChunksToPreallocate, int lightRenderChunksToPreallocate)
        {
            for (var i = 0; i < geometryRenderChunksToPreallocate; i++)
            {
                deadGeometryChunkList.Add(new GeometryRenderChunk());
            }
            for (var i = 0; i < lightRenderChunksToPreallocate; i++)
            {
                deadLightChunkList.Add(new LightRenderChunk());
            }
        }
        public void ClearChunks()
        {
            ClearChunks(geometryChunkLis

            ClearChunks(lightChunkList, deadLightChunkList);
            ClearChunks(particleChunkList, deadParticleChunkList);
        }
        #endregion
        #region Private methods
        private T AllocateChunk<T>(List<T> chunkList, List<T> deadChunkList)
         where T : IRenderChunk, new()
        {
            if (deadChunkList.Count > 0)
            {
                var chunk = deadChunkList[deadChunkList.Count - 1];
                deadChunkList.RemoveAt(deadChunkList.Count - 1);
                chunkList.Add(chunk);
                return chunk;
            }
            else
            {
                var chunk = new T();
                chunkList.Add(chunk);
                return chunk;
            }
        }
        private void ReleaseChunk<T>(T chunk, List<T> deadChunkList)
            where T : IRenderChunk, new()
        {
            chunk.Recycle();
            deadChunkList.Add(chunk);
        }
        private void ClearChunks<T>(List<T> chunkList, L
namespace DENTALMIS.Web.Controllers
    public class ClinicInstrumentController :BaseController
    {
        public ActionResult Index(ClinicInstrumentViewModel model)
        {
            ModelState.Clear();
            var totalrecords = 0;
            model.Name = model.SearchbyName;
           
            model.ClinicalInstruments = ClinicInstrumentManager.GetAllInstrumentByPaging(out totalrecords, model);
            model.TotalRecords = totalrecords;
            return View(model);
        }
        public ActionResult Edit(ClinicInstrumentViewModel model)
        {
           
            if (model.InstrumentId > 0)
            {
                ClinicalInstrument clIns = ClinicInstrumentManager.GetInstrumentById(model.InstrumentId);
                model.InstrumentId = clIns.InstrumentId;
                model.Name = clIns.Name;
                model.Description = clIns.Description;
                model.Market = clIns.Market;
               
               
            }
  

        }
        public JsonResult Save(ClinicInstrumentViewModel model)
        {
            int saveIndex = 0;
            ClinicalInstrument clinicalInstrument = new ClinicalInstrument();
            clinicalInstrument.InstrumentId = model.InstrumentId;
            clinicalInstrument.Name = model.Name;
            clinicalInstrument.Description = model.Description;
            clinicalInstrument.Market = model.Market;
            saveIndex = model.InstrumentId == 0 ? ClinicInstrumentManager.Save(clinicalInstrument) : ClinicInstrumentManager.Edit(clinicalInstrument);
            return Reload(saveIndex);
        }
        public JsonResult Delete(ClinicInstrumentViewModel model)
        {
            int deleteIndex = 0;
            try
            {
                deleteIndex = ClinicInstrumentManager.Delete(model.InstrumentId);
            }
            catch (Exception exception)
            {
                throw new Exception(exception.Message);
            }
            re
namespace autotrade.business
    public class StrategyManager
    {
        private readonly Dictionary<String, InstrumentStrategy> dictStrategies =
            new Dictionary<string, InstrumentStrategy>();
        private readonly BindingList<InstrumentStrategy> instrumentStrategies = new BindingList<InstrumentStrategy>();
        private readonly ILog log = LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);
        private readonly MongoRepository<InstrumentStrategy> strategyRepo = new MongoRepository<InstrumentStrategy>();
        private bool isStart, needWait = false;
        public StrategyManager()
        {
            instrumentStrategies.ListChanged += Strategies_ListChanged;
        }
        public IndicatorManager IndicatorManager { get; set; }
        public OrderManager OrderManager { get; set; }
        public IContainer Container { get; set; }
        private int tick = 0;
        public void PrcessData(MarketData marketData)
        {
            if (!

            InstrumentStrategy instrumentStrategy = dictStrategies[marketData.InstrumentId];
            if (!instrumentStrategy.StartTrade) return;
            foreach (UserStrategy strategy in instrumentStrategy.Strategies)
            {
                if (!strategy.AutoTrade) continue;
                if (needWait)
                {
                    tick++;
                    if (tick >= 240)
                    {
                        needWait = false;
                        tick = 0;
                    }
                    return;
                }
                var sc = (StringCollection) InstrumentType.Default[marketData.Code];
                var today = DateTime.Today;
                if (sc != null)
                {
                    foreach (var time in sc)
                    {
                        int hour = Convert.ToInt32(time.Split(':')[0]);
                        int minute = Convert.ToInt32(time.Split(':')[1]);
                        var endTime =

                        if (endTime > DateTime.Now && DateTime.Now > endTime.AddMinutes(-1))
                        {
                            OrderManager.CancelAllOrder();
                            needWait = true;
                            log.Info("canceling order");
                            return;
                        }
                    }
                }
                List<Order> orders = strategy.Match(marketData);
                foreach (Order order in orders)
                {
                    order.Unit = instrumentStrategy.VolumeMultiple;
                    if (order.Direction == TThostFtdcDirectionType.Buy)
                        order.UseMargin = order.Price*order.Unit*order.Volume*instrumentStrategy.LongMarginRatio;
                    else
                        order.UseMargin = order.Price*order.Unit*order.Volume*instrumentStrategy.ShortMarginRatio;
                    log.Info(order);
                    OrderManager.OrderInsert(order);
  
namespace WestWood3D
    public class ChunkMap
    {
        private Hashtable chunkMap = new Hashtable();
        public ChunkMap()
        {
            initializeChunks();
        }
        private void initializeChunks()
        {
            Chunk meshChunk 				        = new MeshChunk();
    	    Chunk hierarchyChunk 					= new HierarchyChunk();
    	    Chunk hierarchyHeaderChunk 				= new HierarchyHeaderChunk();
            Chunk pivotsChunk 						= new PivotsChunk();
            Chunk pivotFixupsChunk 					= new PivotFixupsChunk();
    	    Chunk hlodChunk		 					= new HlodChunk();
    	    Chunk hlodHeaderChunk					= new HlodHeaderChunk();
            Chunk hlodLodArrayChunk				    = new HlodLodArrayChunk();
            Chunk hlodSubObjectArrayHeaderChunk     = new HlodSubObjectArrayHeaderChunk();
            Chunk hlodSubObjectChunk				= new HlodSubObjectChunk();
            Chunk hlodProxyArrayChunk               = new HLodProxyArrayChunk();
            Chunk meshHeader3Chun

            Chunk verticesChunk					    = new VerticesChunk();
            Chunk vertexNormalsChunk				= new VertexNormalsChunk();
            Chunk trianglesChunk					= new TrianglesChunk();
            Chunk vertexShadeIndicesChunk			= new VertexShadeIndicesChunk();
            Chunk materialInfoChunk				    = new MaterialInfoChunk();
            Chunk vertexMaterialsChunk			    = new VertexMaterialsChunk();
            Chunk vertexMaterialChunk				= new VertexMaterialChunk();
            Chunk vertexMaterialNameChunk			= new VertexMaterialNameChunk();
            Chunk vertexMaterialInfoChunk			= new VertexMaterialInfoChunk();
            Chunk shadersChunk					    = new ShadersChunk();
            Chunk texturesChunk					    = new TexturesChunk();
            Chunk textureChunk					    = new TextureChunk();
            Chunk textureNameChunk				    = new TextureNameChunk();
            Chunk textureInfoChunk                  = new TextureInfoChunk();
            Chunk materialPass

            Chunk vertexMaterialIdsChunk			= new VertexMaterialIdsChunk();
            Chunk shaderIdsChunk					= new ShaderIdsChunk();
            Chunk textureStageChunk				    = new TextureStageChunk();
            Chunk textureIdsChunk					= new TextureIdsChunk();
            Chunk stageTexCoordsChunk				= new StageTexCoordsChunk();
            Chunk aabTreeChunk					    = new AabTreeChunk();
            Chunk aabTreeHeaderChunk				= new AabTreeHeaderChunk();
            Chunk aabTreePolyIndicesChunk			= new AabTreePolyIndicesChunk();
            Chunk aabTreeNodesChunk			    	= new AabTreeNodesChunk();
            Chunk aggregateChunk					= new AggregateChunk();
            Chunk aggregateHeaderChunk			    = new AggregateHeaderChunk();
            Chunk aggregateInfoChunk				= new AggregateInfoChunk();
            Chunk aggregateClassInfoChunk			= new AggregateClassInfoChunk();
    	    Chunk textureReplacerChunk			    = new TextureReplacerChunk();
            Chunk vertexMapperA
namespace GeoPgesSystem.Db.Context
    public class UnitWork : IUnitWork
    {
        public IAuthRepository AuthRepository { get; set; }
        public ICablePointsRepository CablePointsRepository { get; set; }
        public ICablesRepository CablesRepository { get; set; }
        public IDefectPicsRepository DefectPicsRepository { get; set; }
        public IDocumentsRepository DocumentsRepository { get; set; }
        public IElektroCellRepository ElektroCellRepository { get; set; }
        public IFileTypeRepository FileTypeRepository { get; set; }
        public IKachestvoFileRepository KachestvoFileRepository { get; set; }
        public IRepairsRepository RepairsRepository { get; set; }
        public IRubilniksRepository RubilniksRepository { get; set; }
        public ITPRepository TpRepository { get; set; }
        public IUserProfileRepository UserProfileRepository { get; set; }
        public IVedomostRepository VedomostRepository { get; set; }
        public IVlRepositor

        public IWialonRepository WialonRepository { get; set; }
        public UnitWork(
            IAuthRepository authRepository,
            ICablePointsRepository cablePointsRepository,
            ICablesRepository cablesRepository,
            IDefectPicsRepository defectPicsRepository,
            IDocumentsRepository documentsRepository,
            IElektroCellRepository elektroCellRepository,
            IFileTypeRepository fileTypeRepository,
            IKachestvoFileRepository kachestvoFileRepository,
            IRepairsRepository repairsRepository,
            IRubilniksRepository rubilniksRepository,
            ITPRepository tpRepository,
            IUserProfileRepository userProfileRepository,
            IVedomostRepository vedomostRepository,
            IVlRepository vlRepository,
            IWialonRepository wialonRepository
            )
        {
            AuthRepository = authRepository;
            CablePointsRepository = cablePointsRepository;
         
namespace Leap.Unity.Interaction {
  public class ControllerContainer {
    private struct DefinableController<T> where T : IControllerBase {
      public T defaultController;
      public T registeredController;
      public DefinableController(T defaultController) {
        this.defaultController = defaultController;
        registeredController = null;
      }
      public void RegisterCustomController(T customController) {
        if (registeredController != null) {
          throw new InvalidOperationException("Cannot register a custom controller because one is already registered.");
        }
        registeredController = customController;
      }
      public void UnregisterCustomController() {
        if (registeredController == null) {
          throw new InvalidOperationException("Cannot unregister a custom controller because no custom controller is registered.");
        }
        registeredController = null;
      }
      public static implicit operator T(DefinableControll

        if (definableController.registeredController != null) {
          return definableController.registeredController;
        } else {
          return definableController.defaultController;
        }
      }
    }
    private InteractionMaterial _material;
    private DefinableController<IHoldingPoseController> _holdingPoseController;
    private DefinableController<ILayerController> _layerController;
    private DefinableController<IMoveToController> _moveToController;
    private DefinableController<ISuspensionController> _suspensionController;
    private DefinableController<IThrowingController> _throwingController;
    public ControllerContainer(InteractionBehaviour obj, InteractionMaterial material) {
      _material = material;
      _holdingPoseController = new DefinableController<IHoldingPoseController>(_material.CreateHoldingPoseController(obj));
      _layerController = new DefinableController<ILayerController>(_material.CreateLayerController(obj));
      _moveToContro

      _suspensionController = new DefinableController<ISuspensionController>(_material.CreateSuspensionController(obj));
      _throwingController = new DefinableController<IThrowingController>(_material.CreateThrowingController(obj));
    }
    public IHoldingPoseController HoldingPoseController {
      get {
        return _holdingPoseController;
      }
    }
    public void RegisterCustomHoldingPoseController(IHoldingPoseController holdingPoseController) {
      _holdingPoseController.RegisterCustomController(holdingPoseController);
    }
    public void UnregisterCustomHoldingPoseController() {
      _holdingPoseController.UnregisterCustomController();
    }
    public ILayerController LayerController {
      get {
        return _layerController;
      }
    }
    public void RegisterCustomLayerController(ILayerController layerController) {
      _layerController.RegisterCustomController(layerController);
    }
    public void UnregisterCustomLayerController() {
      _layerCont
namespace de.mastersign.shell
    public class ScriptMethod
    {
        public ScriptBlock Block { get; private set; }
        public static implicit operator ScriptMethod(ScriptBlock block)
        {
            return new ScriptMethod(block);
        }
        public static implicit operator ScriptBlock(ScriptMethod method)
        {
            return method.Block;
        }
        public static explicit operator ThreadStart(ScriptMethod method)
        {
            return method.SimpleInvoke;
        }
        public static explicit operator EventHandler(ScriptMethod method)
        {
            return method.EventHandlerInvoke;
        }
        public ScriptMethod(ScriptBlock block)
        {
            Block = block;
        }
        public void SimpleInvoke()
        {
            Block.Invoke();
        }
        public void EventHandlerInvoke(object sender, EventArgs ea)
        {
            Block.Invoke(sender, ea);
        }
        public void SendOrPostCallbackInv

        {
            Block.Invoke(state);
        }
        public Thread CreateThread()
        {
            return new Thread(SimpleInvoke);
        }
        public static Thread CreateThread(ScriptMethod method)
        {
            return method.CreateThread();
        }
        public void InvokeForGuiSync(Control control)
        {
            if (control != null && !control.IsDisposed && control.InvokeRequired)
            {
                try
                {
                    control.Invoke((MethodInvoker)SimpleInvoke);
                }
                catch (InvalidOperationException)
                {
                    SimpleInvoke();
                }
            }
            else
            {
                SimpleInvoke();
            }
        }
        public void InvokeForGuiAsync(Control control)
        {
            if (control.InvokeRequired)
            {
                control.BeginInvoke((MethodInvoker) SimpleInvoke);
            }
            els
namespace W3DT.Formats
    public enum ADTFileType
    {
        ROOT,
        TEX,
        OBJ,
        LOD
    }
    public class ADTException : Exception
    {
        public ADTException(string message) : base(message) { }
    }
    public class ADTFile : ChunkedFormatBase, IChunkProvider
    {
        public static float TILE_SIZE = 4.16675f;
        public ADTFileType Type { get; private set; }
        private Chunk_MCNK CurrentSub;
        public ADTFile(string file, ADTFileType type) : base(file)
        {
            Type = type;
        }
        public override void storeChunk(Chunk_Base chunk)
        {
            if (chunk is IChunkSoup)
            {
                if (CurrentSub != null)
                    CurrentSub.addChunk(chunk);
                else
                    Log.Write("ADT: Sub-chunk found before MCNK chunk? Shun the demons!");
            }
            else
            {
                Chunks.Add(chunk);
                if (chunk is Chunk_MCNK)
     

            }
        }
        public override Chunk_Base lookupChunk(UInt32 magic)
        {
            switch (magic)
            {
                case Chunk_MVER.Magic: return new Chunk_MVER(this);
                case Chunk_MCNK.Magic: return new Chunk_MCNK(this);
                case Chunk_MTEX.Magic: return new Chunk_MTEX(this);
                case Chunk_MMDX.Magic: return new Chunk_MMDX(this);
                case Chunk_MMID.Magic: return new Chunk_MMID(this);
                case Chunk_MWMO.Magic: return new Chunk_MWMO(this);
                case Chunk_MWID.Magic: return new Chunk_MWID(this);
                case Chunk_MDDF.Magic: return new Chunk_MDDF(this);
                case Chunk_MODF.Magic: return new Chunk_MODF(this);
                case Chunk_MCVT.Magic: return new Chunk_MCVT(this);
                case Chunk_MCLV.Magic: return new Chunk_MCLV(this);
                case Chunk_MCCV.Magic: return new Chunk_MCCV(this);
                case Chunk_MCNR.Magic: return n

                case Chunk_MCLY.Magic: return new Chunk_MCLY(this);
                case Chunk_MCRD.Magic: return new Chunk_MCRD(this);
                case Chunk_MCRW.Magic: return new Chunk_MCRW(this);
                case Chunk_MCAL.Magic: return new Chunk_MCAL(this);
                default: return new Chunk_Base(this);
            }
        }
        public override string getFormatName()
        {
            return "ADT";
        }
        public Chunk_Base getChunk(UInt32 chunkID, bool error = true)
        {
            Chunk_Base chunk = getChunksByID(chunkID).FirstOrDefault();
            if (chunk == null && error)
                throw new ADTException(string.Format("File does not contain chunk 0x{0}.", chunkID.ToString("X")));
            return chunk;
        }
        public IEnumerable<Chunk_Base> getChunksByID(UInt32 chunkID)
        {
            return Chunks.Where(c => c.ChunkID == chunkID);
        }
        public IEnumerable<Chunk_Base> getChunks()
        {
  
namespace CraftyServer.Core
    public class ChunkProviderLoadOrGenerate
        : IChunkProvider
    {
        private readonly Chunk blankChunk;
        private readonly IChunkLoader chunkLoader;
        private readonly IChunkProvider chunkProvider;
        private readonly Chunk[] chunks;
        private readonly World worldObj;
        private int field_21112_j;
        private int field_21113_i;
        private Chunk lastQueriedChunk;
        private int lastQueriedChunkXPos;
        private int lastQueriedChunkZPos;
        public ChunkProviderLoadOrGenerate(World world, IChunkLoader ichunkloader, IChunkProvider ichunkprovider)
        {
            chunks = new Chunk[1024];
            lastQueriedChunkXPos = unchecked((int) 0xc4653601);
            lastQueriedChunkZPos = unchecked((int) 0xc4653601);
            blankChunk = new EmptyChunk(world, new byte[32768], 0, 0);
            worldObj = world;
            chunkLoader = ichunkloader;
            chunkProvider = ichunkprovid

        }
        #region IChunkProvider Members
        public bool chunkExists(int i, int j)
        {
            if (!func_21111_c(i, j))
            {
                return false;
            }
            if (i == lastQueriedChunkXPos && j == lastQueriedChunkZPos && lastQueriedChunk != null)
            {
                return true;
            }
            else
            {
                int k = i & 0x1f;
                int l = j & 0x1f;
                int i1 = k + l*32;
                return chunks[i1] != null && (chunks[i1] == blankChunk || chunks[i1].isAtLocation(i, j));
            }
        }
        public Chunk provideChunk(int i, int j)
        {
            if (i == lastQueriedChunkXPos && j == lastQueriedChunkZPos && lastQueriedChunk != null)
            {
                return lastQueriedChunk;
            }
            if (!worldObj.field_9209_x && !func_21111_c(i, j))
            {
                return blankChunk;
            }
            int k = i & 0

            int l = j & 0x1f;
            int i1 = k + l*32;
            if (!chunkExists(i, j))
            {
                if (chunks[i1] != null)
                {
                    chunks[i1].onChunkUnload();
                    saveChunk(chunks[i1]);
                    saveExtraChunkData(chunks[i1]);
                }
                Chunk chunk = func_4059_c(i, j);
                if (chunk == null)
                {
                    if (chunkProvider == null)
                    {
                        chunk = blankChunk;
                    }
                    else
                    {
                        chunk = chunkProvider.provideChunk(i, j);
                    }
                }
                chunks[i1] = chunk;
                chunk.func_4053_c();
                if (chunks[i1] != null)
                {
                    chunks[i1].onChunkLoad();
                }
                if (!chunks[i1].isTerrainPopulated && chunkExists(i + 1, j + 1) && c
namespace Assets.Code.Tasker
    class NewChunkPrefab : Task
    {
        private KeyValuePair<Position, ChunkData> _chunk;
        private readonly Action<Position, Chunk> _createNewChunkCallback;
        public NewChunkPrefab(KeyValuePair<Position, ChunkData> chunk, Action<Position, Chunk> createNewChunkCallback)
        {
            _chunk = chunk;
            _createNewChunkCallback = createNewChunkCallback;
        }
        public override IEnumerator Execute(Action taskdone)
        {
            yield return null;
            GameObject newChunkObject = PoolManager.Spawn(World.World.Instance.ChunkPrefab);
            yield return null;
            newChunkObject.transform.position = _chunk.Key.ToVector3();
            Chunk newChunk = newChunkObject.GetComponent<Chunk>();
            newChunk.Position = _chunk.Key;
            newChunk.SetChunkData(_chunk.Value);
            yield return null;
            Tasker.Instance.Add(new InitializeBlocks(newChunk, _chunk.Value));
    
namespace Cats.ViewModelBinder
    public class ProcessTemplateViewModelBinder
    {
        public static IEnumerable<BusinessProcessState> BindProcessTemplateViewModel(
            List<ProcessTemplateViewModel> processTemplatesViewModel)
        {
            List<BusinessProcessState> processTemplates = new List<BusinessProcessState>();
            if (processTemplatesViewModel.Any())
            {
                foreach (var processTemplate in processTemplatesViewModel)
                {
                    processTemplates.Add(new BusinessProcessState()
                                               {
                                                   ParentBusinessProcessID = processTemplate.ParentBusinessProcessID,
                                                   StateID = processTemplate.StateID,
                                                   PerformedBy = processTemplate.PerformedBy,
                                                   DatePerformed = processTemplate.Dat
namespace HCM.Web.Controllers
    public class InstrumentReferencesController : Controller
    {
        private HcmContext db = new HcmContext();
        public async Task<ActionResult> Index()
        {
            var instrumentReferences = db.InstrumentReferences.Include(i => i.Broker).Include(i => i.Instrument);
            return View(await instrumentReferences.ToListAsync());
        }
        public async Task<ActionResult> Details(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            InstrumentReference instrumentReference = await db.InstrumentReferences.FindAsync(id);
            if (instrumentReference == null)
            {
                return HttpNotFound();
            }
            return View(instrumentReference);
        }
        public ActionResult Create()
        {
            ViewBag.BrokerId = new SelectList(db.Brokers, "Id", "Name");
            ViewBa

            return View();
        }
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<ActionResult> Create([Bind(Include = "Id,Reference,InstrumentId,BrokerId")] InstrumentReference instrumentReference)
        {
            if (ModelState.IsValid)
            {
                db.InstrumentReferences.Add(instrumentReference);
                await db.SaveChangesAsync();
                return RedirectToAction("Index");
            }
            ViewBag.BrokerId = new SelectList(db.Brokers, "Id", "Name", instrumentReference.BrokerId);
            ViewBag.InstrumentId = new SelectList(db.Instruments, "Id", "Name", instrumentReference.InstrumentId);
            return View(instrumentReference);
        }
        public async Task<ActionResult> Edit(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            InstrumentReference instrumentReference = await 

            if (instrumentReference == null)
            {
                return HttpNotFound();
            }
            ViewBag.BrokerId = new SelectList(db.Brokers, "Id", "Name", instrumentReference.BrokerId);
            ViewBag.InstrumentId = new SelectList(db.Instruments, "Id", "Name", instrumentReference.InstrumentId);
            return View(instrumentReference);
        }
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<ActionResult> Edit([Bind(Include = "Id,Reference,InstrumentId,BrokerId")] InstrumentReference instrumentReference)
        {
            if (ModelState.IsValid)
            {
                db.Entry(instrumentReference).State = EntityState.Modified;
                await db.SaveChangesAsync();
                return RedirectToAction("Index");
            }
            ViewBag.BrokerId = new SelectList(db.Brokers, "Id", "Name", instrumentReference.BrokerId);
            ViewBag.InstrumentId = new SelectList(db.Instruments, "Id"
namespace SYFY.IT.DAL
    public class DispatchDal
    {
        public static object SqlNull(object obj)
        {
            if (obj == null)
                return DBNull.Value;
            return obj;
        }
        int result = 0;
        public int AddAndProduct(Dispatch dispatchEntity, List<DispatchProduct> lstMorningShif, List<DispatchProduct> lstMiddleShift, List<DispatchProduct> lstNightShift)
        {
            {
                SqlCommand cmd = new SqlCommand();
                conn.Open();
                SqlTransaction trans = conn.BeginTransaction();
                try
                {
                    StringBuilder strSqlSelect = new StringBuilder();
                    strSqlSelect.Append("select * from Dispatch where WorkTime = ");
                    strSqlSelect.Append("@WorkTime");
                    strSqlSelect.Append(" and ProcessId = ");
                    strSqlSelect.Append("@ProcessId");
                    SqlParameter[] parSelect = {
					   

					                            new SqlParameter("@ProcessId", SqlDbType.NVarChar,50)};
                    parSelect[0].Value = SqlNull(dispatchEntity.WorkTime);
                    parSelect[1].Value = SqlNull(dispatchEntity.ProcessId);
                    {
                        if (dr.Read())
                        {
                            dispatchEntity.DispatchId = dr["DispatchId"].ToString();
                        }
                    }
                    {
                        StringBuilder strSqlAdd = new StringBuilder();
                        strSqlAdd.Append("insert into Dispatch(");
                        strSqlAdd.Append("DispatchId,ProcessId,WorkTime,Early,Noon,Night,PersonId,AddTime,Dispatch_Status)");
                        strSqlAdd.Append(" values (");
                        strSqlAdd.Append("@DispatchId,@ProcessId,@WorkTime,@Early,@Noon,@Night,@PersonId,@AddTime,@Dispatch_Status)");
                        SqlParameter[] parameters = {
					    

					                            new SqlParameter("@ProcessId", SqlDbType.NVarChar,50),
					                            new SqlParameter("@WorkTime", SqlDbType.NVarChar,50),
					                            new SqlParameter("@Early", SqlDbType.NVarChar,50),
					                            new SqlParameter("@Noon", SqlDbType.NVarChar,50),
					                            new SqlParameter("@Night", SqlDbType.NVarChar,50),
					                            new SqlParameter("@PersonId", SqlDbType.NVarChar,50),
					                            new SqlParameter("@AddTime", SqlDbType.NVarChar,50),
					                            new SqlParameter("@Dispatch_Status", SqlDbType.NVarChar,50)};
                        parameters[0].Value = SqlNull(dispatchEntity.DispatchId);
                        parameters[1].Value = SqlNull(dispatchEntity.ProcessId);
                        parameters[2].Value = SqlNull(dispatchEntity.WorkTime);
                        parameters[3].Value = SqlNull(dispatch
namespace System.Runtime.Remoting.Channels
    internal class ChunkedMemoryStream : Stream
    {                               
        private class MemoryChunk
        {
            public byte[] Buffer = null;
            public MemoryChunk Next = null;
        }
        
        public ChunkedMemoryStream(IByteBufferPool bufferPool)
        {
            _bufferPool = bufferPool;
        public override bool CanRead { get { return true; } }
        public override bool CanSeek { get { return true; } }
        public override bool CanWrite { get { return true; } }
        
        public override long Length  
        { 
            get 
            { 
                if (_bClosed)
                {                
                    throw new RemotingException(
                        CoreChannel.GetResourceString("Remoting_Stream_StreamIsClosed"));
                }
            
                int length = 0;
                MemoryChunk chunk = _chunks;
                while (ch

                {
                    MemoryChunk next = chunk.Next;
                    if (next != null)
                        length += chunk.Buffer.Length;
                    else
                        length += _writeOffset;
        
                    chunk = next;
                }
                return (long)length;
            }
        public override long Position
        {
             get 
             {
                if (_bClosed)
                {                
                    throw new RemotingException(
                        CoreChannel.GetResourceString("Remoting_Stream_StreamIsClosed"));
                }
                
                if (_readChunk == null)
                    return 0;
                int pos = 0;
                MemoryChunk chunk = _chunks;
                while (chunk != _readChunk)
                {
                    pos += chunk.Buffer.Length;
                    chunk = chunk.Next;
                }
                pos +

                return (long)pos;
             }
             
             set 
             {
                if (_bClosed)
                {                
                    throw new RemotingException(
                        CoreChannel.GetResourceString("Remoting_Stream_StreamIsClosed"));
                }
                
                if (value < 0)
                    throw new ArgumentOutOfRangeException("value");
                MemoryChunk backupReadChunk = _readChunk;
                int backupReadOffset = _readOffset;
                _readChunk = null;
                _readOffset = 0;
                                    
                int leftUntilAtPos = (int)value;
                MemoryChunk chunk = _chunks;
                while (chunk != null)
                {
                    if ((leftUntilAtPos < chunk.Buffer.Length) ||
                            ((leftUntilAtPos == chunk.Buffer.Length) &&
                             (chunk.Next == null)))
           
namespace TiS.Core.TisCommon.Customizations
    public class TisInvokeTypesMngr
	{
        private DictionaryWithEvents<string, ITisInvokeType> m_oInvokeTypes;
        private TisGetInvokerDelegate m_oGetInvokerDelegate;
		public TisInvokeTypesMngr (
            DictionaryWithEvents<string, ITisInvokeType> invokeTypes, 
			TisGetInvokerDelegate oGetInvokerDelegate)
		{
            m_oInvokeTypes = invokeTypes;
            m_oGetInvokerDelegate = oGetInvokerDelegate;
            foreach (var invokeType in invokeTypes.Values)
			{
                invokeType.OnGetInvoker += m_oGetInvokerDelegate;
			}
		}
        #region IDisposable Members
        public void Dispose()
        {
            foreach (ITisInvokeType oInvokeType in m_oInvokeTypes.Values)
            {
                oInvokeType.OnGetInvoker -= m_oGetInvokerDelegate;
            }
            m_oInvokeTypes.Clear();
        }
        #endregion
		#region ITisInvokeTypesMngr Members
		public ITisInvokeType[] All
		{
			get
	
﻿#region Using
#endregion
namespace Willcraftia.Xna.Blocks.Models
    public struct ChunkBlock
    {
        Chunk chunk;
        IntVector3 position;
        public Chunk Chunk
        {
            get { return chunk; }
        }
        public IntVector3 Position
        {
            get { return position; }
        }
        public ChunkBlock(Chunk chunk, IntVector3 position)
        {
            if (chunk == null) throw new ArgumentNullException("chunk");
            if (!chunk.Contains(position)) throw new ArgumentOutOfRangeException("position");
            this.chunk = chunk;
            this.position = position;
        }
        public ChunkBlock GetNeighbor(Side side)
        {
            if (chunk == null)
                throw new InvalidOperationException("Chunk is null.");
            ChunkBlock neighbor;
            neighbor.chunk = chunk;
            neighbor.position = position + side.Direction;
            if (!neighbor.chunk.Contains(neighbor.position))
         
#if STATS
namespace SampleClient
    delegate void InvokeDelegate(Invoke invoke);
    struct Invoke
    {
        public Delegate Action;
        public object[] Args;
        public String StackTrace;
        public Invoke(Delegate method, params object[] args)
        {
            this.Action = method;
            this.Args = args;
            this.StackTrace = Environment.StackTrace;
        }
    }
    class Utils
    {
        public static void PerformControlOperation(Control control, NoParam action)
        {
            if (control.InvokeRequired)
                control.BeginInvoke(new InvokeDelegate(TryCatchInvoker), new Invoke(action, null));
            else
                TryCatchInvoker(new Invoke(action, null));
        }
        private static void TryCatchInvoker(Invoke invoke)
        {
            try
            {
                invoke.Action.DynamicInvoke(invoke.Args);
            }
            catch (Exception e)
            {
                MessageBox.Show("E
namespace TestServer
    class MtInstrumentChart
    {
        public MtInstrumentChart(MtInstrument instrument)
        {
            Instrument = instrument;
        }
        #region Public Methods
        public void Start()
        {
            lock (mExpertLocker)
            {
                if (Expert != null)
                {
                    if (Instrument != null)
                        Expert.Symbol = Instrument.Symbol;
                    Expert.Init();
                }
            }
            if (Instrument != null)
            {
                Instrument.InstrumentUpdate += Instrument_InstrumentUpdate;
            }
        }
        public void Stop()
        {
            if (Instrument != null)
            {
                Instrument.InstrumentUpdate -= Instrument_InstrumentUpdate;
            }
            lock (mExpertLocker)
            {
                if (Expert != null)
                {
                    Expert.SetStopped();
                    E

                }
            }
        }
        public void AddExpert(MtExpert expert)
        {
            lock (mExpertLocker)
            {
                Expert = expert;
                if (Expert != null)
                {
                    if (Instrument != null)
                        Expert.Symbol = Instrument.Symbol;
                    Expert.Init();
                }
            }
        }
        #endregion
        #region Private Methods
        private void Instrument_InstrumentUpdate(string symbol, double bid, double ask)
        {
            lock (mExpertLocker)
            {
                if (Expert != null)
                {
                    Expert.Symbol = symbol;
                    Expert.Bid = bid;
                    Expert.Ask = ask;
                    Expert.Start();
                }
            }
        }
        #endregion
        #region Properties
        public MtInstrument Instrument { get; private set; }
        public MtExpert Expert 
﻿/*
 * Created by SharpDevelop.
 * User: Alexander Petrovskiy
 * Date: 30/11/2011
 * Time: 08:45 p.m.
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
namespace UIAutomation.Commands
    [Cmdlet(VerbsLifecycle.Invoke, "UiaCollapsePattern")]
    
    public class InvokeUiaCollapsePatternCommand : PatternCmdletBase
    { public InvokeUiaCollapsePatternCommand() { WhatToDo = "Collapse"; }
    }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaButtonCollapse")]
    
    public class InvokeUiaButtonCollapseCommand : InvokeUiaCollapsePatternCommand
    { public InvokeUiaButtonCollapseCommand() { } }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaComboBoxCollapse")]
    
    public class InvokeUiaComboBoxCollapseCommand : InvokeUiaCollapsePatternCommand
    { public InvokeUiaComboBoxCollapseCommand() { } }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaCustomCollapse")]
    
    public class InvokeUiaCustomCollapseCommand : InvokeUiaCollapsePatternCommand
    { pu

    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaDataItemCollapse")]
    
    public class InvokeUiaDataItemCollapseCommand : InvokeUiaCollapsePatternCommand
    { public InvokeUiaDataItemCollapseCommand() { } }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaGroupCollapse")]
    
    public class InvokeUiaGroupCollapseCommand : InvokeUiaCollapsePatternCommand
    { public InvokeUiaGroupCollapseCommand() { } }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaGroupBoxCollapse")]
    
    public class InvokeUiaGroupBoxCollapseCommand : InvokeUiaGroupCollapseCommand
    { public InvokeUiaGroupBoxCollapseCommand() { } }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaListItemCollapse")]
    
    public class InvokeUiaListItemCollapseCommand : InvokeUiaCollapsePatternCommand
    { public InvokeUiaListItemCollapseCommand() { } }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaMenuBarCollapse")]
    
    public class InvokeUiaMenuBarCollapseCommand : InvokeUiaCollapsePatternCommand
    { public InvokeUiaMenuBarCo
namespace Herschel.Lib
    [Serializable]
    public class InstrumentModeFilter
    {
        #region Static properties
        public static InstrumentModeFilter HifiSinglePoint
        {
            get
            {
                return new InstrumentModeFilter()
                {
                    Instrument = Instrument.Hifi,
                    PointingMode = PointingMode.Pointed,
                    InstrumentMode = InstrumentMode.HifiSingleBand
                };
            }
        }
        public static InstrumentModeFilter HifiMapping
        {
            get
            {
                return new InstrumentModeFilter()
                {
                    Instrument = Instrument.Hifi,
                    PointingMode = PointingMode.Mapping,
                    InstrumentMode = InstrumentMode.HifiSingleBand
                };
            }
        }
        public static InstrumentModeFilter HifiSpectralScan
        {
            get
            {
                

                {
                    Instrument = Instrument.Hifi,
                    PointingMode = PointingMode.Any,
                    InstrumentMode = InstrumentMode.HifiSpectralScan,
                };
            }
        }
        public static InstrumentModeFilter PacsPhotometry
        {
            get
            {
                return new InstrumentModeFilter()
                {
                    Instrument = Instrument.Pacs,
                    PointingMode = PointingMode.Any,
                    InstrumentMode = InstrumentMode.Photometry
                };
            }
        }
        public static InstrumentModeFilter PacsRangeSpec
        {
            get
            {
                return new InstrumentModeFilter()
                {
                    Instrument = Instrument.Pacs,
                    PointingMode = PointingMode.Any,
                    InstrumentMode = InstrumentMode.PacsSpectroRange
                };
            }
        }
        pu

        {
            get
            {
                return new InstrumentModeFilter()
                {
                    Instrument = Instrument.Pacs,
                    PointingMode = PointingMode.Any,
                    InstrumentMode = InstrumentMode.PacsSpectroLine
                };
            }
        }
        public static InstrumentModeFilter SpirePhotometry
        {
            get
            {
                return new InstrumentModeFilter()
                {
                    Instrument = Instrument.Spire,
                    PointingMode = PointingMode.Any,
                    InstrumentMode = InstrumentMode.SpirePhoto
                };
            }
        }
        public static InstrumentModeFilter SpireSpectroscopy
        {
            get
            {
                return new InstrumentModeFilter()
                {
                    Instrument = Instrument.Spire,
                    PointingMode = PointingMode.Any,
                    Instrum
namespace GlumOrigins.Client.Controllers
    public class GameController : MonoBehaviour
    {
        private NetworkController networkController;
        private WorldController worldController;
        private TileGraphicController tileGraphicController;
        private PlayerCharacterGraphicController playerCharacterGraphicController;
        [Header("Connection Settings")]
        [SerializeField]
        private string ipAddress;
        [SerializeField]
        private int port;
        private void Start()
        {
            networkController = new NetworkController();
            worldController =  new WorldController();
            tileGraphicController = new TileGraphicController();
            playerCharacterGraphicController = new PlayerCharacterGraphicController();
            PlayerController.Initialize();
            networkController.Connect(ipAddress, port);
        }
        private void Update()
        {
            networkController.Update();
        }
        
namespace SmsMis.Models.Console.Handlers.Fee
    public class hdlInstrumentSerialMaster : DbContext
    {public hdlInstrumentSerialMaster() : base("name=ValencySGIEntities") { }
    public IList<object> SelectAll(int CompanyCode)
        {
            SmsMis.Models.Console.Handlers.Admin.SmsMisDB db = new SmsMis.Models.Console.Handlers.Admin.SmsMisDB();
            var otherItems = (from st in db.InstrumentSerialMaster
                              
                              select new
                              {
                                  CompanyCode= st.CompanyCode ,
                                  BranchCode = st.BranchCode,
                                  AccountCode = st.AccountCode,
                                  InstrumentTypeCode =st.InstrumentTypeCode ,
                                  StartingInstrumentNo=st.StartingInstrumentNo,
                                  EndingInstrumentNo = st.EndingInstrumentNo,
                                  IssueDate = s

                                  Status = st.Status,
                                  AddByUserId=st.AddByUserId,
                                  AddDateTime = st.AddDateTime
                                  
                              }).Where(a => a.CompanyCode == CompanyCode ).ToArray();
            return otherItems;
        }
        public void save(InstrumentSerialDetail InstrumentSerialDetail, string userId)
        {
            try
            {
                {
                    var entrymain = context.Entry(InstrumentSerialDetail);
                    if (entrymain != null)
                    {
                        InstrumentSerialDetail.CancelledDateTime = DateTime.Now;
                        InstrumentSerialDetail.CancelledByUserId = userId;
                        InstrumentSerialDetail.Cancelled = true;
                    }
                    entrymain.State = EntityState.Modified;
                    context.SaveChanges();
                }
         

            catch (System.Data.Entity.Validation.DbEntityValidationException ex)
            {
            }
            catch (Exception ex)
            {
            }
        }
        public void save(InstrumentSerialMaster InstrumentSerialMaster, string userId, bool isNew)
        {
            try
            {
                {
                    var entrymain = context.Entry(InstrumentSerialMaster);
                    if (entrymain != null)
                    {
                        InstrumentSerialMaster.AddDateTime = DateTime.Now;
                        InstrumentSerialMaster.AddByUserId = userId;
                        InstrumentSerialMaster.InstrumentSerialDetail = new List<InstrumentSerialDetail>();
                        for (int i = Convert.ToInt32(InstrumentSerialMaster.StartingInstrumentNo); i <= Convert.ToInt32(InstrumentSerialMaster.EndingInstrumentNo); i++)
                        {
                            InstrumentSerialDetail detail = new InstrumentS
namespace CreditSuisse.TimeSerie.DataTransferObjects
    [SuppressMessage("ReSharper", "NonReadonlyMemberInGetHashCode")]
    public class Instrument
    {
        public Instrument()
        {
        }
        private Instrument(Instrument src)
        {
            if (src == null)
                throw new ArgumentNullException(nameof(src));
            InstrumentId = src.InstrumentId;
            Name = src.Name;
        }
        public long InstrumentId { get; set; }
        public string Name { get; set; }
        public override bool Equals(object obj)
        {
            var p = obj as Instrument;
            if (p == null)
                return false;
            return InstrumentId == p.InstrumentId
                   && Name == p.Name;
        }
        public override int GetHashCode()
        {
            return
                InstrumentId.GetHashCode() ^
                (Name ?? string.Empty).GetHashCode();
        }
        public Instrument Clone()
        {
    
namespace MequantaStudio.SmartQuant
    public partial class ImportInstrumentWidget: Gtk.Bin
    {
        private IInstrumentProvider provider;
        private string requestId;
        private List<Instrument> instruments = new List<Instrument>();
        public ImportInstrumentWidget(string providerName)
        {
            this.Build();
            var f = Framework.Current;
            this.provider = f.ProviderManager.GetProvider(providerName) as IInstrumentProvider;
            f.EventManager.Dispatcher.InstrumentDefinition += new InstrumentDefinitionEventHandler(this.OnInstrumentDefinition);
            f.EventManager.Dispatcher.InstrumentDefinitionEnd += new InstrumentDefinitionEndEventHandler(this.OnInstrumentDefinitionEnd);
        }
        protected override void OnDestroyed()
        {
            var f = Framework.Current;
            f.EventManager.Dispatcher.InstrumentDefinition -= new InstrumentDefinitionEventHandler(this.OnInstrumentDefinition);
            f.Event

            base.OnDestroyed();
        }
        private void OnInstrumentDefinition(object sender, InstrumentDefinitionEventArgs args)
        {
            InstrumentDefinition definition = args.Definition;
            if (definition.RequestId != this.requestId)
                return;
            this.instruments.AddRange((IEnumerable<Instrument>)definition.Instruments);
            Gtk.Application.Invoke(delegate
            {
                if (definition.TotalNum <= 0)
                    return;
                double num = (double)this.instruments.Count / (double)definition.TotalNum * 100.0;
                if (num > 100.0)
                    num = 100.0;
            });
        }
        private void OnInstrumentDefinitionEnd(object sender, InstrumentDefinitionEndEventArgs args)
        {
            InstrumentDefinitionEnd end = args.End;
            if (end.RequestId != this.requestId)
                return;
            this.requestId = null;
            Gtk.Application
namespace HQServer.Domain.Concrete
    public class EFBatchDispatchDetailRepository : IBatchDispatchDetailRepository
    {
        private EFDbContext context = new EFDbContext();
        public IQueryable<BatchDispatchDetail> BatchDispatchDetails
        {
            get { return context.BatchDispatchDetails; }
        }
        public void saveBatchDispatchDetail(BatchDispatchDetail batchDispatchDetail)
        {
            if (context.Entry(batchDispatchDetail).State == EntityState.Detached)
            {
                context.BatchDispatchDetails.Add(batchDispatchDetail);
            }
            context.SaveChanges();
        }
        public void quickSaveBatchDispatchDetail(BatchDispatchDetail batchDispatchDetail)
        {
            context.BatchDispatchDetails.Add(batchDispatchDetail);
        }
        public void saveContext()
        {
            context.SaveChanges();
        }
        public void deleteBatchDispatchDetail(BatchDispatchDetail batchDispatchDetail)
 
namespace SMS2WS_SyncAgent
    internal static partial class WebMethods
    {
        internal static class InstrumentMethods
        {
            internal static Instrument GetInstrumentById(int instrumentId, out string errorMsg)
            {
                string xmlData = GetDataFromWebMethod("instrument",
                                                      "getById",
                                                      "id=" + instrumentId);
                if (WebMethodReturnedError(xmlData, out errorMsg))
                {
                    return null;
                }
                else
                {
                    errorMsg = null;
                    Instrument instrument = InstrumentRepository.LoadInstrumentFromXml(xmlData);
                    return instrument;
                }
            }
            internal static string UpdateInstrument(Instrument instrument)
            {
                string data = instrument.ToXml();
                string re
public class PlayerBase : MonoBehaviour {
    private PlayerAnimationController _animationController;
    public PlayerAnimationController PlayerAnimationController
    {
        get
        {
            if (_animationController == null)
                _animationController = GetComponent<PlayerAnimationController>();
            return _animationController;
        }
    }
    private PlayerCollisionsController _collisionController;
    public PlayerCollisionsController PlayerCollisionsController
    {
        get
        {
            if (_collisionController == null)
                _collisionController = GetComponent<PlayerCollisionsController>();
            return _collisionController;
        }
    }
    private PlayerController _playerController;
    public PlayerController PlayerController
    {
        get
        {
            if (_playerController == null)
                _playerController = GetComponent<PlayerController>();
            return _playerController;
        }

namespace DeltaStore
    public class Manager
    {
        public List<Instrument> Instruments { get; set; }
        public Manager()
        {
            Instruments = new List<Instrument>()
            {
                new Instrument { Name = "Guitar", Inventory = 2 },
                new Instrument { Name = "Bass",   Inventory = 3 },
                new Instrument { Name = "Piano",  Inventory = 5 }
            };
        }
        public void AddInstrument()
        {
            Instrument newInstrument = new Instrument();
            List<string> instrumentNames = Instruments
                .Select(x => x.Name)
                .ToList();
            newInstrument.Name = ValidInput.Name(instrumentNames);
            if (String.IsNullOrEmpty(newInstrument.Name))
            {
                Console.WriteLine("Invalid input, operation aborted.");
                return;
            }
            try
            {
                Console.Write("Inventory: ");
                newI
namespace SmartQuant
	public class InstrumentStreamer : ObjectStreamer
	{
		public InstrumentStreamer()
		{
			this.typeId = 100;
			this.type = typeof(Instrument);
		}
		public override object Read(BinaryReader reader)
		{
			reader.ReadByte();
			int id = reader.ReadInt32();
			InstrumentType type = (InstrumentType)reader.ReadByte();
			string symbol = reader.ReadString();
			string description = reader.ReadString();
			byte currencyId = reader.ReadByte();
			string exchange = reader.ReadString();
			Instrument instrument = new Instrument(id, type, symbol, description, currencyId, exchange);
			instrument.tickSize = reader.ReadDouble();
			instrument.maturity = new DateTime(reader.ReadInt64());
			instrument.factor = reader.ReadDouble();
			instrument.strike = reader.ReadDouble();
			instrument.putcall = (PutCall)reader.ReadByte();
			instrument.margin = reader.ReadDouble();
			int num = reader.ReadInt32();
			for (int i = 0; i < num; i++)
			{
				AltId altId = new AltId();
				altI
namespace Vivmotion.Plugin.Host
    public class ProcessMonitor
    {
        private readonly Action _onProcessExit;
        private bool _fired;
        public ProcessMonitor(Action onProcessExit)
        {
            if (onProcessExit == null) throw new ArgumentNullException("onProcessExit");
            _onProcessExit = onProcessExit;
        }
        public void Start(int processId)
        {
            Start(Process.GetProcessById(processId));
        }
        public void Start(Process process)
        {
            if (process == null)
            {
                FireOnce();
                return;
            }
            process.Exited += (sender, args) => FireOnce();
            process.EnableRaisingEvents = true;
            if (process.HasExited) FireOnce();
        }
        private void FireOnce()
        {
            lock (this)
            {
                if (_fired) return;
                _fired = true;
            }
            _onProcessExit();
        }
 

